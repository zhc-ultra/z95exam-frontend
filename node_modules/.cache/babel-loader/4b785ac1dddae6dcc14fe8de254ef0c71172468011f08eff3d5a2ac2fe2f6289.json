{"ast":null,"code":"import _objectSpread from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _callSuper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _toConsumableArray from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _typeof from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.last-index-of.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.flags.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.replace-all.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isChrome, isEdge, isFirefox, isLinux, isMacintosh, isSafari, isWeb, isWindows } from '../../../base/common/platform.js';\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { Scanner } from './scanner.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { localize } from '../../../nls.js';\nvar CONSTANT_VALUES = new Map();\nCONSTANT_VALUES.set('false', false);\nCONSTANT_VALUES.set('true', true);\nCONSTANT_VALUES.set('isMac', isMacintosh);\nCONSTANT_VALUES.set('isLinux', isLinux);\nCONSTANT_VALUES.set('isWindows', isWindows);\nCONSTANT_VALUES.set('isWeb', isWeb);\nCONSTANT_VALUES.set('isMacNative', isMacintosh && !isWeb);\nCONSTANT_VALUES.set('isEdge', isEdge);\nCONSTANT_VALUES.set('isFirefox', isFirefox);\nCONSTANT_VALUES.set('isChrome', isChrome);\nCONSTANT_VALUES.set('isSafari', isSafari);\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar defaultConfig = {\n  regexParsingWithErrorRecovery: true\n};\nvar errorEmptyString = localize('contextkey.parser.error.emptyString', \"Empty context key expression\");\nvar hintEmptyString = localize('contextkey.parser.error.emptyString.hint', \"Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively.\");\nvar errorNoInAfterNot = localize('contextkey.parser.error.noInAfterNot', \"'in' after 'not'.\");\nvar errorClosingParenthesis = localize('contextkey.parser.error.closingParenthesis', \"closing parenthesis ')'\");\nvar errorUnexpectedToken = localize('contextkey.parser.error.unexpectedToken', \"Unexpected token\");\nvar hintUnexpectedToken = localize('contextkey.parser.error.unexpectedToken.hint', \"Did you forget to put && or || before the token?\");\nvar errorUnexpectedEOF = localize('contextkey.parser.error.unexpectedEOF', \"Unexpected end of expression\");\nvar hintUnexpectedEOF = localize('contextkey.parser.error.unexpectedEOF.hint', \"Did you forget to put a context key?\");\n/**\n * A parser for context key expressions.\n *\n * Example:\n * ```ts\n * const parser = new Parser();\n * const expr = parser.parse('foo == \"bar\" && baz == true');\n *\n * if (expr === undefined) {\n * \t// there were lexing or parsing errors\n * \t// process lexing errors with `parser.lexingErrors`\n *  // process parsing errors with `parser.parsingErrors`\n * } else {\n * \t// expr is a valid expression\n * }\n * ```\n */\nexport var Parser = /*#__PURE__*/function () {\n  function Parser() {\n    var _config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultConfig;\n    _classCallCheck(this, Parser);\n    this._config = _config;\n    // lifetime note: `_scanner` lives as long as the parser does, i.e., is not reset between calls to `parse`\n    this._scanner = new Scanner();\n    // lifetime note: `_tokens`, `_current`, and `_parsingErrors` must be reset between calls to `parse`\n    this._tokens = [];\n    this._current = 0; // invariant: 0 <= this._current < this._tokens.length ; any incrementation of this value must first call `_isAtEnd`\n    this._parsingErrors = [];\n    this._flagsGYRe = /g|y/g;\n  }\n  /**\n   * Parse a context key expression.\n   *\n   * @param input the expression to parse\n   * @returns the parsed expression or `undefined` if there's an error - call `lexingErrors` and `parsingErrors` to see the errors\n   */\n  return _createClass(Parser, [{\n    key: \"parse\",\n    value: function parse(input) {\n      if (input === '') {\n        this._parsingErrors.push({\n          message: errorEmptyString,\n          offset: 0,\n          lexeme: '',\n          additionalInfo: hintEmptyString\n        });\n        return undefined;\n      }\n      this._tokens = this._scanner.reset(input).scan();\n      // @ulugbekna: we do not stop parsing if there are lexing errors to be able to reconstruct regexes with unescaped slashes; TODO@ulugbekna: make this respect config option for recovery\n      this._current = 0;\n      this._parsingErrors = [];\n      try {\n        var expr = this._expr();\n        if (!this._isAtEnd()) {\n          var peek = this._peek();\n          var additionalInfo = peek.type === 17 /* TokenType.Str */ ? hintUnexpectedToken : undefined;\n          this._parsingErrors.push({\n            message: errorUnexpectedToken,\n            offset: peek.offset,\n            lexeme: Scanner.getLexeme(peek),\n            additionalInfo: additionalInfo\n          });\n          throw Parser._parseError;\n        }\n        return expr;\n      } catch (e) {\n        if (!(e === Parser._parseError)) {\n          throw e;\n        }\n        return undefined;\n      }\n    }\n  }, {\n    key: \"_expr\",\n    value: function _expr() {\n      return this._or();\n    }\n  }, {\n    key: \"_or\",\n    value: function _or() {\n      var expr = [this._and()];\n      while (this._matchOne(16 /* TokenType.Or */)) {\n        var right = this._and();\n        expr.push(right);\n      }\n      return expr.length === 1 ? expr[0] : ContextKeyExpr.or.apply(ContextKeyExpr, expr);\n    }\n  }, {\n    key: \"_and\",\n    value: function _and() {\n      var expr = [this._term()];\n      while (this._matchOne(15 /* TokenType.And */)) {\n        var right = this._term();\n        expr.push(right);\n      }\n      return expr.length === 1 ? expr[0] : ContextKeyExpr.and.apply(ContextKeyExpr, expr);\n    }\n  }, {\n    key: \"_term\",\n    value: function _term() {\n      if (this._matchOne(2 /* TokenType.Neg */)) {\n        var peek = this._peek();\n        switch (peek.type) {\n          case 11 /* TokenType.True */:\n            this._advance();\n            return ContextKeyFalseExpr.INSTANCE;\n          case 12 /* TokenType.False */:\n            this._advance();\n            return ContextKeyTrueExpr.INSTANCE;\n          case 0 /* TokenType.LParen */:\n            {\n              this._advance();\n              var expr = this._expr();\n              this._consume(1 /* TokenType.RParen */, errorClosingParenthesis);\n              return expr === null || expr === void 0 ? void 0 : expr.negate();\n            }\n          case 17 /* TokenType.Str */:\n            this._advance();\n            return ContextKeyNotExpr.create(peek.lexeme);\n          default:\n            throw this._errExpectedButGot(\"KEY | true | false | '(' expression ')'\", peek);\n        }\n      }\n      return this._primary();\n    }\n  }, {\n    key: \"_primary\",\n    value: function _primary() {\n      var peek = this._peek();\n      switch (peek.type) {\n        case 11 /* TokenType.True */:\n          this._advance();\n          return ContextKeyExpr[\"true\"]();\n        case 12 /* TokenType.False */:\n          this._advance();\n          return ContextKeyExpr[\"false\"]();\n        case 0 /* TokenType.LParen */:\n          {\n            this._advance();\n            var expr = this._expr();\n            this._consume(1 /* TokenType.RParen */, errorClosingParenthesis);\n            return expr;\n          }\n        case 17 /* TokenType.Str */:\n          {\n            // KEY\n            var key = peek.lexeme;\n            this._advance();\n            // =~ regex\n            if (this._matchOne(9 /* TokenType.RegexOp */)) {\n              // @ulugbekna: we need to reconstruct the regex from the tokens because some extensions use unescaped slashes in regexes\n              var _expr2 = this._peek();\n              if (!this._config.regexParsingWithErrorRecovery) {\n                this._advance();\n                if (_expr2.type !== 10 /* TokenType.RegexStr */) {\n                  throw this._errExpectedButGot(\"REGEX\", _expr2);\n                }\n                var regexLexeme = _expr2.lexeme;\n                var closingSlashIndex = regexLexeme.lastIndexOf('/');\n                var flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n                var regexp;\n                try {\n                  regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);\n                } catch (e) {\n                  throw this._errExpectedButGot(\"REGEX\", _expr2);\n                }\n                return ContextKeyRegexExpr.create(key, regexp);\n              }\n              switch (_expr2.type) {\n                case 10 /* TokenType.RegexStr */:\n                case 19 /* TokenType.Error */:\n                  {\n                    // also handle an ErrorToken in case of smth such as /(/file)/\n                    var lexemeReconstruction = [_expr2.lexeme]; // /REGEX/ or /REGEX/FLAGS\n                    this._advance();\n                    var followingToken = this._peek();\n                    var parenBalance = 0;\n                    for (var i = 0; i < _expr2.lexeme.length; i++) {\n                      if (_expr2.lexeme.charCodeAt(i) === 40 /* CharCode.OpenParen */) {\n                        parenBalance++;\n                      } else if (_expr2.lexeme.charCodeAt(i) === 41 /* CharCode.CloseParen */) {\n                        parenBalance--;\n                      }\n                    }\n                    while (!this._isAtEnd() && followingToken.type !== 15 /* TokenType.And */ && followingToken.type !== 16 /* TokenType.Or */) {\n                      switch (followingToken.type) {\n                        case 0 /* TokenType.LParen */:\n                          parenBalance++;\n                          break;\n                        case 1 /* TokenType.RParen */:\n                          parenBalance--;\n                          break;\n                        case 10 /* TokenType.RegexStr */:\n                        case 18 /* TokenType.QuotedStr */:\n                          for (var _i = 0; _i < followingToken.lexeme.length; _i++) {\n                            if (followingToken.lexeme.charCodeAt(_i) === 40 /* CharCode.OpenParen */) {\n                              parenBalance++;\n                            } else if (_expr2.lexeme.charCodeAt(_i) === 41 /* CharCode.CloseParen */) {\n                              parenBalance--;\n                            }\n                          }\n                      }\n                      if (parenBalance < 0) {\n                        break;\n                      }\n                      lexemeReconstruction.push(Scanner.getLexeme(followingToken));\n                      this._advance();\n                      followingToken = this._peek();\n                    }\n                    var _regexLexeme = lexemeReconstruction.join('');\n                    var _closingSlashIndex = _regexLexeme.lastIndexOf('/');\n                    var _flags = _closingSlashIndex === _regexLexeme.length - 1 ? undefined : this._removeFlagsGY(_regexLexeme.substring(_closingSlashIndex + 1));\n                    var _regexp;\n                    try {\n                      _regexp = new RegExp(_regexLexeme.substring(1, _closingSlashIndex), _flags);\n                    } catch (e) {\n                      throw this._errExpectedButGot(\"REGEX\", _expr2);\n                    }\n                    return ContextKeyExpr.regex(key, _regexp);\n                  }\n                case 18 /* TokenType.QuotedStr */:\n                  {\n                    var serializedValue = _expr2.lexeme;\n                    this._advance();\n                    // replicate old regex parsing behavior\n                    var regex = null;\n                    if (!isFalsyOrWhitespace(serializedValue)) {\n                      var start = serializedValue.indexOf('/');\n                      var end = serializedValue.lastIndexOf('/');\n                      if (start !== end && start >= 0) {\n                        var value = serializedValue.slice(start + 1, end);\n                        var caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n                        try {\n                          regex = new RegExp(value, caseIgnoreFlag);\n                        } catch (_e) {\n                          throw this._errExpectedButGot(\"REGEX\", _expr2);\n                        }\n                      }\n                    }\n                    if (regex === null) {\n                      throw this._errExpectedButGot('REGEX', _expr2);\n                    }\n                    return ContextKeyRegexExpr.create(key, regex);\n                  }\n                default:\n                  throw this._errExpectedButGot('REGEX', this._peek());\n              }\n            }\n            // [ 'not' 'in' value ]\n            if (this._matchOne(14 /* TokenType.Not */)) {\n              this._consume(13 /* TokenType.In */, errorNoInAfterNot);\n              var right = this._value();\n              return ContextKeyExpr.notIn(key, right);\n            }\n            // [ ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in') value ]\n            var maybeOp = this._peek().type;\n            switch (maybeOp) {\n              case 3 /* TokenType.Eq */:\n                {\n                  this._advance();\n                  var _right = this._value();\n                  if (this._previous().type === 18 /* TokenType.QuotedStr */) {\n                    // to preserve old parser behavior: \"foo == 'true'\" is preserved as \"foo == 'true'\", but \"foo == true\" is optimized as \"foo\"\n                    return ContextKeyExpr.equals(key, _right);\n                  }\n                  switch (_right) {\n                    case 'true':\n                      return ContextKeyExpr.has(key);\n                    case 'false':\n                      return ContextKeyExpr.not(key);\n                    default:\n                      return ContextKeyExpr.equals(key, _right);\n                  }\n                }\n              case 4 /* TokenType.NotEq */:\n                {\n                  this._advance();\n                  var _right2 = this._value();\n                  if (this._previous().type === 18 /* TokenType.QuotedStr */) {\n                    // same as above with \"foo != 'true'\"\n                    return ContextKeyExpr.notEquals(key, _right2);\n                  }\n                  switch (_right2) {\n                    case 'true':\n                      return ContextKeyExpr.not(key);\n                    case 'false':\n                      return ContextKeyExpr.has(key);\n                    default:\n                      return ContextKeyExpr.notEquals(key, _right2);\n                  }\n                }\n              // TODO: ContextKeyExpr.smaller(key, right) accepts only `number` as `right` AND during eval of this node, we just eval to `false` if `right` is not a number\n              // consequently, package.json linter should _warn_ the user if they're passing undesired things to ops\n              case 5 /* TokenType.Lt */:\n                this._advance();\n                return ContextKeySmallerExpr.create(key, this._value());\n              case 6 /* TokenType.LtEq */:\n                this._advance();\n                return ContextKeySmallerEqualsExpr.create(key, this._value());\n              case 7 /* TokenType.Gt */:\n                this._advance();\n                return ContextKeyGreaterExpr.create(key, this._value());\n              case 8 /* TokenType.GtEq */:\n                this._advance();\n                return ContextKeyGreaterEqualsExpr.create(key, this._value());\n              case 13 /* TokenType.In */:\n                this._advance();\n                return ContextKeyExpr[\"in\"](key, this._value());\n              default:\n                return ContextKeyExpr.has(key);\n            }\n          }\n        case 20 /* TokenType.EOF */:\n          this._parsingErrors.push({\n            message: errorUnexpectedEOF,\n            offset: peek.offset,\n            lexeme: '',\n            additionalInfo: hintUnexpectedEOF\n          });\n          throw Parser._parseError;\n        default:\n          throw this._errExpectedButGot(\"true | false | KEY \\n\\t| KEY '=~' REGEX \\n\\t| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value\", this._peek());\n      }\n    }\n  }, {\n    key: \"_value\",\n    value: function _value() {\n      var token = this._peek();\n      switch (token.type) {\n        case 17 /* TokenType.Str */:\n        case 18 /* TokenType.QuotedStr */:\n          this._advance();\n          return token.lexeme;\n        case 11 /* TokenType.True */:\n          this._advance();\n          return 'true';\n        case 12 /* TokenType.False */:\n          this._advance();\n          return 'false';\n        case 13 /* TokenType.In */:\n          // we support `in` as a value, e.g., \"when\": \"languageId == in\" - exists in existing extensions\n          this._advance();\n          return 'in';\n        default:\n          // this allows \"when\": \"foo == \" which's used by existing extensions\n          // we do not call `_advance` on purpose - we don't want to eat unintended tokens\n          return '';\n      }\n    }\n  }, {\n    key: \"_removeFlagsGY\",\n    value: function _removeFlagsGY(flags) {\n      return flags.replaceAll(this._flagsGYRe, '');\n    }\n    // careful: this can throw if current token is the initial one (ie index = 0)\n  }, {\n    key: \"_previous\",\n    value: function _previous() {\n      return this._tokens[this._current - 1];\n    }\n  }, {\n    key: \"_matchOne\",\n    value: function _matchOne(token) {\n      if (this._check(token)) {\n        this._advance();\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"_advance\",\n    value: function _advance() {\n      if (!this._isAtEnd()) {\n        this._current++;\n      }\n      return this._previous();\n    }\n  }, {\n    key: \"_consume\",\n    value: function _consume(type, message) {\n      if (this._check(type)) {\n        return this._advance();\n      }\n      throw this._errExpectedButGot(message, this._peek());\n    }\n  }, {\n    key: \"_errExpectedButGot\",\n    value: function _errExpectedButGot(expected, got, additionalInfo) {\n      var message = localize('contextkey.parser.error.expectedButGot', \"Expected: {0}\\nReceived: '{1}'.\", expected, Scanner.getLexeme(got));\n      var offset = got.offset;\n      var lexeme = Scanner.getLexeme(got);\n      this._parsingErrors.push({\n        message: message,\n        offset: offset,\n        lexeme: lexeme,\n        additionalInfo: additionalInfo\n      });\n      return Parser._parseError;\n    }\n  }, {\n    key: \"_check\",\n    value: function _check(type) {\n      return this._peek().type === type;\n    }\n  }, {\n    key: \"_peek\",\n    value: function _peek() {\n      return this._tokens[this._current];\n    }\n  }, {\n    key: \"_isAtEnd\",\n    value: function _isAtEnd() {\n      return this._peek().type === 20 /* TokenType.EOF */;\n    }\n  }]);\n}();\n// Note: this doesn't produce an exact syntax tree but a normalized one\n// ContextKeyExpression's that we use as AST nodes do not expose constructors that do not normalize\nParser._parseError = new Error();\nexport var ContextKeyExpr = /*#__PURE__*/function () {\n  function ContextKeyExpr() {\n    _classCallCheck(this, ContextKeyExpr);\n  }\n  return _createClass(ContextKeyExpr, null, [{\n    key: \"false\",\n    value: function _false() {\n      return ContextKeyFalseExpr.INSTANCE;\n    }\n  }, {\n    key: \"true\",\n    value: function _true() {\n      return ContextKeyTrueExpr.INSTANCE;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return ContextKeyDefinedExpr.create(key);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(key, value) {\n      return ContextKeyEqualsExpr.create(key, value);\n    }\n  }, {\n    key: \"notEquals\",\n    value: function notEquals(key, value) {\n      return ContextKeyNotEqualsExpr.create(key, value);\n    }\n  }, {\n    key: \"regex\",\n    value: function regex(key, value) {\n      return ContextKeyRegexExpr.create(key, value);\n    }\n  }, {\n    key: \"in\",\n    value: function _in(key, value) {\n      return ContextKeyInExpr.create(key, value);\n    }\n  }, {\n    key: \"notIn\",\n    value: function notIn(key, value) {\n      return ContextKeyNotInExpr.create(key, value);\n    }\n  }, {\n    key: \"not\",\n    value: function not(key) {\n      return ContextKeyNotExpr.create(key);\n    }\n  }, {\n    key: \"and\",\n    value: function and() {\n      for (var _len = arguments.length, expr = new Array(_len), _key = 0; _key < _len; _key++) {\n        expr[_key] = arguments[_key];\n      }\n      return ContextKeyAndExpr.create(expr, null, true);\n    }\n  }, {\n    key: \"or\",\n    value: function or() {\n      for (var _len2 = arguments.length, expr = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        expr[_key2] = arguments[_key2];\n      }\n      return ContextKeyOrExpr.create(expr, null, true);\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(serialized) {\n      if (serialized === undefined || serialized === null) {\n        // an empty string needs to be handled by the parser to get a corresponding parsing error reported\n        return undefined;\n      }\n      var expr = this._parser.parse(serialized);\n      return expr;\n    }\n  }]);\n}();\nContextKeyExpr._parser = new Parser({\n  regexParsingWithErrorRecovery: false\n});\nexport function expressionsAreEqualWithConstantSubstitution(a, b) {\n  var aExpr = a ? a.substituteConstants() : undefined;\n  var bExpr = b ? b.substituteConstants() : undefined;\n  if (!aExpr && !bExpr) {\n    return true;\n  }\n  if (!aExpr || !bExpr) {\n    return false;\n  }\n  return aExpr.equals(bExpr);\n}\nfunction _cmp(a, b) {\n  return a.cmp(b);\n}\nexport var ContextKeyFalseExpr = /*#__PURE__*/function () {\n  function ContextKeyFalseExpr() {\n    _classCallCheck(this, ContextKeyFalseExpr);\n    this.type = 0 /* ContextKeyExprType.False */;\n  }\n  return _createClass(ContextKeyFalseExpr, [{\n    key: \"cmp\",\n    value: function cmp(other) {\n      return this.type - other.type;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return other.type === this.type;\n    }\n  }, {\n    key: \"substituteConstants\",\n    value: function substituteConstants() {\n      return this;\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(context) {\n      return false;\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return 'false';\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      return [];\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      return ContextKeyTrueExpr.INSTANCE;\n    }\n  }]);\n}();\nContextKeyFalseExpr.INSTANCE = new ContextKeyFalseExpr();\nexport var ContextKeyTrueExpr = /*#__PURE__*/function () {\n  function ContextKeyTrueExpr() {\n    _classCallCheck(this, ContextKeyTrueExpr);\n    this.type = 1 /* ContextKeyExprType.True */;\n  }\n  return _createClass(ContextKeyTrueExpr, [{\n    key: \"cmp\",\n    value: function cmp(other) {\n      return this.type - other.type;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return other.type === this.type;\n    }\n  }, {\n    key: \"substituteConstants\",\n    value: function substituteConstants() {\n      return this;\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(context) {\n      return true;\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return 'true';\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      return [];\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      return ContextKeyFalseExpr.INSTANCE;\n    }\n  }]);\n}();\nContextKeyTrueExpr.INSTANCE = new ContextKeyTrueExpr();\nexport var ContextKeyDefinedExpr = /*#__PURE__*/function () {\n  function ContextKeyDefinedExpr(key, negated) {\n    _classCallCheck(this, ContextKeyDefinedExpr);\n    this.key = key;\n    this.negated = negated;\n    this.type = 2 /* ContextKeyExprType.Defined */;\n  }\n  return _createClass(ContextKeyDefinedExpr, [{\n    key: \"cmp\",\n    value: function cmp(other) {\n      if (other.type !== this.type) {\n        return this.type - other.type;\n      }\n      return cmp1(this.key, other.key);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (other.type === this.type) {\n        return this.key === other.key;\n      }\n      return false;\n    }\n  }, {\n    key: \"substituteConstants\",\n    value: function substituteConstants() {\n      var constantValue = CONSTANT_VALUES.get(this.key);\n      if (typeof constantValue === 'boolean') {\n        return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n      }\n      return this;\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(context) {\n      return !!context.getValue(this.key);\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return this.key;\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      return [this.key];\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      if (!this.negated) {\n        this.negated = ContextKeyNotExpr.create(this.key, this);\n      }\n      return this.negated;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(key) {\n      var negated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var constantValue = CONSTANT_VALUES.get(key);\n      if (typeof constantValue === 'boolean') {\n        return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n      }\n      return new ContextKeyDefinedExpr(key, negated);\n    }\n  }]);\n}();\nexport var ContextKeyEqualsExpr = /*#__PURE__*/function () {\n  function ContextKeyEqualsExpr(key, value, negated) {\n    _classCallCheck(this, ContextKeyEqualsExpr);\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 4 /* ContextKeyExprType.Equals */;\n  }\n  return _createClass(ContextKeyEqualsExpr, [{\n    key: \"cmp\",\n    value: function cmp(other) {\n      if (other.type !== this.type) {\n        return this.type - other.type;\n      }\n      return cmp2(this.key, this.value, other.key, other.value);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (other.type === this.type) {\n        return this.key === other.key && this.value === other.value;\n      }\n      return false;\n    }\n  }, {\n    key: \"substituteConstants\",\n    value: function substituteConstants() {\n      var constantValue = CONSTANT_VALUES.get(this.key);\n      if (typeof constantValue === 'boolean') {\n        var trueValue = constantValue ? 'true' : 'false';\n        return this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n      }\n      return this;\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(context) {\n      // Intentional ==\n      // eslint-disable-next-line eqeqeq\n      return context.getValue(this.key) == this.value;\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return \"\".concat(this.key, \" == '\").concat(this.value, \"'\");\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      return [this.key];\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      if (!this.negated) {\n        this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);\n      }\n      return this.negated;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(key, value) {\n      var negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      if (typeof value === 'boolean') {\n        return value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated);\n      }\n      var constantValue = CONSTANT_VALUES.get(key);\n      if (typeof constantValue === 'boolean') {\n        var trueValue = constantValue ? 'true' : 'false';\n        return value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n      }\n      return new ContextKeyEqualsExpr(key, value, negated);\n    }\n  }]);\n}();\nexport var ContextKeyInExpr = /*#__PURE__*/function () {\n  function ContextKeyInExpr(key, valueKey) {\n    _classCallCheck(this, ContextKeyInExpr);\n    this.key = key;\n    this.valueKey = valueKey;\n    this.type = 10 /* ContextKeyExprType.In */;\n    this.negated = null;\n  }\n  return _createClass(ContextKeyInExpr, [{\n    key: \"cmp\",\n    value: function cmp(other) {\n      if (other.type !== this.type) {\n        return this.type - other.type;\n      }\n      return cmp2(this.key, this.valueKey, other.key, other.valueKey);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (other.type === this.type) {\n        return this.key === other.key && this.valueKey === other.valueKey;\n      }\n      return false;\n    }\n  }, {\n    key: \"substituteConstants\",\n    value: function substituteConstants() {\n      return this;\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(context) {\n      var source = context.getValue(this.valueKey);\n      var item = context.getValue(this.key);\n      if (Array.isArray(source)) {\n        return source.includes(item);\n      }\n      if (typeof item === 'string' && _typeof(source) === 'object' && source !== null) {\n        return hasOwnProperty.call(source, item);\n      }\n      return false;\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return \"\".concat(this.key, \" in '\").concat(this.valueKey, \"'\");\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      return [this.key, this.valueKey];\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      if (!this.negated) {\n        this.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);\n      }\n      return this.negated;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(key, valueKey) {\n      return new ContextKeyInExpr(key, valueKey);\n    }\n  }]);\n}();\nexport var ContextKeyNotInExpr = /*#__PURE__*/function () {\n  function ContextKeyNotInExpr(key, valueKey) {\n    _classCallCheck(this, ContextKeyNotInExpr);\n    this.key = key;\n    this.valueKey = valueKey;\n    this.type = 11 /* ContextKeyExprType.NotIn */;\n    this._negated = ContextKeyInExpr.create(key, valueKey);\n  }\n  return _createClass(ContextKeyNotInExpr, [{\n    key: \"cmp\",\n    value: function cmp(other) {\n      if (other.type !== this.type) {\n        return this.type - other.type;\n      }\n      return this._negated.cmp(other._negated);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (other.type === this.type) {\n        return this._negated.equals(other._negated);\n      }\n      return false;\n    }\n  }, {\n    key: \"substituteConstants\",\n    value: function substituteConstants() {\n      return this;\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(context) {\n      return !this._negated.evaluate(context);\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return \"\".concat(this.key, \" not in '\").concat(this.valueKey, \"'\");\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      return this._negated.keys();\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      return this._negated;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(key, valueKey) {\n      return new ContextKeyNotInExpr(key, valueKey);\n    }\n  }]);\n}();\nexport var ContextKeyNotEqualsExpr = /*#__PURE__*/function () {\n  function ContextKeyNotEqualsExpr(key, value, negated) {\n    _classCallCheck(this, ContextKeyNotEqualsExpr);\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 5 /* ContextKeyExprType.NotEquals */;\n  }\n  return _createClass(ContextKeyNotEqualsExpr, [{\n    key: \"cmp\",\n    value: function cmp(other) {\n      if (other.type !== this.type) {\n        return this.type - other.type;\n      }\n      return cmp2(this.key, this.value, other.key, other.value);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (other.type === this.type) {\n        return this.key === other.key && this.value === other.value;\n      }\n      return false;\n    }\n  }, {\n    key: \"substituteConstants\",\n    value: function substituteConstants() {\n      var constantValue = CONSTANT_VALUES.get(this.key);\n      if (typeof constantValue === 'boolean') {\n        var falseValue = constantValue ? 'true' : 'false';\n        return this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n      }\n      return this;\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(context) {\n      // Intentional !=\n      // eslint-disable-next-line eqeqeq\n      return context.getValue(this.key) != this.value;\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return \"\".concat(this.key, \" != '\").concat(this.value, \"'\");\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      return [this.key];\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      if (!this.negated) {\n        this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);\n      }\n      return this.negated;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(key, value) {\n      var negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      if (typeof value === 'boolean') {\n        if (value) {\n          return ContextKeyNotExpr.create(key, negated);\n        }\n        return ContextKeyDefinedExpr.create(key, negated);\n      }\n      var constantValue = CONSTANT_VALUES.get(key);\n      if (typeof constantValue === 'boolean') {\n        var falseValue = constantValue ? 'true' : 'false';\n        return value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n      }\n      return new ContextKeyNotEqualsExpr(key, value, negated);\n    }\n  }]);\n}();\nexport var ContextKeyNotExpr = /*#__PURE__*/function () {\n  function ContextKeyNotExpr(key, negated) {\n    _classCallCheck(this, ContextKeyNotExpr);\n    this.key = key;\n    this.negated = negated;\n    this.type = 3 /* ContextKeyExprType.Not */;\n  }\n  return _createClass(ContextKeyNotExpr, [{\n    key: \"cmp\",\n    value: function cmp(other) {\n      if (other.type !== this.type) {\n        return this.type - other.type;\n      }\n      return cmp1(this.key, other.key);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (other.type === this.type) {\n        return this.key === other.key;\n      }\n      return false;\n    }\n  }, {\n    key: \"substituteConstants\",\n    value: function substituteConstants() {\n      var constantValue = CONSTANT_VALUES.get(this.key);\n      if (typeof constantValue === 'boolean') {\n        return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n      }\n      return this;\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(context) {\n      return !context.getValue(this.key);\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return \"!\".concat(this.key);\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      return [this.key];\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      if (!this.negated) {\n        this.negated = ContextKeyDefinedExpr.create(this.key, this);\n      }\n      return this.negated;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(key) {\n      var negated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var constantValue = CONSTANT_VALUES.get(key);\n      if (typeof constantValue === 'boolean') {\n        return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n      }\n      return new ContextKeyNotExpr(key, negated);\n    }\n  }]);\n}();\nfunction withFloatOrStr(value, callback) {\n  if (typeof value === 'string') {\n    var n = parseFloat(value);\n    if (!isNaN(n)) {\n      value = n;\n    }\n  }\n  if (typeof value === 'string' || typeof value === 'number') {\n    return callback(value);\n  }\n  return ContextKeyFalseExpr.INSTANCE;\n}\nexport var ContextKeyGreaterExpr = /*#__PURE__*/function () {\n  function ContextKeyGreaterExpr(key, value, negated) {\n    _classCallCheck(this, ContextKeyGreaterExpr);\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 12 /* ContextKeyExprType.Greater */;\n  }\n  return _createClass(ContextKeyGreaterExpr, [{\n    key: \"cmp\",\n    value: function cmp(other) {\n      if (other.type !== this.type) {\n        return this.type - other.type;\n      }\n      return cmp2(this.key, this.value, other.key, other.value);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (other.type === this.type) {\n        return this.key === other.key && this.value === other.value;\n      }\n      return false;\n    }\n  }, {\n    key: \"substituteConstants\",\n    value: function substituteConstants() {\n      return this;\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(context) {\n      if (typeof this.value === 'string') {\n        return false;\n      }\n      return parseFloat(context.getValue(this.key)) > this.value;\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return \"\".concat(this.key, \" > \").concat(this.value);\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      return [this.key];\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      if (!this.negated) {\n        this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);\n      }\n      return this.negated;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(key, _value) {\n      var negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      return withFloatOrStr(_value, function (value) {\n        return new ContextKeyGreaterExpr(key, value, negated);\n      });\n    }\n  }]);\n}();\nexport var ContextKeyGreaterEqualsExpr = /*#__PURE__*/function () {\n  function ContextKeyGreaterEqualsExpr(key, value, negated) {\n    _classCallCheck(this, ContextKeyGreaterEqualsExpr);\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 13 /* ContextKeyExprType.GreaterEquals */;\n  }\n  return _createClass(ContextKeyGreaterEqualsExpr, [{\n    key: \"cmp\",\n    value: function cmp(other) {\n      if (other.type !== this.type) {\n        return this.type - other.type;\n      }\n      return cmp2(this.key, this.value, other.key, other.value);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (other.type === this.type) {\n        return this.key === other.key && this.value === other.value;\n      }\n      return false;\n    }\n  }, {\n    key: \"substituteConstants\",\n    value: function substituteConstants() {\n      return this;\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(context) {\n      if (typeof this.value === 'string') {\n        return false;\n      }\n      return parseFloat(context.getValue(this.key)) >= this.value;\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return \"\".concat(this.key, \" >= \").concat(this.value);\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      return [this.key];\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      if (!this.negated) {\n        this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);\n      }\n      return this.negated;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(key, _value) {\n      var negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      return withFloatOrStr(_value, function (value) {\n        return new ContextKeyGreaterEqualsExpr(key, value, negated);\n      });\n    }\n  }]);\n}();\nexport var ContextKeySmallerExpr = /*#__PURE__*/function () {\n  function ContextKeySmallerExpr(key, value, negated) {\n    _classCallCheck(this, ContextKeySmallerExpr);\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 14 /* ContextKeyExprType.Smaller */;\n  }\n  return _createClass(ContextKeySmallerExpr, [{\n    key: \"cmp\",\n    value: function cmp(other) {\n      if (other.type !== this.type) {\n        return this.type - other.type;\n      }\n      return cmp2(this.key, this.value, other.key, other.value);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (other.type === this.type) {\n        return this.key === other.key && this.value === other.value;\n      }\n      return false;\n    }\n  }, {\n    key: \"substituteConstants\",\n    value: function substituteConstants() {\n      return this;\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(context) {\n      if (typeof this.value === 'string') {\n        return false;\n      }\n      return parseFloat(context.getValue(this.key)) < this.value;\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return \"\".concat(this.key, \" < \").concat(this.value);\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      return [this.key];\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      if (!this.negated) {\n        this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);\n      }\n      return this.negated;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(key, _value) {\n      var negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      return withFloatOrStr(_value, function (value) {\n        return new ContextKeySmallerExpr(key, value, negated);\n      });\n    }\n  }]);\n}();\nexport var ContextKeySmallerEqualsExpr = /*#__PURE__*/function () {\n  function ContextKeySmallerEqualsExpr(key, value, negated) {\n    _classCallCheck(this, ContextKeySmallerEqualsExpr);\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 15 /* ContextKeyExprType.SmallerEquals */;\n  }\n  return _createClass(ContextKeySmallerEqualsExpr, [{\n    key: \"cmp\",\n    value: function cmp(other) {\n      if (other.type !== this.type) {\n        return this.type - other.type;\n      }\n      return cmp2(this.key, this.value, other.key, other.value);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (other.type === this.type) {\n        return this.key === other.key && this.value === other.value;\n      }\n      return false;\n    }\n  }, {\n    key: \"substituteConstants\",\n    value: function substituteConstants() {\n      return this;\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(context) {\n      if (typeof this.value === 'string') {\n        return false;\n      }\n      return parseFloat(context.getValue(this.key)) <= this.value;\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return \"\".concat(this.key, \" <= \").concat(this.value);\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      return [this.key];\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      if (!this.negated) {\n        this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);\n      }\n      return this.negated;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(key, _value) {\n      var negated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      return withFloatOrStr(_value, function (value) {\n        return new ContextKeySmallerEqualsExpr(key, value, negated);\n      });\n    }\n  }]);\n}();\nexport var ContextKeyRegexExpr = /*#__PURE__*/function () {\n  function ContextKeyRegexExpr(key, regexp) {\n    _classCallCheck(this, ContextKeyRegexExpr);\n    this.key = key;\n    this.regexp = regexp;\n    this.type = 7 /* ContextKeyExprType.Regex */;\n    this.negated = null;\n    //\n  }\n  return _createClass(ContextKeyRegexExpr, [{\n    key: \"cmp\",\n    value: function cmp(other) {\n      if (other.type !== this.type) {\n        return this.type - other.type;\n      }\n      if (this.key < other.key) {\n        return -1;\n      }\n      if (this.key > other.key) {\n        return 1;\n      }\n      var thisSource = this.regexp ? this.regexp.source : '';\n      var otherSource = other.regexp ? other.regexp.source : '';\n      if (thisSource < otherSource) {\n        return -1;\n      }\n      if (thisSource > otherSource) {\n        return 1;\n      }\n      return 0;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (other.type === this.type) {\n        var thisSource = this.regexp ? this.regexp.source : '';\n        var otherSource = other.regexp ? other.regexp.source : '';\n        return this.key === other.key && thisSource === otherSource;\n      }\n      return false;\n    }\n  }, {\n    key: \"substituteConstants\",\n    value: function substituteConstants() {\n      return this;\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(context) {\n      var value = context.getValue(this.key);\n      return this.regexp ? this.regexp.test(value) : false;\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var value = this.regexp ? \"/\".concat(this.regexp.source, \"/\").concat(this.regexp.flags) : '/invalid/';\n      return \"\".concat(this.key, \" =~ \").concat(value);\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      return [this.key];\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      if (!this.negated) {\n        this.negated = ContextKeyNotRegexExpr.create(this);\n      }\n      return this.negated;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(key, regexp) {\n      return new ContextKeyRegexExpr(key, regexp);\n    }\n  }]);\n}();\nexport var ContextKeyNotRegexExpr = /*#__PURE__*/function () {\n  function ContextKeyNotRegexExpr(_actual) {\n    _classCallCheck(this, ContextKeyNotRegexExpr);\n    this._actual = _actual;\n    this.type = 8 /* ContextKeyExprType.NotRegex */;\n    //\n  }\n  return _createClass(ContextKeyNotRegexExpr, [{\n    key: \"cmp\",\n    value: function cmp(other) {\n      if (other.type !== this.type) {\n        return this.type - other.type;\n      }\n      return this._actual.cmp(other._actual);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (other.type === this.type) {\n        return this._actual.equals(other._actual);\n      }\n      return false;\n    }\n  }, {\n    key: \"substituteConstants\",\n    value: function substituteConstants() {\n      return this;\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(context) {\n      return !this._actual.evaluate(context);\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return \"!(\".concat(this._actual.serialize(), \")\");\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      return this._actual.keys();\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      return this._actual;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(actual) {\n      return new ContextKeyNotRegexExpr(actual);\n    }\n  }]);\n}();\n/**\n * @returns the same instance if nothing changed.\n */\nfunction eliminateConstantsInArray(arr) {\n  // Allocate array only if there is a difference\n  var newArr = null;\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var newExpr = arr[i].substituteConstants();\n    if (arr[i] !== newExpr) {\n      // something has changed!\n      // allocate array on first difference\n      if (newArr === null) {\n        newArr = [];\n        for (var j = 0; j < i; j++) {\n          newArr[j] = arr[j];\n        }\n      }\n    }\n    if (newArr !== null) {\n      newArr[i] = newExpr;\n    }\n  }\n  if (newArr === null) {\n    return arr;\n  }\n  return newArr;\n}\nexport var ContextKeyAndExpr = /*#__PURE__*/function () {\n  function ContextKeyAndExpr(expr, negated) {\n    _classCallCheck(this, ContextKeyAndExpr);\n    this.expr = expr;\n    this.negated = negated;\n    this.type = 6 /* ContextKeyExprType.And */;\n  }\n  return _createClass(ContextKeyAndExpr, [{\n    key: \"cmp\",\n    value: function cmp(other) {\n      if (other.type !== this.type) {\n        return this.type - other.type;\n      }\n      if (this.expr.length < other.expr.length) {\n        return -1;\n      }\n      if (this.expr.length > other.expr.length) {\n        return 1;\n      }\n      for (var i = 0, len = this.expr.length; i < len; i++) {\n        var r = _cmp(this.expr[i], other.expr[i]);\n        if (r !== 0) {\n          return r;\n        }\n      }\n      return 0;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (other.type === this.type) {\n        if (this.expr.length !== other.expr.length) {\n          return false;\n        }\n        for (var i = 0, len = this.expr.length; i < len; i++) {\n          if (!this.expr[i].equals(other.expr[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"substituteConstants\",\n    value: function substituteConstants() {\n      var exprArr = eliminateConstantsInArray(this.expr);\n      if (exprArr === this.expr) {\n        // no change\n        return this;\n      }\n      return ContextKeyAndExpr.create(exprArr, this.negated, false);\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(context) {\n      for (var i = 0, len = this.expr.length; i < len; i++) {\n        if (!this.expr[i].evaluate(context)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return this.expr.map(function (e) {\n        return e.serialize();\n      }).join(' && ');\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      var result = [];\n      var _iterator = _createForOfIteratorHelper(this.expr),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var expr = _step.value;\n          result.push.apply(result, _toConsumableArray(expr.keys()));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return result;\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      if (!this.negated) {\n        var result = [];\n        var _iterator2 = _createForOfIteratorHelper(this.expr),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var expr = _step2.value;\n            result.push(expr.negate());\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        this.negated = ContextKeyOrExpr.create(result, this, true);\n      }\n      return this.negated;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(_expr, negated, extraRedundantCheck) {\n      return ContextKeyAndExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n    }\n  }, {\n    key: \"_normalizeArr\",\n    value: function _normalizeArr(arr, negated, extraRedundantCheck) {\n      var expr = [];\n      var hasTrue = false;\n      var _iterator3 = _createForOfIteratorHelper(arr),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var e = _step3.value;\n          if (!e) {\n            continue;\n          }\n          if (e.type === 1 /* ContextKeyExprType.True */) {\n            // anything && true ==> anything\n            hasTrue = true;\n            continue;\n          }\n          if (e.type === 0 /* ContextKeyExprType.False */) {\n            // anything && false ==> false\n            return ContextKeyFalseExpr.INSTANCE;\n          }\n          if (e.type === 6 /* ContextKeyExprType.And */) {\n            expr.push.apply(expr, _toConsumableArray(e.expr));\n            continue;\n          }\n          expr.push(e);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      if (expr.length === 0 && hasTrue) {\n        return ContextKeyTrueExpr.INSTANCE;\n      }\n      if (expr.length === 0) {\n        return undefined;\n      }\n      if (expr.length === 1) {\n        return expr[0];\n      }\n      expr.sort(_cmp);\n      // eliminate duplicate terms\n      for (var i = 1; i < expr.length; i++) {\n        if (expr[i - 1].equals(expr[i])) {\n          expr.splice(i, 1);\n          i--;\n        }\n      }\n      if (expr.length === 1) {\n        return expr[0];\n      }\n      // We must distribute any OR expression because we don't support parens\n      // OR extensions will be at the end (due to sorting rules)\n      var _loop = function _loop() {\n        var lastElement = expr[expr.length - 1];\n        if (lastElement.type !== 9 /* ContextKeyExprType.Or */) {\n          return 1; // break\n        }\n        // pop the last element\n        expr.pop();\n        // pop the second to last element\n        var secondToLastElement = expr.pop();\n        var isFinished = expr.length === 0;\n        // distribute `lastElement` over `secondToLastElement`\n        var resultElement = ContextKeyOrExpr.create(lastElement.expr.map(function (el) {\n          return ContextKeyAndExpr.create([el, secondToLastElement], null, extraRedundantCheck);\n        }), null, isFinished);\n        if (resultElement) {\n          expr.push(resultElement);\n          expr.sort(_cmp);\n        }\n      };\n      while (expr.length > 1) {\n        if (_loop()) break;\n      }\n      if (expr.length === 1) {\n        return expr[0];\n      }\n      // resolve false AND expressions\n      if (extraRedundantCheck) {\n        for (var _i2 = 0; _i2 < expr.length; _i2++) {\n          for (var j = _i2 + 1; j < expr.length; j++) {\n            if (expr[_i2].negate().equals(expr[j])) {\n              // A && !A case\n              return ContextKeyFalseExpr.INSTANCE;\n            }\n          }\n        }\n        if (expr.length === 1) {\n          return expr[0];\n        }\n      }\n      return new ContextKeyAndExpr(expr, negated);\n    }\n  }]);\n}();\nexport var ContextKeyOrExpr = /*#__PURE__*/function () {\n  function ContextKeyOrExpr(expr, negated) {\n    _classCallCheck(this, ContextKeyOrExpr);\n    this.expr = expr;\n    this.negated = negated;\n    this.type = 9 /* ContextKeyExprType.Or */;\n  }\n  return _createClass(ContextKeyOrExpr, [{\n    key: \"cmp\",\n    value: function cmp(other) {\n      if (other.type !== this.type) {\n        return this.type - other.type;\n      }\n      if (this.expr.length < other.expr.length) {\n        return -1;\n      }\n      if (this.expr.length > other.expr.length) {\n        return 1;\n      }\n      for (var i = 0, len = this.expr.length; i < len; i++) {\n        var r = _cmp(this.expr[i], other.expr[i]);\n        if (r !== 0) {\n          return r;\n        }\n      }\n      return 0;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (other.type === this.type) {\n        if (this.expr.length !== other.expr.length) {\n          return false;\n        }\n        for (var i = 0, len = this.expr.length; i < len; i++) {\n          if (!this.expr[i].equals(other.expr[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"substituteConstants\",\n    value: function substituteConstants() {\n      var exprArr = eliminateConstantsInArray(this.expr);\n      if (exprArr === this.expr) {\n        // no change\n        return this;\n      }\n      return ContextKeyOrExpr.create(exprArr, this.negated, false);\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(context) {\n      for (var i = 0, len = this.expr.length; i < len; i++) {\n        if (this.expr[i].evaluate(context)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return this.expr.map(function (e) {\n        return e.serialize();\n      }).join(' || ');\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      var result = [];\n      var _iterator4 = _createForOfIteratorHelper(this.expr),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var expr = _step4.value;\n          result.push.apply(result, _toConsumableArray(expr.keys()));\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      return result;\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      if (!this.negated) {\n        var result = [];\n        var _iterator5 = _createForOfIteratorHelper(this.expr),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var expr = _step5.value;\n            result.push(expr.negate());\n          }\n          // We don't support parens, so here we distribute the AND over the OR terminals\n          // We always take the first 2 AND pairs and distribute them\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n        while (result.length > 1) {\n          var LEFT = result.shift();\n          var RIGHT = result.shift();\n          var all = [];\n          var _iterator6 = _createForOfIteratorHelper(getTerminals(LEFT)),\n            _step6;\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var left = _step6.value;\n              var _iterator7 = _createForOfIteratorHelper(getTerminals(RIGHT)),\n                _step7;\n              try {\n                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                  var right = _step7.value;\n                  all.push(ContextKeyAndExpr.create([left, right], null, false));\n                }\n              } catch (err) {\n                _iterator7.e(err);\n              } finally {\n                _iterator7.f();\n              }\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n          result.unshift(ContextKeyOrExpr.create(all, null, false));\n        }\n        this.negated = ContextKeyOrExpr.create(result, this, true);\n      }\n      return this.negated;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(_expr, negated, extraRedundantCheck) {\n      return ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n    }\n  }, {\n    key: \"_normalizeArr\",\n    value: function _normalizeArr(arr, negated, extraRedundantCheck) {\n      var expr = [];\n      var hasFalse = false;\n      if (arr) {\n        for (var i = 0, len = arr.length; i < len; i++) {\n          var e = arr[i];\n          if (!e) {\n            continue;\n          }\n          if (e.type === 0 /* ContextKeyExprType.False */) {\n            // anything || false ==> anything\n            hasFalse = true;\n            continue;\n          }\n          if (e.type === 1 /* ContextKeyExprType.True */) {\n            // anything || true ==> true\n            return ContextKeyTrueExpr.INSTANCE;\n          }\n          if (e.type === 9 /* ContextKeyExprType.Or */) {\n            expr = expr.concat(e.expr);\n            continue;\n          }\n          expr.push(e);\n        }\n        if (expr.length === 0 && hasFalse) {\n          return ContextKeyFalseExpr.INSTANCE;\n        }\n        expr.sort(_cmp);\n      }\n      if (expr.length === 0) {\n        return undefined;\n      }\n      if (expr.length === 1) {\n        return expr[0];\n      }\n      // eliminate duplicate terms\n      for (var _i3 = 1; _i3 < expr.length; _i3++) {\n        if (expr[_i3 - 1].equals(expr[_i3])) {\n          expr.splice(_i3, 1);\n          _i3--;\n        }\n      }\n      if (expr.length === 1) {\n        return expr[0];\n      }\n      // resolve true OR expressions\n      if (extraRedundantCheck) {\n        for (var _i4 = 0; _i4 < expr.length; _i4++) {\n          for (var j = _i4 + 1; j < expr.length; j++) {\n            if (expr[_i4].negate().equals(expr[j])) {\n              // A || !A case\n              return ContextKeyTrueExpr.INSTANCE;\n            }\n          }\n        }\n        if (expr.length === 1) {\n          return expr[0];\n        }\n      }\n      return new ContextKeyOrExpr(expr, negated);\n    }\n  }]);\n}();\nexport var RawContextKey = /*#__PURE__*/function (_ContextKeyDefinedExp) {\n  function RawContextKey(key, defaultValue, metaOrHide) {\n    var _this;\n    _classCallCheck(this, RawContextKey);\n    _this = _callSuper(this, RawContextKey, [key, null]);\n    _this._defaultValue = defaultValue;\n    // collect all context keys into a central place\n    if (_typeof(metaOrHide) === 'object') {\n      RawContextKey._info.push(_objectSpread(_objectSpread({}, metaOrHide), {}, {\n        key: key\n      }));\n    } else if (metaOrHide !== true) {\n      RawContextKey._info.push({\n        key: key,\n        description: metaOrHide,\n        type: defaultValue !== null && defaultValue !== undefined ? _typeof(defaultValue) : undefined\n      });\n    }\n    return _this;\n  }\n  _inherits(RawContextKey, _ContextKeyDefinedExp);\n  return _createClass(RawContextKey, [{\n    key: \"bindTo\",\n    value: function bindTo(target) {\n      return target.createKey(this.key, this._defaultValue);\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue(target) {\n      return target.getContextKeyValue(this.key);\n    }\n  }, {\n    key: \"toNegated\",\n    value: function toNegated() {\n      return this.negate();\n    }\n  }, {\n    key: \"isEqualTo\",\n    value: function isEqualTo(value) {\n      return ContextKeyEqualsExpr.create(this.key, value);\n    }\n  }], [{\n    key: \"all\",\n    value: function all() {\n      return RawContextKey._info.values();\n    }\n  }]);\n}(ContextKeyDefinedExpr);\nRawContextKey._info = [];\nexport var IContextKeyService = createDecorator('contextKeyService');\nfunction cmp1(key1, key2) {\n  if (key1 < key2) {\n    return -1;\n  }\n  if (key1 > key2) {\n    return 1;\n  }\n  return 0;\n}\nfunction cmp2(key1, value1, key2, value2) {\n  if (key1 < key2) {\n    return -1;\n  }\n  if (key1 > key2) {\n    return 1;\n  }\n  if (value1 < value2) {\n    return -1;\n  }\n  if (value1 > value2) {\n    return 1;\n  }\n  return 0;\n}\n/**\n * Returns true if it is provable `p` implies `q`.\n */\nexport function implies(p, q) {\n  if (p.type === 0 /* ContextKeyExprType.False */ || q.type === 1 /* ContextKeyExprType.True */) {\n    // false implies anything\n    // anything implies true\n    return true;\n  }\n  if (p.type === 9 /* ContextKeyExprType.Or */) {\n    if (q.type === 9 /* ContextKeyExprType.Or */) {\n      // `a || b || c` can only imply something like `a || b || c || d`\n      return allElementsIncluded(p.expr, q.expr);\n    }\n    return false;\n  }\n  if (q.type === 9 /* ContextKeyExprType.Or */) {\n    var _iterator8 = _createForOfIteratorHelper(q.expr),\n      _step8;\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var element = _step8.value;\n        if (implies(p, element)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n    return false;\n  }\n  if (p.type === 6 /* ContextKeyExprType.And */) {\n    if (q.type === 6 /* ContextKeyExprType.And */) {\n      // `a && b && c` implies `a && c`\n      return allElementsIncluded(q.expr, p.expr);\n    }\n    var _iterator9 = _createForOfIteratorHelper(p.expr),\n      _step9;\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var _element = _step9.value;\n        if (implies(_element, q)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n    return false;\n  }\n  return p.equals(q);\n}\n/**\n * Returns true if all elements in `p` are also present in `q`.\n * The two arrays are assumed to be sorted\n */\nfunction allElementsIncluded(p, q) {\n  var pIndex = 0;\n  var qIndex = 0;\n  while (pIndex < p.length && qIndex < q.length) {\n    var cmp = p[pIndex].cmp(q[qIndex]);\n    if (cmp < 0) {\n      // an element from `p` is missing from `q`\n      return false;\n    } else if (cmp === 0) {\n      pIndex++;\n      qIndex++;\n    } else {\n      qIndex++;\n    }\n  }\n  return pIndex === p.length;\n}\nfunction getTerminals(node) {\n  if (node.type === 9 /* ContextKeyExprType.Or */) {\n    return node.expr;\n  }\n  return [node];\n}","map":{"version":3,"names":["isChrome","isEdge","isFirefox","isLinux","isMacintosh","isSafari","isWeb","isWindows","isFalsyOrWhitespace","Scanner","createDecorator","localize","CONSTANT_VALUES","Map","set","hasOwnProperty","Object","prototype","defaultConfig","regexParsingWithErrorRecovery","errorEmptyString","hintEmptyString","errorNoInAfterNot","errorClosingParenthesis","errorUnexpectedToken","hintUnexpectedToken","errorUnexpectedEOF","hintUnexpectedEOF","Parser","_config","arguments","length","undefined","_classCallCheck","_scanner","_tokens","_current","_parsingErrors","_flagsGYRe","_createClass","key","value","parse","input","push","message","offset","lexeme","additionalInfo","reset","scan","expr","_expr","_isAtEnd","peek","_peek","type","getLexeme","_parseError","e","_or","_and","_matchOne","right","ContextKeyExpr","or","apply","_term","and","_advance","ContextKeyFalseExpr","INSTANCE","ContextKeyTrueExpr","_consume","negate","ContextKeyNotExpr","create","_errExpectedButGot","_primary","regexLexeme","closingSlashIndex","lastIndexOf","flags","_removeFlagsGY","substring","regexp","RegExp","ContextKeyRegexExpr","lexemeReconstruction","followingToken","parenBalance","i","charCodeAt","join","regex","serializedValue","start","indexOf","end","slice","caseIgnoreFlag","_e","_value","notIn","maybeOp","_previous","equals","has","not","notEquals","ContextKeySmallerExpr","ContextKeySmallerEqualsExpr","ContextKeyGreaterExpr","ContextKeyGreaterEqualsExpr","token","replaceAll","_check","expected","got","Error","_false","_true","ContextKeyDefinedExpr","ContextKeyEqualsExpr","ContextKeyNotEqualsExpr","_in","ContextKeyInExpr","ContextKeyNotInExpr","_len","Array","_key","ContextKeyAndExpr","_len2","_key2","ContextKeyOrExpr","deserialize","serialized","_parser","expressionsAreEqualWithConstantSubstitution","a","b","aExpr","substituteConstants","bExpr","cmp","other","evaluate","context","serialize","keys","negated","cmp1","constantValue","get","getValue","cmp2","trueValue","concat","valueKey","source","item","isArray","includes","_typeof","call","_negated","falseValue","withFloatOrStr","callback","n","parseFloat","isNaN","thisSource","otherSource","test","ContextKeyNotRegexExpr","_actual","actual","eliminateConstantsInArray","arr","newArr","len","newExpr","j","r","exprArr","map","result","_iterator","_createForOfIteratorHelper","_step","s","done","_toConsumableArray","err","f","_iterator2","_step2","extraRedundantCheck","_normalizeArr","hasTrue","_iterator3","_step3","sort","splice","_loop","lastElement","pop","secondToLastElement","isFinished","resultElement","el","_iterator4","_step4","_iterator5","_step5","LEFT","shift","RIGHT","all","_iterator6","getTerminals","_step6","left","_iterator7","_step7","unshift","hasFalse","RawContextKey","_ContextKeyDefinedExp","defaultValue","metaOrHide","_this","_callSuper","_defaultValue","_info","_objectSpread","description","_inherits","bindTo","target","createKey","getContextKeyValue","toNegated","isEqualTo","values","IContextKeyService","key1","key2","value1","value2","implies","p","q","allElementsIncluded","_iterator8","_step8","element","_iterator9","_step9","pIndex","qIndex","node"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { isChrome, isEdge, isFirefox, isLinux, isMacintosh, isSafari, isWeb, isWindows } from '../../../base/common/platform.js';\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { Scanner } from './scanner.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport { localize } from '../../../nls.js';\nconst CONSTANT_VALUES = new Map();\nCONSTANT_VALUES.set('false', false);\nCONSTANT_VALUES.set('true', true);\nCONSTANT_VALUES.set('isMac', isMacintosh);\nCONSTANT_VALUES.set('isLinux', isLinux);\nCONSTANT_VALUES.set('isWindows', isWindows);\nCONSTANT_VALUES.set('isWeb', isWeb);\nCONSTANT_VALUES.set('isMacNative', isMacintosh && !isWeb);\nCONSTANT_VALUES.set('isEdge', isEdge);\nCONSTANT_VALUES.set('isFirefox', isFirefox);\nCONSTANT_VALUES.set('isChrome', isChrome);\nCONSTANT_VALUES.set('isSafari', isSafari);\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst defaultConfig = {\n    regexParsingWithErrorRecovery: true\n};\nconst errorEmptyString = localize('contextkey.parser.error.emptyString', \"Empty context key expression\");\nconst hintEmptyString = localize('contextkey.parser.error.emptyString.hint', \"Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively.\");\nconst errorNoInAfterNot = localize('contextkey.parser.error.noInAfterNot', \"'in' after 'not'.\");\nconst errorClosingParenthesis = localize('contextkey.parser.error.closingParenthesis', \"closing parenthesis ')'\");\nconst errorUnexpectedToken = localize('contextkey.parser.error.unexpectedToken', \"Unexpected token\");\nconst hintUnexpectedToken = localize('contextkey.parser.error.unexpectedToken.hint', \"Did you forget to put && or || before the token?\");\nconst errorUnexpectedEOF = localize('contextkey.parser.error.unexpectedEOF', \"Unexpected end of expression\");\nconst hintUnexpectedEOF = localize('contextkey.parser.error.unexpectedEOF.hint', \"Did you forget to put a context key?\");\n/**\n * A parser for context key expressions.\n *\n * Example:\n * ```ts\n * const parser = new Parser();\n * const expr = parser.parse('foo == \"bar\" && baz == true');\n *\n * if (expr === undefined) {\n * \t// there were lexing or parsing errors\n * \t// process lexing errors with `parser.lexingErrors`\n *  // process parsing errors with `parser.parsingErrors`\n * } else {\n * \t// expr is a valid expression\n * }\n * ```\n */\nexport class Parser {\n    constructor(_config = defaultConfig) {\n        this._config = _config;\n        // lifetime note: `_scanner` lives as long as the parser does, i.e., is not reset between calls to `parse`\n        this._scanner = new Scanner();\n        // lifetime note: `_tokens`, `_current`, and `_parsingErrors` must be reset between calls to `parse`\n        this._tokens = [];\n        this._current = 0; // invariant: 0 <= this._current < this._tokens.length ; any incrementation of this value must first call `_isAtEnd`\n        this._parsingErrors = [];\n        this._flagsGYRe = /g|y/g;\n    }\n    /**\n     * Parse a context key expression.\n     *\n     * @param input the expression to parse\n     * @returns the parsed expression or `undefined` if there's an error - call `lexingErrors` and `parsingErrors` to see the errors\n     */\n    parse(input) {\n        if (input === '') {\n            this._parsingErrors.push({ message: errorEmptyString, offset: 0, lexeme: '', additionalInfo: hintEmptyString });\n            return undefined;\n        }\n        this._tokens = this._scanner.reset(input).scan();\n        // @ulugbekna: we do not stop parsing if there are lexing errors to be able to reconstruct regexes with unescaped slashes; TODO@ulugbekna: make this respect config option for recovery\n        this._current = 0;\n        this._parsingErrors = [];\n        try {\n            const expr = this._expr();\n            if (!this._isAtEnd()) {\n                const peek = this._peek();\n                const additionalInfo = peek.type === 17 /* TokenType.Str */ ? hintUnexpectedToken : undefined;\n                this._parsingErrors.push({ message: errorUnexpectedToken, offset: peek.offset, lexeme: Scanner.getLexeme(peek), additionalInfo });\n                throw Parser._parseError;\n            }\n            return expr;\n        }\n        catch (e) {\n            if (!(e === Parser._parseError)) {\n                throw e;\n            }\n            return undefined;\n        }\n    }\n    _expr() {\n        return this._or();\n    }\n    _or() {\n        const expr = [this._and()];\n        while (this._matchOne(16 /* TokenType.Or */)) {\n            const right = this._and();\n            expr.push(right);\n        }\n        return expr.length === 1 ? expr[0] : ContextKeyExpr.or(...expr);\n    }\n    _and() {\n        const expr = [this._term()];\n        while (this._matchOne(15 /* TokenType.And */)) {\n            const right = this._term();\n            expr.push(right);\n        }\n        return expr.length === 1 ? expr[0] : ContextKeyExpr.and(...expr);\n    }\n    _term() {\n        if (this._matchOne(2 /* TokenType.Neg */)) {\n            const peek = this._peek();\n            switch (peek.type) {\n                case 11 /* TokenType.True */:\n                    this._advance();\n                    return ContextKeyFalseExpr.INSTANCE;\n                case 12 /* TokenType.False */:\n                    this._advance();\n                    return ContextKeyTrueExpr.INSTANCE;\n                case 0 /* TokenType.LParen */: {\n                    this._advance();\n                    const expr = this._expr();\n                    this._consume(1 /* TokenType.RParen */, errorClosingParenthesis);\n                    return expr === null || expr === void 0 ? void 0 : expr.negate();\n                }\n                case 17 /* TokenType.Str */:\n                    this._advance();\n                    return ContextKeyNotExpr.create(peek.lexeme);\n                default:\n                    throw this._errExpectedButGot(`KEY | true | false | '(' expression ')'`, peek);\n            }\n        }\n        return this._primary();\n    }\n    _primary() {\n        const peek = this._peek();\n        switch (peek.type) {\n            case 11 /* TokenType.True */:\n                this._advance();\n                return ContextKeyExpr.true();\n            case 12 /* TokenType.False */:\n                this._advance();\n                return ContextKeyExpr.false();\n            case 0 /* TokenType.LParen */: {\n                this._advance();\n                const expr = this._expr();\n                this._consume(1 /* TokenType.RParen */, errorClosingParenthesis);\n                return expr;\n            }\n            case 17 /* TokenType.Str */: {\n                // KEY\n                const key = peek.lexeme;\n                this._advance();\n                // =~ regex\n                if (this._matchOne(9 /* TokenType.RegexOp */)) {\n                    // @ulugbekna: we need to reconstruct the regex from the tokens because some extensions use unescaped slashes in regexes\n                    const expr = this._peek();\n                    if (!this._config.regexParsingWithErrorRecovery) {\n                        this._advance();\n                        if (expr.type !== 10 /* TokenType.RegexStr */) {\n                            throw this._errExpectedButGot(`REGEX`, expr);\n                        }\n                        const regexLexeme = expr.lexeme;\n                        const closingSlashIndex = regexLexeme.lastIndexOf('/');\n                        const flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n                        let regexp;\n                        try {\n                            regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);\n                        }\n                        catch (e) {\n                            throw this._errExpectedButGot(`REGEX`, expr);\n                        }\n                        return ContextKeyRegexExpr.create(key, regexp);\n                    }\n                    switch (expr.type) {\n                        case 10 /* TokenType.RegexStr */:\n                        case 19 /* TokenType.Error */: { // also handle an ErrorToken in case of smth such as /(/file)/\n                            const lexemeReconstruction = [expr.lexeme]; // /REGEX/ or /REGEX/FLAGS\n                            this._advance();\n                            let followingToken = this._peek();\n                            let parenBalance = 0;\n                            for (let i = 0; i < expr.lexeme.length; i++) {\n                                if (expr.lexeme.charCodeAt(i) === 40 /* CharCode.OpenParen */) {\n                                    parenBalance++;\n                                }\n                                else if (expr.lexeme.charCodeAt(i) === 41 /* CharCode.CloseParen */) {\n                                    parenBalance--;\n                                }\n                            }\n                            while (!this._isAtEnd() && followingToken.type !== 15 /* TokenType.And */ && followingToken.type !== 16 /* TokenType.Or */) {\n                                switch (followingToken.type) {\n                                    case 0 /* TokenType.LParen */:\n                                        parenBalance++;\n                                        break;\n                                    case 1 /* TokenType.RParen */:\n                                        parenBalance--;\n                                        break;\n                                    case 10 /* TokenType.RegexStr */:\n                                    case 18 /* TokenType.QuotedStr */:\n                                        for (let i = 0; i < followingToken.lexeme.length; i++) {\n                                            if (followingToken.lexeme.charCodeAt(i) === 40 /* CharCode.OpenParen */) {\n                                                parenBalance++;\n                                            }\n                                            else if (expr.lexeme.charCodeAt(i) === 41 /* CharCode.CloseParen */) {\n                                                parenBalance--;\n                                            }\n                                        }\n                                }\n                                if (parenBalance < 0) {\n                                    break;\n                                }\n                                lexemeReconstruction.push(Scanner.getLexeme(followingToken));\n                                this._advance();\n                                followingToken = this._peek();\n                            }\n                            const regexLexeme = lexemeReconstruction.join('');\n                            const closingSlashIndex = regexLexeme.lastIndexOf('/');\n                            const flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n                            let regexp;\n                            try {\n                                regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);\n                            }\n                            catch (e) {\n                                throw this._errExpectedButGot(`REGEX`, expr);\n                            }\n                            return ContextKeyExpr.regex(key, regexp);\n                        }\n                        case 18 /* TokenType.QuotedStr */: {\n                            const serializedValue = expr.lexeme;\n                            this._advance();\n                            // replicate old regex parsing behavior\n                            let regex = null;\n                            if (!isFalsyOrWhitespace(serializedValue)) {\n                                const start = serializedValue.indexOf('/');\n                                const end = serializedValue.lastIndexOf('/');\n                                if (start !== end && start >= 0) {\n                                    const value = serializedValue.slice(start + 1, end);\n                                    const caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n                                    try {\n                                        regex = new RegExp(value, caseIgnoreFlag);\n                                    }\n                                    catch (_e) {\n                                        throw this._errExpectedButGot(`REGEX`, expr);\n                                    }\n                                }\n                            }\n                            if (regex === null) {\n                                throw this._errExpectedButGot('REGEX', expr);\n                            }\n                            return ContextKeyRegexExpr.create(key, regex);\n                        }\n                        default:\n                            throw this._errExpectedButGot('REGEX', this._peek());\n                    }\n                }\n                // [ 'not' 'in' value ]\n                if (this._matchOne(14 /* TokenType.Not */)) {\n                    this._consume(13 /* TokenType.In */, errorNoInAfterNot);\n                    const right = this._value();\n                    return ContextKeyExpr.notIn(key, right);\n                }\n                // [ ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in') value ]\n                const maybeOp = this._peek().type;\n                switch (maybeOp) {\n                    case 3 /* TokenType.Eq */: {\n                        this._advance();\n                        const right = this._value();\n                        if (this._previous().type === 18 /* TokenType.QuotedStr */) { // to preserve old parser behavior: \"foo == 'true'\" is preserved as \"foo == 'true'\", but \"foo == true\" is optimized as \"foo\"\n                            return ContextKeyExpr.equals(key, right);\n                        }\n                        switch (right) {\n                            case 'true':\n                                return ContextKeyExpr.has(key);\n                            case 'false':\n                                return ContextKeyExpr.not(key);\n                            default:\n                                return ContextKeyExpr.equals(key, right);\n                        }\n                    }\n                    case 4 /* TokenType.NotEq */: {\n                        this._advance();\n                        const right = this._value();\n                        if (this._previous().type === 18 /* TokenType.QuotedStr */) { // same as above with \"foo != 'true'\"\n                            return ContextKeyExpr.notEquals(key, right);\n                        }\n                        switch (right) {\n                            case 'true':\n                                return ContextKeyExpr.not(key);\n                            case 'false':\n                                return ContextKeyExpr.has(key);\n                            default:\n                                return ContextKeyExpr.notEquals(key, right);\n                        }\n                    }\n                    // TODO: ContextKeyExpr.smaller(key, right) accepts only `number` as `right` AND during eval of this node, we just eval to `false` if `right` is not a number\n                    // consequently, package.json linter should _warn_ the user if they're passing undesired things to ops\n                    case 5 /* TokenType.Lt */:\n                        this._advance();\n                        return ContextKeySmallerExpr.create(key, this._value());\n                    case 6 /* TokenType.LtEq */:\n                        this._advance();\n                        return ContextKeySmallerEqualsExpr.create(key, this._value());\n                    case 7 /* TokenType.Gt */:\n                        this._advance();\n                        return ContextKeyGreaterExpr.create(key, this._value());\n                    case 8 /* TokenType.GtEq */:\n                        this._advance();\n                        return ContextKeyGreaterEqualsExpr.create(key, this._value());\n                    case 13 /* TokenType.In */:\n                        this._advance();\n                        return ContextKeyExpr.in(key, this._value());\n                    default:\n                        return ContextKeyExpr.has(key);\n                }\n            }\n            case 20 /* TokenType.EOF */:\n                this._parsingErrors.push({ message: errorUnexpectedEOF, offset: peek.offset, lexeme: '', additionalInfo: hintUnexpectedEOF });\n                throw Parser._parseError;\n            default:\n                throw this._errExpectedButGot(`true | false | KEY \\n\\t| KEY '=~' REGEX \\n\\t| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this._peek());\n        }\n    }\n    _value() {\n        const token = this._peek();\n        switch (token.type) {\n            case 17 /* TokenType.Str */:\n            case 18 /* TokenType.QuotedStr */:\n                this._advance();\n                return token.lexeme;\n            case 11 /* TokenType.True */:\n                this._advance();\n                return 'true';\n            case 12 /* TokenType.False */:\n                this._advance();\n                return 'false';\n            case 13 /* TokenType.In */: // we support `in` as a value, e.g., \"when\": \"languageId == in\" - exists in existing extensions\n                this._advance();\n                return 'in';\n            default:\n                // this allows \"when\": \"foo == \" which's used by existing extensions\n                // we do not call `_advance` on purpose - we don't want to eat unintended tokens\n                return '';\n        }\n    }\n    _removeFlagsGY(flags) {\n        return flags.replaceAll(this._flagsGYRe, '');\n    }\n    // careful: this can throw if current token is the initial one (ie index = 0)\n    _previous() {\n        return this._tokens[this._current - 1];\n    }\n    _matchOne(token) {\n        if (this._check(token)) {\n            this._advance();\n            return true;\n        }\n        return false;\n    }\n    _advance() {\n        if (!this._isAtEnd()) {\n            this._current++;\n        }\n        return this._previous();\n    }\n    _consume(type, message) {\n        if (this._check(type)) {\n            return this._advance();\n        }\n        throw this._errExpectedButGot(message, this._peek());\n    }\n    _errExpectedButGot(expected, got, additionalInfo) {\n        const message = localize('contextkey.parser.error.expectedButGot', \"Expected: {0}\\nReceived: '{1}'.\", expected, Scanner.getLexeme(got));\n        const offset = got.offset;\n        const lexeme = Scanner.getLexeme(got);\n        this._parsingErrors.push({ message, offset, lexeme, additionalInfo });\n        return Parser._parseError;\n    }\n    _check(type) {\n        return this._peek().type === type;\n    }\n    _peek() {\n        return this._tokens[this._current];\n    }\n    _isAtEnd() {\n        return this._peek().type === 20 /* TokenType.EOF */;\n    }\n}\n// Note: this doesn't produce an exact syntax tree but a normalized one\n// ContextKeyExpression's that we use as AST nodes do not expose constructors that do not normalize\nParser._parseError = new Error();\nexport class ContextKeyExpr {\n    static false() {\n        return ContextKeyFalseExpr.INSTANCE;\n    }\n    static true() {\n        return ContextKeyTrueExpr.INSTANCE;\n    }\n    static has(key) {\n        return ContextKeyDefinedExpr.create(key);\n    }\n    static equals(key, value) {\n        return ContextKeyEqualsExpr.create(key, value);\n    }\n    static notEquals(key, value) {\n        return ContextKeyNotEqualsExpr.create(key, value);\n    }\n    static regex(key, value) {\n        return ContextKeyRegexExpr.create(key, value);\n    }\n    static in(key, value) {\n        return ContextKeyInExpr.create(key, value);\n    }\n    static notIn(key, value) {\n        return ContextKeyNotInExpr.create(key, value);\n    }\n    static not(key) {\n        return ContextKeyNotExpr.create(key);\n    }\n    static and(...expr) {\n        return ContextKeyAndExpr.create(expr, null, true);\n    }\n    static or(...expr) {\n        return ContextKeyOrExpr.create(expr, null, true);\n    }\n    static deserialize(serialized) {\n        if (serialized === undefined || serialized === null) { // an empty string needs to be handled by the parser to get a corresponding parsing error reported\n            return undefined;\n        }\n        const expr = this._parser.parse(serialized);\n        return expr;\n    }\n}\nContextKeyExpr._parser = new Parser({ regexParsingWithErrorRecovery: false });\nexport function expressionsAreEqualWithConstantSubstitution(a, b) {\n    const aExpr = a ? a.substituteConstants() : undefined;\n    const bExpr = b ? b.substituteConstants() : undefined;\n    if (!aExpr && !bExpr) {\n        return true;\n    }\n    if (!aExpr || !bExpr) {\n        return false;\n    }\n    return aExpr.equals(bExpr);\n}\nfunction cmp(a, b) {\n    return a.cmp(b);\n}\nexport class ContextKeyFalseExpr {\n    constructor() {\n        this.type = 0 /* ContextKeyExprType.False */;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return false;\n    }\n    serialize() {\n        return 'false';\n    }\n    keys() {\n        return [];\n    }\n    negate() {\n        return ContextKeyTrueExpr.INSTANCE;\n    }\n}\nContextKeyFalseExpr.INSTANCE = new ContextKeyFalseExpr();\nexport class ContextKeyTrueExpr {\n    constructor() {\n        this.type = 1 /* ContextKeyExprType.True */;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return true;\n    }\n    serialize() {\n        return 'true';\n    }\n    keys() {\n        return [];\n    }\n    negate() {\n        return ContextKeyFalseExpr.INSTANCE;\n    }\n}\nContextKeyTrueExpr.INSTANCE = new ContextKeyTrueExpr();\nexport class ContextKeyDefinedExpr {\n    static create(key, negated = null) {\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n        }\n        return new ContextKeyDefinedExpr(key, negated);\n    }\n    constructor(key, negated) {\n        this.key = key;\n        this.negated = negated;\n        this.type = 2 /* ContextKeyExprType.Defined */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (!!context.getValue(this.key));\n    }\n    serialize() {\n        return this.key;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotExpr.create(this.key, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyEqualsExpr {\n    static create(key, value, negated = null) {\n        if (typeof value === 'boolean') {\n            return (value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated));\n        }\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            const trueValue = constantValue ? 'true' : 'false';\n            return (value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n        }\n        return new ContextKeyEqualsExpr(key, value, negated);\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 4 /* ContextKeyExprType.Equals */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            const trueValue = constantValue ? 'true' : 'false';\n            return (this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        // Intentional ==\n        // eslint-disable-next-line eqeqeq\n        return (context.getValue(this.key) == this.value);\n    }\n    serialize() {\n        return `${this.key} == '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyInExpr {\n    static create(key, valueKey) {\n        return new ContextKeyInExpr(key, valueKey);\n    }\n    constructor(key, valueKey) {\n        this.key = key;\n        this.valueKey = valueKey;\n        this.type = 10 /* ContextKeyExprType.In */;\n        this.negated = null;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.valueKey, other.key, other.valueKey);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.valueKey === other.valueKey);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        const source = context.getValue(this.valueKey);\n        const item = context.getValue(this.key);\n        if (Array.isArray(source)) {\n            return source.includes(item);\n        }\n        if (typeof item === 'string' && typeof source === 'object' && source !== null) {\n            return hasOwnProperty.call(source, item);\n        }\n        return false;\n    }\n    serialize() {\n        return `${this.key} in '${this.valueKey}'`;\n    }\n    keys() {\n        return [this.key, this.valueKey];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotInExpr {\n    static create(key, valueKey) {\n        return new ContextKeyNotInExpr(key, valueKey);\n    }\n    constructor(key, valueKey) {\n        this.key = key;\n        this.valueKey = valueKey;\n        this.type = 11 /* ContextKeyExprType.NotIn */;\n        this._negated = ContextKeyInExpr.create(key, valueKey);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._negated.cmp(other._negated);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._negated.equals(other._negated);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return !this._negated.evaluate(context);\n    }\n    serialize() {\n        return `${this.key} not in '${this.valueKey}'`;\n    }\n    keys() {\n        return this._negated.keys();\n    }\n    negate() {\n        return this._negated;\n    }\n}\nexport class ContextKeyNotEqualsExpr {\n    static create(key, value, negated = null) {\n        if (typeof value === 'boolean') {\n            if (value) {\n                return ContextKeyNotExpr.create(key, negated);\n            }\n            return ContextKeyDefinedExpr.create(key, negated);\n        }\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            const falseValue = constantValue ? 'true' : 'false';\n            return (value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return new ContextKeyNotEqualsExpr(key, value, negated);\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 5 /* ContextKeyExprType.NotEquals */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            const falseValue = constantValue ? 'true' : 'false';\n            return (this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        // Intentional !=\n        // eslint-disable-next-line eqeqeq\n        return (context.getValue(this.key) != this.value);\n    }\n    serialize() {\n        return `${this.key} != '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotExpr {\n    static create(key, negated = null) {\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return new ContextKeyNotExpr(key, negated);\n    }\n    constructor(key, negated) {\n        this.key = key;\n        this.negated = negated;\n        this.type = 3 /* ContextKeyExprType.Not */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (!context.getValue(this.key));\n    }\n    serialize() {\n        return `!${this.key}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyDefinedExpr.create(this.key, this);\n        }\n        return this.negated;\n    }\n}\nfunction withFloatOrStr(value, callback) {\n    if (typeof value === 'string') {\n        const n = parseFloat(value);\n        if (!isNaN(n)) {\n            value = n;\n        }\n    }\n    if (typeof value === 'string' || typeof value === 'number') {\n        return callback(value);\n    }\n    return ContextKeyFalseExpr.INSTANCE;\n}\nexport class ContextKeyGreaterExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeyGreaterExpr(key, value, negated));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 12 /* ContextKeyExprType.Greater */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) > this.value);\n    }\n    serialize() {\n        return `${this.key} > ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyGreaterEqualsExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeyGreaterEqualsExpr(key, value, negated));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 13 /* ContextKeyExprType.GreaterEquals */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) >= this.value);\n    }\n    serialize() {\n        return `${this.key} >= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeySmallerExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeySmallerExpr(key, value, negated));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 14 /* ContextKeyExprType.Smaller */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) < this.value);\n    }\n    serialize() {\n        return `${this.key} < ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeySmallerEqualsExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => new ContextKeySmallerEqualsExpr(key, value, negated));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 15 /* ContextKeyExprType.SmallerEquals */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) <= this.value);\n    }\n    serialize() {\n        return `${this.key} <= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyRegexExpr {\n    static create(key, regexp) {\n        return new ContextKeyRegexExpr(key, regexp);\n    }\n    constructor(key, regexp) {\n        this.key = key;\n        this.regexp = regexp;\n        this.type = 7 /* ContextKeyExprType.Regex */;\n        this.negated = null;\n        //\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.key < other.key) {\n            return -1;\n        }\n        if (this.key > other.key) {\n            return 1;\n        }\n        const thisSource = this.regexp ? this.regexp.source : '';\n        const otherSource = other.regexp ? other.regexp.source : '';\n        if (thisSource < otherSource) {\n            return -1;\n        }\n        if (thisSource > otherSource) {\n            return 1;\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            const thisSource = this.regexp ? this.regexp.source : '';\n            const otherSource = other.regexp ? other.regexp.source : '';\n            return (this.key === other.key && thisSource === otherSource);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        const value = context.getValue(this.key);\n        return this.regexp ? this.regexp.test(value) : false;\n    }\n    serialize() {\n        const value = this.regexp\n            ? `/${this.regexp.source}/${this.regexp.flags}`\n            : '/invalid/';\n        return `${this.key} =~ ${value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotRegexExpr.create(this);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyNotRegexExpr {\n    static create(actual) {\n        return new ContextKeyNotRegexExpr(actual);\n    }\n    constructor(_actual) {\n        this._actual = _actual;\n        this.type = 8 /* ContextKeyExprType.NotRegex */;\n        //\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._actual.cmp(other._actual);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._actual.equals(other._actual);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return !this._actual.evaluate(context);\n    }\n    serialize() {\n        return `!(${this._actual.serialize()})`;\n    }\n    keys() {\n        return this._actual.keys();\n    }\n    negate() {\n        return this._actual;\n    }\n}\n/**\n * @returns the same instance if nothing changed.\n */\nfunction eliminateConstantsInArray(arr) {\n    // Allocate array only if there is a difference\n    let newArr = null;\n    for (let i = 0, len = arr.length; i < len; i++) {\n        const newExpr = arr[i].substituteConstants();\n        if (arr[i] !== newExpr) {\n            // something has changed!\n            // allocate array on first difference\n            if (newArr === null) {\n                newArr = [];\n                for (let j = 0; j < i; j++) {\n                    newArr[j] = arr[j];\n                }\n            }\n        }\n        if (newArr !== null) {\n            newArr[i] = newExpr;\n        }\n    }\n    if (newArr === null) {\n        return arr;\n    }\n    return newArr;\n}\nexport class ContextKeyAndExpr {\n    static create(_expr, negated, extraRedundantCheck) {\n        return ContextKeyAndExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n    }\n    constructor(expr, negated) {\n        this.expr = expr;\n        this.negated = negated;\n        this.type = 6 /* ContextKeyExprType.And */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    substituteConstants() {\n        const exprArr = eliminateConstantsInArray(this.expr);\n        if (exprArr === this.expr) {\n            // no change\n            return this;\n        }\n        return ContextKeyAndExpr.create(exprArr, this.negated, false);\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (!this.expr[i].evaluate(context)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _normalizeArr(arr, negated, extraRedundantCheck) {\n        const expr = [];\n        let hasTrue = false;\n        for (const e of arr) {\n            if (!e) {\n                continue;\n            }\n            if (e.type === 1 /* ContextKeyExprType.True */) {\n                // anything && true ==> anything\n                hasTrue = true;\n                continue;\n            }\n            if (e.type === 0 /* ContextKeyExprType.False */) {\n                // anything && false ==> false\n                return ContextKeyFalseExpr.INSTANCE;\n            }\n            if (e.type === 6 /* ContextKeyExprType.And */) {\n                expr.push(...e.expr);\n                continue;\n            }\n            expr.push(e);\n        }\n        if (expr.length === 0 && hasTrue) {\n            return ContextKeyTrueExpr.INSTANCE;\n        }\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        expr.sort(cmp);\n        // eliminate duplicate terms\n        for (let i = 1; i < expr.length; i++) {\n            if (expr[i - 1].equals(expr[i])) {\n                expr.splice(i, 1);\n                i--;\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // We must distribute any OR expression because we don't support parens\n        // OR extensions will be at the end (due to sorting rules)\n        while (expr.length > 1) {\n            const lastElement = expr[expr.length - 1];\n            if (lastElement.type !== 9 /* ContextKeyExprType.Or */) {\n                break;\n            }\n            // pop the last element\n            expr.pop();\n            // pop the second to last element\n            const secondToLastElement = expr.pop();\n            const isFinished = (expr.length === 0);\n            // distribute `lastElement` over `secondToLastElement`\n            const resultElement = ContextKeyOrExpr.create(lastElement.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement], null, extraRedundantCheck)), null, isFinished);\n            if (resultElement) {\n                expr.push(resultElement);\n                expr.sort(cmp);\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // resolve false AND expressions\n        if (extraRedundantCheck) {\n            for (let i = 0; i < expr.length; i++) {\n                for (let j = i + 1; j < expr.length; j++) {\n                    if (expr[i].negate().equals(expr[j])) {\n                        // A && !A case\n                        return ContextKeyFalseExpr.INSTANCE;\n                    }\n                }\n            }\n            if (expr.length === 1) {\n                return expr[0];\n            }\n        }\n        return new ContextKeyAndExpr(expr, negated);\n    }\n    serialize() {\n        return this.expr.map(e => e.serialize()).join(' && ');\n    }\n    keys() {\n        const result = [];\n        for (const expr of this.expr) {\n            result.push(...expr.keys());\n        }\n        return result;\n    }\n    negate() {\n        if (!this.negated) {\n            const result = [];\n            for (const expr of this.expr) {\n                result.push(expr.negate());\n            }\n            this.negated = ContextKeyOrExpr.create(result, this, true);\n        }\n        return this.negated;\n    }\n}\nexport class ContextKeyOrExpr {\n    static create(_expr, negated, extraRedundantCheck) {\n        return ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n    }\n    constructor(expr, negated) {\n        this.expr = expr;\n        this.negated = negated;\n        this.type = 9 /* ContextKeyExprType.Or */;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    substituteConstants() {\n        const exprArr = eliminateConstantsInArray(this.expr);\n        if (exprArr === this.expr) {\n            // no change\n            return this;\n        }\n        return ContextKeyOrExpr.create(exprArr, this.negated, false);\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (this.expr[i].evaluate(context)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static _normalizeArr(arr, negated, extraRedundantCheck) {\n        let expr = [];\n        let hasFalse = false;\n        if (arr) {\n            for (let i = 0, len = arr.length; i < len; i++) {\n                const e = arr[i];\n                if (!e) {\n                    continue;\n                }\n                if (e.type === 0 /* ContextKeyExprType.False */) {\n                    // anything || false ==> anything\n                    hasFalse = true;\n                    continue;\n                }\n                if (e.type === 1 /* ContextKeyExprType.True */) {\n                    // anything || true ==> true\n                    return ContextKeyTrueExpr.INSTANCE;\n                }\n                if (e.type === 9 /* ContextKeyExprType.Or */) {\n                    expr = expr.concat(e.expr);\n                    continue;\n                }\n                expr.push(e);\n            }\n            if (expr.length === 0 && hasFalse) {\n                return ContextKeyFalseExpr.INSTANCE;\n            }\n            expr.sort(cmp);\n        }\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // eliminate duplicate terms\n        for (let i = 1; i < expr.length; i++) {\n            if (expr[i - 1].equals(expr[i])) {\n                expr.splice(i, 1);\n                i--;\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        // resolve true OR expressions\n        if (extraRedundantCheck) {\n            for (let i = 0; i < expr.length; i++) {\n                for (let j = i + 1; j < expr.length; j++) {\n                    if (expr[i].negate().equals(expr[j])) {\n                        // A || !A case\n                        return ContextKeyTrueExpr.INSTANCE;\n                    }\n                }\n            }\n            if (expr.length === 1) {\n                return expr[0];\n            }\n        }\n        return new ContextKeyOrExpr(expr, negated);\n    }\n    serialize() {\n        return this.expr.map(e => e.serialize()).join(' || ');\n    }\n    keys() {\n        const result = [];\n        for (const expr of this.expr) {\n            result.push(...expr.keys());\n        }\n        return result;\n    }\n    negate() {\n        if (!this.negated) {\n            const result = [];\n            for (const expr of this.expr) {\n                result.push(expr.negate());\n            }\n            // We don't support parens, so here we distribute the AND over the OR terminals\n            // We always take the first 2 AND pairs and distribute them\n            while (result.length > 1) {\n                const LEFT = result.shift();\n                const RIGHT = result.shift();\n                const all = [];\n                for (const left of getTerminals(LEFT)) {\n                    for (const right of getTerminals(RIGHT)) {\n                        all.push(ContextKeyAndExpr.create([left, right], null, false));\n                    }\n                }\n                result.unshift(ContextKeyOrExpr.create(all, null, false));\n            }\n            this.negated = ContextKeyOrExpr.create(result, this, true);\n        }\n        return this.negated;\n    }\n}\nexport class RawContextKey extends ContextKeyDefinedExpr {\n    static all() {\n        return RawContextKey._info.values();\n    }\n    constructor(key, defaultValue, metaOrHide) {\n        super(key, null);\n        this._defaultValue = defaultValue;\n        // collect all context keys into a central place\n        if (typeof metaOrHide === 'object') {\n            RawContextKey._info.push({ ...metaOrHide, key });\n        }\n        else if (metaOrHide !== true) {\n            RawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined });\n        }\n    }\n    bindTo(target) {\n        return target.createKey(this.key, this._defaultValue);\n    }\n    getValue(target) {\n        return target.getContextKeyValue(this.key);\n    }\n    toNegated() {\n        return this.negate();\n    }\n    isEqualTo(value) {\n        return ContextKeyEqualsExpr.create(this.key, value);\n    }\n}\nRawContextKey._info = [];\nexport const IContextKeyService = createDecorator('contextKeyService');\nfunction cmp1(key1, key2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    return 0;\n}\nfunction cmp2(key1, value1, key2, value2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    if (value1 < value2) {\n        return -1;\n    }\n    if (value1 > value2) {\n        return 1;\n    }\n    return 0;\n}\n/**\n * Returns true if it is provable `p` implies `q`.\n */\nexport function implies(p, q) {\n    if (p.type === 0 /* ContextKeyExprType.False */ || q.type === 1 /* ContextKeyExprType.True */) {\n        // false implies anything\n        // anything implies true\n        return true;\n    }\n    if (p.type === 9 /* ContextKeyExprType.Or */) {\n        if (q.type === 9 /* ContextKeyExprType.Or */) {\n            // `a || b || c` can only imply something like `a || b || c || d`\n            return allElementsIncluded(p.expr, q.expr);\n        }\n        return false;\n    }\n    if (q.type === 9 /* ContextKeyExprType.Or */) {\n        for (const element of q.expr) {\n            if (implies(p, element)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (p.type === 6 /* ContextKeyExprType.And */) {\n        if (q.type === 6 /* ContextKeyExprType.And */) {\n            // `a && b && c` implies `a && c`\n            return allElementsIncluded(q.expr, p.expr);\n        }\n        for (const element of p.expr) {\n            if (implies(element, q)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return p.equals(q);\n}\n/**\n * Returns true if all elements in `p` are also present in `q`.\n * The two arrays are assumed to be sorted\n */\nfunction allElementsIncluded(p, q) {\n    let pIndex = 0;\n    let qIndex = 0;\n    while (pIndex < p.length && qIndex < q.length) {\n        const cmp = p[pIndex].cmp(q[qIndex]);\n        if (cmp < 0) {\n            // an element from `p` is missing from `q`\n            return false;\n        }\n        else if (cmp === 0) {\n            pIndex++;\n            qIndex++;\n        }\n        else {\n            qIndex++;\n        }\n    }\n    return (pIndex === p.length);\n}\nfunction getTerminals(node) {\n    if (node.type === 9 /* ContextKeyExprType.Or */) {\n        return node.expr;\n    }\n    return [node];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}