{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\n/**\n * A range of offsets (0-based).\n*/\nexport var OffsetRange = /*#__PURE__*/function () {\n  function OffsetRange(start, endExclusive) {\n    _classCallCheck(this, OffsetRange);\n    this.start = start;\n    this.endExclusive = endExclusive;\n    if (start > endExclusive) {\n      throw new BugIndicatingError(\"Invalid range: \".concat(this.toString()));\n    }\n  }\n  return _createClass(OffsetRange, [{\n    key: \"isEmpty\",\n    get: function get() {\n      return this.start === this.endExclusive;\n    }\n  }, {\n    key: \"delta\",\n    value: function delta(offset) {\n      return new OffsetRange(this.start + offset, this.endExclusive + offset);\n    }\n  }, {\n    key: \"deltaStart\",\n    value: function deltaStart(offset) {\n      return new OffsetRange(this.start + offset, this.endExclusive);\n    }\n  }, {\n    key: \"deltaEnd\",\n    value: function deltaEnd(offset) {\n      return new OffsetRange(this.start, this.endExclusive + offset);\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.endExclusive - this.start;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"[\".concat(this.start, \", \").concat(this.endExclusive, \")\");\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(offset) {\n      return this.start <= offset && offset < this.endExclusive;\n    }\n    /**\n     * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)\n     * The joined range is the smallest range that contains both ranges.\n     */\n  }, {\n    key: \"join\",\n    value: function join(other) {\n      return new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\n    }\n    /**\n     * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)\n     *\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n  }, {\n    key: \"intersect\",\n    value: function intersect(other) {\n      var start = Math.max(this.start, other.start);\n      var end = Math.min(this.endExclusive, other.endExclusive);\n      if (start <= end) {\n        return new OffsetRange(start, end);\n      }\n      return undefined;\n    }\n  }, {\n    key: \"intersects\",\n    value: function intersects(other) {\n      var start = Math.max(this.start, other.start);\n      var end = Math.min(this.endExclusive, other.endExclusive);\n      return start < end;\n    }\n  }, {\n    key: \"isBefore\",\n    value: function isBefore(other) {\n      return this.endExclusive <= other.start;\n    }\n  }, {\n    key: \"isAfter\",\n    value: function isAfter(other) {\n      return this.start >= other.endExclusive;\n    }\n  }, {\n    key: \"slice\",\n    value: function slice(arr) {\n      return arr.slice(this.start, this.endExclusive);\n    }\n  }, {\n    key: \"substring\",\n    value: function substring(str) {\n      return str.substring(this.start, this.endExclusive);\n    }\n    /**\n     * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.\n     * The range must not be empty.\n     */\n  }, {\n    key: \"clip\",\n    value: function clip(value) {\n      if (this.isEmpty) {\n        throw new BugIndicatingError(\"Invalid clipping range: \".concat(this.toString()));\n      }\n      return Math.max(this.start, Math.min(this.endExclusive - 1, value));\n    }\n    /**\n     * Returns `r := value + k * length` such that `r` is contained in this range.\n     * The range must not be empty.\n     *\n     * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.\n     */\n  }, {\n    key: \"clipCyclic\",\n    value: function clipCyclic(value) {\n      if (this.isEmpty) {\n        throw new BugIndicatingError(\"Invalid clipping range: \".concat(this.toString()));\n      }\n      if (value < this.start) {\n        return this.endExclusive - (this.start - value) % this.length;\n      }\n      if (value >= this.endExclusive) {\n        return this.start + (value - this.start) % this.length;\n      }\n      return value;\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      for (var i = this.start; i < this.endExclusive; i++) {\n        f(i);\n      }\n    }\n  }], [{\n    key: \"addRange\",\n    value: function addRange(range, sortedRanges) {\n      var i = 0;\n      while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {\n        i++;\n      }\n      var j = i;\n      while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {\n        j++;\n      }\n      if (i === j) {\n        sortedRanges.splice(i, 0, range);\n      } else {\n        var start = Math.min(range.start, sortedRanges[i].start);\n        var end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);\n        sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n      }\n    }\n  }, {\n    key: \"tryCreate\",\n    value: function tryCreate(start, endExclusive) {\n      if (start > endExclusive) {\n        return undefined;\n      }\n      return new OffsetRange(start, endExclusive);\n    }\n  }, {\n    key: \"ofLength\",\n    value: function ofLength(length) {\n      return new OffsetRange(0, length);\n    }\n  }, {\n    key: \"ofStartAndLength\",\n    value: function ofStartAndLength(start, length) {\n      return new OffsetRange(start, start + length);\n    }\n  }]);\n}();\nexport var OffsetRangeSet = /*#__PURE__*/function () {\n  function OffsetRangeSet() {\n    _classCallCheck(this, OffsetRangeSet);\n    this._sortedRanges = [];\n  }\n  return _createClass(OffsetRangeSet, [{\n    key: \"addRange\",\n    value: function addRange(range) {\n      var i = 0;\n      while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive < range.start) {\n        i++;\n      }\n      var j = i;\n      while (j < this._sortedRanges.length && this._sortedRanges[j].start <= range.endExclusive) {\n        j++;\n      }\n      if (i === j) {\n        this._sortedRanges.splice(i, 0, range);\n      } else {\n        var start = Math.min(range.start, this._sortedRanges[i].start);\n        var end = Math.max(range.endExclusive, this._sortedRanges[j - 1].endExclusive);\n        this._sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n      }\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this._sortedRanges.map(function (r) {\n        return r.toString();\n      }).join(', ');\n    }\n    /**\n     * Returns of there is a value that is contained in this instance and the given range.\n     */\n  }, {\n    key: \"intersectsStrict\",\n    value: function intersectsStrict(other) {\n      // TODO use binary search\n      var i = 0;\n      while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive <= other.start) {\n        i++;\n      }\n      return i < this._sortedRanges.length && this._sortedRanges[i].start < other.endExclusive;\n    }\n  }, {\n    key: \"intersectWithRange\",\n    value: function intersectWithRange(other) {\n      // TODO use binary search + slice\n      var result = new OffsetRangeSet();\n      var _iterator = _createForOfIteratorHelper(this._sortedRanges),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var range = _step.value;\n          var intersection = range.intersect(other);\n          if (intersection) {\n            result.addRange(intersection);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return result;\n    }\n  }, {\n    key: \"intersectWithRangeLength\",\n    value: function intersectWithRangeLength(other) {\n      return this.intersectWithRange(other).length;\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._sortedRanges.reduce(function (prev, cur) {\n        return prev + cur.length;\n      }, 0);\n    }\n  }]);\n}();","map":{"version":3,"names":["BugIndicatingError","OffsetRange","start","endExclusive","_classCallCheck","concat","toString","_createClass","key","get","value","delta","offset","deltaStart","deltaEnd","contains","join","other","Math","min","max","intersect","end","undefined","intersects","isBefore","isAfter","slice","arr","substring","str","clip","isEmpty","clipCyclic","length","forEach","f","i","addRange","range","sortedRanges","j","splice","tryCreate","ofLength","ofStartAndLength","OffsetRangeSet","_sortedRanges","map","r","intersectsStrict","intersectWithRange","result","_iterator","_createForOfIteratorHelper","_step","s","n","done","intersection","err","e","intersectWithRangeLength","reduce","prev","cur"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\n/**\n * A range of offsets (0-based).\n*/\nexport class OffsetRange {\n    static addRange(range, sortedRanges) {\n        let i = 0;\n        while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {\n            i++;\n        }\n        let j = i;\n        while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {\n            j++;\n        }\n        if (i === j) {\n            sortedRanges.splice(i, 0, range);\n        }\n        else {\n            const start = Math.min(range.start, sortedRanges[i].start);\n            const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);\n            sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n        }\n    }\n    static tryCreate(start, endExclusive) {\n        if (start > endExclusive) {\n            return undefined;\n        }\n        return new OffsetRange(start, endExclusive);\n    }\n    static ofLength(length) {\n        return new OffsetRange(0, length);\n    }\n    static ofStartAndLength(start, length) {\n        return new OffsetRange(start, start + length);\n    }\n    constructor(start, endExclusive) {\n        this.start = start;\n        this.endExclusive = endExclusive;\n        if (start > endExclusive) {\n            throw new BugIndicatingError(`Invalid range: ${this.toString()}`);\n        }\n    }\n    get isEmpty() {\n        return this.start === this.endExclusive;\n    }\n    delta(offset) {\n        return new OffsetRange(this.start + offset, this.endExclusive + offset);\n    }\n    deltaStart(offset) {\n        return new OffsetRange(this.start + offset, this.endExclusive);\n    }\n    deltaEnd(offset) {\n        return new OffsetRange(this.start, this.endExclusive + offset);\n    }\n    get length() {\n        return this.endExclusive - this.start;\n    }\n    toString() {\n        return `[${this.start}, ${this.endExclusive})`;\n    }\n    contains(offset) {\n        return this.start <= offset && offset < this.endExclusive;\n    }\n    /**\n     * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)\n     * The joined range is the smallest range that contains both ranges.\n     */\n    join(other) {\n        return new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\n    }\n    /**\n     * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)\n     *\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const start = Math.max(this.start, other.start);\n        const end = Math.min(this.endExclusive, other.endExclusive);\n        if (start <= end) {\n            return new OffsetRange(start, end);\n        }\n        return undefined;\n    }\n    intersects(other) {\n        const start = Math.max(this.start, other.start);\n        const end = Math.min(this.endExclusive, other.endExclusive);\n        return start < end;\n    }\n    isBefore(other) {\n        return this.endExclusive <= other.start;\n    }\n    isAfter(other) {\n        return this.start >= other.endExclusive;\n    }\n    slice(arr) {\n        return arr.slice(this.start, this.endExclusive);\n    }\n    substring(str) {\n        return str.substring(this.start, this.endExclusive);\n    }\n    /**\n     * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.\n     * The range must not be empty.\n     */\n    clip(value) {\n        if (this.isEmpty) {\n            throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n        }\n        return Math.max(this.start, Math.min(this.endExclusive - 1, value));\n    }\n    /**\n     * Returns `r := value + k * length` such that `r` is contained in this range.\n     * The range must not be empty.\n     *\n     * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.\n     */\n    clipCyclic(value) {\n        if (this.isEmpty) {\n            throw new BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n        }\n        if (value < this.start) {\n            return this.endExclusive - ((this.start - value) % this.length);\n        }\n        if (value >= this.endExclusive) {\n            return this.start + ((value - this.start) % this.length);\n        }\n        return value;\n    }\n    forEach(f) {\n        for (let i = this.start; i < this.endExclusive; i++) {\n            f(i);\n        }\n    }\n}\nexport class OffsetRangeSet {\n    constructor() {\n        this._sortedRanges = [];\n    }\n    addRange(range) {\n        let i = 0;\n        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive < range.start) {\n            i++;\n        }\n        let j = i;\n        while (j < this._sortedRanges.length && this._sortedRanges[j].start <= range.endExclusive) {\n            j++;\n        }\n        if (i === j) {\n            this._sortedRanges.splice(i, 0, range);\n        }\n        else {\n            const start = Math.min(range.start, this._sortedRanges[i].start);\n            const end = Math.max(range.endExclusive, this._sortedRanges[j - 1].endExclusive);\n            this._sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n        }\n    }\n    toString() {\n        return this._sortedRanges.map(r => r.toString()).join(', ');\n    }\n    /**\n     * Returns of there is a value that is contained in this instance and the given range.\n     */\n    intersectsStrict(other) {\n        // TODO use binary search\n        let i = 0;\n        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive <= other.start) {\n            i++;\n        }\n        return i < this._sortedRanges.length && this._sortedRanges[i].start < other.endExclusive;\n    }\n    intersectWithRange(other) {\n        // TODO use binary search + slice\n        const result = new OffsetRangeSet();\n        for (const range of this._sortedRanges) {\n            const intersection = range.intersect(other);\n            if (intersection) {\n                result.addRange(intersection);\n            }\n        }\n        return result;\n    }\n    intersectWithRangeLength(other) {\n        return this.intersectWithRange(other).length;\n    }\n    get length() {\n        return this._sortedRanges.reduce((prev, cur) => prev + cur.length, 0);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}