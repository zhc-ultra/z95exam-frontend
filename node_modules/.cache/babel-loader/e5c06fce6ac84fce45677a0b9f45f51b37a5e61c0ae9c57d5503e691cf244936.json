{"ast":null,"code":"import _callSuper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { Position } from './position.js';\nimport { PositionOffsetTransformer } from './positionToOffset.js';\nimport { Range } from './range.js';\nimport { TextLength } from './textLength.js';\nexport var TextEdit = /*#__PURE__*/function () {\n  function TextEdit(edits) {\n    _classCallCheck(this, TextEdit);\n    this.edits = edits;\n    assertFn(function () {\n      return checkAdjacentItems(edits, function (a, b) {\n        return a.range.getEndPosition().isBeforeOrEqual(b.range.getStartPosition());\n      });\n    });\n  }\n  return _createClass(TextEdit, [{\n    key: \"apply\",\n    value: function apply(text) {\n      var result = '';\n      var lastEditEnd = new Position(1, 1);\n      var _iterator = _createForOfIteratorHelper(this.edits),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var edit = _step.value;\n          var editRange = edit.range;\n          var editStart = editRange.getStartPosition();\n          var editEnd = editRange.getEndPosition();\n          var _r = rangeFromPositions(lastEditEnd, editStart);\n          if (!_r.isEmpty()) {\n            result += text.getValueOfRange(_r);\n          }\n          result += edit.text;\n          lastEditEnd = editEnd;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var r = rangeFromPositions(lastEditEnd, text.endPositionExclusive);\n      if (!r.isEmpty()) {\n        result += text.getValueOfRange(r);\n      }\n      return result;\n    }\n  }, {\n    key: \"applyToString\",\n    value: function applyToString(str) {\n      var strText = new StringText(str);\n      return this.apply(strText);\n    }\n  }, {\n    key: \"getNewRanges\",\n    value: function getNewRanges() {\n      var newRanges = [];\n      var previousEditEndLineNumber = 0;\n      var lineOffset = 0;\n      var columnOffset = 0;\n      var _iterator2 = _createForOfIteratorHelper(this.edits),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var edit = _step2.value;\n          var textLength = TextLength.ofText(edit.text);\n          var newRangeStart = Position.lift({\n            lineNumber: edit.range.startLineNumber + lineOffset,\n            column: edit.range.startColumn + (edit.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)\n          });\n          var newRange = textLength.createRange(newRangeStart);\n          newRanges.push(newRange);\n          lineOffset = newRange.endLineNumber - edit.range.endLineNumber;\n          columnOffset = newRange.endColumn - edit.range.endColumn;\n          previousEditEndLineNumber = edit.range.endLineNumber;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return newRanges;\n    }\n  }]);\n}();\nexport var SingleTextEdit = /*#__PURE__*/_createClass(function SingleTextEdit(range, text) {\n  _classCallCheck(this, SingleTextEdit);\n  this.range = range;\n  this.text = text;\n});\nfunction rangeFromPositions(start, end) {\n  if (!start.isBeforeOrEqual(end)) {\n    throw new BugIndicatingError('start must be before end');\n  }\n  return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n}\nexport var AbstractText = /*#__PURE__*/function () {\n  function AbstractText() {\n    _classCallCheck(this, AbstractText);\n  }\n  return _createClass(AbstractText, [{\n    key: \"endPositionExclusive\",\n    get: function get() {\n      return this.length.addToPosition(new Position(1, 1));\n    }\n  }]);\n}();\nexport var StringText = /*#__PURE__*/function (_AbstractText) {\n  function StringText(value) {\n    var _this;\n    _classCallCheck(this, StringText);\n    _this = _callSuper(this, StringText);\n    _this.value = value;\n    _this._t = new PositionOffsetTransformer(_this.value);\n    return _this;\n  }\n  _inherits(StringText, _AbstractText);\n  return _createClass(StringText, [{\n    key: \"getValueOfRange\",\n    value: function getValueOfRange(range) {\n      return this._t.getOffsetRange(range).substring(this.value);\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._t.textLength;\n    }\n  }]);\n}(AbstractText);","map":{"version":3,"names":["assertFn","checkAdjacentItems","BugIndicatingError","Position","PositionOffsetTransformer","Range","TextLength","TextEdit","edits","_classCallCheck","a","b","range","getEndPosition","isBeforeOrEqual","getStartPosition","_createClass","key","value","apply","text","result","lastEditEnd","_iterator","_createForOfIteratorHelper","_step","s","n","done","edit","editRange","editStart","editEnd","r","rangeFromPositions","isEmpty","getValueOfRange","err","e","f","endPositionExclusive","applyToString","str","strText","StringText","getNewRanges","newRanges","previousEditEndLineNumber","lineOffset","columnOffset","_iterator2","_step2","textLength","ofText","newRangeStart","lift","lineNumber","startLineNumber","column","startColumn","newRange","createRange","push","endLineNumber","endColumn","SingleTextEdit","start","end","AbstractText","get","length","addToPosition","_AbstractText","_this","_callSuper","_t","_inherits","getOffsetRange","substring"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/core/textEdit.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { Position } from './position.js';\nimport { PositionOffsetTransformer } from './positionToOffset.js';\nimport { Range } from './range.js';\nimport { TextLength } from './textLength.js';\nexport class TextEdit {\n    constructor(edits) {\n        this.edits = edits;\n        assertFn(() => checkAdjacentItems(edits, (a, b) => a.range.getEndPosition().isBeforeOrEqual(b.range.getStartPosition())));\n    }\n    apply(text) {\n        let result = '';\n        let lastEditEnd = new Position(1, 1);\n        for (const edit of this.edits) {\n            const editRange = edit.range;\n            const editStart = editRange.getStartPosition();\n            const editEnd = editRange.getEndPosition();\n            const r = rangeFromPositions(lastEditEnd, editStart);\n            if (!r.isEmpty()) {\n                result += text.getValueOfRange(r);\n            }\n            result += edit.text;\n            lastEditEnd = editEnd;\n        }\n        const r = rangeFromPositions(lastEditEnd, text.endPositionExclusive);\n        if (!r.isEmpty()) {\n            result += text.getValueOfRange(r);\n        }\n        return result;\n    }\n    applyToString(str) {\n        const strText = new StringText(str);\n        return this.apply(strText);\n    }\n    getNewRanges() {\n        const newRanges = [];\n        let previousEditEndLineNumber = 0;\n        let lineOffset = 0;\n        let columnOffset = 0;\n        for (const edit of this.edits) {\n            const textLength = TextLength.ofText(edit.text);\n            const newRangeStart = Position.lift({\n                lineNumber: edit.range.startLineNumber + lineOffset,\n                column: edit.range.startColumn + (edit.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)\n            });\n            const newRange = textLength.createRange(newRangeStart);\n            newRanges.push(newRange);\n            lineOffset = newRange.endLineNumber - edit.range.endLineNumber;\n            columnOffset = newRange.endColumn - edit.range.endColumn;\n            previousEditEndLineNumber = edit.range.endLineNumber;\n        }\n        return newRanges;\n    }\n}\nexport class SingleTextEdit {\n    constructor(range, text) {\n        this.range = range;\n        this.text = text;\n    }\n}\nfunction rangeFromPositions(start, end) {\n    if (!start.isBeforeOrEqual(end)) {\n        throw new BugIndicatingError('start must be before end');\n    }\n    return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n}\nexport class AbstractText {\n    get endPositionExclusive() {\n        return this.length.addToPosition(new Position(1, 1));\n    }\n}\nexport class StringText extends AbstractText {\n    constructor(value) {\n        super();\n        this.value = value;\n        this._t = new PositionOffsetTransformer(this.value);\n    }\n    getValueOfRange(range) {\n        return this._t.getOffsetRange(range).substring(this.value);\n    }\n    get length() {\n        return this._t.textLength;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}