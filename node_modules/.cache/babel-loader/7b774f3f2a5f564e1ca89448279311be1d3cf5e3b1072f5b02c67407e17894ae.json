{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { FindMatch, SearchData } from '../model.js';\nvar LIMIT_FIND_COUNT = 999;\nexport var SearchParams = /*#__PURE__*/function () {\n  function SearchParams(searchString, isRegex, matchCase, wordSeparators) {\n    _classCallCheck(this, SearchParams);\n    this.searchString = searchString;\n    this.isRegex = isRegex;\n    this.matchCase = matchCase;\n    this.wordSeparators = wordSeparators;\n  }\n  return _createClass(SearchParams, [{\n    key: \"parseSearchRequest\",\n    value: function parseSearchRequest() {\n      if (this.searchString === '') {\n        return null;\n      }\n      // Try to create a RegExp out of the params\n      var multiline;\n      if (this.isRegex) {\n        multiline = isMultilineRegexSource(this.searchString);\n      } else {\n        multiline = this.searchString.indexOf('\\n') >= 0;\n      }\n      var regex = null;\n      try {\n        regex = strings.createRegExp(this.searchString, this.isRegex, {\n          matchCase: this.matchCase,\n          wholeWord: false,\n          multiline: multiline,\n          global: true,\n          unicode: true\n        });\n      } catch (err) {\n        return null;\n      }\n      if (!regex) {\n        return null;\n      }\n      var canUseSimpleSearch = !this.isRegex && !multiline;\n      if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n        // casing might make a difference\n        canUseSimpleSearch = this.matchCase;\n      }\n      return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators, []) : null, canUseSimpleSearch ? this.searchString : null);\n    }\n  }]);\n}();\nexport function isMultilineRegexSource(searchString) {\n  if (!searchString || searchString.length === 0) {\n    return false;\n  }\n  for (var i = 0, len = searchString.length; i < len; i++) {\n    var chCode = searchString.charCodeAt(i);\n    if (chCode === 10 /* CharCode.LineFeed */) {\n      return true;\n    }\n    if (chCode === 92 /* CharCode.Backslash */) {\n      // move to next char\n      i++;\n      if (i >= len) {\n        // string ends with a \\\n        break;\n      }\n      var nextChCode = searchString.charCodeAt(i);\n      if (nextChCode === 110 /* CharCode.n */ || nextChCode === 114 /* CharCode.r */ || nextChCode === 87 /* CharCode.W */) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nexport function createFindMatch(range, rawMatches, captureMatches) {\n  if (!captureMatches) {\n    return new FindMatch(range, null);\n  }\n  var matches = [];\n  for (var i = 0, len = rawMatches.length; i < len; i++) {\n    matches[i] = rawMatches[i];\n  }\n  return new FindMatch(range, matches);\n}\nvar LineFeedCounter = /*#__PURE__*/function () {\n  function LineFeedCounter(text) {\n    _classCallCheck(this, LineFeedCounter);\n    var lineFeedsOffsets = [];\n    var lineFeedsOffsetsLen = 0;\n    for (var i = 0, textLen = text.length; i < textLen; i++) {\n      if (text.charCodeAt(i) === 10 /* CharCode.LineFeed */) {\n        lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n      }\n    }\n    this._lineFeedsOffsets = lineFeedsOffsets;\n  }\n  return _createClass(LineFeedCounter, [{\n    key: \"findLineFeedCountBeforeOffset\",\n    value: function findLineFeedCountBeforeOffset(offset) {\n      var lineFeedsOffsets = this._lineFeedsOffsets;\n      var min = 0;\n      var max = lineFeedsOffsets.length - 1;\n      if (max === -1) {\n        // no line feeds\n        return 0;\n      }\n      if (offset <= lineFeedsOffsets[0]) {\n        // before first line feed\n        return 0;\n      }\n      while (min < max) {\n        var mid = min + ((max - min) / 2 >> 0);\n        if (lineFeedsOffsets[mid] >= offset) {\n          max = mid - 1;\n        } else {\n          if (lineFeedsOffsets[mid + 1] >= offset) {\n            // bingo!\n            min = mid;\n            max = mid;\n          } else {\n            min = mid + 1;\n          }\n        }\n      }\n      return min + 1;\n    }\n  }]);\n}();\nexport var TextModelSearch = /*#__PURE__*/function () {\n  function TextModelSearch() {\n    _classCallCheck(this, TextModelSearch);\n  }\n  return _createClass(TextModelSearch, null, [{\n    key: \"findMatches\",\n    value: function findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {\n      var searchData = searchParams.parseSearchRequest();\n      if (!searchData) {\n        return [];\n      }\n      if (searchData.regex.multiline) {\n        return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n      }\n      return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Multiline search always executes on the lines concatenated with \\n.\n     * We must therefore compensate for the count of \\n in case the model is CRLF\n     */\n  }, {\n    key: \"_getMultilineMatchRange\",\n    value: function _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {\n      var startOffset;\n      var lineFeedCountBeforeMatch = 0;\n      if (lfCounter) {\n        lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n        startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n      } else {\n        startOffset = deltaOffset + matchIndex;\n      }\n      var endOffset;\n      if (lfCounter) {\n        var lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n        var lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n        endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n      } else {\n        endOffset = startOffset + match0.length;\n      }\n      var startPosition = model.getPositionAt(startOffset);\n      var endPosition = model.getPositionAt(endOffset);\n      return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n  }, {\n    key: \"_doFindMatchesMultiline\",\n    value: function _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {\n      var deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n      // We always execute multiline search over the lines joined with \\n\n      // This makes it that \\n will match the EOL for both CRLF and LF models\n      // We compensate for offset errors in `_getMultilineMatchRange`\n      var text = model.getValueInRange(searchRange, 1 /* EndOfLinePreference.LF */);\n      var lfCounter = model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null;\n      var result = [];\n      var counter = 0;\n      var m;\n      searcher.reset(0);\n      while (m = searcher.next(text)) {\n        result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n        if (counter >= limitResultCount) {\n          return result;\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"_doFindMatchesLineByLine\",\n    value: function _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {\n      var result = [];\n      var resultLen = 0;\n      // Early case for a search range that starts & stops on the same line number\n      if (searchRange.startLineNumber === searchRange.endLineNumber) {\n        var _text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, _text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n        return result;\n      }\n      // Collect results from first line\n      var text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n      resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n      // Collect results from middle lines\n      for (var lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n        resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n      }\n      // Collect results from last line\n      if (resultLen < limitResultCount) {\n        var _text2 = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, _text2, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n      }\n      return result;\n    }\n  }, {\n    key: \"_findMatchesInLine\",\n    value: function _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n      var wordSeparators = searchData.wordSeparators;\n      if (!captureMatches && searchData.simpleSearch) {\n        var searchString = searchData.simpleSearch;\n        var searchStringLen = searchString.length;\n        var textLength = text.length;\n        var lastMatchIndex = -searchStringLen;\n        while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n          if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n            result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n            if (resultLen >= limitResultCount) {\n              return resultLen;\n            }\n          }\n        }\n        return resultLen;\n      }\n      var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n      var m;\n      // Reset regex to search from the beginning\n      searcher.reset(0);\n      do {\n        m = searcher.next(text);\n        if (m) {\n          result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n          if (resultLen >= limitResultCount) {\n            return resultLen;\n          }\n        }\n      } while (m);\n      return resultLen;\n    }\n  }, {\n    key: \"findNextMatch\",\n    value: function findNextMatch(model, searchParams, searchStart, captureMatches) {\n      var searchData = searchParams.parseSearchRequest();\n      if (!searchData) {\n        return null;\n      }\n      var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n      if (searchData.regex.multiline) {\n        return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n      }\n      return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n  }, {\n    key: \"_doFindNextMatchMultiline\",\n    value: function _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {\n      var searchTextStart = new Position(searchStart.lineNumber, 1);\n      var deltaOffset = model.getOffsetAt(searchTextStart);\n      var lineCount = model.getLineCount();\n      // We always execute multiline search over the lines joined with \\n\n      // This makes it that \\n will match the EOL for both CRLF and LF models\n      // We compensate for offset errors in `_getMultilineMatchRange`\n      var text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* EndOfLinePreference.LF */);\n      var lfCounter = model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null;\n      searcher.reset(searchStart.column - 1);\n      var m = searcher.next(text);\n      if (m) {\n        return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n      }\n      if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n        // Try again from the top\n        return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n      }\n      return null;\n    }\n  }, {\n    key: \"_doFindNextMatchLineByLine\",\n    value: function _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {\n      var lineCount = model.getLineCount();\n      var startLineNumber = searchStart.lineNumber;\n      // Look in first line\n      var text = model.getLineContent(startLineNumber);\n      var r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n      if (r) {\n        return r;\n      }\n      for (var i = 1; i <= lineCount; i++) {\n        var lineIndex = (startLineNumber + i - 1) % lineCount;\n        var _text3 = model.getLineContent(lineIndex + 1);\n        var _r = this._findFirstMatchInLine(searcher, _text3, lineIndex + 1, 1, captureMatches);\n        if (_r) {\n          return _r;\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_findFirstMatchInLine\",\n    value: function _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {\n      // Set regex to search from column\n      searcher.reset(fromColumn - 1);\n      var m = searcher.next(text);\n      if (m) {\n        return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n      }\n      return null;\n    }\n  }, {\n    key: \"findPreviousMatch\",\n    value: function findPreviousMatch(model, searchParams, searchStart, captureMatches) {\n      var searchData = searchParams.parseSearchRequest();\n      if (!searchData) {\n        return null;\n      }\n      var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n      if (searchData.regex.multiline) {\n        return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n      }\n      return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n  }, {\n    key: \"_doFindPreviousMatchMultiline\",\n    value: function _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {\n      var matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n      if (matches.length > 0) {\n        return matches[matches.length - 1];\n      }\n      var lineCount = model.getLineCount();\n      if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n        // Try again with all content\n        return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n      }\n      return null;\n    }\n  }, {\n    key: \"_doFindPreviousMatchLineByLine\",\n    value: function _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {\n      var lineCount = model.getLineCount();\n      var startLineNumber = searchStart.lineNumber;\n      // Look in first line\n      var text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n      var r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n      if (r) {\n        return r;\n      }\n      for (var i = 1; i <= lineCount; i++) {\n        var lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n        var _text4 = model.getLineContent(lineIndex + 1);\n        var _r2 = this._findLastMatchInLine(searcher, _text4, lineIndex + 1, captureMatches);\n        if (_r2) {\n          return _r2;\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_findLastMatchInLine\",\n    value: function _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {\n      var bestResult = null;\n      var m;\n      searcher.reset(0);\n      while (m = searcher.next(text)) {\n        bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n      }\n      return bestResult;\n    }\n  }]);\n}();\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  if (matchStartIndex === 0) {\n    // Match starts at start of string\n    return true;\n  }\n  var charBefore = text.charCodeAt(matchStartIndex - 1);\n  if (wordSeparators.get(charBefore) !== 0 /* WordCharacterClass.Regular */) {\n    // The character before the match is a word separator\n    return true;\n  }\n  if (charBefore === 13 /* CharCode.CarriageReturn */ || charBefore === 10 /* CharCode.LineFeed */) {\n    // The character before the match is line break or carriage return.\n    return true;\n  }\n  if (matchLength > 0) {\n    var firstCharInMatch = text.charCodeAt(matchStartIndex);\n    if (wordSeparators.get(firstCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n      // The first character inside the match is a word separator\n      return true;\n    }\n  }\n  return false;\n}\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  if (matchStartIndex + matchLength === textLength) {\n    // Match ends at end of string\n    return true;\n  }\n  var charAfter = text.charCodeAt(matchStartIndex + matchLength);\n  if (wordSeparators.get(charAfter) !== 0 /* WordCharacterClass.Regular */) {\n    // The character after the match is a word separator\n    return true;\n  }\n  if (charAfter === 13 /* CharCode.CarriageReturn */ || charAfter === 10 /* CharCode.LineFeed */) {\n    // The character after the match is line break or carriage return.\n    return true;\n  }\n  if (matchLength > 0) {\n    var lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n    if (wordSeparators.get(lastCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n      // The last character in the match is a word separator\n      return true;\n    }\n  }\n  return false;\n}\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  return leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength);\n}\nexport var Searcher = /*#__PURE__*/function () {\n  function Searcher(wordSeparators, searchRegex) {\n    _classCallCheck(this, Searcher);\n    this._wordSeparators = wordSeparators;\n    this._searchRegex = searchRegex;\n    this._prevMatchStartIndex = -1;\n    this._prevMatchLength = 0;\n  }\n  return _createClass(Searcher, [{\n    key: \"reset\",\n    value: function reset(lastIndex) {\n      this._searchRegex.lastIndex = lastIndex;\n      this._prevMatchStartIndex = -1;\n      this._prevMatchLength = 0;\n    }\n  }, {\n    key: \"next\",\n    value: function next(text) {\n      var textLength = text.length;\n      var m;\n      do {\n        if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n          // Reached the end of the line\n          return null;\n        }\n        m = this._searchRegex.exec(text);\n        if (!m) {\n          return null;\n        }\n        var matchStartIndex = m.index;\n        var matchLength = m[0].length;\n        if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n          if (matchLength === 0) {\n            // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n            // we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n            if (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n              this._searchRegex.lastIndex += 2;\n            } else {\n              this._searchRegex.lastIndex += 1;\n            }\n            continue;\n          }\n          // Exit early if the regex matches the same range twice\n          return null;\n        }\n        this._prevMatchStartIndex = matchStartIndex;\n        this._prevMatchLength = matchLength;\n        if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n          return m;\n        }\n      } while (m);\n      return null;\n    }\n  }]);\n}();","map":{"version":3,"names":["strings","getMapForWordSeparators","Position","Range","FindMatch","SearchData","LIMIT_FIND_COUNT","SearchParams","searchString","isRegex","matchCase","wordSeparators","_classCallCheck","_createClass","key","value","parseSearchRequest","multiline","isMultilineRegexSource","indexOf","regex","createRegExp","wholeWord","global","unicode","err","canUseSimpleSearch","toLowerCase","toUpperCase","length","i","len","chCode","charCodeAt","nextChCode","createFindMatch","range","rawMatches","captureMatches","matches","LineFeedCounter","text","lineFeedsOffsets","lineFeedsOffsetsLen","textLen","_lineFeedsOffsets","findLineFeedCountBeforeOffset","offset","min","max","mid","TextModelSearch","findMatches","model","searchParams","searchRange","limitResultCount","searchData","_doFindMatchesMultiline","Searcher","_doFindMatchesLineByLine","_getMultilineMatchRange","deltaOffset","lfCounter","matchIndex","match0","startOffset","lineFeedCountBeforeMatch","endOffset","lineFeedCountBeforeEndOfMatch","lineFeedCountInMatch","startPosition","getPositionAt","endPosition","lineNumber","column","searcher","getOffsetAt","getStartPosition","getValueInRange","getEOL","result","counter","m","reset","next","index","resultLen","startLineNumber","endLineNumber","getLineContent","substring","startColumn","endColumn","_findMatchesInLine","simpleSearch","searchStringLen","textLength","lastMatchIndex","isValidMatch","findNextMatch","searchStart","_doFindNextMatchMultiline","_doFindNextMatchLineByLine","searchTextStart","lineCount","getLineCount","getLineMaxColumn","r","_findFirstMatchInLine","lineIndex","fromColumn","findPreviousMatch","_doFindPreviousMatchMultiline","_doFindPreviousMatchLineByLine","_findLastMatchInLine","bestResult","leftIsWordBounday","matchStartIndex","matchLength","charBefore","get","firstCharInMatch","rightIsWordBounday","charAfter","lastCharInMatch","searchRegex","_wordSeparators","_searchRegex","_prevMatchStartIndex","_prevMatchLength","lastIndex","exec","getNextCodePoint"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { FindMatch, SearchData } from '../model.js';\nconst LIMIT_FIND_COUNT = 999;\nexport class SearchParams {\n    constructor(searchString, isRegex, matchCase, wordSeparators) {\n        this.searchString = searchString;\n        this.isRegex = isRegex;\n        this.matchCase = matchCase;\n        this.wordSeparators = wordSeparators;\n    }\n    parseSearchRequest() {\n        if (this.searchString === '') {\n            return null;\n        }\n        // Try to create a RegExp out of the params\n        let multiline;\n        if (this.isRegex) {\n            multiline = isMultilineRegexSource(this.searchString);\n        }\n        else {\n            multiline = (this.searchString.indexOf('\\n') >= 0);\n        }\n        let regex = null;\n        try {\n            regex = strings.createRegExp(this.searchString, this.isRegex, {\n                matchCase: this.matchCase,\n                wholeWord: false,\n                multiline: multiline,\n                global: true,\n                unicode: true\n            });\n        }\n        catch (err) {\n            return null;\n        }\n        if (!regex) {\n            return null;\n        }\n        let canUseSimpleSearch = (!this.isRegex && !multiline);\n        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n            // casing might make a difference\n            canUseSimpleSearch = this.matchCase;\n        }\n        return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators, []) : null, canUseSimpleSearch ? this.searchString : null);\n    }\n}\nexport function isMultilineRegexSource(searchString) {\n    if (!searchString || searchString.length === 0) {\n        return false;\n    }\n    for (let i = 0, len = searchString.length; i < len; i++) {\n        const chCode = searchString.charCodeAt(i);\n        if (chCode === 10 /* CharCode.LineFeed */) {\n            return true;\n        }\n        if (chCode === 92 /* CharCode.Backslash */) {\n            // move to next char\n            i++;\n            if (i >= len) {\n                // string ends with a \\\n                break;\n            }\n            const nextChCode = searchString.charCodeAt(i);\n            if (nextChCode === 110 /* CharCode.n */ || nextChCode === 114 /* CharCode.r */ || nextChCode === 87 /* CharCode.W */) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function createFindMatch(range, rawMatches, captureMatches) {\n    if (!captureMatches) {\n        return new FindMatch(range, null);\n    }\n    const matches = [];\n    for (let i = 0, len = rawMatches.length; i < len; i++) {\n        matches[i] = rawMatches[i];\n    }\n    return new FindMatch(range, matches);\n}\nclass LineFeedCounter {\n    constructor(text) {\n        const lineFeedsOffsets = [];\n        let lineFeedsOffsetsLen = 0;\n        for (let i = 0, textLen = text.length; i < textLen; i++) {\n            if (text.charCodeAt(i) === 10 /* CharCode.LineFeed */) {\n                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n            }\n        }\n        this._lineFeedsOffsets = lineFeedsOffsets;\n    }\n    findLineFeedCountBeforeOffset(offset) {\n        const lineFeedsOffsets = this._lineFeedsOffsets;\n        let min = 0;\n        let max = lineFeedsOffsets.length - 1;\n        if (max === -1) {\n            // no line feeds\n            return 0;\n        }\n        if (offset <= lineFeedsOffsets[0]) {\n            // before first line feed\n            return 0;\n        }\n        while (min < max) {\n            const mid = min + ((max - min) / 2 >> 0);\n            if (lineFeedsOffsets[mid] >= offset) {\n                max = mid - 1;\n            }\n            else {\n                if (lineFeedsOffsets[mid + 1] >= offset) {\n                    // bingo!\n                    min = mid;\n                    max = mid;\n                }\n                else {\n                    min = mid + 1;\n                }\n            }\n        }\n        return min + 1;\n    }\n}\nexport class TextModelSearch {\n    static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return [];\n        }\n        if (searchData.regex.multiline) {\n            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n        }\n        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Multiline search always executes on the lines concatenated with \\n.\n     * We must therefore compensate for the count of \\n in case the model is CRLF\n     */\n    static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {\n        let startOffset;\n        let lineFeedCountBeforeMatch = 0;\n        if (lfCounter) {\n            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            startOffset = deltaOffset + matchIndex;\n        }\n        let endOffset;\n        if (lfCounter) {\n            const lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n            const lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            endOffset = startOffset + match0.length;\n        }\n        const startPosition = model.getPositionAt(startOffset);\n        const endPosition = model.getPositionAt(endOffset);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {\n        const deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(searchRange, 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        const result = [];\n        let counter = 0;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n            if (counter >= limitResultCount) {\n                return result;\n            }\n        }\n        return result;\n    }\n    static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        // Early case for a search range that starts & stops on the same line number\n        if (searchRange.startLineNumber === searchRange.endLineNumber) {\n            const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        // Collect results from first line\n        const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n        // Collect results from middle lines\n        for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        // Collect results from last line\n        if (resultLen < limitResultCount) {\n            const text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        return result;\n    }\n    static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    static findNextMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const searchTextStart = new Position(searchStart.lineNumber, 1);\n        const deltaOffset = model.getOffsetAt(searchTextStart);\n        const lineCount = model.getLineCount();\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        searcher.reset(searchStart.column - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n        }\n        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n            // Try again from the top\n            return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber);\n        const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (startLineNumber + i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {\n        // Set regex to search from column\n        searcher.reset(fromColumn - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return null;\n    }\n    static findPreviousMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n        if (matches.length > 0) {\n            return matches[matches.length - 1];\n        }\n        const lineCount = model.getLineCount();\n        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n            // Try again with all content\n            return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n        const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {\n        let bestResult = null;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return bestResult;\n    }\n}\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex === 0) {\n        // Match starts at start of string\n        return true;\n    }\n    const charBefore = text.charCodeAt(matchStartIndex - 1);\n    if (wordSeparators.get(charBefore) !== 0 /* WordCharacterClass.Regular */) {\n        // The character before the match is a word separator\n        return true;\n    }\n    if (charBefore === 13 /* CharCode.CarriageReturn */ || charBefore === 10 /* CharCode.LineFeed */) {\n        // The character before the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const firstCharInMatch = text.charCodeAt(matchStartIndex);\n        if (wordSeparators.get(firstCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The first character inside the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex + matchLength === textLength) {\n        // Match ends at end of string\n        return true;\n    }\n    const charAfter = text.charCodeAt(matchStartIndex + matchLength);\n    if (wordSeparators.get(charAfter) !== 0 /* WordCharacterClass.Regular */) {\n        // The character after the match is a word separator\n        return true;\n    }\n    if (charAfter === 13 /* CharCode.CarriageReturn */ || charAfter === 10 /* CharCode.LineFeed */) {\n        // The character after the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n        if (wordSeparators.get(lastCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The last character in the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));\n}\nexport class Searcher {\n    constructor(wordSeparators, searchRegex) {\n        this._wordSeparators = wordSeparators;\n        this._searchRegex = searchRegex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    reset(lastIndex) {\n        this._searchRegex.lastIndex = lastIndex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    next(text) {\n        const textLength = text.length;\n        let m;\n        do {\n            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n                // Reached the end of the line\n                return null;\n            }\n            m = this._searchRegex.exec(text);\n            if (!m) {\n                return null;\n            }\n            const matchStartIndex = m.index;\n            const matchLength = m[0].length;\n            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n                if (matchLength === 0) {\n                    // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n                    // we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n                    if (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n                        this._searchRegex.lastIndex += 2;\n                    }\n                    else {\n                        this._searchRegex.lastIndex += 1;\n                    }\n                    continue;\n                }\n                // Exit early if the regex matches the same range twice\n                return null;\n            }\n            this._prevMatchStartIndex = matchStartIndex;\n            this._prevMatchLength = matchLength;\n            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n                return m;\n            }\n        } while (m);\n        return null;\n    }\n}\n"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA,OAAO,KAAKA,OAAO,MAAM,iCAAiC;AAC1D,SAASC,uBAAuB,QAAQ,oCAAoC;AAC5E,SAASC,QAAQ,QAAQ,qBAAqB;AAC9C,SAASC,KAAK,QAAQ,kBAAkB;AACxC,SAASC,SAAS,EAAEC,UAAU,QAAQ,aAAa;AACnD,IAAMC,gBAAgB,GAAG,GAAG;AAC5B,WAAaC,YAAY;EACrB,SAAAA,aAAYC,YAAY,EAAEC,OAAO,EAAEC,SAAS,EAAEC,cAAc,EAAE;IAAAC,eAAA,OAAAL,YAAA;IAC1D,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,cAAc,GAAGA,cAAc;EACxC;EAAC,OAAAE,YAAA,CAAAN,YAAA;IAAAO,GAAA;IAAAC,KAAA,EACD,SAAAC,mBAAA,EAAqB;MACjB,IAAI,IAAI,CAACR,YAAY,KAAK,EAAE,EAAE;QAC1B,OAAO,IAAI;MACf;MACA;MACA,IAAIS,SAAS;MACb,IAAI,IAAI,CAACR,OAAO,EAAE;QACdQ,SAAS,GAAGC,sBAAsB,CAAC,IAAI,CAACV,YAAY,CAAC;MACzD,CAAC,MACI;QACDS,SAAS,GAAI,IAAI,CAACT,YAAY,CAACW,OAAO,CAAC,IAAI,CAAC,IAAI,CAAE;MACtD;MACA,IAAIC,KAAK,GAAG,IAAI;MAChB,IAAI;QACAA,KAAK,GAAGpB,OAAO,CAACqB,YAAY,CAAC,IAAI,CAACb,YAAY,EAAE,IAAI,CAACC,OAAO,EAAE;UAC1DC,SAAS,EAAE,IAAI,CAACA,SAAS;UACzBY,SAAS,EAAE,KAAK;UAChBL,SAAS,EAAEA,SAAS;UACpBM,MAAM,EAAE,IAAI;UACZC,OAAO,EAAE;QACb,CAAC,CAAC;MACN,CAAC,CACD,OAAOC,GAAG,EAAE;QACR,OAAO,IAAI;MACf;MACA,IAAI,CAACL,KAAK,EAAE;QACR,OAAO,IAAI;MACf;MACA,IAAIM,kBAAkB,GAAI,CAAC,IAAI,CAACjB,OAAO,IAAI,CAACQ,SAAU;MACtD,IAAIS,kBAAkB,IAAI,IAAI,CAAClB,YAAY,CAACmB,WAAW,CAAC,CAAC,KAAK,IAAI,CAACnB,YAAY,CAACoB,WAAW,CAAC,CAAC,EAAE;QAC3F;QACAF,kBAAkB,GAAG,IAAI,CAAChB,SAAS;MACvC;MACA,OAAO,IAAIL,UAAU,CAACe,KAAK,EAAE,IAAI,CAACT,cAAc,GAAGV,uBAAuB,CAAC,IAAI,CAACU,cAAc,EAAE,EAAE,CAAC,GAAG,IAAI,EAAEe,kBAAkB,GAAG,IAAI,CAAClB,YAAY,GAAG,IAAI,CAAC;IAC9J;EAAC;AAAA;AAEL,OAAO,SAASU,sBAAsBA,CAACV,YAAY,EAAE;EACjD,IAAI,CAACA,YAAY,IAAIA,YAAY,CAACqB,MAAM,KAAK,CAAC,EAAE;IAC5C,OAAO,KAAK;EAChB;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGvB,YAAY,CAACqB,MAAM,EAAEC,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;IACrD,IAAME,MAAM,GAAGxB,YAAY,CAACyB,UAAU,CAACH,CAAC,CAAC;IACzC,IAAIE,MAAM,KAAK,EAAE,CAAC,yBAAyB;MACvC,OAAO,IAAI;IACf;IACA,IAAIA,MAAM,KAAK,EAAE,CAAC,0BAA0B;MACxC;MACAF,CAAC,EAAE;MACH,IAAIA,CAAC,IAAIC,GAAG,EAAE;QACV;QACA;MACJ;MACA,IAAMG,UAAU,GAAG1B,YAAY,CAACyB,UAAU,CAACH,CAAC,CAAC;MAC7C,IAAII,UAAU,KAAK,GAAG,CAAC,oBAAoBA,UAAU,KAAK,GAAG,CAAC,oBAAoBA,UAAU,KAAK,EAAE,CAAC,kBAAkB;QAClH,OAAO,IAAI;MACf;IACJ;EACJ;EACA,OAAO,KAAK;AAChB;AACA,OAAO,SAASC,eAAeA,CAACC,KAAK,EAAEC,UAAU,EAAEC,cAAc,EAAE;EAC/D,IAAI,CAACA,cAAc,EAAE;IACjB,OAAO,IAAIlC,SAAS,CAACgC,KAAK,EAAE,IAAI,CAAC;EACrC;EACA,IAAMG,OAAO,GAAG,EAAE;EAClB,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGM,UAAU,CAACR,MAAM,EAAEC,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;IACnDS,OAAO,CAACT,CAAC,CAAC,GAAGO,UAAU,CAACP,CAAC,CAAC;EAC9B;EACA,OAAO,IAAI1B,SAAS,CAACgC,KAAK,EAAEG,OAAO,CAAC;AACxC;AAAC,IACKC,eAAe;EACjB,SAAAA,gBAAYC,IAAI,EAAE;IAAA7B,eAAA,OAAA4B,eAAA;IACd,IAAME,gBAAgB,GAAG,EAAE;IAC3B,IAAIC,mBAAmB,GAAG,CAAC;IAC3B,KAAK,IAAIb,CAAC,GAAG,CAAC,EAAEc,OAAO,GAAGH,IAAI,CAACZ,MAAM,EAAEC,CAAC,GAAGc,OAAO,EAAEd,CAAC,EAAE,EAAE;MACrD,IAAIW,IAAI,CAACR,UAAU,CAACH,CAAC,CAAC,KAAK,EAAE,CAAC,yBAAyB;QACnDY,gBAAgB,CAACC,mBAAmB,EAAE,CAAC,GAAGb,CAAC;MAC/C;IACJ;IACA,IAAI,CAACe,iBAAiB,GAAGH,gBAAgB;EAC7C;EAAC,OAAA7B,YAAA,CAAA2B,eAAA;IAAA1B,GAAA;IAAAC,KAAA,EACD,SAAA+B,8BAA8BC,MAAM,EAAE;MAClC,IAAML,gBAAgB,GAAG,IAAI,CAACG,iBAAiB;MAC/C,IAAIG,GAAG,GAAG,CAAC;MACX,IAAIC,GAAG,GAAGP,gBAAgB,CAACb,MAAM,GAAG,CAAC;MACrC,IAAIoB,GAAG,KAAK,CAAC,CAAC,EAAE;QACZ;QACA,OAAO,CAAC;MACZ;MACA,IAAIF,MAAM,IAAIL,gBAAgB,CAAC,CAAC,CAAC,EAAE;QAC/B;QACA,OAAO,CAAC;MACZ;MACA,OAAOM,GAAG,GAAGC,GAAG,EAAE;QACd,IAAMC,GAAG,GAAGF,GAAG,IAAI,CAACC,GAAG,GAAGD,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC;QACxC,IAAIN,gBAAgB,CAACQ,GAAG,CAAC,IAAIH,MAAM,EAAE;UACjCE,GAAG,GAAGC,GAAG,GAAG,CAAC;QACjB,CAAC,MACI;UACD,IAAIR,gBAAgB,CAACQ,GAAG,GAAG,CAAC,CAAC,IAAIH,MAAM,EAAE;YACrC;YACAC,GAAG,GAAGE,GAAG;YACTD,GAAG,GAAGC,GAAG;UACb,CAAC,MACI;YACDF,GAAG,GAAGE,GAAG,GAAG,CAAC;UACjB;QACJ;MACJ;MACA,OAAOF,GAAG,GAAG,CAAC;IAClB;EAAC;AAAA;AAEL,WAAaG,eAAe;EAAA,SAAAA,gBAAA;IAAAvC,eAAA,OAAAuC,eAAA;EAAA;EAAA,OAAAtC,YAAA,CAAAsC,eAAA;IAAArC,GAAA;IAAAC,KAAA,EACxB,SAAAqC,YAAmBC,KAAK,EAAEC,YAAY,EAAEC,WAAW,EAAEjB,cAAc,EAAEkB,gBAAgB,EAAE;MACnF,IAAMC,UAAU,GAAGH,YAAY,CAACtC,kBAAkB,CAAC,CAAC;MACpD,IAAI,CAACyC,UAAU,EAAE;QACb,OAAO,EAAE;MACb;MACA,IAAIA,UAAU,CAACrC,KAAK,CAACH,SAAS,EAAE;QAC5B,OAAO,IAAI,CAACyC,uBAAuB,CAACL,KAAK,EAAEE,WAAW,EAAE,IAAII,QAAQ,CAACF,UAAU,CAAC9C,cAAc,EAAE8C,UAAU,CAACrC,KAAK,CAAC,EAAEkB,cAAc,EAAEkB,gBAAgB,CAAC;MACxJ;MACA,OAAO,IAAI,CAACI,wBAAwB,CAACP,KAAK,EAAEE,WAAW,EAAEE,UAAU,EAAEnB,cAAc,EAAEkB,gBAAgB,CAAC;IAC1G;IACA;AACJ;AACA;AACA;EAHI;IAAA1C,GAAA;IAAAC,KAAA,EAIA,SAAA8C,wBAA+BR,KAAK,EAAES,WAAW,EAAErB,IAAI,EAAEsB,SAAS,EAAEC,UAAU,EAAEC,MAAM,EAAE;MACpF,IAAIC,WAAW;MACf,IAAIC,wBAAwB,GAAG,CAAC;MAChC,IAAIJ,SAAS,EAAE;QACXI,wBAAwB,GAAGJ,SAAS,CAACjB,6BAA6B,CAACkB,UAAU,CAAC;QAC9EE,WAAW,GAAGJ,WAAW,GAAGE,UAAU,GAAGG,wBAAwB,CAAC;MACtE,CAAC,MACI;QACDD,WAAW,GAAGJ,WAAW,GAAGE,UAAU;MAC1C;MACA,IAAII,SAAS;MACb,IAAIL,SAAS,EAAE;QACX,IAAMM,6BAA6B,GAAGN,SAAS,CAACjB,6BAA6B,CAACkB,UAAU,GAAGC,MAAM,CAACpC,MAAM,CAAC;QACzG,IAAMyC,oBAAoB,GAAGD,6BAA6B,GAAGF,wBAAwB;QACrFC,SAAS,GAAGF,WAAW,GAAGD,MAAM,CAACpC,MAAM,GAAGyC,oBAAoB,CAAC;MACnE,CAAC,MACI;QACDF,SAAS,GAAGF,WAAW,GAAGD,MAAM,CAACpC,MAAM;MAC3C;MACA,IAAM0C,aAAa,GAAGlB,KAAK,CAACmB,aAAa,CAACN,WAAW,CAAC;MACtD,IAAMO,WAAW,GAAGpB,KAAK,CAACmB,aAAa,CAACJ,SAAS,CAAC;MAClD,OAAO,IAAIjE,KAAK,CAACoE,aAAa,CAACG,UAAU,EAAEH,aAAa,CAACI,MAAM,EAAEF,WAAW,CAACC,UAAU,EAAED,WAAW,CAACE,MAAM,CAAC;IAChH;EAAC;IAAA7D,GAAA;IAAAC,KAAA,EACD,SAAA2C,wBAA+BL,KAAK,EAAEE,WAAW,EAAEqB,QAAQ,EAAEtC,cAAc,EAAEkB,gBAAgB,EAAE;MAC3F,IAAMM,WAAW,GAAGT,KAAK,CAACwB,WAAW,CAACtB,WAAW,CAACuB,gBAAgB,CAAC,CAAC,CAAC;MACrE;MACA;MACA;MACA,IAAMrC,IAAI,GAAGY,KAAK,CAAC0B,eAAe,CAACxB,WAAW,EAAE,CAAC,CAAC,4BAA4B,CAAC;MAC/E,IAAMQ,SAAS,GAAIV,KAAK,CAAC2B,MAAM,CAAC,CAAC,KAAK,MAAM,GAAG,IAAIxC,eAAe,CAACC,IAAI,CAAC,GAAG,IAAK;MAChF,IAAMwC,MAAM,GAAG,EAAE;MACjB,IAAIC,OAAO,GAAG,CAAC;MACf,IAAIC,CAAC;MACLP,QAAQ,CAACQ,KAAK,CAAC,CAAC,CAAC;MACjB,OAAQD,CAAC,GAAGP,QAAQ,CAACS,IAAI,CAAC5C,IAAI,CAAC,EAAG;QAC9BwC,MAAM,CAACC,OAAO,EAAE,CAAC,GAAG/C,eAAe,CAAC,IAAI,CAAC0B,uBAAuB,CAACR,KAAK,EAAES,WAAW,EAAErB,IAAI,EAAEsB,SAAS,EAAEoB,CAAC,CAACG,KAAK,EAAEH,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,EAAE7C,cAAc,CAAC;QACxI,IAAI4C,OAAO,IAAI1B,gBAAgB,EAAE;UAC7B,OAAOyB,MAAM;QACjB;MACJ;MACA,OAAOA,MAAM;IACjB;EAAC;IAAAnE,GAAA;IAAAC,KAAA,EACD,SAAA6C,yBAAgCP,KAAK,EAAEE,WAAW,EAAEE,UAAU,EAAEnB,cAAc,EAAEkB,gBAAgB,EAAE;MAC9F,IAAMyB,MAAM,GAAG,EAAE;MACjB,IAAIM,SAAS,GAAG,CAAC;MACjB;MACA,IAAIhC,WAAW,CAACiC,eAAe,KAAKjC,WAAW,CAACkC,aAAa,EAAE;QAC3D,IAAMhD,KAAI,GAAGY,KAAK,CAACqC,cAAc,CAACnC,WAAW,CAACiC,eAAe,CAAC,CAACG,SAAS,CAACpC,WAAW,CAACqC,WAAW,GAAG,CAAC,EAAErC,WAAW,CAACsC,SAAS,GAAG,CAAC,CAAC;QAChIN,SAAS,GAAG,IAAI,CAACO,kBAAkB,CAACrC,UAAU,EAAEhB,KAAI,EAAEc,WAAW,CAACiC,eAAe,EAAEjC,WAAW,CAACqC,WAAW,GAAG,CAAC,EAAEL,SAAS,EAAEN,MAAM,EAAE3C,cAAc,EAAEkB,gBAAgB,CAAC;QACpK,OAAOyB,MAAM;MACjB;MACA;MACA,IAAMxC,IAAI,GAAGY,KAAK,CAACqC,cAAc,CAACnC,WAAW,CAACiC,eAAe,CAAC,CAACG,SAAS,CAACpC,WAAW,CAACqC,WAAW,GAAG,CAAC,CAAC;MACrGL,SAAS,GAAG,IAAI,CAACO,kBAAkB,CAACrC,UAAU,EAAEhB,IAAI,EAAEc,WAAW,CAACiC,eAAe,EAAEjC,WAAW,CAACqC,WAAW,GAAG,CAAC,EAAEL,SAAS,EAAEN,MAAM,EAAE3C,cAAc,EAAEkB,gBAAgB,CAAC;MACpK;MACA,KAAK,IAAIkB,UAAU,GAAGnB,WAAW,CAACiC,eAAe,GAAG,CAAC,EAAEd,UAAU,GAAGnB,WAAW,CAACkC,aAAa,IAAIF,SAAS,GAAG/B,gBAAgB,EAAEkB,UAAU,EAAE,EAAE;QACzIa,SAAS,GAAG,IAAI,CAACO,kBAAkB,CAACrC,UAAU,EAAEJ,KAAK,CAACqC,cAAc,CAAChB,UAAU,CAAC,EAAEA,UAAU,EAAE,CAAC,EAAEa,SAAS,EAAEN,MAAM,EAAE3C,cAAc,EAAEkB,gBAAgB,CAAC;MACzJ;MACA;MACA,IAAI+B,SAAS,GAAG/B,gBAAgB,EAAE;QAC9B,IAAMf,MAAI,GAAGY,KAAK,CAACqC,cAAc,CAACnC,WAAW,CAACkC,aAAa,CAAC,CAACE,SAAS,CAAC,CAAC,EAAEpC,WAAW,CAACsC,SAAS,GAAG,CAAC,CAAC;QACpGN,SAAS,GAAG,IAAI,CAACO,kBAAkB,CAACrC,UAAU,EAAEhB,MAAI,EAAEc,WAAW,CAACkC,aAAa,EAAE,CAAC,EAAEF,SAAS,EAAEN,MAAM,EAAE3C,cAAc,EAAEkB,gBAAgB,CAAC;MAC5I;MACA,OAAOyB,MAAM;IACjB;EAAC;IAAAnE,GAAA;IAAAC,KAAA,EACD,SAAA+E,mBAA0BrC,UAAU,EAAEhB,IAAI,EAAEiC,UAAU,EAAEZ,WAAW,EAAEyB,SAAS,EAAEN,MAAM,EAAE3C,cAAc,EAAEkB,gBAAgB,EAAE;MACtH,IAAM7C,cAAc,GAAG8C,UAAU,CAAC9C,cAAc;MAChD,IAAI,CAAC2B,cAAc,IAAImB,UAAU,CAACsC,YAAY,EAAE;QAC5C,IAAMvF,YAAY,GAAGiD,UAAU,CAACsC,YAAY;QAC5C,IAAMC,eAAe,GAAGxF,YAAY,CAACqB,MAAM;QAC3C,IAAMoE,UAAU,GAAGxD,IAAI,CAACZ,MAAM;QAC9B,IAAIqE,cAAc,GAAG,CAACF,eAAe;QACrC,OAAO,CAACE,cAAc,GAAGzD,IAAI,CAACtB,OAAO,CAACX,YAAY,EAAE0F,cAAc,GAAGF,eAAe,CAAC,MAAM,CAAC,CAAC,EAAE;UAC3F,IAAI,CAACrF,cAAc,IAAIwF,YAAY,CAACxF,cAAc,EAAE8B,IAAI,EAAEwD,UAAU,EAAEC,cAAc,EAAEF,eAAe,CAAC,EAAE;YACpGf,MAAM,CAACM,SAAS,EAAE,CAAC,GAAG,IAAInF,SAAS,CAAC,IAAID,KAAK,CAACuE,UAAU,EAAEwB,cAAc,GAAG,CAAC,GAAGpC,WAAW,EAAEY,UAAU,EAAEwB,cAAc,GAAG,CAAC,GAAGF,eAAe,GAAGlC,WAAW,CAAC,EAAE,IAAI,CAAC;YAClK,IAAIyB,SAAS,IAAI/B,gBAAgB,EAAE;cAC/B,OAAO+B,SAAS;YACpB;UACJ;QACJ;QACA,OAAOA,SAAS;MACpB;MACA,IAAMX,QAAQ,GAAG,IAAIjB,QAAQ,CAACF,UAAU,CAAC9C,cAAc,EAAE8C,UAAU,CAACrC,KAAK,CAAC;MAC1E,IAAI+D,CAAC;MACL;MACAP,QAAQ,CAACQ,KAAK,CAAC,CAAC,CAAC;MACjB,GAAG;QACCD,CAAC,GAAGP,QAAQ,CAACS,IAAI,CAAC5C,IAAI,CAAC;QACvB,IAAI0C,CAAC,EAAE;UACHF,MAAM,CAACM,SAAS,EAAE,CAAC,GAAGpD,eAAe,CAAC,IAAIhC,KAAK,CAACuE,UAAU,EAAES,CAAC,CAACG,KAAK,GAAG,CAAC,GAAGxB,WAAW,EAAEY,UAAU,EAAES,CAAC,CAACG,KAAK,GAAG,CAAC,GAAGH,CAAC,CAAC,CAAC,CAAC,CAACtD,MAAM,GAAGiC,WAAW,CAAC,EAAEqB,CAAC,EAAE7C,cAAc,CAAC;UAC/J,IAAIiD,SAAS,IAAI/B,gBAAgB,EAAE;YAC/B,OAAO+B,SAAS;UACpB;QACJ;MACJ,CAAC,QAAQJ,CAAC;MACV,OAAOI,SAAS;IACpB;EAAC;IAAAzE,GAAA;IAAAC,KAAA,EACD,SAAAqF,cAAqB/C,KAAK,EAAEC,YAAY,EAAE+C,WAAW,EAAE/D,cAAc,EAAE;MACnE,IAAMmB,UAAU,GAAGH,YAAY,CAACtC,kBAAkB,CAAC,CAAC;MACpD,IAAI,CAACyC,UAAU,EAAE;QACb,OAAO,IAAI;MACf;MACA,IAAMmB,QAAQ,GAAG,IAAIjB,QAAQ,CAACF,UAAU,CAAC9C,cAAc,EAAE8C,UAAU,CAACrC,KAAK,CAAC;MAC1E,IAAIqC,UAAU,CAACrC,KAAK,CAACH,SAAS,EAAE;QAC5B,OAAO,IAAI,CAACqF,yBAAyB,CAACjD,KAAK,EAAEgD,WAAW,EAAEzB,QAAQ,EAAEtC,cAAc,CAAC;MACvF;MACA,OAAO,IAAI,CAACiE,0BAA0B,CAAClD,KAAK,EAAEgD,WAAW,EAAEzB,QAAQ,EAAEtC,cAAc,CAAC;IACxF;EAAC;IAAAxB,GAAA;IAAAC,KAAA,EACD,SAAAuF,0BAAiCjD,KAAK,EAAEgD,WAAW,EAAEzB,QAAQ,EAAEtC,cAAc,EAAE;MAC3E,IAAMkE,eAAe,GAAG,IAAItG,QAAQ,CAACmG,WAAW,CAAC3B,UAAU,EAAE,CAAC,CAAC;MAC/D,IAAMZ,WAAW,GAAGT,KAAK,CAACwB,WAAW,CAAC2B,eAAe,CAAC;MACtD,IAAMC,SAAS,GAAGpD,KAAK,CAACqD,YAAY,CAAC,CAAC;MACtC;MACA;MACA;MACA,IAAMjE,IAAI,GAAGY,KAAK,CAAC0B,eAAe,CAAC,IAAI5E,KAAK,CAACqG,eAAe,CAAC9B,UAAU,EAAE8B,eAAe,CAAC7B,MAAM,EAAE8B,SAAS,EAAEpD,KAAK,CAACsD,gBAAgB,CAACF,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,4BAA4B,CAAC;MAC/K,IAAM1C,SAAS,GAAIV,KAAK,CAAC2B,MAAM,CAAC,CAAC,KAAK,MAAM,GAAG,IAAIxC,eAAe,CAACC,IAAI,CAAC,GAAG,IAAK;MAChFmC,QAAQ,CAACQ,KAAK,CAACiB,WAAW,CAAC1B,MAAM,GAAG,CAAC,CAAC;MACtC,IAAMQ,CAAC,GAAGP,QAAQ,CAACS,IAAI,CAAC5C,IAAI,CAAC;MAC7B,IAAI0C,CAAC,EAAE;QACH,OAAOhD,eAAe,CAAC,IAAI,CAAC0B,uBAAuB,CAACR,KAAK,EAAES,WAAW,EAAErB,IAAI,EAAEsB,SAAS,EAAEoB,CAAC,CAACG,KAAK,EAAEH,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,EAAE7C,cAAc,CAAC;MAC/H;MACA,IAAI+D,WAAW,CAAC3B,UAAU,KAAK,CAAC,IAAI2B,WAAW,CAAC1B,MAAM,KAAK,CAAC,EAAE;QAC1D;QACA,OAAO,IAAI,CAAC2B,yBAAyB,CAACjD,KAAK,EAAE,IAAInD,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE0E,QAAQ,EAAEtC,cAAc,CAAC;MAC9F;MACA,OAAO,IAAI;IACf;EAAC;IAAAxB,GAAA;IAAAC,KAAA,EACD,SAAAwF,2BAAkClD,KAAK,EAAEgD,WAAW,EAAEzB,QAAQ,EAAEtC,cAAc,EAAE;MAC5E,IAAMmE,SAAS,GAAGpD,KAAK,CAACqD,YAAY,CAAC,CAAC;MACtC,IAAMlB,eAAe,GAAGa,WAAW,CAAC3B,UAAU;MAC9C;MACA,IAAMjC,IAAI,GAAGY,KAAK,CAACqC,cAAc,CAACF,eAAe,CAAC;MAClD,IAAMoB,CAAC,GAAG,IAAI,CAACC,qBAAqB,CAACjC,QAAQ,EAAEnC,IAAI,EAAE+C,eAAe,EAAEa,WAAW,CAAC1B,MAAM,EAAErC,cAAc,CAAC;MACzG,IAAIsE,CAAC,EAAE;QACH,OAAOA,CAAC;MACZ;MACA,KAAK,IAAI9E,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI2E,SAAS,EAAE3E,CAAC,EAAE,EAAE;QACjC,IAAMgF,SAAS,GAAG,CAACtB,eAAe,GAAG1D,CAAC,GAAG,CAAC,IAAI2E,SAAS;QACvD,IAAMhE,MAAI,GAAGY,KAAK,CAACqC,cAAc,CAACoB,SAAS,GAAG,CAAC,CAAC;QAChD,IAAMF,EAAC,GAAG,IAAI,CAACC,qBAAqB,CAACjC,QAAQ,EAAEnC,MAAI,EAAEqE,SAAS,GAAG,CAAC,EAAE,CAAC,EAAExE,cAAc,CAAC;QACtF,IAAIsE,EAAC,EAAE;UACH,OAAOA,EAAC;QACZ;MACJ;MACA,OAAO,IAAI;IACf;EAAC;IAAA9F,GAAA;IAAAC,KAAA,EACD,SAAA8F,sBAA6BjC,QAAQ,EAAEnC,IAAI,EAAEiC,UAAU,EAAEqC,UAAU,EAAEzE,cAAc,EAAE;MACjF;MACAsC,QAAQ,CAACQ,KAAK,CAAC2B,UAAU,GAAG,CAAC,CAAC;MAC9B,IAAM5B,CAAC,GAAGP,QAAQ,CAACS,IAAI,CAAC5C,IAAI,CAAC;MAC7B,IAAI0C,CAAC,EAAE;QACH,OAAOhD,eAAe,CAAC,IAAIhC,KAAK,CAACuE,UAAU,EAAES,CAAC,CAACG,KAAK,GAAG,CAAC,EAAEZ,UAAU,EAAES,CAAC,CAACG,KAAK,GAAG,CAAC,GAAGH,CAAC,CAAC,CAAC,CAAC,CAACtD,MAAM,CAAC,EAAEsD,CAAC,EAAE7C,cAAc,CAAC;MACxH;MACA,OAAO,IAAI;IACf;EAAC;IAAAxB,GAAA;IAAAC,KAAA,EACD,SAAAiG,kBAAyB3D,KAAK,EAAEC,YAAY,EAAE+C,WAAW,EAAE/D,cAAc,EAAE;MACvE,IAAMmB,UAAU,GAAGH,YAAY,CAACtC,kBAAkB,CAAC,CAAC;MACpD,IAAI,CAACyC,UAAU,EAAE;QACb,OAAO,IAAI;MACf;MACA,IAAMmB,QAAQ,GAAG,IAAIjB,QAAQ,CAACF,UAAU,CAAC9C,cAAc,EAAE8C,UAAU,CAACrC,KAAK,CAAC;MAC1E,IAAIqC,UAAU,CAACrC,KAAK,CAACH,SAAS,EAAE;QAC5B,OAAO,IAAI,CAACgG,6BAA6B,CAAC5D,KAAK,EAAEgD,WAAW,EAAEzB,QAAQ,EAAEtC,cAAc,CAAC;MAC3F;MACA,OAAO,IAAI,CAAC4E,8BAA8B,CAAC7D,KAAK,EAAEgD,WAAW,EAAEzB,QAAQ,EAAEtC,cAAc,CAAC;IAC5F;EAAC;IAAAxB,GAAA;IAAAC,KAAA,EACD,SAAAkG,8BAAqC5D,KAAK,EAAEgD,WAAW,EAAEzB,QAAQ,EAAEtC,cAAc,EAAE;MAC/E,IAAMC,OAAO,GAAG,IAAI,CAACmB,uBAAuB,CAACL,KAAK,EAAE,IAAIlD,KAAK,CAAC,CAAC,EAAE,CAAC,EAAEkG,WAAW,CAAC3B,UAAU,EAAE2B,WAAW,CAAC1B,MAAM,CAAC,EAAEC,QAAQ,EAAEtC,cAAc,EAAE,EAAE,GAAGhC,gBAAgB,CAAC;MACjK,IAAIiC,OAAO,CAACV,MAAM,GAAG,CAAC,EAAE;QACpB,OAAOU,OAAO,CAACA,OAAO,CAACV,MAAM,GAAG,CAAC,CAAC;MACtC;MACA,IAAM4E,SAAS,GAAGpD,KAAK,CAACqD,YAAY,CAAC,CAAC;MACtC,IAAIL,WAAW,CAAC3B,UAAU,KAAK+B,SAAS,IAAIJ,WAAW,CAAC1B,MAAM,KAAKtB,KAAK,CAACsD,gBAAgB,CAACF,SAAS,CAAC,EAAE;QAClG;QACA,OAAO,IAAI,CAACQ,6BAA6B,CAAC5D,KAAK,EAAE,IAAInD,QAAQ,CAACuG,SAAS,EAAEpD,KAAK,CAACsD,gBAAgB,CAACF,SAAS,CAAC,CAAC,EAAE7B,QAAQ,EAAEtC,cAAc,CAAC;MAC1I;MACA,OAAO,IAAI;IACf;EAAC;IAAAxB,GAAA;IAAAC,KAAA,EACD,SAAAmG,+BAAsC7D,KAAK,EAAEgD,WAAW,EAAEzB,QAAQ,EAAEtC,cAAc,EAAE;MAChF,IAAMmE,SAAS,GAAGpD,KAAK,CAACqD,YAAY,CAAC,CAAC;MACtC,IAAMlB,eAAe,GAAGa,WAAW,CAAC3B,UAAU;MAC9C;MACA,IAAMjC,IAAI,GAAGY,KAAK,CAACqC,cAAc,CAACF,eAAe,CAAC,CAACG,SAAS,CAAC,CAAC,EAAEU,WAAW,CAAC1B,MAAM,GAAG,CAAC,CAAC;MACvF,IAAMiC,CAAC,GAAG,IAAI,CAACO,oBAAoB,CAACvC,QAAQ,EAAEnC,IAAI,EAAE+C,eAAe,EAAElD,cAAc,CAAC;MACpF,IAAIsE,CAAC,EAAE;QACH,OAAOA,CAAC;MACZ;MACA,KAAK,IAAI9E,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI2E,SAAS,EAAE3E,CAAC,EAAE,EAAE;QACjC,IAAMgF,SAAS,GAAG,CAACL,SAAS,GAAGjB,eAAe,GAAG1D,CAAC,GAAG,CAAC,IAAI2E,SAAS;QACnE,IAAMhE,MAAI,GAAGY,KAAK,CAACqC,cAAc,CAACoB,SAAS,GAAG,CAAC,CAAC;QAChD,IAAMF,GAAC,GAAG,IAAI,CAACO,oBAAoB,CAACvC,QAAQ,EAAEnC,MAAI,EAAEqE,SAAS,GAAG,CAAC,EAAExE,cAAc,CAAC;QAClF,IAAIsE,GAAC,EAAE;UACH,OAAOA,GAAC;QACZ;MACJ;MACA,OAAO,IAAI;IACf;EAAC;IAAA9F,GAAA;IAAAC,KAAA,EACD,SAAAoG,qBAA4BvC,QAAQ,EAAEnC,IAAI,EAAEiC,UAAU,EAAEpC,cAAc,EAAE;MACpE,IAAI8E,UAAU,GAAG,IAAI;MACrB,IAAIjC,CAAC;MACLP,QAAQ,CAACQ,KAAK,CAAC,CAAC,CAAC;MACjB,OAAQD,CAAC,GAAGP,QAAQ,CAACS,IAAI,CAAC5C,IAAI,CAAC,EAAG;QAC9B2E,UAAU,GAAGjF,eAAe,CAAC,IAAIhC,KAAK,CAACuE,UAAU,EAAES,CAAC,CAACG,KAAK,GAAG,CAAC,EAAEZ,UAAU,EAAES,CAAC,CAACG,KAAK,GAAG,CAAC,GAAGH,CAAC,CAAC,CAAC,CAAC,CAACtD,MAAM,CAAC,EAAEsD,CAAC,EAAE7C,cAAc,CAAC;MAC9H;MACA,OAAO8E,UAAU;IACrB;EAAC;AAAA;AAEL,SAASC,iBAAiBA,CAAC1G,cAAc,EAAE8B,IAAI,EAAEwD,UAAU,EAAEqB,eAAe,EAAEC,WAAW,EAAE;EACvF,IAAID,eAAe,KAAK,CAAC,EAAE;IACvB;IACA,OAAO,IAAI;EACf;EACA,IAAME,UAAU,GAAG/E,IAAI,CAACR,UAAU,CAACqF,eAAe,GAAG,CAAC,CAAC;EACvD,IAAI3G,cAAc,CAAC8G,GAAG,CAACD,UAAU,CAAC,KAAK,CAAC,CAAC,kCAAkC;IACvE;IACA,OAAO,IAAI;EACf;EACA,IAAIA,UAAU,KAAK,EAAE,CAAC,iCAAiCA,UAAU,KAAK,EAAE,CAAC,yBAAyB;IAC9F;IACA,OAAO,IAAI;EACf;EACA,IAAID,WAAW,GAAG,CAAC,EAAE;IACjB,IAAMG,gBAAgB,GAAGjF,IAAI,CAACR,UAAU,CAACqF,eAAe,CAAC;IACzD,IAAI3G,cAAc,CAAC8G,GAAG,CAACC,gBAAgB,CAAC,KAAK,CAAC,CAAC,kCAAkC;MAC7E;MACA,OAAO,IAAI;IACf;EACJ;EACA,OAAO,KAAK;AAChB;AACA,SAASC,kBAAkBA,CAAChH,cAAc,EAAE8B,IAAI,EAAEwD,UAAU,EAAEqB,eAAe,EAAEC,WAAW,EAAE;EACxF,IAAID,eAAe,GAAGC,WAAW,KAAKtB,UAAU,EAAE;IAC9C;IACA,OAAO,IAAI;EACf;EACA,IAAM2B,SAAS,GAAGnF,IAAI,CAACR,UAAU,CAACqF,eAAe,GAAGC,WAAW,CAAC;EAChE,IAAI5G,cAAc,CAAC8G,GAAG,CAACG,SAAS,CAAC,KAAK,CAAC,CAAC,kCAAkC;IACtE;IACA,OAAO,IAAI;EACf;EACA,IAAIA,SAAS,KAAK,EAAE,CAAC,iCAAiCA,SAAS,KAAK,EAAE,CAAC,yBAAyB;IAC5F;IACA,OAAO,IAAI;EACf;EACA,IAAIL,WAAW,GAAG,CAAC,EAAE;IACjB,IAAMM,eAAe,GAAGpF,IAAI,CAACR,UAAU,CAACqF,eAAe,GAAGC,WAAW,GAAG,CAAC,CAAC;IAC1E,IAAI5G,cAAc,CAAC8G,GAAG,CAACI,eAAe,CAAC,KAAK,CAAC,CAAC,kCAAkC;MAC5E;MACA,OAAO,IAAI;IACf;EACJ;EACA,OAAO,KAAK;AAChB;AACA,OAAO,SAAS1B,YAAYA,CAACxF,cAAc,EAAE8B,IAAI,EAAEwD,UAAU,EAAEqB,eAAe,EAAEC,WAAW,EAAE;EACzF,OAAQF,iBAAiB,CAAC1G,cAAc,EAAE8B,IAAI,EAAEwD,UAAU,EAAEqB,eAAe,EAAEC,WAAW,CAAC,IAClFI,kBAAkB,CAAChH,cAAc,EAAE8B,IAAI,EAAEwD,UAAU,EAAEqB,eAAe,EAAEC,WAAW,CAAC;AAC7F;AACA,WAAa5D,QAAQ;EACjB,SAAAA,SAAYhD,cAAc,EAAEmH,WAAW,EAAE;IAAAlH,eAAA,OAAA+C,QAAA;IACrC,IAAI,CAACoE,eAAe,GAAGpH,cAAc;IACrC,IAAI,CAACqH,YAAY,GAAGF,WAAW;IAC/B,IAAI,CAACG,oBAAoB,GAAG,CAAC,CAAC;IAC9B,IAAI,CAACC,gBAAgB,GAAG,CAAC;EAC7B;EAAC,OAAArH,YAAA,CAAA8C,QAAA;IAAA7C,GAAA;IAAAC,KAAA,EACD,SAAAqE,MAAM+C,SAAS,EAAE;MACb,IAAI,CAACH,YAAY,CAACG,SAAS,GAAGA,SAAS;MACvC,IAAI,CAACF,oBAAoB,GAAG,CAAC,CAAC;MAC9B,IAAI,CAACC,gBAAgB,GAAG,CAAC;IAC7B;EAAC;IAAApH,GAAA;IAAAC,KAAA,EACD,SAAAsE,KAAK5C,IAAI,EAAE;MACP,IAAMwD,UAAU,GAAGxD,IAAI,CAACZ,MAAM;MAC9B,IAAIsD,CAAC;MACL,GAAG;QACC,IAAI,IAAI,CAAC8C,oBAAoB,GAAG,IAAI,CAACC,gBAAgB,KAAKjC,UAAU,EAAE;UAClE;UACA,OAAO,IAAI;QACf;QACAd,CAAC,GAAG,IAAI,CAAC6C,YAAY,CAACI,IAAI,CAAC3F,IAAI,CAAC;QAChC,IAAI,CAAC0C,CAAC,EAAE;UACJ,OAAO,IAAI;QACf;QACA,IAAMmC,eAAe,GAAGnC,CAAC,CAACG,KAAK;QAC/B,IAAMiC,WAAW,GAAGpC,CAAC,CAAC,CAAC,CAAC,CAACtD,MAAM;QAC/B,IAAIyF,eAAe,KAAK,IAAI,CAACW,oBAAoB,IAAIV,WAAW,KAAK,IAAI,CAACW,gBAAgB,EAAE;UACxF,IAAIX,WAAW,KAAK,CAAC,EAAE;YACnB;YACA;YACA,IAAIvH,OAAO,CAACqI,gBAAgB,CAAC5F,IAAI,EAAEwD,UAAU,EAAE,IAAI,CAAC+B,YAAY,CAACG,SAAS,CAAC,GAAG,MAAM,EAAE;cAClF,IAAI,CAACH,YAAY,CAACG,SAAS,IAAI,CAAC;YACpC,CAAC,MACI;cACD,IAAI,CAACH,YAAY,CAACG,SAAS,IAAI,CAAC;YACpC;YACA;UACJ;UACA;UACA,OAAO,IAAI;QACf;QACA,IAAI,CAACF,oBAAoB,GAAGX,eAAe;QAC3C,IAAI,CAACY,gBAAgB,GAAGX,WAAW;QACnC,IAAI,CAAC,IAAI,CAACQ,eAAe,IAAI5B,YAAY,CAAC,IAAI,CAAC4B,eAAe,EAAEtF,IAAI,EAAEwD,UAAU,EAAEqB,eAAe,EAAEC,WAAW,CAAC,EAAE;UAC7G,OAAOpC,CAAC;QACZ;MACJ,CAAC,QAAQA,CAAC;MACV,OAAO,IAAI;IACf;EAAC;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}