{"ast":null,"code":"import _slicedToArray from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _typeof from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.reflect.to-string-tag.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar SnippetSession_1;\nimport { groupBy } from '../../../../base/common/arrays.js';\nimport { dispose as _dispose } from '../../../../base/common/lifecycle.js';\nimport { getLeadingWhitespace } from '../../../../base/common/strings.js';\nimport './snippetSession.css';\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { ModelDecorationOptions } from '../../../common/model/textModel.js';\nimport { ILabelService } from '../../../../platform/label/common/label.js';\nimport { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.js';\nimport { Choice, Placeholder, SnippetParser, Text, TextmateSnippet } from './snippetParser.js';\nimport { ClipboardBasedVariableResolver, CommentBasedVariableResolver, CompositeSnippetVariableResolver, ModelBasedVariableResolver, RandomBasedVariableResolver, SelectionBasedVariableResolver, TimeBasedVariableResolver, WorkspaceBasedVariableResolver } from './snippetVariables.js';\nexport var OneSnippet = /*#__PURE__*/function () {\n  function OneSnippet(_editor, _snippet, _snippetLineLeadingWhitespace) {\n    _classCallCheck(this, OneSnippet);\n    this._editor = _editor;\n    this._snippet = _snippet;\n    this._snippetLineLeadingWhitespace = _snippetLineLeadingWhitespace;\n    this._offset = -1;\n    this._nestingLevel = 1;\n    this._placeholderGroups = groupBy(_snippet.placeholders, Placeholder.compareByIndex);\n    this._placeholderGroupsIdx = -1;\n  }\n  return _createClass(OneSnippet, [{\n    key: \"initialize\",\n    value: function initialize(textChange) {\n      this._offset = textChange.newPosition;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (this._placeholderDecorations) {\n        this._editor.removeDecorations(_toConsumableArray(this._placeholderDecorations.values()));\n      }\n      this._placeholderGroups.length = 0;\n    }\n  }, {\n    key: \"_initDecorations\",\n    value: function _initDecorations() {\n      var _this = this;\n      if (this._offset === -1) {\n        throw new Error(\"Snippet not initialized!\");\n      }\n      if (this._placeholderDecorations) {\n        // already initialized\n        return;\n      }\n      this._placeholderDecorations = new Map();\n      var model = this._editor.getModel();\n      this._editor.changeDecorations(function (accessor) {\n        // create a decoration for each placeholder\n        var _iterator = _createForOfIteratorHelper(_this._snippet.placeholders),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var placeholder = _step.value;\n            var placeholderOffset = _this._snippet.offset(placeholder);\n            var placeholderLen = _this._snippet.fullLen(placeholder);\n            var range = Range.fromPositions(model.getPositionAt(_this._offset + placeholderOffset), model.getPositionAt(_this._offset + placeholderOffset + placeholderLen));\n            var options = placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive;\n            var handle = accessor.addDecoration(range, options);\n            _this._placeholderDecorations.set(placeholder, handle);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      });\n    }\n  }, {\n    key: \"move\",\n    value: function move(fwd) {\n      var _this2 = this;\n      if (!this._editor.hasModel()) {\n        return [];\n      }\n      this._initDecorations();\n      // Transform placeholder text if necessary\n      if (this._placeholderGroupsIdx >= 0) {\n        var operations = [];\n        var _iterator2 = _createForOfIteratorHelper(this._placeholderGroups[this._placeholderGroupsIdx]),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var placeholder = _step2.value;\n            // Check if the placeholder has a transformation\n            if (placeholder.transform) {\n              var id = this._placeholderDecorations.get(placeholder);\n              var range = this._editor.getModel().getDecorationRange(id);\n              var currentValue = this._editor.getModel().getValueInRange(range);\n              var transformedValueLines = placeholder.transform.resolve(currentValue).split(/\\r\\n|\\r|\\n/);\n              // fix indentation for transformed lines\n              for (var i = 1; i < transformedValueLines.length; i++) {\n                transformedValueLines[i] = this._editor.getModel().normalizeIndentation(this._snippetLineLeadingWhitespace + transformedValueLines[i]);\n              }\n              operations.push(EditOperation.replace(range, transformedValueLines.join(this._editor.getModel().getEOL())));\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        if (operations.length > 0) {\n          this._editor.executeEdits('snippet.placeholderTransform', operations);\n        }\n      }\n      var couldSkipThisPlaceholder = false;\n      if (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {\n        this._placeholderGroupsIdx += 1;\n        couldSkipThisPlaceholder = true;\n      } else if (fwd === false && this._placeholderGroupsIdx > 0) {\n        this._placeholderGroupsIdx -= 1;\n        couldSkipThisPlaceholder = true;\n      } else {\n        // the selection of the current placeholder might\n        // not acurate any more -> simply restore it\n      }\n      var newSelections = this._editor.getModel().changeDecorations(function (accessor) {\n        var activePlaceholders = new Set();\n        // change stickiness to always grow when typing at its edges\n        // because these decorations represent the currently active\n        // tabstop.\n        // Special case #1: reaching the final tabstop\n        // Special case #2: placeholders enclosing active placeholders\n        var selections = [];\n        var _iterator3 = _createForOfIteratorHelper(_this2._placeholderGroups[_this2._placeholderGroupsIdx]),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _placeholder = _step3.value;\n            var _id = _this2._placeholderDecorations.get(_placeholder);\n            var _range = _this2._editor.getModel().getDecorationRange(_id);\n            selections.push(new Selection(_range.startLineNumber, _range.startColumn, _range.endLineNumber, _range.endColumn));\n            // consider to skip this placeholder index when the decoration\n            // range is empty but when the placeholder wasn't. that's a strong\n            // hint that the placeholder has been deleted. (all placeholder must match this)\n            couldSkipThisPlaceholder = couldSkipThisPlaceholder && _this2._hasPlaceholderBeenCollapsed(_placeholder);\n            accessor.changeDecorationOptions(_id, _placeholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n            activePlaceholders.add(_placeholder);\n            var _iterator5 = _createForOfIteratorHelper(_this2._snippet.enclosingPlaceholders(_placeholder)),\n              _step5;\n            try {\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                var enclosingPlaceholder = _step5.value;\n                var _id2 = _this2._placeholderDecorations.get(enclosingPlaceholder);\n                accessor.changeDecorationOptions(_id2, enclosingPlaceholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n                activePlaceholders.add(enclosingPlaceholder);\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n          }\n          // change stickness to never grow when typing at its edges\n          // so that in-active tabstops never grow\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        var _iterator4 = _createForOfIteratorHelper(_this2._placeholderDecorations),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _step4$value = _slicedToArray(_step4.value, 2),\n              _placeholder2 = _step4$value[0],\n              _id3 = _step4$value[1];\n            if (!activePlaceholders.has(_placeholder2)) {\n              accessor.changeDecorationOptions(_id3, _placeholder2.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive);\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n        return selections;\n      });\n      return !couldSkipThisPlaceholder ? newSelections !== null && newSelections !== void 0 ? newSelections : [] : this.move(fwd);\n    }\n  }, {\n    key: \"_hasPlaceholderBeenCollapsed\",\n    value: function _hasPlaceholderBeenCollapsed(placeholder) {\n      // A placeholder is empty when it wasn't empty when authored but\n      // when its tracking decoration is empty. This also applies to all\n      // potential parent placeholders\n      var marker = placeholder;\n      while (marker) {\n        if (marker instanceof Placeholder) {\n          var id = this._placeholderDecorations.get(marker);\n          var range = this._editor.getModel().getDecorationRange(id);\n          if (range.isEmpty() && marker.toString().length > 0) {\n            return true;\n          }\n        }\n        marker = marker.parent;\n      }\n      return false;\n    }\n  }, {\n    key: \"isAtFirstPlaceholder\",\n    get: function get() {\n      return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;\n    }\n  }, {\n    key: \"isAtLastPlaceholder\",\n    get: function get() {\n      return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;\n    }\n  }, {\n    key: \"hasPlaceholder\",\n    get: function get() {\n      return this._snippet.placeholders.length > 0;\n    }\n    /**\n     * A snippet is trivial when it has no placeholder or only a final placeholder at\n     * its very end\n     */\n  }, {\n    key: \"isTrivialSnippet\",\n    get: function get() {\n      if (this._snippet.placeholders.length === 0) {\n        return true;\n      }\n      if (this._snippet.placeholders.length === 1) {\n        var _this$_snippet$placeh = _slicedToArray(this._snippet.placeholders, 1),\n          placeholder = _this$_snippet$placeh[0];\n        if (placeholder.isFinalTabstop) {\n          if (this._snippet.rightMostDescendant === placeholder) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"computePossibleSelections\",\n    value: function computePossibleSelections() {\n      var result = new Map();\n      var _iterator6 = _createForOfIteratorHelper(this._placeholderGroups),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var placeholdersWithEqualIndex = _step6.value;\n          var ranges = void 0;\n          var _iterator7 = _createForOfIteratorHelper(placeholdersWithEqualIndex),\n            _step7;\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var placeholder = _step7.value;\n              if (placeholder.isFinalTabstop) {\n                // ignore those\n                break;\n              }\n              if (!ranges) {\n                ranges = [];\n                result.set(placeholder.index, ranges);\n              }\n              var id = this._placeholderDecorations.get(placeholder);\n              var range = this._editor.getModel().getDecorationRange(id);\n              if (!range) {\n                // one of the placeholder lost its decoration and\n                // therefore we bail out and pretend the placeholder\n                // (with its mirrors) doesn't exist anymore.\n                result[\"delete\"](placeholder.index);\n                break;\n              }\n              ranges.push(range);\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      return result;\n    }\n  }, {\n    key: \"activeChoice\",\n    get: function get() {\n      if (!this._placeholderDecorations) {\n        return undefined;\n      }\n      var placeholder = this._placeholderGroups[this._placeholderGroupsIdx][0];\n      if (!(placeholder === null || placeholder === void 0 ? void 0 : placeholder.choice)) {\n        return undefined;\n      }\n      var id = this._placeholderDecorations.get(placeholder);\n      if (!id) {\n        return undefined;\n      }\n      var range = this._editor.getModel().getDecorationRange(id);\n      if (!range) {\n        return undefined;\n      }\n      return {\n        range: range,\n        choice: placeholder.choice\n      };\n    }\n  }, {\n    key: \"hasChoice\",\n    get: function get() {\n      var result = false;\n      this._snippet.walk(function (marker) {\n        result = marker instanceof Choice;\n        return !result;\n      });\n      return result;\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(others) {\n      var _this3 = this;\n      var model = this._editor.getModel();\n      this._nestingLevel *= 10;\n      this._editor.changeDecorations(function (accessor) {\n        // For each active placeholder take one snippet and merge it\n        // in that the placeholder (can be many for `$1foo$1foo`). Because\n        // everything is sorted by editor selection we can simply remove\n        // elements from the beginning of the array\n        var _iterator8 = _createForOfIteratorHelper(_this3._placeholderGroups[_this3._placeholderGroupsIdx]),\n          _step8;\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var placeholder = _step8.value;\n            var nested = others.shift();\n            console.assert(nested._offset !== -1);\n            console.assert(!nested._placeholderDecorations);\n            // Massage placeholder-indicies of the nested snippet to be\n            // sorted right after the insertion point. This ensures we move\n            // through the placeholders in the correct order\n            var indexLastPlaceholder = nested._snippet.placeholderInfo.last.index;\n            var _iterator9 = _createForOfIteratorHelper(nested._snippet.placeholderInfo.all),\n              _step9;\n            try {\n              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                var nestedPlaceholder = _step9.value;\n                if (nestedPlaceholder.isFinalTabstop) {\n                  nestedPlaceholder.index = placeholder.index + (indexLastPlaceholder + 1) / _this3._nestingLevel;\n                } else {\n                  nestedPlaceholder.index = placeholder.index + nestedPlaceholder.index / _this3._nestingLevel;\n                }\n              }\n            } catch (err) {\n              _iterator9.e(err);\n            } finally {\n              _iterator9.f();\n            }\n            _this3._snippet.replace(placeholder, nested._snippet.children);\n            // Remove the placeholder at which position are inserting\n            // the snippet and also remove its decoration.\n            var id = _this3._placeholderDecorations.get(placeholder);\n            accessor.removeDecoration(id);\n            _this3._placeholderDecorations[\"delete\"](placeholder);\n            // For each *new* placeholder we create decoration to monitor\n            // how and if it grows/shrinks.\n            var _iterator10 = _createForOfIteratorHelper(nested._snippet.placeholders),\n              _step10;\n            try {\n              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                var _placeholder3 = _step10.value;\n                var placeholderOffset = nested._snippet.offset(_placeholder3);\n                var placeholderLen = nested._snippet.fullLen(_placeholder3);\n                var range = Range.fromPositions(model.getPositionAt(nested._offset + placeholderOffset), model.getPositionAt(nested._offset + placeholderOffset + placeholderLen));\n                var handle = accessor.addDecoration(range, OneSnippet._decor.inactive);\n                _this3._placeholderDecorations.set(_placeholder3, handle);\n              }\n            } catch (err) {\n              _iterator10.e(err);\n            } finally {\n              _iterator10.f();\n            }\n          }\n          // Last, re-create the placeholder groups by sorting placeholders by their index.\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n        _this3._placeholderGroups = groupBy(_this3._snippet.placeholders, Placeholder.compareByIndex);\n      });\n    }\n  }]);\n}();\nOneSnippet._decor = {\n  active: ModelDecorationOptions.register({\n    description: 'snippet-placeholder-1',\n    stickiness: 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */,\n    className: 'snippet-placeholder'\n  }),\n  inactive: ModelDecorationOptions.register({\n    description: 'snippet-placeholder-2',\n    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */,\n    className: 'snippet-placeholder'\n  }),\n  activeFinal: ModelDecorationOptions.register({\n    description: 'snippet-placeholder-3',\n    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */,\n    className: 'finish-snippet-placeholder'\n  }),\n  inactiveFinal: ModelDecorationOptions.register({\n    description: 'snippet-placeholder-4',\n    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */,\n    className: 'finish-snippet-placeholder'\n  })\n};\nvar _defaultOptions = {\n  overwriteBefore: 0,\n  overwriteAfter: 0,\n  adjustWhitespace: true,\n  clipboardText: undefined,\n  overtypingCapturer: undefined\n};\nvar SnippetSession = SnippetSession_1 = /*#__PURE__*/function () {\n  function SnippetSession(_editor, _template) {\n    var _options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _defaultOptions;\n    var _languageConfigurationService = arguments.length > 3 ? arguments[3] : undefined;\n    _classCallCheck(this, SnippetSession);\n    this._editor = _editor;\n    this._template = _template;\n    this._options = _options;\n    this._languageConfigurationService = _languageConfigurationService;\n    this._templateMerges = [];\n    this._snippets = [];\n  }\n  return _createClass(SnippetSession, [{\n    key: \"dispose\",\n    value: function dispose() {\n      _dispose(this._snippets);\n    }\n  }, {\n    key: \"_logInfo\",\n    value: function _logInfo() {\n      return \"template=\\\"\".concat(this._template, \"\\\", merged_templates=\\\"\").concat(this._templateMerges.join(' -> '), \"\\\"\");\n    }\n  }, {\n    key: \"insert\",\n    value: function insert() {\n      var _this4 = this;\n      if (!this._editor.hasModel()) {\n        return;\n      }\n      // make insert edit and start with first selections\n      var _ref = typeof this._template === 'string' ? SnippetSession_1.createEditsAndSnippetsFromSelections(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService) : SnippetSession_1.createEditsAndSnippetsFromEdits(this._editor, this._template, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService),\n        edits = _ref.edits,\n        snippets = _ref.snippets;\n      this._snippets = snippets;\n      this._editor.executeEdits('snippet', edits, function (_undoEdits) {\n        // Sometimes, the text buffer will remove automatic whitespace when doing any edits,\n        // so we need to look only at the undo edits relevant for us.\n        // Our edits have an identifier set so that's how we can distinguish them\n        var undoEdits = _undoEdits.filter(function (edit) {\n          return !!edit.identifier;\n        });\n        for (var idx = 0; idx < snippets.length; idx++) {\n          snippets[idx].initialize(undoEdits[idx].textChange);\n        }\n        if (_this4._snippets[0].hasPlaceholder) {\n          return _this4._move(true);\n        } else {\n          return undoEdits.map(function (edit) {\n            return Selection.fromPositions(edit.range.getEndPosition());\n          });\n        }\n      });\n      this._editor.revealRange(this._editor.getSelections()[0]);\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(template) {\n      var _this5 = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultOptions;\n      if (!this._editor.hasModel()) {\n        return;\n      }\n      this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, template]);\n      var _SnippetSession_1$cre = SnippetSession_1.createEditsAndSnippetsFromSelections(this._editor, template, options.overwriteBefore, options.overwriteAfter, true, options.adjustWhitespace, options.clipboardText, options.overtypingCapturer, this._languageConfigurationService),\n        edits = _SnippetSession_1$cre.edits,\n        snippets = _SnippetSession_1$cre.snippets;\n      this._editor.executeEdits('snippet', edits, function (_undoEdits) {\n        // Sometimes, the text buffer will remove automatic whitespace when doing any edits,\n        // so we need to look only at the undo edits relevant for us.\n        // Our edits have an identifier set so that's how we can distinguish them\n        var undoEdits = _undoEdits.filter(function (edit) {\n          return !!edit.identifier;\n        });\n        for (var idx = 0; idx < snippets.length; idx++) {\n          snippets[idx].initialize(undoEdits[idx].textChange);\n        }\n        // Trivial snippets have no placeholder or are just the final placeholder. That means they\n        // are just text insertions and we don't need to merge the nested snippet into the existing\n        // snippet\n        var isTrivialSnippet = snippets[0].isTrivialSnippet;\n        if (!isTrivialSnippet) {\n          var _iterator11 = _createForOfIteratorHelper(_this5._snippets),\n            _step11;\n          try {\n            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n              var snippet = _step11.value;\n              snippet.merge(snippets);\n            }\n          } catch (err) {\n            _iterator11.e(err);\n          } finally {\n            _iterator11.f();\n          }\n          console.assert(snippets.length === 0);\n        }\n        if (_this5._snippets[0].hasPlaceholder && !isTrivialSnippet) {\n          return _this5._move(undefined);\n        } else {\n          return undoEdits.map(function (edit) {\n            return Selection.fromPositions(edit.range.getEndPosition());\n          });\n        }\n      });\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      var newSelections = this._move(true);\n      this._editor.setSelections(newSelections);\n      this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n    }\n  }, {\n    key: \"prev\",\n    value: function prev() {\n      var newSelections = this._move(false);\n      this._editor.setSelections(newSelections);\n      this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n    }\n  }, {\n    key: \"_move\",\n    value: function _move(fwd) {\n      var selections = [];\n      var _iterator12 = _createForOfIteratorHelper(this._snippets),\n        _step12;\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var snippet = _step12.value;\n          var oneSelection = snippet.move(fwd);\n          selections.push.apply(selections, _toConsumableArray(oneSelection));\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n      return selections;\n    }\n  }, {\n    key: \"isAtFirstPlaceholder\",\n    get: function get() {\n      return this._snippets[0].isAtFirstPlaceholder;\n    }\n  }, {\n    key: \"isAtLastPlaceholder\",\n    get: function get() {\n      return this._snippets[0].isAtLastPlaceholder;\n    }\n  }, {\n    key: \"hasPlaceholder\",\n    get: function get() {\n      return this._snippets[0].hasPlaceholder;\n    }\n  }, {\n    key: \"hasChoice\",\n    get: function get() {\n      return this._snippets[0].hasChoice;\n    }\n  }, {\n    key: \"activeChoice\",\n    get: function get() {\n      return this._snippets[0].activeChoice;\n    }\n  }, {\n    key: \"isSelectionWithinPlaceholders\",\n    value: function isSelectionWithinPlaceholders() {\n      if (!this.hasPlaceholder) {\n        return false;\n      }\n      var selections = this._editor.getSelections();\n      if (selections.length < this._snippets.length) {\n        // this means we started snippet mode with N\n        // selections and have M (N > M) selections.\n        // So one snippet is without selection -> cancel\n        return false;\n      }\n      var allPossibleSelections = new Map();\n      var _iterator13 = _createForOfIteratorHelper(this._snippets),\n        _step13;\n      try {\n        var _loop = function _loop() {\n            var snippet = _step13.value;\n            var possibleSelections = snippet.computePossibleSelections();\n            // for the first snippet find the placeholder (and its ranges)\n            // that contain at least one selection. for all remaining snippets\n            // the same placeholder (and their ranges) must be used.\n            if (allPossibleSelections.size === 0) {\n              var _iterator15 = _createForOfIteratorHelper(possibleSelections),\n                _step15;\n              try {\n                for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n                  var _step15$value = _slicedToArray(_step15.value, 2),\n                    index = _step15$value[0],\n                    ranges = _step15$value[1];\n                  ranges.sort(Range.compareRangesUsingStarts);\n                  var _iterator16 = _createForOfIteratorHelper(selections),\n                    _step16;\n                  try {\n                    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n                      var selection = _step16.value;\n                      if (ranges[0].containsRange(selection)) {\n                        allPossibleSelections.set(index, []);\n                        break;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator16.e(err);\n                  } finally {\n                    _iterator16.f();\n                  }\n                }\n              } catch (err) {\n                _iterator15.e(err);\n              } finally {\n                _iterator15.f();\n              }\n            }\n            if (allPossibleSelections.size === 0) {\n              // return false if we couldn't associate a selection to\n              // this (the first) snippet\n              return {\n                v: false\n              };\n            }\n            // add selections from 'this' snippet so that we know all\n            // selections for this placeholder\n            allPossibleSelections.forEach(function (array, index) {\n              array.push.apply(array, _toConsumableArray(possibleSelections.get(index)));\n            });\n          },\n          _ret;\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          _ret = _loop();\n          if (_ret) return _ret.v;\n        }\n        // sort selections (and later placeholder-ranges). then walk both\n        // arrays and make sure the placeholder-ranges contain the corresponding\n        // selection\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n      selections.sort(Range.compareRangesUsingStarts);\n      var _iterator14 = _createForOfIteratorHelper(allPossibleSelections),\n        _step14;\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var _step14$value = _slicedToArray(_step14.value, 2),\n            index = _step14$value[0],\n            ranges = _step14$value[1];\n          if (ranges.length !== selections.length) {\n            allPossibleSelections[\"delete\"](index);\n            continue;\n          }\n          ranges.sort(Range.compareRangesUsingStarts);\n          for (var i = 0; i < ranges.length; i++) {\n            if (!ranges[i].containsRange(selections[i])) {\n              allPossibleSelections[\"delete\"](index);\n              continue;\n            }\n          }\n        }\n        // from all possible selections we have deleted those\n        // that don't match with the current selection. if we don't\n        // have any left, we don't have a selection anymore\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n      return allPossibleSelections.size > 0;\n    }\n  }], [{\n    key: \"adjustWhitespace\",\n    value: function adjustWhitespace(model, position, adjustIndentation, snippet, filter) {\n      var line = model.getLineContent(position.lineNumber);\n      var lineLeadingWhitespace = getLeadingWhitespace(line, 0, position.column - 1);\n      // the snippet as inserted\n      var snippetTextString;\n      snippet.walk(function (marker) {\n        // all text elements that are not inside choice\n        if (!(marker instanceof Text) || marker.parent instanceof Choice) {\n          return true;\n        }\n        // check with filter (iff provided)\n        if (filter && !filter.has(marker)) {\n          return true;\n        }\n        var lines = marker.value.split(/\\r\\n|\\r|\\n/);\n        if (adjustIndentation) {\n          // adjust indentation of snippet test\n          // -the snippet-start doesn't get extra-indented (lineLeadingWhitespace), only normalized\n          // -all N+1 lines get extra-indented and normalized\n          // -the text start get extra-indented and normalized when following a linebreak\n          var offset = snippet.offset(marker);\n          if (offset === 0) {\n            // snippet start\n            lines[0] = model.normalizeIndentation(lines[0]);\n          } else {\n            // check if text start is after a linebreak\n            snippetTextString = snippetTextString !== null && snippetTextString !== void 0 ? snippetTextString : snippet.toString();\n            var prevChar = snippetTextString.charCodeAt(offset - 1);\n            if (prevChar === 10 /* CharCode.LineFeed */ || prevChar === 13 /* CharCode.CarriageReturn */) {\n              lines[0] = model.normalizeIndentation(lineLeadingWhitespace + lines[0]);\n            }\n          }\n          for (var i = 1; i < lines.length; i++) {\n            lines[i] = model.normalizeIndentation(lineLeadingWhitespace + lines[i]);\n          }\n        }\n        var newValue = lines.join(model.getEOL());\n        if (newValue !== marker.value) {\n          marker.parent.replace(marker, [new Text(newValue)]);\n          snippetTextString = undefined;\n        }\n        return true;\n      });\n      return lineLeadingWhitespace;\n    }\n  }, {\n    key: \"adjustSelection\",\n    value: function adjustSelection(model, selection, overwriteBefore, overwriteAfter) {\n      if (overwriteBefore !== 0 || overwriteAfter !== 0) {\n        // overwrite[Before|After] is compute using the position, not the whole\n        // selection. therefore we adjust the selection around that position\n        var _selection = selection,\n          positionLineNumber = _selection.positionLineNumber,\n          positionColumn = _selection.positionColumn;\n        var positionColumnBefore = positionColumn - overwriteBefore;\n        var positionColumnAfter = positionColumn + overwriteAfter;\n        var range = model.validateRange({\n          startLineNumber: positionLineNumber,\n          startColumn: positionColumnBefore,\n          endLineNumber: positionLineNumber,\n          endColumn: positionColumnAfter\n        });\n        selection = Selection.createWithDirection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn, selection.getDirection());\n      }\n      return selection;\n    }\n  }, {\n    key: \"createEditsAndSnippetsFromSelections\",\n    value: function createEditsAndSnippetsFromSelections(editor, template, overwriteBefore, overwriteAfter, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer, languageConfigurationService) {\n      var edits = [];\n      var snippets = [];\n      if (!editor.hasModel()) {\n        return {\n          edits: edits,\n          snippets: snippets\n        };\n      }\n      var model = editor.getModel();\n      var workspaceService = editor.invokeWithinContext(function (accessor) {\n        return accessor.get(IWorkspaceContextService);\n      });\n      var modelBasedVariableResolver = editor.invokeWithinContext(function (accessor) {\n        return new ModelBasedVariableResolver(accessor.get(ILabelService), model);\n      });\n      var readClipboardText = function readClipboardText() {\n        return clipboardText;\n      };\n      // know what text the overwrite[Before|After] extensions\n      // of the primary curser have selected because only when\n      // secondary selections extend to the same text we can grow them\n      var firstBeforeText = model.getValueInRange(SnippetSession_1.adjustSelection(model, editor.getSelection(), overwriteBefore, 0));\n      var firstAfterText = model.getValueInRange(SnippetSession_1.adjustSelection(model, editor.getSelection(), 0, overwriteAfter));\n      // remember the first non-whitespace column to decide if\n      // `keepWhitespace` should be overruled for secondary selections\n      var firstLineFirstNonWhitespace = model.getLineFirstNonWhitespaceColumn(editor.getSelection().positionLineNumber);\n      // sort selections by their start position but remeber\n      // the original index. that allows you to create correct\n      // offset-based selection logic without changing the\n      // primary selection\n      var indexedSelections = editor.getSelections().map(function (selection, idx) {\n        return {\n          selection: selection,\n          idx: idx\n        };\n      }).sort(function (a, b) {\n        return Range.compareRangesUsingStarts(a.selection, b.selection);\n      });\n      var _iterator17 = _createForOfIteratorHelper(indexedSelections),\n        _step17;\n      try {\n        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n          var _step17$value = _step17.value,\n            selection = _step17$value.selection,\n            idx = _step17$value.idx;\n          // extend selection with the `overwriteBefore` and `overwriteAfter` and then\n          // compare if this matches the extensions of the primary selection\n          var extensionBefore = SnippetSession_1.adjustSelection(model, selection, overwriteBefore, 0);\n          var extensionAfter = SnippetSession_1.adjustSelection(model, selection, 0, overwriteAfter);\n          if (firstBeforeText !== model.getValueInRange(extensionBefore)) {\n            extensionBefore = selection;\n          }\n          if (firstAfterText !== model.getValueInRange(extensionAfter)) {\n            extensionAfter = selection;\n          }\n          // merge the before and after selection into one\n          var snippetSelection = selection.setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn).setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);\n          var snippet = new SnippetParser().parse(template, true, enforceFinalTabstop);\n          // adjust the template string to match the indentation and\n          // whitespace rules of this insert location (can be different for each cursor)\n          // happens when being asked for (default) or when this is a secondary\n          // cursor and the leading whitespace is different\n          var start = snippetSelection.getStartPosition();\n          var snippetLineLeadingWhitespace = SnippetSession_1.adjustWhitespace(model, start, adjustWhitespace || idx > 0 && firstLineFirstNonWhitespace !== model.getLineFirstNonWhitespaceColumn(selection.positionLineNumber), snippet);\n          snippet.resolveVariables(new CompositeSnippetVariableResolver([modelBasedVariableResolver, new ClipboardBasedVariableResolver(readClipboardText, idx, indexedSelections.length, editor.getOption(79 /* EditorOption.multiCursorPaste */) === 'spread'), new SelectionBasedVariableResolver(model, selection, idx, overtypingCapturer), new CommentBasedVariableResolver(model, selection, languageConfigurationService), new TimeBasedVariableResolver(), new WorkspaceBasedVariableResolver(workspaceService), new RandomBasedVariableResolver()]));\n          // store snippets with the index of their originating selection.\n          // that ensures the primiary cursor stays primary despite not being\n          // the one with lowest start position\n          edits[idx] = EditOperation.replace(snippetSelection, snippet.toString());\n          edits[idx].identifier = {\n            major: idx,\n            minor: 0\n          }; // mark the edit so only our undo edits will be used to generate end cursors\n          edits[idx]._isTracked = true;\n          snippets[idx] = new OneSnippet(editor, snippet, snippetLineLeadingWhitespace);\n        }\n      } catch (err) {\n        _iterator17.e(err);\n      } finally {\n        _iterator17.f();\n      }\n      return {\n        edits: edits,\n        snippets: snippets\n      };\n    }\n  }, {\n    key: \"createEditsAndSnippetsFromEdits\",\n    value: function createEditsAndSnippetsFromEdits(editor, snippetEdits, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer, languageConfigurationService) {\n      if (!editor.hasModel() || snippetEdits.length === 0) {\n        return {\n          edits: [],\n          snippets: []\n        };\n      }\n      var edits = [];\n      var model = editor.getModel();\n      var parser = new SnippetParser();\n      var snippet = new TextmateSnippet();\n      // snippet variables resolver\n      var resolver = new CompositeSnippetVariableResolver([editor.invokeWithinContext(function (accessor) {\n        return new ModelBasedVariableResolver(accessor.get(ILabelService), model);\n      }), new ClipboardBasedVariableResolver(function () {\n        return clipboardText;\n      }, 0, editor.getSelections().length, editor.getOption(79 /* EditorOption.multiCursorPaste */) === 'spread'), new SelectionBasedVariableResolver(model, editor.getSelection(), 0, overtypingCapturer), new CommentBasedVariableResolver(model, editor.getSelection(), languageConfigurationService), new TimeBasedVariableResolver(), new WorkspaceBasedVariableResolver(editor.invokeWithinContext(function (accessor) {\n        return accessor.get(IWorkspaceContextService);\n      })), new RandomBasedVariableResolver()]);\n      //\n      snippetEdits = snippetEdits.sort(function (a, b) {\n        return Range.compareRangesUsingStarts(a.range, b.range);\n      });\n      var offset = 0;\n      for (var i = 0; i < snippetEdits.length; i++) {\n        var _snippetEdits$i = snippetEdits[i],\n          range = _snippetEdits$i.range,\n          template = _snippetEdits$i.template;\n        // gaps between snippet edits are appended as text nodes. this\n        // ensures placeholder-offsets are later correct\n        if (i > 0) {\n          var lastRange = snippetEdits[i - 1].range;\n          var textRange = Range.fromPositions(lastRange.getEndPosition(), range.getStartPosition());\n          var textNode = new Text(model.getValueInRange(textRange));\n          snippet.appendChild(textNode);\n          offset += textNode.value.length;\n        }\n        var newNodes = parser.parseFragment(template, snippet);\n        SnippetSession_1.adjustWhitespace(model, range.getStartPosition(), true, snippet, new Set(newNodes));\n        snippet.resolveVariables(resolver);\n        var snippetText = snippet.toString();\n        var snippetFragmentText = snippetText.slice(offset);\n        offset = snippetText.length;\n        // make edit\n        var edit = EditOperation.replace(range, snippetFragmentText);\n        edit.identifier = {\n          major: i,\n          minor: 0\n        }; // mark the edit so only our undo edits will be used to generate end cursors\n        edit._isTracked = true;\n        edits.push(edit);\n      }\n      //\n      parser.ensureFinalTabstop(snippet, enforceFinalTabstop, true);\n      return {\n        edits: edits,\n        snippets: [new OneSnippet(editor, snippet, '')]\n      };\n    }\n  }]);\n}();\nSnippetSession = SnippetSession_1 = __decorate([__param(3, ILanguageConfigurationService)], SnippetSession);\nexport { SnippetSession };","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","_typeof","decorate","i","defineProperty","__param","paramIndex","decorator","SnippetSession_1","groupBy","dispose","getLeadingWhitespace","EditOperation","Range","Selection","ILanguageConfigurationService","ModelDecorationOptions","ILabelService","IWorkspaceContextService","Choice","Placeholder","SnippetParser","Text","TextmateSnippet","ClipboardBasedVariableResolver","CommentBasedVariableResolver","CompositeSnippetVariableResolver","ModelBasedVariableResolver","RandomBasedVariableResolver","SelectionBasedVariableResolver","TimeBasedVariableResolver","WorkspaceBasedVariableResolver","OneSnippet","_editor","_snippet","_snippetLineLeadingWhitespace","_classCallCheck","_offset","_nestingLevel","_placeholderGroups","placeholders","compareByIndex","_placeholderGroupsIdx","_createClass","value","initialize","textChange","newPosition","_placeholderDecorations","removeDecorations","_toConsumableArray","values","_initDecorations","_this","Error","Map","model","getModel","changeDecorations","accessor","_iterator","_createForOfIteratorHelper","_step","s","n","done","placeholder","placeholderOffset","offset","placeholderLen","fullLen","range","fromPositions","getPositionAt","options","isFinalTabstop","_decor","inactiveFinal","inactive","handle","addDecoration","set","err","e","f","move","fwd","_this2","hasModel","operations","_iterator2","_step2","transform","id","get","getDecorationRange","currentValue","getValueInRange","transformedValueLines","resolve","split","normalizeIndentation","push","replace","join","getEOL","executeEdits","couldSkipThisPlaceholder","newSelections","activePlaceholders","Set","selections","_iterator3","_step3","startLineNumber","startColumn","endLineNumber","endColumn","_hasPlaceholderBeenCollapsed","changeDecorationOptions","activeFinal","active","add","_iterator5","enclosingPlaceholders","_step5","enclosingPlaceholder","_iterator4","_step4","_step4$value","_slicedToArray","has","marker","isEmpty","toString","parent","_this$_snippet$placeh","rightMostDescendant","computePossibleSelections","result","_iterator6","_step6","placeholdersWithEqualIndex","ranges","_iterator7","_step7","index","undefined","choice","walk","merge","others","_this3","_iterator8","_step8","nested","shift","console","assert","indexLastPlaceholder","placeholderInfo","last","_iterator9","all","_step9","nestedPlaceholder","children","removeDecoration","_iterator10","_step10","register","description","stickiness","className","_defaultOptions","overwriteBefore","overwriteAfter","adjustWhitespace","clipboardText","overtypingCapturer","SnippetSession","_template","_options","_languageConfigurationService","_templateMerges","_snippets","_logInfo","concat","insert","_this4","_ref","createEditsAndSnippetsFromSelections","createEditsAndSnippetsFromEdits","edits","snippets","_undoEdits","undoEdits","filter","edit","identifier","idx","hasPlaceholder","_move","map","getEndPosition","revealRange","getSelections","template","_this5","_SnippetSession_1$cre","isTrivialSnippet","_iterator11","_step11","snippet","next","setSelections","revealPositionInCenterIfOutsideViewport","getPosition","prev","_iterator12","_step12","oneSelection","apply","isAtFirstPlaceholder","isAtLastPlaceholder","hasChoice","activeChoice","isSelectionWithinPlaceholders","allPossibleSelections","_iterator13","_step13","_loop","possibleSelections","size","_iterator15","_step15","_step15$value","sort","compareRangesUsingStarts","_iterator16","_step16","selection","containsRange","v","forEach","array","_ret","_iterator14","_step14","_step14$value","position","adjustIndentation","line","getLineContent","lineNumber","lineLeadingWhitespace","column","snippetTextString","lines","prevChar","charCodeAt","newValue","adjustSelection","_selection","positionLineNumber","positionColumn","positionColumnBefore","positionColumnAfter","validateRange","createWithDirection","getDirection","editor","enforceFinalTabstop","languageConfigurationService","workspaceService","invokeWithinContext","modelBasedVariableResolver","readClipboardText","firstBeforeText","getSelection","firstAfterText","firstLineFirstNonWhitespace","getLineFirstNonWhitespaceColumn","indexedSelections","a","b","_iterator17","_step17","_step17$value","extensionBefore","extensionAfter","snippetSelection","setStartPosition","setEndPosition","parse","start","getStartPosition","snippetLineLeadingWhitespace","resolveVariables","getOption","major","minor","_isTracked","snippetEdits","parser","resolver","_snippetEdits$i","lastRange","textRange","textNode","appendChild","newNodes","parseFragment","snippetText","snippetFragmentText","slice","ensureFinalTabstop"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetSession.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar SnippetSession_1;\nimport { groupBy } from '../../../../base/common/arrays.js';\nimport { dispose } from '../../../../base/common/lifecycle.js';\nimport { getLeadingWhitespace } from '../../../../base/common/strings.js';\nimport './snippetSession.css';\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport { ModelDecorationOptions } from '../../../common/model/textModel.js';\nimport { ILabelService } from '../../../../platform/label/common/label.js';\nimport { IWorkspaceContextService } from '../../../../platform/workspace/common/workspace.js';\nimport { Choice, Placeholder, SnippetParser, Text, TextmateSnippet } from './snippetParser.js';\nimport { ClipboardBasedVariableResolver, CommentBasedVariableResolver, CompositeSnippetVariableResolver, ModelBasedVariableResolver, RandomBasedVariableResolver, SelectionBasedVariableResolver, TimeBasedVariableResolver, WorkspaceBasedVariableResolver } from './snippetVariables.js';\nexport class OneSnippet {\n    constructor(_editor, _snippet, _snippetLineLeadingWhitespace) {\n        this._editor = _editor;\n        this._snippet = _snippet;\n        this._snippetLineLeadingWhitespace = _snippetLineLeadingWhitespace;\n        this._offset = -1;\n        this._nestingLevel = 1;\n        this._placeholderGroups = groupBy(_snippet.placeholders, Placeholder.compareByIndex);\n        this._placeholderGroupsIdx = -1;\n    }\n    initialize(textChange) {\n        this._offset = textChange.newPosition;\n    }\n    dispose() {\n        if (this._placeholderDecorations) {\n            this._editor.removeDecorations([...this._placeholderDecorations.values()]);\n        }\n        this._placeholderGroups.length = 0;\n    }\n    _initDecorations() {\n        if (this._offset === -1) {\n            throw new Error(`Snippet not initialized!`);\n        }\n        if (this._placeholderDecorations) {\n            // already initialized\n            return;\n        }\n        this._placeholderDecorations = new Map();\n        const model = this._editor.getModel();\n        this._editor.changeDecorations(accessor => {\n            // create a decoration for each placeholder\n            for (const placeholder of this._snippet.placeholders) {\n                const placeholderOffset = this._snippet.offset(placeholder);\n                const placeholderLen = this._snippet.fullLen(placeholder);\n                const range = Range.fromPositions(model.getPositionAt(this._offset + placeholderOffset), model.getPositionAt(this._offset + placeholderOffset + placeholderLen));\n                const options = placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive;\n                const handle = accessor.addDecoration(range, options);\n                this._placeholderDecorations.set(placeholder, handle);\n            }\n        });\n    }\n    move(fwd) {\n        if (!this._editor.hasModel()) {\n            return [];\n        }\n        this._initDecorations();\n        // Transform placeholder text if necessary\n        if (this._placeholderGroupsIdx >= 0) {\n            const operations = [];\n            for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n                // Check if the placeholder has a transformation\n                if (placeholder.transform) {\n                    const id = this._placeholderDecorations.get(placeholder);\n                    const range = this._editor.getModel().getDecorationRange(id);\n                    const currentValue = this._editor.getModel().getValueInRange(range);\n                    const transformedValueLines = placeholder.transform.resolve(currentValue).split(/\\r\\n|\\r|\\n/);\n                    // fix indentation for transformed lines\n                    for (let i = 1; i < transformedValueLines.length; i++) {\n                        transformedValueLines[i] = this._editor.getModel().normalizeIndentation(this._snippetLineLeadingWhitespace + transformedValueLines[i]);\n                    }\n                    operations.push(EditOperation.replace(range, transformedValueLines.join(this._editor.getModel().getEOL())));\n                }\n            }\n            if (operations.length > 0) {\n                this._editor.executeEdits('snippet.placeholderTransform', operations);\n            }\n        }\n        let couldSkipThisPlaceholder = false;\n        if (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {\n            this._placeholderGroupsIdx += 1;\n            couldSkipThisPlaceholder = true;\n        }\n        else if (fwd === false && this._placeholderGroupsIdx > 0) {\n            this._placeholderGroupsIdx -= 1;\n            couldSkipThisPlaceholder = true;\n        }\n        else {\n            // the selection of the current placeholder might\n            // not acurate any more -> simply restore it\n        }\n        const newSelections = this._editor.getModel().changeDecorations(accessor => {\n            const activePlaceholders = new Set();\n            // change stickiness to always grow when typing at its edges\n            // because these decorations represent the currently active\n            // tabstop.\n            // Special case #1: reaching the final tabstop\n            // Special case #2: placeholders enclosing active placeholders\n            const selections = [];\n            for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n                const id = this._placeholderDecorations.get(placeholder);\n                const range = this._editor.getModel().getDecorationRange(id);\n                selections.push(new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn));\n                // consider to skip this placeholder index when the decoration\n                // range is empty but when the placeholder wasn't. that's a strong\n                // hint that the placeholder has been deleted. (all placeholder must match this)\n                couldSkipThisPlaceholder = couldSkipThisPlaceholder && this._hasPlaceholderBeenCollapsed(placeholder);\n                accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n                activePlaceholders.add(placeholder);\n                for (const enclosingPlaceholder of this._snippet.enclosingPlaceholders(placeholder)) {\n                    const id = this._placeholderDecorations.get(enclosingPlaceholder);\n                    accessor.changeDecorationOptions(id, enclosingPlaceholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);\n                    activePlaceholders.add(enclosingPlaceholder);\n                }\n            }\n            // change stickness to never grow when typing at its edges\n            // so that in-active tabstops never grow\n            for (const [placeholder, id] of this._placeholderDecorations) {\n                if (!activePlaceholders.has(placeholder)) {\n                    accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive);\n                }\n            }\n            return selections;\n        });\n        return !couldSkipThisPlaceholder ? newSelections !== null && newSelections !== void 0 ? newSelections : [] : this.move(fwd);\n    }\n    _hasPlaceholderBeenCollapsed(placeholder) {\n        // A placeholder is empty when it wasn't empty when authored but\n        // when its tracking decoration is empty. This also applies to all\n        // potential parent placeholders\n        let marker = placeholder;\n        while (marker) {\n            if (marker instanceof Placeholder) {\n                const id = this._placeholderDecorations.get(marker);\n                const range = this._editor.getModel().getDecorationRange(id);\n                if (range.isEmpty() && marker.toString().length > 0) {\n                    return true;\n                }\n            }\n            marker = marker.parent;\n        }\n        return false;\n    }\n    get isAtFirstPlaceholder() {\n        return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;\n    }\n    get isAtLastPlaceholder() {\n        return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;\n    }\n    get hasPlaceholder() {\n        return this._snippet.placeholders.length > 0;\n    }\n    /**\n     * A snippet is trivial when it has no placeholder or only a final placeholder at\n     * its very end\n     */\n    get isTrivialSnippet() {\n        if (this._snippet.placeholders.length === 0) {\n            return true;\n        }\n        if (this._snippet.placeholders.length === 1) {\n            const [placeholder] = this._snippet.placeholders;\n            if (placeholder.isFinalTabstop) {\n                if (this._snippet.rightMostDescendant === placeholder) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    computePossibleSelections() {\n        const result = new Map();\n        for (const placeholdersWithEqualIndex of this._placeholderGroups) {\n            let ranges;\n            for (const placeholder of placeholdersWithEqualIndex) {\n                if (placeholder.isFinalTabstop) {\n                    // ignore those\n                    break;\n                }\n                if (!ranges) {\n                    ranges = [];\n                    result.set(placeholder.index, ranges);\n                }\n                const id = this._placeholderDecorations.get(placeholder);\n                const range = this._editor.getModel().getDecorationRange(id);\n                if (!range) {\n                    // one of the placeholder lost its decoration and\n                    // therefore we bail out and pretend the placeholder\n                    // (with its mirrors) doesn't exist anymore.\n                    result.delete(placeholder.index);\n                    break;\n                }\n                ranges.push(range);\n            }\n        }\n        return result;\n    }\n    get activeChoice() {\n        if (!this._placeholderDecorations) {\n            return undefined;\n        }\n        const placeholder = this._placeholderGroups[this._placeholderGroupsIdx][0];\n        if (!(placeholder === null || placeholder === void 0 ? void 0 : placeholder.choice)) {\n            return undefined;\n        }\n        const id = this._placeholderDecorations.get(placeholder);\n        if (!id) {\n            return undefined;\n        }\n        const range = this._editor.getModel().getDecorationRange(id);\n        if (!range) {\n            return undefined;\n        }\n        return { range, choice: placeholder.choice };\n    }\n    get hasChoice() {\n        let result = false;\n        this._snippet.walk(marker => {\n            result = marker instanceof Choice;\n            return !result;\n        });\n        return result;\n    }\n    merge(others) {\n        const model = this._editor.getModel();\n        this._nestingLevel *= 10;\n        this._editor.changeDecorations(accessor => {\n            // For each active placeholder take one snippet and merge it\n            // in that the placeholder (can be many for `$1foo$1foo`). Because\n            // everything is sorted by editor selection we can simply remove\n            // elements from the beginning of the array\n            for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\n                const nested = others.shift();\n                console.assert(nested._offset !== -1);\n                console.assert(!nested._placeholderDecorations);\n                // Massage placeholder-indicies of the nested snippet to be\n                // sorted right after the insertion point. This ensures we move\n                // through the placeholders in the correct order\n                const indexLastPlaceholder = nested._snippet.placeholderInfo.last.index;\n                for (const nestedPlaceholder of nested._snippet.placeholderInfo.all) {\n                    if (nestedPlaceholder.isFinalTabstop) {\n                        nestedPlaceholder.index = placeholder.index + ((indexLastPlaceholder + 1) / this._nestingLevel);\n                    }\n                    else {\n                        nestedPlaceholder.index = placeholder.index + (nestedPlaceholder.index / this._nestingLevel);\n                    }\n                }\n                this._snippet.replace(placeholder, nested._snippet.children);\n                // Remove the placeholder at which position are inserting\n                // the snippet and also remove its decoration.\n                const id = this._placeholderDecorations.get(placeholder);\n                accessor.removeDecoration(id);\n                this._placeholderDecorations.delete(placeholder);\n                // For each *new* placeholder we create decoration to monitor\n                // how and if it grows/shrinks.\n                for (const placeholder of nested._snippet.placeholders) {\n                    const placeholderOffset = nested._snippet.offset(placeholder);\n                    const placeholderLen = nested._snippet.fullLen(placeholder);\n                    const range = Range.fromPositions(model.getPositionAt(nested._offset + placeholderOffset), model.getPositionAt(nested._offset + placeholderOffset + placeholderLen));\n                    const handle = accessor.addDecoration(range, OneSnippet._decor.inactive);\n                    this._placeholderDecorations.set(placeholder, handle);\n                }\n            }\n            // Last, re-create the placeholder groups by sorting placeholders by their index.\n            this._placeholderGroups = groupBy(this._snippet.placeholders, Placeholder.compareByIndex);\n        });\n    }\n}\nOneSnippet._decor = {\n    active: ModelDecorationOptions.register({ description: 'snippet-placeholder-1', stickiness: 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */, className: 'snippet-placeholder' }),\n    inactive: ModelDecorationOptions.register({ description: 'snippet-placeholder-2', stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */, className: 'snippet-placeholder' }),\n    activeFinal: ModelDecorationOptions.register({ description: 'snippet-placeholder-3', stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */, className: 'finish-snippet-placeholder' }),\n    inactiveFinal: ModelDecorationOptions.register({ description: 'snippet-placeholder-4', stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */, className: 'finish-snippet-placeholder' }),\n};\nconst _defaultOptions = {\n    overwriteBefore: 0,\n    overwriteAfter: 0,\n    adjustWhitespace: true,\n    clipboardText: undefined,\n    overtypingCapturer: undefined\n};\nlet SnippetSession = SnippetSession_1 = class SnippetSession {\n    static adjustWhitespace(model, position, adjustIndentation, snippet, filter) {\n        const line = model.getLineContent(position.lineNumber);\n        const lineLeadingWhitespace = getLeadingWhitespace(line, 0, position.column - 1);\n        // the snippet as inserted\n        let snippetTextString;\n        snippet.walk(marker => {\n            // all text elements that are not inside choice\n            if (!(marker instanceof Text) || marker.parent instanceof Choice) {\n                return true;\n            }\n            // check with filter (iff provided)\n            if (filter && !filter.has(marker)) {\n                return true;\n            }\n            const lines = marker.value.split(/\\r\\n|\\r|\\n/);\n            if (adjustIndentation) {\n                // adjust indentation of snippet test\n                // -the snippet-start doesn't get extra-indented (lineLeadingWhitespace), only normalized\n                // -all N+1 lines get extra-indented and normalized\n                // -the text start get extra-indented and normalized when following a linebreak\n                const offset = snippet.offset(marker);\n                if (offset === 0) {\n                    // snippet start\n                    lines[0] = model.normalizeIndentation(lines[0]);\n                }\n                else {\n                    // check if text start is after a linebreak\n                    snippetTextString = snippetTextString !== null && snippetTextString !== void 0 ? snippetTextString : snippet.toString();\n                    const prevChar = snippetTextString.charCodeAt(offset - 1);\n                    if (prevChar === 10 /* CharCode.LineFeed */ || prevChar === 13 /* CharCode.CarriageReturn */) {\n                        lines[0] = model.normalizeIndentation(lineLeadingWhitespace + lines[0]);\n                    }\n                }\n                for (let i = 1; i < lines.length; i++) {\n                    lines[i] = model.normalizeIndentation(lineLeadingWhitespace + lines[i]);\n                }\n            }\n            const newValue = lines.join(model.getEOL());\n            if (newValue !== marker.value) {\n                marker.parent.replace(marker, [new Text(newValue)]);\n                snippetTextString = undefined;\n            }\n            return true;\n        });\n        return lineLeadingWhitespace;\n    }\n    static adjustSelection(model, selection, overwriteBefore, overwriteAfter) {\n        if (overwriteBefore !== 0 || overwriteAfter !== 0) {\n            // overwrite[Before|After] is compute using the position, not the whole\n            // selection. therefore we adjust the selection around that position\n            const { positionLineNumber, positionColumn } = selection;\n            const positionColumnBefore = positionColumn - overwriteBefore;\n            const positionColumnAfter = positionColumn + overwriteAfter;\n            const range = model.validateRange({\n                startLineNumber: positionLineNumber,\n                startColumn: positionColumnBefore,\n                endLineNumber: positionLineNumber,\n                endColumn: positionColumnAfter\n            });\n            selection = Selection.createWithDirection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn, selection.getDirection());\n        }\n        return selection;\n    }\n    static createEditsAndSnippetsFromSelections(editor, template, overwriteBefore, overwriteAfter, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer, languageConfigurationService) {\n        const edits = [];\n        const snippets = [];\n        if (!editor.hasModel()) {\n            return { edits, snippets };\n        }\n        const model = editor.getModel();\n        const workspaceService = editor.invokeWithinContext(accessor => accessor.get(IWorkspaceContextService));\n        const modelBasedVariableResolver = editor.invokeWithinContext(accessor => new ModelBasedVariableResolver(accessor.get(ILabelService), model));\n        const readClipboardText = () => clipboardText;\n        // know what text the overwrite[Before|After] extensions\n        // of the primary curser have selected because only when\n        // secondary selections extend to the same text we can grow them\n        const firstBeforeText = model.getValueInRange(SnippetSession_1.adjustSelection(model, editor.getSelection(), overwriteBefore, 0));\n        const firstAfterText = model.getValueInRange(SnippetSession_1.adjustSelection(model, editor.getSelection(), 0, overwriteAfter));\n        // remember the first non-whitespace column to decide if\n        // `keepWhitespace` should be overruled for secondary selections\n        const firstLineFirstNonWhitespace = model.getLineFirstNonWhitespaceColumn(editor.getSelection().positionLineNumber);\n        // sort selections by their start position but remeber\n        // the original index. that allows you to create correct\n        // offset-based selection logic without changing the\n        // primary selection\n        const indexedSelections = editor.getSelections()\n            .map((selection, idx) => ({ selection, idx }))\n            .sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));\n        for (const { selection, idx } of indexedSelections) {\n            // extend selection with the `overwriteBefore` and `overwriteAfter` and then\n            // compare if this matches the extensions of the primary selection\n            let extensionBefore = SnippetSession_1.adjustSelection(model, selection, overwriteBefore, 0);\n            let extensionAfter = SnippetSession_1.adjustSelection(model, selection, 0, overwriteAfter);\n            if (firstBeforeText !== model.getValueInRange(extensionBefore)) {\n                extensionBefore = selection;\n            }\n            if (firstAfterText !== model.getValueInRange(extensionAfter)) {\n                extensionAfter = selection;\n            }\n            // merge the before and after selection into one\n            const snippetSelection = selection\n                .setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn)\n                .setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);\n            const snippet = new SnippetParser().parse(template, true, enforceFinalTabstop);\n            // adjust the template string to match the indentation and\n            // whitespace rules of this insert location (can be different for each cursor)\n            // happens when being asked for (default) or when this is a secondary\n            // cursor and the leading whitespace is different\n            const start = snippetSelection.getStartPosition();\n            const snippetLineLeadingWhitespace = SnippetSession_1.adjustWhitespace(model, start, adjustWhitespace || (idx > 0 && firstLineFirstNonWhitespace !== model.getLineFirstNonWhitespaceColumn(selection.positionLineNumber)), snippet);\n            snippet.resolveVariables(new CompositeSnippetVariableResolver([\n                modelBasedVariableResolver,\n                new ClipboardBasedVariableResolver(readClipboardText, idx, indexedSelections.length, editor.getOption(79 /* EditorOption.multiCursorPaste */) === 'spread'),\n                new SelectionBasedVariableResolver(model, selection, idx, overtypingCapturer),\n                new CommentBasedVariableResolver(model, selection, languageConfigurationService),\n                new TimeBasedVariableResolver,\n                new WorkspaceBasedVariableResolver(workspaceService),\n                new RandomBasedVariableResolver,\n            ]));\n            // store snippets with the index of their originating selection.\n            // that ensures the primiary cursor stays primary despite not being\n            // the one with lowest start position\n            edits[idx] = EditOperation.replace(snippetSelection, snippet.toString());\n            edits[idx].identifier = { major: idx, minor: 0 }; // mark the edit so only our undo edits will be used to generate end cursors\n            edits[idx]._isTracked = true;\n            snippets[idx] = new OneSnippet(editor, snippet, snippetLineLeadingWhitespace);\n        }\n        return { edits, snippets };\n    }\n    static createEditsAndSnippetsFromEdits(editor, snippetEdits, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer, languageConfigurationService) {\n        if (!editor.hasModel() || snippetEdits.length === 0) {\n            return { edits: [], snippets: [] };\n        }\n        const edits = [];\n        const model = editor.getModel();\n        const parser = new SnippetParser();\n        const snippet = new TextmateSnippet();\n        // snippet variables resolver\n        const resolver = new CompositeSnippetVariableResolver([\n            editor.invokeWithinContext(accessor => new ModelBasedVariableResolver(accessor.get(ILabelService), model)),\n            new ClipboardBasedVariableResolver(() => clipboardText, 0, editor.getSelections().length, editor.getOption(79 /* EditorOption.multiCursorPaste */) === 'spread'),\n            new SelectionBasedVariableResolver(model, editor.getSelection(), 0, overtypingCapturer),\n            new CommentBasedVariableResolver(model, editor.getSelection(), languageConfigurationService),\n            new TimeBasedVariableResolver,\n            new WorkspaceBasedVariableResolver(editor.invokeWithinContext(accessor => accessor.get(IWorkspaceContextService))),\n            new RandomBasedVariableResolver,\n        ]);\n        //\n        snippetEdits = snippetEdits.sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range));\n        let offset = 0;\n        for (let i = 0; i < snippetEdits.length; i++) {\n            const { range, template } = snippetEdits[i];\n            // gaps between snippet edits are appended as text nodes. this\n            // ensures placeholder-offsets are later correct\n            if (i > 0) {\n                const lastRange = snippetEdits[i - 1].range;\n                const textRange = Range.fromPositions(lastRange.getEndPosition(), range.getStartPosition());\n                const textNode = new Text(model.getValueInRange(textRange));\n                snippet.appendChild(textNode);\n                offset += textNode.value.length;\n            }\n            const newNodes = parser.parseFragment(template, snippet);\n            SnippetSession_1.adjustWhitespace(model, range.getStartPosition(), true, snippet, new Set(newNodes));\n            snippet.resolveVariables(resolver);\n            const snippetText = snippet.toString();\n            const snippetFragmentText = snippetText.slice(offset);\n            offset = snippetText.length;\n            // make edit\n            const edit = EditOperation.replace(range, snippetFragmentText);\n            edit.identifier = { major: i, minor: 0 }; // mark the edit so only our undo edits will be used to generate end cursors\n            edit._isTracked = true;\n            edits.push(edit);\n        }\n        //\n        parser.ensureFinalTabstop(snippet, enforceFinalTabstop, true);\n        return {\n            edits,\n            snippets: [new OneSnippet(editor, snippet, '')]\n        };\n    }\n    constructor(_editor, _template, _options = _defaultOptions, _languageConfigurationService) {\n        this._editor = _editor;\n        this._template = _template;\n        this._options = _options;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._templateMerges = [];\n        this._snippets = [];\n    }\n    dispose() {\n        dispose(this._snippets);\n    }\n    _logInfo() {\n        return `template=\"${this._template}\", merged_templates=\"${this._templateMerges.join(' -> ')}\"`;\n    }\n    insert() {\n        if (!this._editor.hasModel()) {\n            return;\n        }\n        // make insert edit and start with first selections\n        const { edits, snippets } = typeof this._template === 'string'\n            ? SnippetSession_1.createEditsAndSnippetsFromSelections(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService)\n            : SnippetSession_1.createEditsAndSnippetsFromEdits(this._editor, this._template, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService);\n        this._snippets = snippets;\n        this._editor.executeEdits('snippet', edits, _undoEdits => {\n            // Sometimes, the text buffer will remove automatic whitespace when doing any edits,\n            // so we need to look only at the undo edits relevant for us.\n            // Our edits have an identifier set so that's how we can distinguish them\n            const undoEdits = _undoEdits.filter(edit => !!edit.identifier);\n            for (let idx = 0; idx < snippets.length; idx++) {\n                snippets[idx].initialize(undoEdits[idx].textChange);\n            }\n            if (this._snippets[0].hasPlaceholder) {\n                return this._move(true);\n            }\n            else {\n                return undoEdits\n                    .map(edit => Selection.fromPositions(edit.range.getEndPosition()));\n            }\n        });\n        this._editor.revealRange(this._editor.getSelections()[0]);\n    }\n    merge(template, options = _defaultOptions) {\n        if (!this._editor.hasModel()) {\n            return;\n        }\n        this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, template]);\n        const { edits, snippets } = SnippetSession_1.createEditsAndSnippetsFromSelections(this._editor, template, options.overwriteBefore, options.overwriteAfter, true, options.adjustWhitespace, options.clipboardText, options.overtypingCapturer, this._languageConfigurationService);\n        this._editor.executeEdits('snippet', edits, _undoEdits => {\n            // Sometimes, the text buffer will remove automatic whitespace when doing any edits,\n            // so we need to look only at the undo edits relevant for us.\n            // Our edits have an identifier set so that's how we can distinguish them\n            const undoEdits = _undoEdits.filter(edit => !!edit.identifier);\n            for (let idx = 0; idx < snippets.length; idx++) {\n                snippets[idx].initialize(undoEdits[idx].textChange);\n            }\n            // Trivial snippets have no placeholder or are just the final placeholder. That means they\n            // are just text insertions and we don't need to merge the nested snippet into the existing\n            // snippet\n            const isTrivialSnippet = snippets[0].isTrivialSnippet;\n            if (!isTrivialSnippet) {\n                for (const snippet of this._snippets) {\n                    snippet.merge(snippets);\n                }\n                console.assert(snippets.length === 0);\n            }\n            if (this._snippets[0].hasPlaceholder && !isTrivialSnippet) {\n                return this._move(undefined);\n            }\n            else {\n                return undoEdits.map(edit => Selection.fromPositions(edit.range.getEndPosition()));\n            }\n        });\n    }\n    next() {\n        const newSelections = this._move(true);\n        this._editor.setSelections(newSelections);\n        this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n    }\n    prev() {\n        const newSelections = this._move(false);\n        this._editor.setSelections(newSelections);\n        this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\n    }\n    _move(fwd) {\n        const selections = [];\n        for (const snippet of this._snippets) {\n            const oneSelection = snippet.move(fwd);\n            selections.push(...oneSelection);\n        }\n        return selections;\n    }\n    get isAtFirstPlaceholder() {\n        return this._snippets[0].isAtFirstPlaceholder;\n    }\n    get isAtLastPlaceholder() {\n        return this._snippets[0].isAtLastPlaceholder;\n    }\n    get hasPlaceholder() {\n        return this._snippets[0].hasPlaceholder;\n    }\n    get hasChoice() {\n        return this._snippets[0].hasChoice;\n    }\n    get activeChoice() {\n        return this._snippets[0].activeChoice;\n    }\n    isSelectionWithinPlaceholders() {\n        if (!this.hasPlaceholder) {\n            return false;\n        }\n        const selections = this._editor.getSelections();\n        if (selections.length < this._snippets.length) {\n            // this means we started snippet mode with N\n            // selections and have M (N > M) selections.\n            // So one snippet is without selection -> cancel\n            return false;\n        }\n        const allPossibleSelections = new Map();\n        for (const snippet of this._snippets) {\n            const possibleSelections = snippet.computePossibleSelections();\n            // for the first snippet find the placeholder (and its ranges)\n            // that contain at least one selection. for all remaining snippets\n            // the same placeholder (and their ranges) must be used.\n            if (allPossibleSelections.size === 0) {\n                for (const [index, ranges] of possibleSelections) {\n                    ranges.sort(Range.compareRangesUsingStarts);\n                    for (const selection of selections) {\n                        if (ranges[0].containsRange(selection)) {\n                            allPossibleSelections.set(index, []);\n                            break;\n                        }\n                    }\n                }\n            }\n            if (allPossibleSelections.size === 0) {\n                // return false if we couldn't associate a selection to\n                // this (the first) snippet\n                return false;\n            }\n            // add selections from 'this' snippet so that we know all\n            // selections for this placeholder\n            allPossibleSelections.forEach((array, index) => {\n                array.push(...possibleSelections.get(index));\n            });\n        }\n        // sort selections (and later placeholder-ranges). then walk both\n        // arrays and make sure the placeholder-ranges contain the corresponding\n        // selection\n        selections.sort(Range.compareRangesUsingStarts);\n        for (const [index, ranges] of allPossibleSelections) {\n            if (ranges.length !== selections.length) {\n                allPossibleSelections.delete(index);\n                continue;\n            }\n            ranges.sort(Range.compareRangesUsingStarts);\n            for (let i = 0; i < ranges.length; i++) {\n                if (!ranges[i].containsRange(selections[i])) {\n                    allPossibleSelections.delete(index);\n                    continue;\n                }\n            }\n        }\n        // from all possible selections we have deleted those\n        // that don't match with the current selection. if we don't\n        // have any left, we don't have a selection anymore\n        return allPossibleSelections.size > 0;\n    }\n};\nSnippetSession = SnippetSession_1 = __decorate([\n    __param(3, ILanguageConfigurationService)\n], SnippetSession);\nexport { SnippetSession };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}