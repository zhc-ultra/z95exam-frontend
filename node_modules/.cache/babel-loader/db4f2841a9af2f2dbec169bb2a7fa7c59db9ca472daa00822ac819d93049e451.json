{"ast":null,"code":"import _callSuper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _get from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _slicedToArray from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _toConsumableArray from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.date.to-json.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/web.queue-microtask.js\";\nimport \"core-js/modules/web.timers.js\";\nimport { onUnexpectedError } from './errors.js';\nimport { createSingleCallFunction } from './functional.js';\nimport { combinedDisposable, Disposable, DisposableStore, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a listener is GC'ed without having been disposed. This is a LEAK.\n// -----------------------------------------------------------------------------------------------------------------------\nvar _enableListenerGCedWarning = false;\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nvar _enableDisposeWithListenerWarning = false;\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nvar _enableSnapshotPotentialLeakWarning = false;\nexport var Event;\n(function (Event) {\n  Event.None = function () {\n    return Disposable.None;\n  };\n  function _addLeakageTraceLogic(options) {\n    if (_enableSnapshotPotentialLeakWarning) {\n      var origListenerDidAdd = options.onDidAddListener;\n      var stack = Stacktrace.create();\n      var count = 0;\n      options.onDidAddListener = function () {\n        if (++count === 2) {\n          console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n          stack.print();\n        }\n        origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();\n      };\n    }\n  }\n  /**\n   * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\n   * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\n   * result of merging events and to try prevent race conditions that could arise when using related deferred and\n   * non-deferred events.\n   *\n   * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\n   * (eg. latency of keypress to text rendered).\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   *\n   * @param event The event source for the new event.\n   * @param disposable A disposable store to add the new EventEmitter to.\n   */\n  function defer(event, disposable) {\n    return debounce(event, function () {\n      return void 0;\n    }, 0, undefined, true, undefined, disposable);\n  }\n  Event.defer = defer;\n  /**\n   * Given an event, returns another event which only fires once.\n   *\n   * @param event The event source for the new event.\n   */\n  function once(event) {\n    return function (listener) {\n      var thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var disposables = arguments.length > 2 ? arguments[2] : undefined;\n      // we need this, in case the event fires during the listener call\n      var didFire = false;\n      var result = undefined;\n      result = event(function (e) {\n        if (didFire) {\n          return;\n        } else if (result) {\n          result.dispose();\n        } else {\n          didFire = true;\n        }\n        return listener.call(thisArgs, e);\n      }, null, disposables);\n      if (didFire) {\n        result.dispose();\n      }\n      return result;\n    };\n  }\n  Event.once = once;\n  /**\n   * Maps an event of one type into an event of another type using a mapping function, similar to how\n   * `Array.prototype.map` works.\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   *\n   * @param event The event source for the new event.\n   * @param map The mapping function.\n   * @param disposable A disposable store to add the new EventEmitter to.\n   */\n  function map(event, map, disposable) {\n    return snapshot(function (listener) {\n      var thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return event(function (i) {\n        return listener.call(thisArgs, map(i));\n      }, null, disposables);\n    }, disposable);\n  }\n  Event.map = map;\n  /**\n   * Wraps an event in another event that performs some function on the event object before firing.\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   *\n   * @param event The event source for the new event.\n   * @param each The function to perform on the event object.\n   * @param disposable A disposable store to add the new EventEmitter to.\n   */\n  function forEach(event, each, disposable) {\n    return snapshot(function (listener) {\n      var thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return event(function (i) {\n        each(i);\n        listener.call(thisArgs, i);\n      }, null, disposables);\n    }, disposable);\n  }\n  Event.forEach = forEach;\n  function filter(event, filter, disposable) {\n    return snapshot(function (listener) {\n      var thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return event(function (e) {\n        return filter(e) && listener.call(thisArgs, e);\n      }, null, disposables);\n    }, disposable);\n  }\n  Event.filter = filter;\n  /**\n   * Given an event, returns the same event but typed as `Event<void>`.\n   */\n  function signal(event) {\n    return event;\n  }\n  Event.signal = signal;\n  function any() {\n    for (var _len = arguments.length, events = new Array(_len), _key = 0; _key < _len; _key++) {\n      events[_key] = arguments[_key];\n    }\n    return function (listener) {\n      var thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var disposables = arguments.length > 2 ? arguments[2] : undefined;\n      var disposable = combinedDisposable.apply(void 0, _toConsumableArray(events.map(function (event) {\n        return event(function (e) {\n          return listener.call(thisArgs, e);\n        });\n      })));\n      return addAndReturnDisposable(disposable, disposables);\n    };\n  }\n  Event.any = any;\n  /**\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   */\n  function reduce(event, merge, initial, disposable) {\n    var output = initial;\n    return map(event, function (e) {\n      output = merge(output, e);\n      return output;\n    }, disposable);\n  }\n  Event.reduce = reduce;\n  function snapshot(event, disposable) {\n    var listener;\n    var options = {\n      onWillAddFirstListener: function onWillAddFirstListener() {\n        listener = event(emitter.fire, emitter);\n      },\n      onDidRemoveLastListener: function onDidRemoveLastListener() {\n        listener === null || listener === void 0 ? void 0 : listener.dispose();\n      }\n    };\n    if (!disposable) {\n      _addLeakageTraceLogic(options);\n    }\n    var emitter = new Emitter(options);\n    disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n    return emitter.event;\n  }\n  /**\n   * Adds the IDisposable to the store if it's set, and returns it. Useful to\n   * Event function implementation.\n   */\n  function addAndReturnDisposable(d, store) {\n    if (store instanceof Array) {\n      store.push(d);\n    } else if (store) {\n      store.add(d);\n    }\n    return d;\n  }\n  function debounce(event, merge) {\n    var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n    var leading = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var flushOnListenerRemove = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    var leakWarningThreshold = arguments.length > 5 ? arguments[5] : undefined;\n    var disposable = arguments.length > 6 ? arguments[6] : undefined;\n    var subscription;\n    var output = undefined;\n    var handle = undefined;\n    var numDebouncedCalls = 0;\n    var doFire;\n    var options = {\n      leakWarningThreshold: leakWarningThreshold,\n      onWillAddFirstListener: function onWillAddFirstListener() {\n        subscription = event(function (cur) {\n          numDebouncedCalls++;\n          output = merge(output, cur);\n          if (leading && !handle) {\n            emitter.fire(output);\n            output = undefined;\n          }\n          doFire = function doFire() {\n            var _output = output;\n            output = undefined;\n            handle = undefined;\n            if (!leading || numDebouncedCalls > 1) {\n              emitter.fire(_output);\n            }\n            numDebouncedCalls = 0;\n          };\n          if (typeof delay === 'number') {\n            clearTimeout(handle);\n            handle = setTimeout(doFire, delay);\n          } else {\n            if (handle === undefined) {\n              handle = 0;\n              queueMicrotask(doFire);\n            }\n          }\n        });\n      },\n      onWillRemoveListener: function onWillRemoveListener() {\n        if (flushOnListenerRemove && numDebouncedCalls > 0) {\n          doFire === null || doFire === void 0 ? void 0 : doFire();\n        }\n      },\n      onDidRemoveLastListener: function onDidRemoveLastListener() {\n        doFire = undefined;\n        subscription.dispose();\n      }\n    };\n    if (!disposable) {\n      _addLeakageTraceLogic(options);\n    }\n    var emitter = new Emitter(options);\n    disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n    return emitter.event;\n  }\n  Event.debounce = debounce;\n  /**\n   * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   */\n  function accumulate(event) {\n    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var disposable = arguments.length > 2 ? arguments[2] : undefined;\n    return Event.debounce(event, function (last, e) {\n      if (!last) {\n        return [e];\n      }\n      last.push(e);\n      return last;\n    }, delay, undefined, true, undefined, disposable);\n  }\n  Event.accumulate = accumulate;\n  /**\n   * Filters an event such that some condition is _not_ met more than once in a row, effectively ensuring duplicate\n   * event objects from different sources do not fire the same event object.\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   *\n   * @param event The event source for the new event.\n   * @param equals The equality condition.\n   * @param disposable A disposable store to add the new EventEmitter to.\n   *\n   * @example\n   * ```\n   * // Fire only one time when a single window is opened or focused\n   * Event.latch(Event.any(onDidOpenWindow, onDidFocusWindow))\n   * ```\n   */\n  function latch(event) {\n    var equals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (a, b) {\n      return a === b;\n    };\n    var disposable = arguments.length > 2 ? arguments[2] : undefined;\n    var firstCall = true;\n    var cache;\n    return filter(event, function (value) {\n      var shouldEmit = firstCall || !equals(value, cache);\n      firstCall = false;\n      cache = value;\n      return shouldEmit;\n    }, disposable);\n  }\n  Event.latch = latch;\n  /**\n   * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   *\n   * @example\n   * ```\n   * const event = new EventEmitter<number | undefined>().event;\n   * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\n   * ```\n   *\n   * @param event The event source for the new event.\n   * @param isT A function that determines what event is of the first type.\n   * @param disposable A disposable store to add the new EventEmitter to.\n   */\n  function split(event, isT, disposable) {\n    return [Event.filter(event, isT, disposable), Event.filter(event, function (e) {\n      return !isT(e);\n    }, disposable)];\n  }\n  Event.split = split;\n  /**\n   * Buffers an event until it has a listener attached.\n   *\n   * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n   * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n   * returned event causes this utility to leak a listener on the original event.\n   *\n   * @param event The event source for the new event.\n   * @param flushAfterTimeout Determines whether to flush the buffer after a timeout immediately or after a\n   * `setTimeout` when the first event listener is added.\n   * @param _buffer Internal: A source event array used for tests.\n   *\n   * @example\n   * ```\n   * // Start accumulating events, when the first listener is attached, flush\n   * // the event after a timeout such that multiple listeners attached before\n   * // the timeout would receive the event\n   * this.onInstallExtension = Event.buffer(service.onInstallExtension, true);\n   * ```\n   */\n  function buffer(event) {\n    var flushAfterTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var _buffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var disposable = arguments.length > 3 ? arguments[3] : undefined;\n    var buffer = _buffer.slice();\n    var listener = event(function (e) {\n      if (buffer) {\n        buffer.push(e);\n      } else {\n        emitter.fire(e);\n      }\n    });\n    if (disposable) {\n      disposable.add(listener);\n    }\n    var flush = function flush() {\n      buffer === null || buffer === void 0 ? void 0 : buffer.forEach(function (e) {\n        return emitter.fire(e);\n      });\n      buffer = null;\n    };\n    var emitter = new Emitter({\n      onWillAddFirstListener: function onWillAddFirstListener() {\n        if (!listener) {\n          listener = event(function (e) {\n            return emitter.fire(e);\n          });\n          if (disposable) {\n            disposable.add(listener);\n          }\n        }\n      },\n      onDidAddFirstListener: function onDidAddFirstListener() {\n        if (buffer) {\n          if (flushAfterTimeout) {\n            setTimeout(flush);\n          } else {\n            flush();\n          }\n        }\n      },\n      onDidRemoveLastListener: function onDidRemoveLastListener() {\n        if (listener) {\n          listener.dispose();\n        }\n        listener = null;\n      }\n    });\n    if (disposable) {\n      disposable.add(emitter);\n    }\n    return emitter.event;\n  }\n  Event.buffer = buffer;\n  /**\n   * Wraps the event in an {@link IChainableEvent}, allowing a more functional programming style.\n   *\n   * @example\n   * ```\n   * // Normal\n   * const onEnterPressNormal = Event.filter(\n   *   Event.map(onKeyPress.event, e => new StandardKeyboardEvent(e)),\n   *   e.keyCode === KeyCode.Enter\n   * ).event;\n   *\n   * // Using chain\n   * const onEnterPressChain = Event.chain(onKeyPress.event, $ => $\n   *   .map(e => new StandardKeyboardEvent(e))\n   *   .filter(e => e.keyCode === KeyCode.Enter)\n   * );\n   * ```\n   */\n  function chain(event, sythensize) {\n    var fn = function fn(listener, thisArgs, disposables) {\n      var cs = sythensize(new ChainableSynthesis());\n      return event(function (value) {\n        var result = cs.evaluate(value);\n        if (result !== HaltChainable) {\n          listener.call(thisArgs, result);\n        }\n      }, undefined, disposables);\n    };\n    return fn;\n  }\n  Event.chain = chain;\n  var HaltChainable = Symbol('HaltChainable');\n  var ChainableSynthesis = /*#__PURE__*/function () {\n    function ChainableSynthesis() {\n      _classCallCheck(this, ChainableSynthesis);\n      this.steps = [];\n    }\n    return _createClass(ChainableSynthesis, [{\n      key: \"map\",\n      value: function map(fn) {\n        this.steps.push(fn);\n        return this;\n      }\n    }, {\n      key: \"forEach\",\n      value: function forEach(fn) {\n        this.steps.push(function (v) {\n          fn(v);\n          return v;\n        });\n        return this;\n      }\n    }, {\n      key: \"filter\",\n      value: function filter(fn) {\n        this.steps.push(function (v) {\n          return fn(v) ? v : HaltChainable;\n        });\n        return this;\n      }\n    }, {\n      key: \"reduce\",\n      value: function reduce(merge, initial) {\n        var last = initial;\n        this.steps.push(function (v) {\n          last = merge(last, v);\n          return last;\n        });\n        return this;\n      }\n    }, {\n      key: \"latch\",\n      value: function latch() {\n        var equals = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (a, b) {\n          return a === b;\n        };\n        var firstCall = true;\n        var cache;\n        this.steps.push(function (value) {\n          var shouldEmit = firstCall || !equals(value, cache);\n          firstCall = false;\n          cache = value;\n          return shouldEmit ? value : HaltChainable;\n        });\n        return this;\n      }\n    }, {\n      key: \"evaluate\",\n      value: function evaluate(value) {\n        var _iterator = _createForOfIteratorHelper(this.steps),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var step = _step.value;\n            value = step(value);\n            if (value === HaltChainable) {\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        return value;\n      }\n    }]);\n  }();\n  /**\n   * Creates an {@link Event} from a node event emitter.\n   */\n  function fromNodeEventEmitter(emitter, eventName) {\n    var map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (id) {\n      return id;\n    };\n    var fn = function fn() {\n      return result.fire(map.apply(void 0, arguments));\n    };\n    var onFirstListenerAdd = function onFirstListenerAdd() {\n      return emitter.on(eventName, fn);\n    };\n    var onLastListenerRemove = function onLastListenerRemove() {\n      return emitter.removeListener(eventName, fn);\n    };\n    var result = new Emitter({\n      onWillAddFirstListener: onFirstListenerAdd,\n      onDidRemoveLastListener: onLastListenerRemove\n    });\n    return result.event;\n  }\n  Event.fromNodeEventEmitter = fromNodeEventEmitter;\n  /**\n   * Creates an {@link Event} from a DOM event emitter.\n   */\n  function fromDOMEventEmitter(emitter, eventName) {\n    var map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (id) {\n      return id;\n    };\n    var fn = function fn() {\n      return result.fire(map.apply(void 0, arguments));\n    };\n    var onFirstListenerAdd = function onFirstListenerAdd() {\n      return emitter.addEventListener(eventName, fn);\n    };\n    var onLastListenerRemove = function onLastListenerRemove() {\n      return emitter.removeEventListener(eventName, fn);\n    };\n    var result = new Emitter({\n      onWillAddFirstListener: onFirstListenerAdd,\n      onDidRemoveLastListener: onLastListenerRemove\n    });\n    return result.event;\n  }\n  Event.fromDOMEventEmitter = fromDOMEventEmitter;\n  /**\n   * Creates a promise out of an event, using the {@link Event.once} helper.\n   */\n  function toPromise(event) {\n    return new Promise(function (resolve) {\n      return once(event)(resolve);\n    });\n  }\n  Event.toPromise = toPromise;\n  /**\n   * Creates an event out of a promise that fires once when the promise is\n   * resolved with the result of the promise or `undefined`.\n   */\n  function fromPromise(promise) {\n    var result = new Emitter();\n    promise.then(function (res) {\n      result.fire(res);\n    }, function () {\n      result.fire(undefined);\n    })[\"finally\"](function () {\n      result.dispose();\n    });\n    return result.event;\n  }\n  Event.fromPromise = fromPromise;\n  function runAndSubscribe(event, handler, initial) {\n    handler(initial);\n    return event(function (e) {\n      return handler(e);\n    });\n  }\n  Event.runAndSubscribe = runAndSubscribe;\n  var EmitterObserver = /*#__PURE__*/function () {\n    function EmitterObserver(_observable, store) {\n      var _this = this;\n      _classCallCheck(this, EmitterObserver);\n      this._observable = _observable;\n      this._counter = 0;\n      this._hasChanged = false;\n      var options = {\n        onWillAddFirstListener: function onWillAddFirstListener() {\n          _observable.addObserver(_this);\n        },\n        onDidRemoveLastListener: function onDidRemoveLastListener() {\n          _observable.removeObserver(_this);\n        }\n      };\n      if (!store) {\n        _addLeakageTraceLogic(options);\n      }\n      this.emitter = new Emitter(options);\n      if (store) {\n        store.add(this.emitter);\n      }\n    }\n    return _createClass(EmitterObserver, [{\n      key: \"beginUpdate\",\n      value: function beginUpdate(_observable) {\n        // assert(_observable === this.obs);\n        this._counter++;\n      }\n    }, {\n      key: \"handlePossibleChange\",\n      value: function handlePossibleChange(_observable) {\n        // assert(_observable === this.obs);\n      }\n    }, {\n      key: \"handleChange\",\n      value: function handleChange(_observable, _change) {\n        // assert(_observable === this.obs);\n        this._hasChanged = true;\n      }\n    }, {\n      key: \"endUpdate\",\n      value: function endUpdate(_observable) {\n        // assert(_observable === this.obs);\n        this._counter--;\n        if (this._counter === 0) {\n          this._observable.reportChanges();\n          if (this._hasChanged) {\n            this._hasChanged = false;\n            this.emitter.fire(this._observable.get());\n          }\n        }\n      }\n    }]);\n  }();\n  /**\n   * Creates an event emitter that is fired when the observable changes.\n   * Each listeners subscribes to the emitter.\n   */\n  function fromObservable(obs, store) {\n    var observer = new EmitterObserver(obs, store);\n    return observer.emitter.event;\n  }\n  Event.fromObservable = fromObservable;\n  /**\n   * Each listener is attached to the observable directly.\n   */\n  function fromObservableLight(observable) {\n    return function (listener, thisArgs, disposables) {\n      var count = 0;\n      var didChange = false;\n      var observer = {\n        beginUpdate: function beginUpdate() {\n          count++;\n        },\n        endUpdate: function endUpdate() {\n          count--;\n          if (count === 0) {\n            observable.reportChanges();\n            if (didChange) {\n              didChange = false;\n              listener.call(thisArgs);\n            }\n          }\n        },\n        handlePossibleChange: function handlePossibleChange() {\n          // noop\n        },\n        handleChange: function handleChange() {\n          didChange = true;\n        }\n      };\n      observable.addObserver(observer);\n      observable.reportChanges();\n      var disposable = {\n        dispose: function dispose() {\n          observable.removeObserver(observer);\n        }\n      };\n      if (disposables instanceof DisposableStore) {\n        disposables.add(disposable);\n      } else if (Array.isArray(disposables)) {\n        disposables.push(disposable);\n      }\n      return disposable;\n    };\n  }\n  Event.fromObservableLight = fromObservableLight;\n})(Event || (Event = {}));\nexport var EventProfiling = /*#__PURE__*/function () {\n  function EventProfiling(name) {\n    _classCallCheck(this, EventProfiling);\n    this.listenerCount = 0;\n    this.invocationCount = 0;\n    this.elapsedOverall = 0;\n    this.durations = [];\n    this.name = \"\".concat(name, \"_\").concat(EventProfiling._idPool++);\n    EventProfiling.all.add(this);\n  }\n  return _createClass(EventProfiling, [{\n    key: \"start\",\n    value: function start(listenerCount) {\n      this._stopWatch = new StopWatch();\n      this.listenerCount = listenerCount;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this._stopWatch) {\n        var elapsed = this._stopWatch.elapsed();\n        this.durations.push(elapsed);\n        this.elapsedOverall += elapsed;\n        this.invocationCount += 1;\n        this._stopWatch = undefined;\n      }\n    }\n  }]);\n}();\nEventProfiling.all = new Set();\nEventProfiling._idPool = 0;\nvar _globalLeakWarningThreshold = -1;\nvar LeakageMonitor = /*#__PURE__*/function () {\n  function LeakageMonitor(threshold) {\n    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Math.random().toString(18).slice(2, 5);\n    _classCallCheck(this, LeakageMonitor);\n    this.threshold = threshold;\n    this.name = name;\n    this._warnCountdown = 0;\n  }\n  return _createClass(LeakageMonitor, [{\n    key: \"dispose\",\n    value: function dispose() {\n      var _a;\n      (_a = this._stacks) === null || _a === void 0 ? void 0 : _a.clear();\n    }\n  }, {\n    key: \"check\",\n    value: function check(stack, listenerCount) {\n      var _this2 = this;\n      var threshold = this.threshold;\n      if (threshold <= 0 || listenerCount < threshold) {\n        return undefined;\n      }\n      if (!this._stacks) {\n        this._stacks = new Map();\n      }\n      var count = this._stacks.get(stack.value) || 0;\n      this._stacks.set(stack.value, count + 1);\n      this._warnCountdown -= 1;\n      if (this._warnCountdown <= 0) {\n        // only warn on first exceed and then every time the limit\n        // is exceeded by 50% again\n        this._warnCountdown = threshold * 0.5;\n        // find most frequent listener and print warning\n        var topStack;\n        var topCount = 0;\n        var _iterator2 = _createForOfIteratorHelper(this._stacks),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _step2$value = _slicedToArray(_step2.value, 2),\n              _stack = _step2$value[0],\n              _count = _step2$value[1];\n            if (!topStack || topCount < _count) {\n              topStack = _stack;\n              topCount = _count;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        console.warn(\"[\".concat(this.name, \"] potential listener LEAK detected, having \").concat(listenerCount, \" listeners already. MOST frequent listener (\").concat(topCount, \"):\"));\n        console.warn(topStack);\n      }\n      return function () {\n        var count = _this2._stacks.get(stack.value) || 0;\n        _this2._stacks.set(stack.value, count - 1);\n      };\n    }\n  }]);\n}();\nvar Stacktrace = /*#__PURE__*/function () {\n  function Stacktrace(value) {\n    _classCallCheck(this, Stacktrace);\n    this.value = value;\n  }\n  return _createClass(Stacktrace, [{\n    key: \"print\",\n    value: function print() {\n      console.warn(this.value.split('\\n').slice(2).join('\\n'));\n    }\n  }], [{\n    key: \"create\",\n    value: function create() {\n      var _a;\n      return new Stacktrace((_a = new Error().stack) !== null && _a !== void 0 ? _a : '');\n    }\n  }]);\n}();\nvar UniqueContainer = /*#__PURE__*/_createClass(function UniqueContainer(value) {\n  _classCallCheck(this, UniqueContainer);\n  this.value = value;\n});\nvar compactionThreshold = 2;\nvar forEachListener = function forEachListener(listeners, fn) {\n  if (listeners instanceof UniqueContainer) {\n    fn(listeners);\n  } else {\n    for (var i = 0; i < listeners.length; i++) {\n      var l = listeners[i];\n      if (l) {\n        fn(l);\n      }\n    }\n  }\n};\nvar _listenerFinalizers = _enableListenerGCedWarning ? new FinalizationRegistry(function (heldValue) {\n  if (typeof heldValue === 'string') {\n    console.warn('[LEAKING LISTENER] GC\\'ed a listener that was NOT yet disposed. This is where is was created:');\n    console.warn(heldValue);\n  }\n}) : undefined;\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nexport var Emitter = /*#__PURE__*/function () {\n  function Emitter(options) {\n    _classCallCheck(this, Emitter);\n    var _a, _b, _c, _d, _e;\n    this._size = 0;\n    this._options = options;\n    this._leakageMon = _globalLeakWarningThreshold > 0 || ((_a = this._options) === null || _a === void 0 ? void 0 : _a.leakWarningThreshold) ? new LeakageMonitor((_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.leakWarningThreshold) !== null && _c !== void 0 ? _c : _globalLeakWarningThreshold) : undefined;\n    this._perfMon = ((_d = this._options) === null || _d === void 0 ? void 0 : _d._profName) ? new EventProfiling(this._options._profName) : undefined;\n    this._deliveryQueue = (_e = this._options) === null || _e === void 0 ? void 0 : _e.deliveryQueue;\n  }\n  return _createClass(Emitter, [{\n    key: \"dispose\",\n    value: function dispose() {\n      var _a, _b, _c, _d;\n      if (!this._disposed) {\n        this._disposed = true;\n        // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n        // alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n        // unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n        // the following programming pattern is very popular:\n        //\n        // const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n        // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n        // ...later...\n        // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n        if (((_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.current) === this) {\n          this._deliveryQueue.reset();\n        }\n        if (this._listeners) {\n          if (_enableDisposeWithListenerWarning) {\n            var listeners = this._listeners;\n            queueMicrotask(function () {\n              forEachListener(listeners, function (l) {\n                var _a;\n                return (_a = l.stack) === null || _a === void 0 ? void 0 : _a.print();\n              });\n            });\n          }\n          this._listeners = undefined;\n          this._size = 0;\n        }\n        (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onDidRemoveLastListener) === null || _c === void 0 ? void 0 : _c.call(_b);\n        (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();\n      }\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n  }, {\n    key: \"event\",\n    get: function get() {\n      var _this3 = this;\n      var _a;\n      (_a = this._event) !== null && _a !== void 0 ? _a : this._event = function (callback, thisArgs, disposables) {\n        var _a, _b, _c, _d, _e;\n        if (_this3._leakageMon && _this3._size > _this3._leakageMon.threshold * 3) {\n          console.warn(\"[\".concat(_this3._leakageMon.name, \"] REFUSES to accept new listeners because it exceeded its threshold by far\"));\n          return Disposable.None;\n        }\n        if (_this3._disposed) {\n          // todo: should we warn if a listener is added to a disposed emitter? This happens often\n          return Disposable.None;\n        }\n        if (thisArgs) {\n          callback = callback.bind(thisArgs);\n        }\n        var contained = new UniqueContainer(callback);\n        var removeMonitor;\n        var stack;\n        if (_this3._leakageMon && _this3._size >= Math.ceil(_this3._leakageMon.threshold * 0.2)) {\n          // check and record this emitter for potential leakage\n          contained.stack = Stacktrace.create();\n          removeMonitor = _this3._leakageMon.check(contained.stack, _this3._size + 1);\n        }\n        if (_enableDisposeWithListenerWarning) {\n          contained.stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();\n        }\n        if (!_this3._listeners) {\n          (_b = (_a = _this3._options) === null || _a === void 0 ? void 0 : _a.onWillAddFirstListener) === null || _b === void 0 ? void 0 : _b.call(_a, _this3);\n          _this3._listeners = contained;\n          (_d = (_c = _this3._options) === null || _c === void 0 ? void 0 : _c.onDidAddFirstListener) === null || _d === void 0 ? void 0 : _d.call(_c, _this3);\n        } else if (_this3._listeners instanceof UniqueContainer) {\n          (_e = _this3._deliveryQueue) !== null && _e !== void 0 ? _e : _this3._deliveryQueue = new EventDeliveryQueuePrivate();\n          _this3._listeners = [_this3._listeners, contained];\n        } else {\n          _this3._listeners.push(contained);\n        }\n        _this3._size++;\n        var result = toDisposable(function () {\n          _listenerFinalizers === null || _listenerFinalizers === void 0 ? void 0 : _listenerFinalizers.unregister(result);\n          removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor();\n          _this3._removeListener(contained);\n        });\n        if (disposables instanceof DisposableStore) {\n          disposables.add(result);\n        } else if (Array.isArray(disposables)) {\n          disposables.push(result);\n        }\n        if (_listenerFinalizers) {\n          var _stack2 = new Error().stack.split('\\n').slice(2).join('\\n').trim();\n          _listenerFinalizers.register(result, _stack2, result);\n        }\n        return result;\n      };\n      return this._event;\n    }\n  }, {\n    key: \"_removeListener\",\n    value: function _removeListener(listener) {\n      var _a, _b, _c, _d;\n      (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.onWillRemoveListener) === null || _b === void 0 ? void 0 : _b.call(_a, this);\n      if (!this._listeners) {\n        return; // expected if a listener gets disposed\n      }\n      if (this._size === 1) {\n        this._listeners = undefined;\n        (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidRemoveLastListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);\n        this._size = 0;\n        return;\n      }\n      // size > 1 which requires that listeners be a list:\n      var listeners = this._listeners;\n      var index = listeners.indexOf(listener);\n      if (index === -1) {\n        console.log('disposed?', this._disposed);\n        console.log('size?', this._size);\n        console.log('arr?', JSON.stringify(this._listeners));\n        throw new Error('Attempted to dispose unknown listener');\n      }\n      this._size--;\n      listeners[index] = undefined;\n      var adjustDeliveryQueue = this._deliveryQueue.current === this;\n      if (this._size * compactionThreshold <= listeners.length) {\n        var n = 0;\n        for (var i = 0; i < listeners.length; i++) {\n          if (listeners[i]) {\n            listeners[n++] = listeners[i];\n          } else if (adjustDeliveryQueue) {\n            this._deliveryQueue.end--;\n            if (n < this._deliveryQueue.i) {\n              this._deliveryQueue.i--;\n            }\n          }\n        }\n        listeners.length = n;\n      }\n    }\n  }, {\n    key: \"_deliver\",\n    value: function _deliver(listener, value) {\n      var _a;\n      if (!listener) {\n        return;\n      }\n      var errorHandler = ((_a = this._options) === null || _a === void 0 ? void 0 : _a.onListenerError) || onUnexpectedError;\n      if (!errorHandler) {\n        listener.value(value);\n        return;\n      }\n      try {\n        listener.value(value);\n      } catch (e) {\n        errorHandler(e);\n      }\n    }\n    /** Delivers items in the queue. Assumes the queue is ready to go. */\n  }, {\n    key: \"_deliverQueue\",\n    value: function _deliverQueue(dq) {\n      var listeners = dq.current._listeners;\n      while (dq.i < dq.end) {\n        // important: dq.i is incremented before calling deliver() because it might reenter deliverQueue()\n        this._deliver(listeners[dq.i++], dq.value);\n      }\n      dq.reset();\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n  }, {\n    key: \"fire\",\n    value: function fire(event) {\n      var _a, _b, _c, _d;\n      if ((_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.current) {\n        this._deliverQueue(this._deliveryQueue);\n        (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch\n      }\n      (_c = this._perfMon) === null || _c === void 0 ? void 0 : _c.start(this._size);\n      if (!this._listeners) {\n        // no-op\n      } else if (this._listeners instanceof UniqueContainer) {\n        this._deliver(this._listeners, event);\n      } else {\n        var dq = this._deliveryQueue;\n        dq.enqueue(this, event, this._listeners.length);\n        this._deliverQueue(dq);\n      }\n      (_d = this._perfMon) === null || _d === void 0 ? void 0 : _d.stop();\n    }\n  }, {\n    key: \"hasListeners\",\n    value: function hasListeners() {\n      return this._size > 0;\n    }\n  }]);\n}();\nexport var createEventDeliveryQueue = function createEventDeliveryQueue() {\n  return new EventDeliveryQueuePrivate();\n};\nvar EventDeliveryQueuePrivate = /*#__PURE__*/function () {\n  function EventDeliveryQueuePrivate() {\n    _classCallCheck(this, EventDeliveryQueuePrivate);\n    /**\n     * Index in current's listener list.\n     */\n    this.i = -1;\n    /**\n     * The last index in the listener's list to deliver.\n     */\n    this.end = 0;\n  }\n  return _createClass(EventDeliveryQueuePrivate, [{\n    key: \"enqueue\",\n    value: function enqueue(emitter, value, end) {\n      this.i = 0;\n      this.end = end;\n      this.current = emitter;\n      this.value = value;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.i = this.end; // force any current emission loop to stop, mainly for during dispose\n      this.current = undefined;\n      this.value = undefined;\n    }\n  }]);\n}();\nexport var PauseableEmitter = /*#__PURE__*/function (_Emitter) {\n  function PauseableEmitter(options) {\n    var _this4;\n    _classCallCheck(this, PauseableEmitter);\n    _this4 = _callSuper(this, PauseableEmitter, [options]);\n    _this4._isPaused = 0;\n    _this4._eventQueue = new LinkedList();\n    _this4._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n    return _this4;\n  }\n  _inherits(PauseableEmitter, _Emitter);\n  return _createClass(PauseableEmitter, [{\n    key: \"pause\",\n    value: function pause() {\n      this._isPaused++;\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (this._isPaused !== 0 && --this._isPaused === 0) {\n        if (this._mergeFn) {\n          // use the merge function to create a single composite\n          // event. make a copy in case firing pauses this emitter\n          if (this._eventQueue.size > 0) {\n            var events = Array.from(this._eventQueue);\n            this._eventQueue.clear();\n            _get(_getPrototypeOf(PauseableEmitter.prototype), \"fire\", this).call(this, this._mergeFn(events));\n          }\n        } else {\n          // no merging, fire each event individually and test\n          // that this emitter isn't paused halfway through\n          while (!this._isPaused && this._eventQueue.size !== 0) {\n            _get(_getPrototypeOf(PauseableEmitter.prototype), \"fire\", this).call(this, this._eventQueue.shift());\n          }\n        }\n      }\n    }\n  }, {\n    key: \"fire\",\n    value: function fire(event) {\n      if (this._size) {\n        if (this._isPaused !== 0) {\n          this._eventQueue.push(event);\n        } else {\n          _get(_getPrototypeOf(PauseableEmitter.prototype), \"fire\", this).call(this, event);\n        }\n      }\n    }\n  }]);\n}(Emitter);\nexport var DebounceEmitter = /*#__PURE__*/function (_PauseableEmitter) {\n  function DebounceEmitter(options) {\n    var _this5;\n    _classCallCheck(this, DebounceEmitter);\n    var _a;\n    _this5 = _callSuper(this, DebounceEmitter, [options]);\n    _this5._delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 100;\n    return _this5;\n  }\n  _inherits(DebounceEmitter, _PauseableEmitter);\n  return _createClass(DebounceEmitter, [{\n    key: \"fire\",\n    value: function fire(event) {\n      var _this6 = this;\n      if (!this._handle) {\n        this.pause();\n        this._handle = setTimeout(function () {\n          _this6._handle = undefined;\n          _this6.resume();\n        }, this._delay);\n      }\n      _get(_getPrototypeOf(DebounceEmitter.prototype), \"fire\", this).call(this, event);\n    }\n  }]);\n}(PauseableEmitter);\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nexport var MicrotaskEmitter = /*#__PURE__*/function (_Emitter2) {\n  function MicrotaskEmitter(options) {\n    var _this7;\n    _classCallCheck(this, MicrotaskEmitter);\n    _this7 = _callSuper(this, MicrotaskEmitter, [options]);\n    _this7._queuedEvents = [];\n    _this7._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n    return _this7;\n  }\n  _inherits(MicrotaskEmitter, _Emitter2);\n  return _createClass(MicrotaskEmitter, [{\n    key: \"fire\",\n    value: function fire(event) {\n      var _this8 = this;\n      if (!this.hasListeners()) {\n        return;\n      }\n      this._queuedEvents.push(event);\n      if (this._queuedEvents.length === 1) {\n        queueMicrotask(function () {\n          if (_this8._mergeFn) {\n            _get(_getPrototypeOf(MicrotaskEmitter.prototype), \"fire\", _this8).call(_this8, _this8._mergeFn(_this8._queuedEvents));\n          } else {\n            _this8._queuedEvents.forEach(function (e) {\n              return _get(_getPrototypeOf(MicrotaskEmitter.prototype), \"fire\", _this8).call(_this8, e);\n            });\n          }\n          _this8._queuedEvents = [];\n        });\n      }\n    }\n  }]);\n}(Emitter);\n/**\n * An event emitter that multiplexes many events into a single event.\n *\n * @example Listen to the `onData` event of all `Thing`s, dynamically adding and removing `Thing`s\n * to the multiplexer as needed.\n *\n * ```typescript\n * const anythingDataMultiplexer = new EventMultiplexer<{ data: string }>();\n *\n * const thingListeners = DisposableMap<Thing, IDisposable>();\n *\n * thingService.onDidAddThing(thing => {\n *   thingListeners.set(thing, anythingDataMultiplexer.add(thing.onData);\n * });\n * thingService.onDidRemoveThing(thing => {\n *   thingListeners.deleteAndDispose(thing);\n * });\n *\n * anythingDataMultiplexer.event(e => {\n *   console.log('Something fired data ' + e.data)\n * });\n * ```\n */\nexport var EventMultiplexer = /*#__PURE__*/function () {\n  function EventMultiplexer() {\n    var _this9 = this;\n    _classCallCheck(this, EventMultiplexer);\n    this.hasListeners = false;\n    this.events = [];\n    this.emitter = new Emitter({\n      onWillAddFirstListener: function onWillAddFirstListener() {\n        return _this9.onFirstListenerAdd();\n      },\n      onDidRemoveLastListener: function onDidRemoveLastListener() {\n        return _this9.onLastListenerRemove();\n      }\n    });\n  }\n  return _createClass(EventMultiplexer, [{\n    key: \"event\",\n    get: function get() {\n      return this.emitter.event;\n    }\n  }, {\n    key: \"add\",\n    value: function add(event) {\n      var _this10 = this;\n      var e = {\n        event: event,\n        listener: null\n      };\n      this.events.push(e);\n      if (this.hasListeners) {\n        this.hook(e);\n      }\n      var dispose = function dispose() {\n        if (_this10.hasListeners) {\n          _this10.unhook(e);\n        }\n        var idx = _this10.events.indexOf(e);\n        _this10.events.splice(idx, 1);\n      };\n      return toDisposable(createSingleCallFunction(dispose));\n    }\n  }, {\n    key: \"onFirstListenerAdd\",\n    value: function onFirstListenerAdd() {\n      var _this11 = this;\n      this.hasListeners = true;\n      this.events.forEach(function (e) {\n        return _this11.hook(e);\n      });\n    }\n  }, {\n    key: \"onLastListenerRemove\",\n    value: function onLastListenerRemove() {\n      var _this12 = this;\n      this.hasListeners = false;\n      this.events.forEach(function (e) {\n        return _this12.unhook(e);\n      });\n    }\n  }, {\n    key: \"hook\",\n    value: function hook(e) {\n      var _this13 = this;\n      e.listener = e.event(function (r) {\n        return _this13.emitter.fire(r);\n      });\n    }\n  }, {\n    key: \"unhook\",\n    value: function unhook(e) {\n      var _a;\n      (_a = e.listener) === null || _a === void 0 ? void 0 : _a.dispose();\n      e.listener = null;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var _a;\n      this.emitter.dispose();\n      var _iterator3 = _createForOfIteratorHelper(this.events),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var e = _step3.value;\n          (_a = e.listener) === null || _a === void 0 ? void 0 : _a.dispose();\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      this.events = [];\n    }\n  }]);\n}();\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport var EventBufferer = /*#__PURE__*/function () {\n  function EventBufferer() {\n    _classCallCheck(this, EventBufferer);\n    this.buffers = [];\n  }\n  return _createClass(EventBufferer, [{\n    key: \"wrapEvent\",\n    value: function wrapEvent(event) {\n      var _this14 = this;\n      return function (listener, thisArgs, disposables) {\n        return event(function (i) {\n          var buffer = _this14.buffers[_this14.buffers.length - 1];\n          if (buffer) {\n            buffer.push(function () {\n              return listener.call(thisArgs, i);\n            });\n          } else {\n            listener.call(thisArgs, i);\n          }\n        }, undefined, disposables);\n      };\n    }\n  }, {\n    key: \"bufferEvents\",\n    value: function bufferEvents(fn) {\n      var buffer = [];\n      this.buffers.push(buffer);\n      var r = fn();\n      this.buffers.pop();\n      buffer.forEach(function (flush) {\n        return flush();\n      });\n      return r;\n    }\n  }]);\n}();\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport var Relay = /*#__PURE__*/function () {\n  function Relay() {\n    var _this15 = this;\n    _classCallCheck(this, Relay);\n    this.listening = false;\n    this.inputEvent = Event.None;\n    this.inputEventListener = Disposable.None;\n    this.emitter = new Emitter({\n      onDidAddFirstListener: function onDidAddFirstListener() {\n        _this15.listening = true;\n        _this15.inputEventListener = _this15.inputEvent(_this15.emitter.fire, _this15.emitter);\n      },\n      onDidRemoveLastListener: function onDidRemoveLastListener() {\n        _this15.listening = false;\n        _this15.inputEventListener.dispose();\n      }\n    });\n    this.event = this.emitter.event;\n  }\n  return _createClass(Relay, [{\n    key: \"input\",\n    set: function set(event) {\n      this.inputEvent = event;\n      if (this.listening) {\n        this.inputEventListener.dispose();\n        this.inputEventListener = event(this.emitter.fire, this.emitter);\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.inputEventListener.dispose();\n      this.emitter.dispose();\n    }\n  }]);\n}();","map":{"version":3,"names":["onUnexpectedError","createSingleCallFunction","combinedDisposable","Disposable","DisposableStore","toDisposable","LinkedList","StopWatch","_enableListenerGCedWarning","_enableDisposeWithListenerWarning","_enableSnapshotPotentialLeakWarning","Event","None","_addLeakageTraceLogic","options","origListenerDidAdd","onDidAddListener","stack","Stacktrace","create","count","console","warn","print","defer","event","disposable","debounce","undefined","once","listener","thisArgs","arguments","length","disposables","didFire","result","e","dispose","call","map","snapshot","i","forEach","each","filter","signal","any","_len","events","Array","_key","apply","_toConsumableArray","addAndReturnDisposable","reduce","merge","initial","output","onWillAddFirstListener","emitter","fire","onDidRemoveLastListener","Emitter","add","d","store","push","delay","leading","flushOnListenerRemove","leakWarningThreshold","subscription","handle","numDebouncedCalls","doFire","cur","_output","clearTimeout","setTimeout","queueMicrotask","onWillRemoveListener","accumulate","last","latch","equals","a","b","firstCall","cache","value","shouldEmit","split","isT","buffer","flushAfterTimeout","_buffer","slice","flush","onDidAddFirstListener","chain","sythensize","fn","cs","ChainableSynthesis","evaluate","HaltChainable","Symbol","_classCallCheck","steps","_createClass","key","v","_iterator","_createForOfIteratorHelper","_step","s","n","done","step","err","f","fromNodeEventEmitter","eventName","id","onFirstListenerAdd","on","onLastListenerRemove","removeListener","fromDOMEventEmitter","addEventListener","removeEventListener","toPromise","Promise","resolve","fromPromise","promise","then","res","runAndSubscribe","handler","EmitterObserver","_observable","_this","_counter","_hasChanged","addObserver","removeObserver","beginUpdate","handlePossibleChange","handleChange","_change","endUpdate","reportChanges","get","fromObservable","obs","observer","fromObservableLight","observable","didChange","isArray","EventProfiling","name","listenerCount","invocationCount","elapsedOverall","durations","concat","_idPool","all","start","_stopWatch","stop","elapsed","Set","_globalLeakWarningThreshold","LeakageMonitor","threshold","Math","random","toString","_warnCountdown","_a","_stacks","clear","check","_this2","Map","set","topStack","topCount","_iterator2","_step2","_step2$value","_slicedToArray","join","Error","UniqueContainer","compactionThreshold","forEachListener","listeners","l","_listenerFinalizers","FinalizationRegistry","heldValue","_b","_c","_d","_e","_size","_options","_leakageMon","_perfMon","_profName","_deliveryQueue","deliveryQueue","_disposed","current","reset","_listeners","_this3","_event","callback","bind","contained","removeMonitor","ceil","EventDeliveryQueuePrivate","unregister","_removeListener","trim","register","index","indexOf","log","JSON","stringify","adjustDeliveryQueue","end","_deliver","errorHandler","onListenerError","_deliverQueue","dq","enqueue","hasListeners","createEventDeliveryQueue","PauseableEmitter","_Emitter","_this4","_callSuper","_isPaused","_eventQueue","_mergeFn","_inherits","pause","resume","size","from","_get","_getPrototypeOf","prototype","shift","DebounceEmitter","_PauseableEmitter","_this5","_delay","_this6","_handle","MicrotaskEmitter","_Emitter2","_this7","_queuedEvents","_this8","EventMultiplexer","_this9","_this10","hook","unhook","idx","splice","_this11","_this12","_this13","r","_iterator3","_step3","EventBufferer","buffers","wrapEvent","_this14","bufferEvents","pop","Relay","_this15","listening","inputEvent","inputEventListener"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/base/common/event.js"],"sourcesContent":["import { onUnexpectedError } from './errors.js';\nimport { createSingleCallFunction } from './functional.js';\nimport { combinedDisposable, Disposable, DisposableStore, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a listener is GC'ed without having been disposed. This is a LEAK.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableListenerGCedWarning = false;\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false;\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false;\nexport var Event;\n(function (Event) {\n    Event.None = () => Disposable.None;\n    function _addLeakageTraceLogic(options) {\n        if (_enableSnapshotPotentialLeakWarning) {\n            const { onDidAddListener: origListenerDidAdd } = options;\n            const stack = Stacktrace.create();\n            let count = 0;\n            options.onDidAddListener = () => {\n                if (++count === 2) {\n                    console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n                    stack.print();\n                }\n                origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();\n            };\n        }\n    }\n    /**\n     * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\n     * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\n     * result of merging events and to try prevent race conditions that could arise when using related deferred and\n     * non-deferred events.\n     *\n     * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\n     * (eg. latency of keypress to text rendered).\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function defer(event, disposable) {\n        return debounce(event, () => void 0, 0, undefined, true, undefined, disposable);\n    }\n    Event.defer = defer;\n    /**\n     * Given an event, returns another event which only fires once.\n     *\n     * @param event The event source for the new event.\n     */\n    function once(event) {\n        return (listener, thisArgs = null, disposables) => {\n            // we need this, in case the event fires during the listener call\n            let didFire = false;\n            let result = undefined;\n            result = event(e => {\n                if (didFire) {\n                    return;\n                }\n                else if (result) {\n                    result.dispose();\n                }\n                else {\n                    didFire = true;\n                }\n                return listener.call(thisArgs, e);\n            }, null, disposables);\n            if (didFire) {\n                result.dispose();\n            }\n            return result;\n        };\n    }\n    Event.once = once;\n    /**\n     * Maps an event of one type into an event of another type using a mapping function, similar to how\n     * `Array.prototype.map` works.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param map The mapping function.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function map(event, map, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n    }\n    Event.map = map;\n    /**\n     * Wraps an event in another event that performs some function on the event object before firing.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param each The function to perform on the event object.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function forEach(event, each, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\n    }\n    Event.forEach = forEach;\n    function filter(event, filter, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n    }\n    Event.filter = filter;\n    /**\n     * Given an event, returns the same event but typed as `Event<void>`.\n     */\n    function signal(event) {\n        return event;\n    }\n    Event.signal = signal;\n    function any(...events) {\n        return (listener, thisArgs = null, disposables) => {\n            const disposable = combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e))));\n            return addAndReturnDisposable(disposable, disposables);\n        };\n    }\n    Event.any = any;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function reduce(event, merge, initial, disposable) {\n        let output = initial;\n        return map(event, e => {\n            output = merge(output, e);\n            return output;\n        }, disposable);\n    }\n    Event.reduce = reduce;\n    function snapshot(event, disposable) {\n        let listener;\n        const options = {\n            onWillAddFirstListener() {\n                listener = event(emitter.fire, emitter);\n            },\n            onDidRemoveLastListener() {\n                listener === null || listener === void 0 ? void 0 : listener.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n        return emitter.event;\n    }\n    /**\n     * Adds the IDisposable to the store if it's set, and returns it. Useful to\n     * Event function implementation.\n     */\n    function addAndReturnDisposable(d, store) {\n        if (store instanceof Array) {\n            store.push(d);\n        }\n        else if (store) {\n            store.add(d);\n        }\n        return d;\n    }\n    function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {\n        let subscription;\n        let output = undefined;\n        let handle = undefined;\n        let numDebouncedCalls = 0;\n        let doFire;\n        const options = {\n            leakWarningThreshold,\n            onWillAddFirstListener() {\n                subscription = event(cur => {\n                    numDebouncedCalls++;\n                    output = merge(output, cur);\n                    if (leading && !handle) {\n                        emitter.fire(output);\n                        output = undefined;\n                    }\n                    doFire = () => {\n                        const _output = output;\n                        output = undefined;\n                        handle = undefined;\n                        if (!leading || numDebouncedCalls > 1) {\n                            emitter.fire(_output);\n                        }\n                        numDebouncedCalls = 0;\n                    };\n                    if (typeof delay === 'number') {\n                        clearTimeout(handle);\n                        handle = setTimeout(doFire, delay);\n                    }\n                    else {\n                        if (handle === undefined) {\n                            handle = 0;\n                            queueMicrotask(doFire);\n                        }\n                    }\n                });\n            },\n            onWillRemoveListener() {\n                if (flushOnListenerRemove && numDebouncedCalls > 0) {\n                    doFire === null || doFire === void 0 ? void 0 : doFire();\n                }\n            },\n            onDidRemoveLastListener() {\n                doFire = undefined;\n                subscription.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n        return emitter.event;\n    }\n    Event.debounce = debounce;\n    /**\n     * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function accumulate(event, delay = 0, disposable) {\n        return Event.debounce(event, (last, e) => {\n            if (!last) {\n                return [e];\n            }\n            last.push(e);\n            return last;\n        }, delay, undefined, true, undefined, disposable);\n    }\n    Event.accumulate = accumulate;\n    /**\n     * Filters an event such that some condition is _not_ met more than once in a row, effectively ensuring duplicate\n     * event objects from different sources do not fire the same event object.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param equals The equality condition.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     *\n     * @example\n     * ```\n     * // Fire only one time when a single window is opened or focused\n     * Event.latch(Event.any(onDidOpenWindow, onDidFocusWindow))\n     * ```\n     */\n    function latch(event, equals = (a, b) => a === b, disposable) {\n        let firstCall = true;\n        let cache;\n        return filter(event, value => {\n            const shouldEmit = firstCall || !equals(value, cache);\n            firstCall = false;\n            cache = value;\n            return shouldEmit;\n        }, disposable);\n    }\n    Event.latch = latch;\n    /**\n     * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @example\n     * ```\n     * const event = new EventEmitter<number | undefined>().event;\n     * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\n     * ```\n     *\n     * @param event The event source for the new event.\n     * @param isT A function that determines what event is of the first type.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function split(event, isT, disposable) {\n        return [\n            Event.filter(event, isT, disposable),\n            Event.filter(event, e => !isT(e), disposable),\n        ];\n    }\n    Event.split = split;\n    /**\n     * Buffers an event until it has a listener attached.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param flushAfterTimeout Determines whether to flush the buffer after a timeout immediately or after a\n     * `setTimeout` when the first event listener is added.\n     * @param _buffer Internal: A source event array used for tests.\n     *\n     * @example\n     * ```\n     * // Start accumulating events, when the first listener is attached, flush\n     * // the event after a timeout such that multiple listeners attached before\n     * // the timeout would receive the event\n     * this.onInstallExtension = Event.buffer(service.onInstallExtension, true);\n     * ```\n     */\n    function buffer(event, flushAfterTimeout = false, _buffer = [], disposable) {\n        let buffer = _buffer.slice();\n        let listener = event(e => {\n            if (buffer) {\n                buffer.push(e);\n            }\n            else {\n                emitter.fire(e);\n            }\n        });\n        if (disposable) {\n            disposable.add(listener);\n        }\n        const flush = () => {\n            buffer === null || buffer === void 0 ? void 0 : buffer.forEach(e => emitter.fire(e));\n            buffer = null;\n        };\n        const emitter = new Emitter({\n            onWillAddFirstListener() {\n                if (!listener) {\n                    listener = event(e => emitter.fire(e));\n                    if (disposable) {\n                        disposable.add(listener);\n                    }\n                }\n            },\n            onDidAddFirstListener() {\n                if (buffer) {\n                    if (flushAfterTimeout) {\n                        setTimeout(flush);\n                    }\n                    else {\n                        flush();\n                    }\n                }\n            },\n            onDidRemoveLastListener() {\n                if (listener) {\n                    listener.dispose();\n                }\n                listener = null;\n            }\n        });\n        if (disposable) {\n            disposable.add(emitter);\n        }\n        return emitter.event;\n    }\n    Event.buffer = buffer;\n    /**\n     * Wraps the event in an {@link IChainableEvent}, allowing a more functional programming style.\n     *\n     * @example\n     * ```\n     * // Normal\n     * const onEnterPressNormal = Event.filter(\n     *   Event.map(onKeyPress.event, e => new StandardKeyboardEvent(e)),\n     *   e.keyCode === KeyCode.Enter\n     * ).event;\n     *\n     * // Using chain\n     * const onEnterPressChain = Event.chain(onKeyPress.event, $ => $\n     *   .map(e => new StandardKeyboardEvent(e))\n     *   .filter(e => e.keyCode === KeyCode.Enter)\n     * );\n     * ```\n     */\n    function chain(event, sythensize) {\n        const fn = (listener, thisArgs, disposables) => {\n            const cs = sythensize(new ChainableSynthesis());\n            return event(function (value) {\n                const result = cs.evaluate(value);\n                if (result !== HaltChainable) {\n                    listener.call(thisArgs, result);\n                }\n            }, undefined, disposables);\n        };\n        return fn;\n    }\n    Event.chain = chain;\n    const HaltChainable = Symbol('HaltChainable');\n    class ChainableSynthesis {\n        constructor() {\n            this.steps = [];\n        }\n        map(fn) {\n            this.steps.push(fn);\n            return this;\n        }\n        forEach(fn) {\n            this.steps.push(v => {\n                fn(v);\n                return v;\n            });\n            return this;\n        }\n        filter(fn) {\n            this.steps.push(v => fn(v) ? v : HaltChainable);\n            return this;\n        }\n        reduce(merge, initial) {\n            let last = initial;\n            this.steps.push(v => {\n                last = merge(last, v);\n                return last;\n            });\n            return this;\n        }\n        latch(equals = (a, b) => a === b) {\n            let firstCall = true;\n            let cache;\n            this.steps.push(value => {\n                const shouldEmit = firstCall || !equals(value, cache);\n                firstCall = false;\n                cache = value;\n                return shouldEmit ? value : HaltChainable;\n            });\n            return this;\n        }\n        evaluate(value) {\n            for (const step of this.steps) {\n                value = step(value);\n                if (value === HaltChainable) {\n                    break;\n                }\n            }\n            return value;\n        }\n    }\n    /**\n     * Creates an {@link Event} from a node event emitter.\n     */\n    function fromNodeEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.on(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\n    /**\n     * Creates an {@link Event} from a DOM event emitter.\n     */\n    function fromDOMEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\n    /**\n     * Creates a promise out of an event, using the {@link Event.once} helper.\n     */\n    function toPromise(event) {\n        return new Promise(resolve => once(event)(resolve));\n    }\n    Event.toPromise = toPromise;\n    /**\n     * Creates an event out of a promise that fires once when the promise is\n     * resolved with the result of the promise or `undefined`.\n     */\n    function fromPromise(promise) {\n        const result = new Emitter();\n        promise.then(res => {\n            result.fire(res);\n        }, () => {\n            result.fire(undefined);\n        }).finally(() => {\n            result.dispose();\n        });\n        return result.event;\n    }\n    Event.fromPromise = fromPromise;\n    function runAndSubscribe(event, handler, initial) {\n        handler(initial);\n        return event(e => handler(e));\n    }\n    Event.runAndSubscribe = runAndSubscribe;\n    class EmitterObserver {\n        constructor(_observable, store) {\n            this._observable = _observable;\n            this._counter = 0;\n            this._hasChanged = false;\n            const options = {\n                onWillAddFirstListener: () => {\n                    _observable.addObserver(this);\n                },\n                onDidRemoveLastListener: () => {\n                    _observable.removeObserver(this);\n                }\n            };\n            if (!store) {\n                _addLeakageTraceLogic(options);\n            }\n            this.emitter = new Emitter(options);\n            if (store) {\n                store.add(this.emitter);\n            }\n        }\n        beginUpdate(_observable) {\n            // assert(_observable === this.obs);\n            this._counter++;\n        }\n        handlePossibleChange(_observable) {\n            // assert(_observable === this.obs);\n        }\n        handleChange(_observable, _change) {\n            // assert(_observable === this.obs);\n            this._hasChanged = true;\n        }\n        endUpdate(_observable) {\n            // assert(_observable === this.obs);\n            this._counter--;\n            if (this._counter === 0) {\n                this._observable.reportChanges();\n                if (this._hasChanged) {\n                    this._hasChanged = false;\n                    this.emitter.fire(this._observable.get());\n                }\n            }\n        }\n    }\n    /**\n     * Creates an event emitter that is fired when the observable changes.\n     * Each listeners subscribes to the emitter.\n     */\n    function fromObservable(obs, store) {\n        const observer = new EmitterObserver(obs, store);\n        return observer.emitter.event;\n    }\n    Event.fromObservable = fromObservable;\n    /**\n     * Each listener is attached to the observable directly.\n     */\n    function fromObservableLight(observable) {\n        return (listener, thisArgs, disposables) => {\n            let count = 0;\n            let didChange = false;\n            const observer = {\n                beginUpdate() {\n                    count++;\n                },\n                endUpdate() {\n                    count--;\n                    if (count === 0) {\n                        observable.reportChanges();\n                        if (didChange) {\n                            didChange = false;\n                            listener.call(thisArgs);\n                        }\n                    }\n                },\n                handlePossibleChange() {\n                    // noop\n                },\n                handleChange() {\n                    didChange = true;\n                }\n            };\n            observable.addObserver(observer);\n            observable.reportChanges();\n            const disposable = {\n                dispose() {\n                    observable.removeObserver(observer);\n                }\n            };\n            if (disposables instanceof DisposableStore) {\n                disposables.add(disposable);\n            }\n            else if (Array.isArray(disposables)) {\n                disposables.push(disposable);\n            }\n            return disposable;\n        };\n    }\n    Event.fromObservableLight = fromObservableLight;\n})(Event || (Event = {}));\nexport class EventProfiling {\n    constructor(name) {\n        this.listenerCount = 0;\n        this.invocationCount = 0;\n        this.elapsedOverall = 0;\n        this.durations = [];\n        this.name = `${name}_${EventProfiling._idPool++}`;\n        EventProfiling.all.add(this);\n    }\n    start(listenerCount) {\n        this._stopWatch = new StopWatch();\n        this.listenerCount = listenerCount;\n    }\n    stop() {\n        if (this._stopWatch) {\n            const elapsed = this._stopWatch.elapsed();\n            this.durations.push(elapsed);\n            this.elapsedOverall += elapsed;\n            this.invocationCount += 1;\n            this._stopWatch = undefined;\n        }\n    }\n}\nEventProfiling.all = new Set();\nEventProfiling._idPool = 0;\nlet _globalLeakWarningThreshold = -1;\nclass LeakageMonitor {\n    constructor(threshold, name = Math.random().toString(18).slice(2, 5)) {\n        this.threshold = threshold;\n        this.name = name;\n        this._warnCountdown = 0;\n    }\n    dispose() {\n        var _a;\n        (_a = this._stacks) === null || _a === void 0 ? void 0 : _a.clear();\n    }\n    check(stack, listenerCount) {\n        const threshold = this.threshold;\n        if (threshold <= 0 || listenerCount < threshold) {\n            return undefined;\n        }\n        if (!this._stacks) {\n            this._stacks = new Map();\n        }\n        const count = (this._stacks.get(stack.value) || 0);\n        this._stacks.set(stack.value, count + 1);\n        this._warnCountdown -= 1;\n        if (this._warnCountdown <= 0) {\n            // only warn on first exceed and then every time the limit\n            // is exceeded by 50% again\n            this._warnCountdown = threshold * 0.5;\n            // find most frequent listener and print warning\n            let topStack;\n            let topCount = 0;\n            for (const [stack, count] of this._stacks) {\n                if (!topStack || topCount < count) {\n                    topStack = stack;\n                    topCount = count;\n                }\n            }\n            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n            console.warn(topStack);\n        }\n        return () => {\n            const count = (this._stacks.get(stack.value) || 0);\n            this._stacks.set(stack.value, count - 1);\n        };\n    }\n}\nclass Stacktrace {\n    static create() {\n        var _a;\n        return new Stacktrace((_a = new Error().stack) !== null && _a !== void 0 ? _a : '');\n    }\n    constructor(value) {\n        this.value = value;\n    }\n    print() {\n        console.warn(this.value.split('\\n').slice(2).join('\\n'));\n    }\n}\nclass UniqueContainer {\n    constructor(value) {\n        this.value = value;\n    }\n}\nconst compactionThreshold = 2;\nconst forEachListener = (listeners, fn) => {\n    if (listeners instanceof UniqueContainer) {\n        fn(listeners);\n    }\n    else {\n        for (let i = 0; i < listeners.length; i++) {\n            const l = listeners[i];\n            if (l) {\n                fn(l);\n            }\n        }\n    }\n};\nconst _listenerFinalizers = _enableListenerGCedWarning\n    ? new FinalizationRegistry(heldValue => {\n        if (typeof heldValue === 'string') {\n            console.warn('[LEAKING LISTENER] GC\\'ed a listener that was NOT yet disposed. This is where is was created:');\n            console.warn(heldValue);\n        }\n    })\n    : undefined;\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nexport class Emitter {\n    constructor(options) {\n        var _a, _b, _c, _d, _e;\n        this._size = 0;\n        this._options = options;\n        this._leakageMon = _globalLeakWarningThreshold > 0 || ((_a = this._options) === null || _a === void 0 ? void 0 : _a.leakWarningThreshold) ? new LeakageMonitor((_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.leakWarningThreshold) !== null && _c !== void 0 ? _c : _globalLeakWarningThreshold) : undefined;\n        this._perfMon = ((_d = this._options) === null || _d === void 0 ? void 0 : _d._profName) ? new EventProfiling(this._options._profName) : undefined;\n        this._deliveryQueue = (_e = this._options) === null || _e === void 0 ? void 0 : _e.deliveryQueue;\n    }\n    dispose() {\n        var _a, _b, _c, _d;\n        if (!this._disposed) {\n            this._disposed = true;\n            // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n            // alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n            // unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n            // the following programming pattern is very popular:\n            //\n            // const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n            // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n            // ...later...\n            // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n            if (((_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.current) === this) {\n                this._deliveryQueue.reset();\n            }\n            if (this._listeners) {\n                if (_enableDisposeWithListenerWarning) {\n                    const listeners = this._listeners;\n                    queueMicrotask(() => {\n                        forEachListener(listeners, l => { var _a; return (_a = l.stack) === null || _a === void 0 ? void 0 : _a.print(); });\n                    });\n                }\n                this._listeners = undefined;\n                this._size = 0;\n            }\n            (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onDidRemoveLastListener) === null || _c === void 0 ? void 0 : _c.call(_b);\n            (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();\n        }\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        var _a;\n        (_a = this._event) !== null && _a !== void 0 ? _a : (this._event = (callback, thisArgs, disposables) => {\n            var _a, _b, _c, _d, _e;\n            if (this._leakageMon && this._size > this._leakageMon.threshold * 3) {\n                console.warn(`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`);\n                return Disposable.None;\n            }\n            if (this._disposed) {\n                // todo: should we warn if a listener is added to a disposed emitter? This happens often\n                return Disposable.None;\n            }\n            if (thisArgs) {\n                callback = callback.bind(thisArgs);\n            }\n            const contained = new UniqueContainer(callback);\n            let removeMonitor;\n            let stack;\n            if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {\n                // check and record this emitter for potential leakage\n                contained.stack = Stacktrace.create();\n                removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);\n            }\n            if (_enableDisposeWithListenerWarning) {\n                contained.stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();\n            }\n            if (!this._listeners) {\n                (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.onWillAddFirstListener) === null || _b === void 0 ? void 0 : _b.call(_a, this);\n                this._listeners = contained;\n                (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidAddFirstListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);\n            }\n            else if (this._listeners instanceof UniqueContainer) {\n                (_e = this._deliveryQueue) !== null && _e !== void 0 ? _e : (this._deliveryQueue = new EventDeliveryQueuePrivate());\n                this._listeners = [this._listeners, contained];\n            }\n            else {\n                this._listeners.push(contained);\n            }\n            this._size++;\n            const result = toDisposable(() => {\n                _listenerFinalizers === null || _listenerFinalizers === void 0 ? void 0 : _listenerFinalizers.unregister(result);\n                removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor();\n                this._removeListener(contained);\n            });\n            if (disposables instanceof DisposableStore) {\n                disposables.add(result);\n            }\n            else if (Array.isArray(disposables)) {\n                disposables.push(result);\n            }\n            if (_listenerFinalizers) {\n                const stack = new Error().stack.split('\\n').slice(2).join('\\n').trim();\n                _listenerFinalizers.register(result, stack, result);\n            }\n            return result;\n        });\n        return this._event;\n    }\n    _removeListener(listener) {\n        var _a, _b, _c, _d;\n        (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.onWillRemoveListener) === null || _b === void 0 ? void 0 : _b.call(_a, this);\n        if (!this._listeners) {\n            return; // expected if a listener gets disposed\n        }\n        if (this._size === 1) {\n            this._listeners = undefined;\n            (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidRemoveLastListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);\n            this._size = 0;\n            return;\n        }\n        // size > 1 which requires that listeners be a list:\n        const listeners = this._listeners;\n        const index = listeners.indexOf(listener);\n        if (index === -1) {\n            console.log('disposed?', this._disposed);\n            console.log('size?', this._size);\n            console.log('arr?', JSON.stringify(this._listeners));\n            throw new Error('Attempted to dispose unknown listener');\n        }\n        this._size--;\n        listeners[index] = undefined;\n        const adjustDeliveryQueue = this._deliveryQueue.current === this;\n        if (this._size * compactionThreshold <= listeners.length) {\n            let n = 0;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listeners[i]) {\n                    listeners[n++] = listeners[i];\n                }\n                else if (adjustDeliveryQueue) {\n                    this._deliveryQueue.end--;\n                    if (n < this._deliveryQueue.i) {\n                        this._deliveryQueue.i--;\n                    }\n                }\n            }\n            listeners.length = n;\n        }\n    }\n    _deliver(listener, value) {\n        var _a;\n        if (!listener) {\n            return;\n        }\n        const errorHandler = ((_a = this._options) === null || _a === void 0 ? void 0 : _a.onListenerError) || onUnexpectedError;\n        if (!errorHandler) {\n            listener.value(value);\n            return;\n        }\n        try {\n            listener.value(value);\n        }\n        catch (e) {\n            errorHandler(e);\n        }\n    }\n    /** Delivers items in the queue. Assumes the queue is ready to go. */\n    _deliverQueue(dq) {\n        const listeners = dq.current._listeners;\n        while (dq.i < dq.end) {\n            // important: dq.i is incremented before calling deliver() because it might reenter deliverQueue()\n            this._deliver(listeners[dq.i++], dq.value);\n        }\n        dq.reset();\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        var _a, _b, _c, _d;\n        if ((_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.current) {\n            this._deliverQueue(this._deliveryQueue);\n            (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch\n        }\n        (_c = this._perfMon) === null || _c === void 0 ? void 0 : _c.start(this._size);\n        if (!this._listeners) {\n            // no-op\n        }\n        else if (this._listeners instanceof UniqueContainer) {\n            this._deliver(this._listeners, event);\n        }\n        else {\n            const dq = this._deliveryQueue;\n            dq.enqueue(this, event, this._listeners.length);\n            this._deliverQueue(dq);\n        }\n        (_d = this._perfMon) === null || _d === void 0 ? void 0 : _d.stop();\n    }\n    hasListeners() {\n        return this._size > 0;\n    }\n}\nexport const createEventDeliveryQueue = () => new EventDeliveryQueuePrivate();\nclass EventDeliveryQueuePrivate {\n    constructor() {\n        /**\n         * Index in current's listener list.\n         */\n        this.i = -1;\n        /**\n         * The last index in the listener's list to deliver.\n         */\n        this.end = 0;\n    }\n    enqueue(emitter, value, end) {\n        this.i = 0;\n        this.end = end;\n        this.current = emitter;\n        this.value = value;\n    }\n    reset() {\n        this.i = this.end; // force any current emission loop to stop, mainly for during dispose\n        this.current = undefined;\n        this.value = undefined;\n    }\n}\nexport class PauseableEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._isPaused = 0;\n        this._eventQueue = new LinkedList();\n        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n    }\n    pause() {\n        this._isPaused++;\n    }\n    resume() {\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\n            if (this._mergeFn) {\n                // use the merge function to create a single composite\n                // event. make a copy in case firing pauses this emitter\n                if (this._eventQueue.size > 0) {\n                    const events = Array.from(this._eventQueue);\n                    this._eventQueue.clear();\n                    super.fire(this._mergeFn(events));\n                }\n            }\n            else {\n                // no merging, fire each event individually and test\n                // that this emitter isn't paused halfway through\n                while (!this._isPaused && this._eventQueue.size !== 0) {\n                    super.fire(this._eventQueue.shift());\n                }\n            }\n        }\n    }\n    fire(event) {\n        if (this._size) {\n            if (this._isPaused !== 0) {\n                this._eventQueue.push(event);\n            }\n            else {\n                super.fire(event);\n            }\n        }\n    }\n}\nexport class DebounceEmitter extends PauseableEmitter {\n    constructor(options) {\n        var _a;\n        super(options);\n        this._delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 100;\n    }\n    fire(event) {\n        if (!this._handle) {\n            this.pause();\n            this._handle = setTimeout(() => {\n                this._handle = undefined;\n                this.resume();\n            }, this._delay);\n        }\n        super.fire(event);\n    }\n}\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nexport class MicrotaskEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._queuedEvents = [];\n        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n    }\n    fire(event) {\n        if (!this.hasListeners()) {\n            return;\n        }\n        this._queuedEvents.push(event);\n        if (this._queuedEvents.length === 1) {\n            queueMicrotask(() => {\n                if (this._mergeFn) {\n                    super.fire(this._mergeFn(this._queuedEvents));\n                }\n                else {\n                    this._queuedEvents.forEach(e => super.fire(e));\n                }\n                this._queuedEvents = [];\n            });\n        }\n    }\n}\n/**\n * An event emitter that multiplexes many events into a single event.\n *\n * @example Listen to the `onData` event of all `Thing`s, dynamically adding and removing `Thing`s\n * to the multiplexer as needed.\n *\n * ```typescript\n * const anythingDataMultiplexer = new EventMultiplexer<{ data: string }>();\n *\n * const thingListeners = DisposableMap<Thing, IDisposable>();\n *\n * thingService.onDidAddThing(thing => {\n *   thingListeners.set(thing, anythingDataMultiplexer.add(thing.onData);\n * });\n * thingService.onDidRemoveThing(thing => {\n *   thingListeners.deleteAndDispose(thing);\n * });\n *\n * anythingDataMultiplexer.event(e => {\n *   console.log('Something fired data ' + e.data)\n * });\n * ```\n */\nexport class EventMultiplexer {\n    constructor() {\n        this.hasListeners = false;\n        this.events = [];\n        this.emitter = new Emitter({\n            onWillAddFirstListener: () => this.onFirstListenerAdd(),\n            onDidRemoveLastListener: () => this.onLastListenerRemove()\n        });\n    }\n    get event() {\n        return this.emitter.event;\n    }\n    add(event) {\n        const e = { event: event, listener: null };\n        this.events.push(e);\n        if (this.hasListeners) {\n            this.hook(e);\n        }\n        const dispose = () => {\n            if (this.hasListeners) {\n                this.unhook(e);\n            }\n            const idx = this.events.indexOf(e);\n            this.events.splice(idx, 1);\n        };\n        return toDisposable(createSingleCallFunction(dispose));\n    }\n    onFirstListenerAdd() {\n        this.hasListeners = true;\n        this.events.forEach(e => this.hook(e));\n    }\n    onLastListenerRemove() {\n        this.hasListeners = false;\n        this.events.forEach(e => this.unhook(e));\n    }\n    hook(e) {\n        e.listener = e.event(r => this.emitter.fire(r));\n    }\n    unhook(e) {\n        var _a;\n        (_a = e.listener) === null || _a === void 0 ? void 0 : _a.dispose();\n        e.listener = null;\n    }\n    dispose() {\n        var _a;\n        this.emitter.dispose();\n        for (const e of this.events) {\n            (_a = e.listener) === null || _a === void 0 ? void 0 : _a.dispose();\n        }\n        this.events = [];\n    }\n}\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n    constructor() {\n        this.buffers = [];\n    }\n    wrapEvent(event) {\n        return (listener, thisArgs, disposables) => {\n            return event(i => {\n                const buffer = this.buffers[this.buffers.length - 1];\n                if (buffer) {\n                    buffer.push(() => listener.call(thisArgs, i));\n                }\n                else {\n                    listener.call(thisArgs, i);\n                }\n            }, undefined, disposables);\n        };\n    }\n    bufferEvents(fn) {\n        const buffer = [];\n        this.buffers.push(buffer);\n        const r = fn();\n        this.buffers.pop();\n        buffer.forEach(flush => flush());\n        return r;\n    }\n}\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay {\n    constructor() {\n        this.listening = false;\n        this.inputEvent = Event.None;\n        this.inputEventListener = Disposable.None;\n        this.emitter = new Emitter({\n            onDidAddFirstListener: () => {\n                this.listening = true;\n                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n            },\n            onDidRemoveLastListener: () => {\n                this.listening = false;\n                this.inputEventListener.dispose();\n            }\n        });\n        this.event = this.emitter.event;\n    }\n    set input(event) {\n        this.inputEvent = event;\n        if (this.listening) {\n            this.inputEventListener.dispose();\n            this.inputEventListener = event(this.emitter.fire, this.emitter);\n        }\n    }\n    dispose() {\n        this.inputEventListener.dispose();\n        this.emitter.dispose();\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}