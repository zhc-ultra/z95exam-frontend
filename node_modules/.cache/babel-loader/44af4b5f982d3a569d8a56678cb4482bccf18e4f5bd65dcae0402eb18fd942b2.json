{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.splice.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport { createTrustedTypesPolicy } from '../../../base/browser/trustedTypes.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { StringBuilder } from '../../common/core/stringBuilder.js';\nexport var RenderedLinesCollection = /*#__PURE__*/function () {\n  function RenderedLinesCollection(createLine) {\n    _classCallCheck(this, RenderedLinesCollection);\n    this._createLine = createLine;\n    this._set(1, []);\n  }\n  return _createClass(RenderedLinesCollection, [{\n    key: \"flush\",\n    value: function flush() {\n      this._set(1, []);\n    }\n  }, {\n    key: \"_set\",\n    value: function _set(rendLineNumberStart, lines) {\n      this._lines = lines;\n      this._rendLineNumberStart = rendLineNumberStart;\n    }\n  }, {\n    key: \"_get\",\n    value: function _get() {\n      return {\n        rendLineNumberStart: this._rendLineNumberStart,\n        lines: this._lines\n      };\n    }\n    /**\n     * @returns Inclusive line number that is inside this collection\n     */\n  }, {\n    key: \"getStartLineNumber\",\n    value: function getStartLineNumber() {\n      return this._rendLineNumberStart;\n    }\n    /**\n     * @returns Inclusive line number that is inside this collection\n     */\n  }, {\n    key: \"getEndLineNumber\",\n    value: function getEndLineNumber() {\n      return this._rendLineNumberStart + this._lines.length - 1;\n    }\n  }, {\n    key: \"getCount\",\n    value: function getCount() {\n      return this._lines.length;\n    }\n  }, {\n    key: \"getLine\",\n    value: function getLine(lineNumber) {\n      var lineIndex = lineNumber - this._rendLineNumberStart;\n      if (lineIndex < 0 || lineIndex >= this._lines.length) {\n        throw new BugIndicatingError('Illegal value for lineNumber');\n      }\n      return this._lines[lineIndex];\n    }\n    /**\n     * @returns Lines that were removed from this collection\n     */\n  }, {\n    key: \"onLinesDeleted\",\n    value: function onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n      if (this.getCount() === 0) {\n        // no lines\n        return null;\n      }\n      var startLineNumber = this.getStartLineNumber();\n      var endLineNumber = this.getEndLineNumber();\n      if (deleteToLineNumber < startLineNumber) {\n        // deleting above the viewport\n        var deleteCnt = deleteToLineNumber - deleteFromLineNumber + 1;\n        this._rendLineNumberStart -= deleteCnt;\n        return null;\n      }\n      if (deleteFromLineNumber > endLineNumber) {\n        // deleted below the viewport\n        return null;\n      }\n      // Record what needs to be deleted\n      var deleteStartIndex = 0;\n      var deleteCount = 0;\n      for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n        var lineIndex = lineNumber - this._rendLineNumberStart;\n        if (deleteFromLineNumber <= lineNumber && lineNumber <= deleteToLineNumber) {\n          // this is a line to be deleted\n          if (deleteCount === 0) {\n            // this is the first line to be deleted\n            deleteStartIndex = lineIndex;\n            deleteCount = 1;\n          } else {\n            deleteCount++;\n          }\n        }\n      }\n      // Adjust this._rendLineNumberStart for lines deleted above\n      if (deleteFromLineNumber < startLineNumber) {\n        // Something was deleted above\n        var deleteAboveCount = 0;\n        if (deleteToLineNumber < startLineNumber) {\n          // the entire deleted lines are above\n          deleteAboveCount = deleteToLineNumber - deleteFromLineNumber + 1;\n        } else {\n          deleteAboveCount = startLineNumber - deleteFromLineNumber;\n        }\n        this._rendLineNumberStart -= deleteAboveCount;\n      }\n      var deleted = this._lines.splice(deleteStartIndex, deleteCount);\n      return deleted;\n    }\n  }, {\n    key: \"onLinesChanged\",\n    value: function onLinesChanged(changeFromLineNumber, changeCount) {\n      var changeToLineNumber = changeFromLineNumber + changeCount - 1;\n      if (this.getCount() === 0) {\n        // no lines\n        return false;\n      }\n      var startLineNumber = this.getStartLineNumber();\n      var endLineNumber = this.getEndLineNumber();\n      var someoneNotified = false;\n      for (var changedLineNumber = changeFromLineNumber; changedLineNumber <= changeToLineNumber; changedLineNumber++) {\n        if (changedLineNumber >= startLineNumber && changedLineNumber <= endLineNumber) {\n          // Notify the line\n          this._lines[changedLineNumber - this._rendLineNumberStart].onContentChanged();\n          someoneNotified = true;\n        }\n      }\n      return someoneNotified;\n    }\n  }, {\n    key: \"onLinesInserted\",\n    value: function onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n      if (this.getCount() === 0) {\n        // no lines\n        return null;\n      }\n      var insertCnt = insertToLineNumber - insertFromLineNumber + 1;\n      var startLineNumber = this.getStartLineNumber();\n      var endLineNumber = this.getEndLineNumber();\n      if (insertFromLineNumber <= startLineNumber) {\n        // inserting above the viewport\n        this._rendLineNumberStart += insertCnt;\n        return null;\n      }\n      if (insertFromLineNumber > endLineNumber) {\n        // inserting below the viewport\n        return null;\n      }\n      if (insertCnt + insertFromLineNumber > endLineNumber) {\n        // insert inside the viewport in such a way that all remaining lines are pushed outside\n        var deleted = this._lines.splice(insertFromLineNumber - this._rendLineNumberStart, endLineNumber - insertFromLineNumber + 1);\n        return deleted;\n      }\n      // insert inside the viewport, push out some lines, but not all remaining lines\n      var newLines = [];\n      for (var i = 0; i < insertCnt; i++) {\n        newLines[i] = this._createLine();\n      }\n      var insertIndex = insertFromLineNumber - this._rendLineNumberStart;\n      var beforeLines = this._lines.slice(0, insertIndex);\n      var afterLines = this._lines.slice(insertIndex, this._lines.length - insertCnt);\n      var deletedLines = this._lines.slice(this._lines.length - insertCnt, this._lines.length);\n      this._lines = beforeLines.concat(newLines).concat(afterLines);\n      return deletedLines;\n    }\n  }, {\n    key: \"onTokensChanged\",\n    value: function onTokensChanged(ranges) {\n      if (this.getCount() === 0) {\n        // no lines\n        return false;\n      }\n      var startLineNumber = this.getStartLineNumber();\n      var endLineNumber = this.getEndLineNumber();\n      var notifiedSomeone = false;\n      for (var i = 0, len = ranges.length; i < len; i++) {\n        var rng = ranges[i];\n        if (rng.toLineNumber < startLineNumber || rng.fromLineNumber > endLineNumber) {\n          // range outside viewport\n          continue;\n        }\n        var from = Math.max(startLineNumber, rng.fromLineNumber);\n        var to = Math.min(endLineNumber, rng.toLineNumber);\n        for (var lineNumber = from; lineNumber <= to; lineNumber++) {\n          var lineIndex = lineNumber - this._rendLineNumberStart;\n          this._lines[lineIndex].onTokensChanged();\n          notifiedSomeone = true;\n        }\n      }\n      return notifiedSomeone;\n    }\n  }]);\n}();\nexport var VisibleLinesCollection = /*#__PURE__*/function () {\n  function VisibleLinesCollection(host) {\n    var _this = this;\n    _classCallCheck(this, VisibleLinesCollection);\n    this._host = host;\n    this.domNode = this._createDomNode();\n    this._linesCollection = new RenderedLinesCollection(function () {\n      return _this._host.createVisibleLine();\n    });\n  }\n  return _createClass(VisibleLinesCollection, [{\n    key: \"_createDomNode\",\n    value: function _createDomNode() {\n      var domNode = createFastDomNode(document.createElement('div'));\n      domNode.setClassName('view-layer');\n      domNode.setPosition('absolute');\n      domNode.domNode.setAttribute('role', 'presentation');\n      domNode.domNode.setAttribute('aria-hidden', 'true');\n      return domNode;\n    }\n    // ---- begin view event handlers\n  }, {\n    key: \"onConfigurationChanged\",\n    value: function onConfigurationChanged(e) {\n      if (e.hasChanged(145 /* EditorOption.layoutInfo */)) {\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"onFlushed\",\n    value: function onFlushed(e) {\n      this._linesCollection.flush();\n      // No need to clear the dom node because a full .innerHTML will occur in ViewLayerRenderer._render\n      return true;\n    }\n  }, {\n    key: \"onLinesChanged\",\n    value: function onLinesChanged(e) {\n      return this._linesCollection.onLinesChanged(e.fromLineNumber, e.count);\n    }\n  }, {\n    key: \"onLinesDeleted\",\n    value: function onLinesDeleted(e) {\n      var deleted = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n      if (deleted) {\n        // Remove from DOM\n        for (var i = 0, len = deleted.length; i < len; i++) {\n          var lineDomNode = deleted[i].getDomNode();\n          if (lineDomNode) {\n            this.domNode.domNode.removeChild(lineDomNode);\n          }\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"onLinesInserted\",\n    value: function onLinesInserted(e) {\n      var deleted = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n      if (deleted) {\n        // Remove from DOM\n        for (var i = 0, len = deleted.length; i < len; i++) {\n          var lineDomNode = deleted[i].getDomNode();\n          if (lineDomNode) {\n            this.domNode.domNode.removeChild(lineDomNode);\n          }\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"onScrollChanged\",\n    value: function onScrollChanged(e) {\n      return e.scrollTopChanged;\n    }\n  }, {\n    key: \"onTokensChanged\",\n    value: function onTokensChanged(e) {\n      return this._linesCollection.onTokensChanged(e.ranges);\n    }\n  }, {\n    key: \"onZonesChanged\",\n    value: function onZonesChanged(e) {\n      return true;\n    }\n    // ---- end view event handlers\n  }, {\n    key: \"getStartLineNumber\",\n    value: function getStartLineNumber() {\n      return this._linesCollection.getStartLineNumber();\n    }\n  }, {\n    key: \"getEndLineNumber\",\n    value: function getEndLineNumber() {\n      return this._linesCollection.getEndLineNumber();\n    }\n  }, {\n    key: \"getVisibleLine\",\n    value: function getVisibleLine(lineNumber) {\n      return this._linesCollection.getLine(lineNumber);\n    }\n  }, {\n    key: \"renderLines\",\n    value: function renderLines(viewportData) {\n      var inp = this._linesCollection._get();\n      var renderer = new ViewLayerRenderer(this.domNode.domNode, this._host, viewportData);\n      var ctx = {\n        rendLineNumberStart: inp.rendLineNumberStart,\n        lines: inp.lines,\n        linesLength: inp.lines.length\n      };\n      // Decide if this render will do a single update (single large .innerHTML) or many updates (inserting/removing dom nodes)\n      var resCtx = renderer.render(ctx, viewportData.startLineNumber, viewportData.endLineNumber, viewportData.relativeVerticalOffset);\n      this._linesCollection._set(resCtx.rendLineNumberStart, resCtx.lines);\n    }\n  }]);\n}();\nvar ViewLayerRenderer = /*#__PURE__*/function () {\n  function ViewLayerRenderer(domNode, host, viewportData) {\n    _classCallCheck(this, ViewLayerRenderer);\n    this.domNode = domNode;\n    this.host = host;\n    this.viewportData = viewportData;\n  }\n  return _createClass(ViewLayerRenderer, [{\n    key: \"render\",\n    value: function render(inContext, startLineNumber, stopLineNumber, deltaTop) {\n      var ctx = {\n        rendLineNumberStart: inContext.rendLineNumberStart,\n        lines: inContext.lines.slice(0),\n        linesLength: inContext.linesLength\n      };\n      if (ctx.rendLineNumberStart + ctx.linesLength - 1 < startLineNumber || stopLineNumber < ctx.rendLineNumberStart) {\n        // There is no overlap whatsoever\n        ctx.rendLineNumberStart = startLineNumber;\n        ctx.linesLength = stopLineNumber - startLineNumber + 1;\n        ctx.lines = [];\n        for (var x = startLineNumber; x <= stopLineNumber; x++) {\n          ctx.lines[x - startLineNumber] = this.host.createVisibleLine();\n        }\n        this._finishRendering(ctx, true, deltaTop);\n        return ctx;\n      }\n      // Update lines which will remain untouched\n      this._renderUntouchedLines(ctx, Math.max(startLineNumber - ctx.rendLineNumberStart, 0), Math.min(stopLineNumber - ctx.rendLineNumberStart, ctx.linesLength - 1), deltaTop, startLineNumber);\n      if (ctx.rendLineNumberStart > startLineNumber) {\n        // Insert lines before\n        var fromLineNumber = startLineNumber;\n        var toLineNumber = Math.min(stopLineNumber, ctx.rendLineNumberStart - 1);\n        if (fromLineNumber <= toLineNumber) {\n          this._insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);\n          ctx.linesLength += toLineNumber - fromLineNumber + 1;\n        }\n      } else if (ctx.rendLineNumberStart < startLineNumber) {\n        // Remove lines before\n        var removeCnt = Math.min(ctx.linesLength, startLineNumber - ctx.rendLineNumberStart);\n        if (removeCnt > 0) {\n          this._removeLinesBefore(ctx, removeCnt);\n          ctx.linesLength -= removeCnt;\n        }\n      }\n      ctx.rendLineNumberStart = startLineNumber;\n      if (ctx.rendLineNumberStart + ctx.linesLength - 1 < stopLineNumber) {\n        // Insert lines after\n        var _fromLineNumber = ctx.rendLineNumberStart + ctx.linesLength;\n        var _toLineNumber = stopLineNumber;\n        if (_fromLineNumber <= _toLineNumber) {\n          this._insertLinesAfter(ctx, _fromLineNumber, _toLineNumber, deltaTop, startLineNumber);\n          ctx.linesLength += _toLineNumber - _fromLineNumber + 1;\n        }\n      } else if (ctx.rendLineNumberStart + ctx.linesLength - 1 > stopLineNumber) {\n        // Remove lines after\n        var _fromLineNumber2 = Math.max(0, stopLineNumber - ctx.rendLineNumberStart + 1);\n        var _toLineNumber2 = ctx.linesLength - 1;\n        var _removeCnt = _toLineNumber2 - _fromLineNumber2 + 1;\n        if (_removeCnt > 0) {\n          this._removeLinesAfter(ctx, _removeCnt);\n          ctx.linesLength -= _removeCnt;\n        }\n      }\n      this._finishRendering(ctx, false, deltaTop);\n      return ctx;\n    }\n  }, {\n    key: \"_renderUntouchedLines\",\n    value: function _renderUntouchedLines(ctx, startIndex, endIndex, deltaTop, deltaLN) {\n      var rendLineNumberStart = ctx.rendLineNumberStart;\n      var lines = ctx.lines;\n      for (var i = startIndex; i <= endIndex; i++) {\n        var lineNumber = rendLineNumberStart + i;\n        lines[i].layoutLine(lineNumber, deltaTop[lineNumber - deltaLN], this.viewportData.lineHeight);\n      }\n    }\n  }, {\n    key: \"_insertLinesBefore\",\n    value: function _insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {\n      var newLines = [];\n      var newLinesLen = 0;\n      for (var lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n        newLines[newLinesLen++] = this.host.createVisibleLine();\n      }\n      ctx.lines = newLines.concat(ctx.lines);\n    }\n  }, {\n    key: \"_removeLinesBefore\",\n    value: function _removeLinesBefore(ctx, removeCount) {\n      for (var i = 0; i < removeCount; i++) {\n        var lineDomNode = ctx.lines[i].getDomNode();\n        if (lineDomNode) {\n          this.domNode.removeChild(lineDomNode);\n        }\n      }\n      ctx.lines.splice(0, removeCount);\n    }\n  }, {\n    key: \"_insertLinesAfter\",\n    value: function _insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {\n      var newLines = [];\n      var newLinesLen = 0;\n      for (var lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n        newLines[newLinesLen++] = this.host.createVisibleLine();\n      }\n      ctx.lines = ctx.lines.concat(newLines);\n    }\n  }, {\n    key: \"_removeLinesAfter\",\n    value: function _removeLinesAfter(ctx, removeCount) {\n      var removeIndex = ctx.linesLength - removeCount;\n      for (var i = 0; i < removeCount; i++) {\n        var lineDomNode = ctx.lines[removeIndex + i].getDomNode();\n        if (lineDomNode) {\n          this.domNode.removeChild(lineDomNode);\n        }\n      }\n      ctx.lines.splice(removeIndex, removeCount);\n    }\n  }, {\n    key: \"_finishRenderingNewLines\",\n    value: function _finishRenderingNewLines(ctx, domNodeIsEmpty, newLinesHTML, wasNew) {\n      if (ViewLayerRenderer._ttPolicy) {\n        newLinesHTML = ViewLayerRenderer._ttPolicy.createHTML(newLinesHTML);\n      }\n      var lastChild = this.domNode.lastChild;\n      if (domNodeIsEmpty || !lastChild) {\n        this.domNode.innerHTML = newLinesHTML; // explains the ugly casts -> https://github.com/microsoft/vscode/issues/106396#issuecomment-692625393;\n      } else {\n        lastChild.insertAdjacentHTML('afterend', newLinesHTML);\n      }\n      var currChild = this.domNode.lastChild;\n      for (var i = ctx.linesLength - 1; i >= 0; i--) {\n        var line = ctx.lines[i];\n        if (wasNew[i]) {\n          line.setDomNode(currChild);\n          currChild = currChild.previousSibling;\n        }\n      }\n    }\n  }, {\n    key: \"_finishRenderingInvalidLines\",\n    value: function _finishRenderingInvalidLines(ctx, invalidLinesHTML, wasInvalid) {\n      var hugeDomNode = document.createElement('div');\n      if (ViewLayerRenderer._ttPolicy) {\n        invalidLinesHTML = ViewLayerRenderer._ttPolicy.createHTML(invalidLinesHTML);\n      }\n      hugeDomNode.innerHTML = invalidLinesHTML;\n      for (var i = 0; i < ctx.linesLength; i++) {\n        var line = ctx.lines[i];\n        if (wasInvalid[i]) {\n          var source = hugeDomNode.firstChild;\n          var lineDomNode = line.getDomNode();\n          lineDomNode.parentNode.replaceChild(source, lineDomNode);\n          line.setDomNode(source);\n        }\n      }\n    }\n  }, {\n    key: \"_finishRendering\",\n    value: function _finishRendering(ctx, domNodeIsEmpty, deltaTop) {\n      var sb = ViewLayerRenderer._sb;\n      var linesLength = ctx.linesLength;\n      var lines = ctx.lines;\n      var rendLineNumberStart = ctx.rendLineNumberStart;\n      var wasNew = [];\n      {\n        sb.reset();\n        var hadNewLine = false;\n        for (var i = 0; i < linesLength; i++) {\n          var line = lines[i];\n          wasNew[i] = false;\n          var lineDomNode = line.getDomNode();\n          if (lineDomNode) {\n            // line is not new\n            continue;\n          }\n          var renderResult = line.renderLine(i + rendLineNumberStart, deltaTop[i], this.viewportData.lineHeight, this.viewportData, sb);\n          if (!renderResult) {\n            // line does not need rendering\n            continue;\n          }\n          wasNew[i] = true;\n          hadNewLine = true;\n        }\n        if (hadNewLine) {\n          this._finishRenderingNewLines(ctx, domNodeIsEmpty, sb.build(), wasNew);\n        }\n      }\n      {\n        sb.reset();\n        var hadInvalidLine = false;\n        var wasInvalid = [];\n        for (var _i = 0; _i < linesLength; _i++) {\n          var _line = lines[_i];\n          wasInvalid[_i] = false;\n          if (wasNew[_i]) {\n            // line was new\n            continue;\n          }\n          var _renderResult = _line.renderLine(_i + rendLineNumberStart, deltaTop[_i], this.viewportData.lineHeight, this.viewportData, sb);\n          if (!_renderResult) {\n            // line does not need rendering\n            continue;\n          }\n          wasInvalid[_i] = true;\n          hadInvalidLine = true;\n        }\n        if (hadInvalidLine) {\n          this._finishRenderingInvalidLines(ctx, sb.build(), wasInvalid);\n        }\n      }\n    }\n  }]);\n}();\nViewLayerRenderer._ttPolicy = createTrustedTypesPolicy('editorViewLayer', {\n  createHTML: function createHTML(value) {\n    return value;\n  }\n});\nViewLayerRenderer._sb = new StringBuilder(100000);","map":{"version":3,"names":["createFastDomNode","createTrustedTypesPolicy","BugIndicatingError","StringBuilder","RenderedLinesCollection","createLine","_classCallCheck","_createLine","_set","_createClass","key","value","flush","rendLineNumberStart","lines","_lines","_rendLineNumberStart","_get","getStartLineNumber","getEndLineNumber","length","getCount","getLine","lineNumber","lineIndex","onLinesDeleted","deleteFromLineNumber","deleteToLineNumber","startLineNumber","endLineNumber","deleteCnt","deleteStartIndex","deleteCount","deleteAboveCount","deleted","splice","onLinesChanged","changeFromLineNumber","changeCount","changeToLineNumber","someoneNotified","changedLineNumber","onContentChanged","onLinesInserted","insertFromLineNumber","insertToLineNumber","insertCnt","newLines","i","insertIndex","beforeLines","slice","afterLines","deletedLines","concat","onTokensChanged","ranges","notifiedSomeone","len","rng","toLineNumber","fromLineNumber","from","Math","max","to","min","VisibleLinesCollection","host","_this","_host","domNode","_createDomNode","_linesCollection","createVisibleLine","document","createElement","setClassName","setPosition","setAttribute","onConfigurationChanged","e","hasChanged","onFlushed","count","lineDomNode","getDomNode","removeChild","onScrollChanged","scrollTopChanged","onZonesChanged","getVisibleLine","renderLines","viewportData","inp","renderer","ViewLayerRenderer","ctx","linesLength","resCtx","render","relativeVerticalOffset","inContext","stopLineNumber","deltaTop","x","_finishRendering","_renderUntouchedLines","_insertLinesBefore","removeCnt","_removeLinesBefore","_insertLinesAfter","_removeLinesAfter","startIndex","endIndex","deltaLN","layoutLine","lineHeight","newLinesLen","removeCount","removeIndex","_finishRenderingNewLines","domNodeIsEmpty","newLinesHTML","wasNew","_ttPolicy","createHTML","lastChild","innerHTML","insertAdjacentHTML","currChild","line","setDomNode","previousSibling","_finishRenderingInvalidLines","invalidLinesHTML","wasInvalid","hugeDomNode","source","firstChild","parentNode","replaceChild","sb","_sb","reset","hadNewLine","renderResult","renderLine","build","hadInvalidLine"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/browser/view/viewLayer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createFastDomNode } from '../../../base/browser/fastDomNode.js';\nimport { createTrustedTypesPolicy } from '../../../base/browser/trustedTypes.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { StringBuilder } from '../../common/core/stringBuilder.js';\nexport class RenderedLinesCollection {\n    constructor(createLine) {\n        this._createLine = createLine;\n        this._set(1, []);\n    }\n    flush() {\n        this._set(1, []);\n    }\n    _set(rendLineNumberStart, lines) {\n        this._lines = lines;\n        this._rendLineNumberStart = rendLineNumberStart;\n    }\n    _get() {\n        return {\n            rendLineNumberStart: this._rendLineNumberStart,\n            lines: this._lines\n        };\n    }\n    /**\n     * @returns Inclusive line number that is inside this collection\n     */\n    getStartLineNumber() {\n        return this._rendLineNumberStart;\n    }\n    /**\n     * @returns Inclusive line number that is inside this collection\n     */\n    getEndLineNumber() {\n        return this._rendLineNumberStart + this._lines.length - 1;\n    }\n    getCount() {\n        return this._lines.length;\n    }\n    getLine(lineNumber) {\n        const lineIndex = lineNumber - this._rendLineNumberStart;\n        if (lineIndex < 0 || lineIndex >= this._lines.length) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._lines[lineIndex];\n    }\n    /**\n     * @returns Lines that were removed from this collection\n     */\n    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n        if (this.getCount() === 0) {\n            // no lines\n            return null;\n        }\n        const startLineNumber = this.getStartLineNumber();\n        const endLineNumber = this.getEndLineNumber();\n        if (deleteToLineNumber < startLineNumber) {\n            // deleting above the viewport\n            const deleteCnt = deleteToLineNumber - deleteFromLineNumber + 1;\n            this._rendLineNumberStart -= deleteCnt;\n            return null;\n        }\n        if (deleteFromLineNumber > endLineNumber) {\n            // deleted below the viewport\n            return null;\n        }\n        // Record what needs to be deleted\n        let deleteStartIndex = 0;\n        let deleteCount = 0;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - this._rendLineNumberStart;\n            if (deleteFromLineNumber <= lineNumber && lineNumber <= deleteToLineNumber) {\n                // this is a line to be deleted\n                if (deleteCount === 0) {\n                    // this is the first line to be deleted\n                    deleteStartIndex = lineIndex;\n                    deleteCount = 1;\n                }\n                else {\n                    deleteCount++;\n                }\n            }\n        }\n        // Adjust this._rendLineNumberStart for lines deleted above\n        if (deleteFromLineNumber < startLineNumber) {\n            // Something was deleted above\n            let deleteAboveCount = 0;\n            if (deleteToLineNumber < startLineNumber) {\n                // the entire deleted lines are above\n                deleteAboveCount = deleteToLineNumber - deleteFromLineNumber + 1;\n            }\n            else {\n                deleteAboveCount = startLineNumber - deleteFromLineNumber;\n            }\n            this._rendLineNumberStart -= deleteAboveCount;\n        }\n        const deleted = this._lines.splice(deleteStartIndex, deleteCount);\n        return deleted;\n    }\n    onLinesChanged(changeFromLineNumber, changeCount) {\n        const changeToLineNumber = changeFromLineNumber + changeCount - 1;\n        if (this.getCount() === 0) {\n            // no lines\n            return false;\n        }\n        const startLineNumber = this.getStartLineNumber();\n        const endLineNumber = this.getEndLineNumber();\n        let someoneNotified = false;\n        for (let changedLineNumber = changeFromLineNumber; changedLineNumber <= changeToLineNumber; changedLineNumber++) {\n            if (changedLineNumber >= startLineNumber && changedLineNumber <= endLineNumber) {\n                // Notify the line\n                this._lines[changedLineNumber - this._rendLineNumberStart].onContentChanged();\n                someoneNotified = true;\n            }\n        }\n        return someoneNotified;\n    }\n    onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n        if (this.getCount() === 0) {\n            // no lines\n            return null;\n        }\n        const insertCnt = insertToLineNumber - insertFromLineNumber + 1;\n        const startLineNumber = this.getStartLineNumber();\n        const endLineNumber = this.getEndLineNumber();\n        if (insertFromLineNumber <= startLineNumber) {\n            // inserting above the viewport\n            this._rendLineNumberStart += insertCnt;\n            return null;\n        }\n        if (insertFromLineNumber > endLineNumber) {\n            // inserting below the viewport\n            return null;\n        }\n        if (insertCnt + insertFromLineNumber > endLineNumber) {\n            // insert inside the viewport in such a way that all remaining lines are pushed outside\n            const deleted = this._lines.splice(insertFromLineNumber - this._rendLineNumberStart, endLineNumber - insertFromLineNumber + 1);\n            return deleted;\n        }\n        // insert inside the viewport, push out some lines, but not all remaining lines\n        const newLines = [];\n        for (let i = 0; i < insertCnt; i++) {\n            newLines[i] = this._createLine();\n        }\n        const insertIndex = insertFromLineNumber - this._rendLineNumberStart;\n        const beforeLines = this._lines.slice(0, insertIndex);\n        const afterLines = this._lines.slice(insertIndex, this._lines.length - insertCnt);\n        const deletedLines = this._lines.slice(this._lines.length - insertCnt, this._lines.length);\n        this._lines = beforeLines.concat(newLines).concat(afterLines);\n        return deletedLines;\n    }\n    onTokensChanged(ranges) {\n        if (this.getCount() === 0) {\n            // no lines\n            return false;\n        }\n        const startLineNumber = this.getStartLineNumber();\n        const endLineNumber = this.getEndLineNumber();\n        let notifiedSomeone = false;\n        for (let i = 0, len = ranges.length; i < len; i++) {\n            const rng = ranges[i];\n            if (rng.toLineNumber < startLineNumber || rng.fromLineNumber > endLineNumber) {\n                // range outside viewport\n                continue;\n            }\n            const from = Math.max(startLineNumber, rng.fromLineNumber);\n            const to = Math.min(endLineNumber, rng.toLineNumber);\n            for (let lineNumber = from; lineNumber <= to; lineNumber++) {\n                const lineIndex = lineNumber - this._rendLineNumberStart;\n                this._lines[lineIndex].onTokensChanged();\n                notifiedSomeone = true;\n            }\n        }\n        return notifiedSomeone;\n    }\n}\nexport class VisibleLinesCollection {\n    constructor(host) {\n        this._host = host;\n        this.domNode = this._createDomNode();\n        this._linesCollection = new RenderedLinesCollection(() => this._host.createVisibleLine());\n    }\n    _createDomNode() {\n        const domNode = createFastDomNode(document.createElement('div'));\n        domNode.setClassName('view-layer');\n        domNode.setPosition('absolute');\n        domNode.domNode.setAttribute('role', 'presentation');\n        domNode.domNode.setAttribute('aria-hidden', 'true');\n        return domNode;\n    }\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        if (e.hasChanged(145 /* EditorOption.layoutInfo */)) {\n            return true;\n        }\n        return false;\n    }\n    onFlushed(e) {\n        this._linesCollection.flush();\n        // No need to clear the dom node because a full .innerHTML will occur in ViewLayerRenderer._render\n        return true;\n    }\n    onLinesChanged(e) {\n        return this._linesCollection.onLinesChanged(e.fromLineNumber, e.count);\n    }\n    onLinesDeleted(e) {\n        const deleted = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n        if (deleted) {\n            // Remove from DOM\n            for (let i = 0, len = deleted.length; i < len; i++) {\n                const lineDomNode = deleted[i].getDomNode();\n                if (lineDomNode) {\n                    this.domNode.domNode.removeChild(lineDomNode);\n                }\n            }\n        }\n        return true;\n    }\n    onLinesInserted(e) {\n        const deleted = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n        if (deleted) {\n            // Remove from DOM\n            for (let i = 0, len = deleted.length; i < len; i++) {\n                const lineDomNode = deleted[i].getDomNode();\n                if (lineDomNode) {\n                    this.domNode.domNode.removeChild(lineDomNode);\n                }\n            }\n        }\n        return true;\n    }\n    onScrollChanged(e) {\n        return e.scrollTopChanged;\n    }\n    onTokensChanged(e) {\n        return this._linesCollection.onTokensChanged(e.ranges);\n    }\n    onZonesChanged(e) {\n        return true;\n    }\n    // ---- end view event handlers\n    getStartLineNumber() {\n        return this._linesCollection.getStartLineNumber();\n    }\n    getEndLineNumber() {\n        return this._linesCollection.getEndLineNumber();\n    }\n    getVisibleLine(lineNumber) {\n        return this._linesCollection.getLine(lineNumber);\n    }\n    renderLines(viewportData) {\n        const inp = this._linesCollection._get();\n        const renderer = new ViewLayerRenderer(this.domNode.domNode, this._host, viewportData);\n        const ctx = {\n            rendLineNumberStart: inp.rendLineNumberStart,\n            lines: inp.lines,\n            linesLength: inp.lines.length\n        };\n        // Decide if this render will do a single update (single large .innerHTML) or many updates (inserting/removing dom nodes)\n        const resCtx = renderer.render(ctx, viewportData.startLineNumber, viewportData.endLineNumber, viewportData.relativeVerticalOffset);\n        this._linesCollection._set(resCtx.rendLineNumberStart, resCtx.lines);\n    }\n}\nclass ViewLayerRenderer {\n    constructor(domNode, host, viewportData) {\n        this.domNode = domNode;\n        this.host = host;\n        this.viewportData = viewportData;\n    }\n    render(inContext, startLineNumber, stopLineNumber, deltaTop) {\n        const ctx = {\n            rendLineNumberStart: inContext.rendLineNumberStart,\n            lines: inContext.lines.slice(0),\n            linesLength: inContext.linesLength\n        };\n        if ((ctx.rendLineNumberStart + ctx.linesLength - 1 < startLineNumber) || (stopLineNumber < ctx.rendLineNumberStart)) {\n            // There is no overlap whatsoever\n            ctx.rendLineNumberStart = startLineNumber;\n            ctx.linesLength = stopLineNumber - startLineNumber + 1;\n            ctx.lines = [];\n            for (let x = startLineNumber; x <= stopLineNumber; x++) {\n                ctx.lines[x - startLineNumber] = this.host.createVisibleLine();\n            }\n            this._finishRendering(ctx, true, deltaTop);\n            return ctx;\n        }\n        // Update lines which will remain untouched\n        this._renderUntouchedLines(ctx, Math.max(startLineNumber - ctx.rendLineNumberStart, 0), Math.min(stopLineNumber - ctx.rendLineNumberStart, ctx.linesLength - 1), deltaTop, startLineNumber);\n        if (ctx.rendLineNumberStart > startLineNumber) {\n            // Insert lines before\n            const fromLineNumber = startLineNumber;\n            const toLineNumber = Math.min(stopLineNumber, ctx.rendLineNumberStart - 1);\n            if (fromLineNumber <= toLineNumber) {\n                this._insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);\n                ctx.linesLength += toLineNumber - fromLineNumber + 1;\n            }\n        }\n        else if (ctx.rendLineNumberStart < startLineNumber) {\n            // Remove lines before\n            const removeCnt = Math.min(ctx.linesLength, startLineNumber - ctx.rendLineNumberStart);\n            if (removeCnt > 0) {\n                this._removeLinesBefore(ctx, removeCnt);\n                ctx.linesLength -= removeCnt;\n            }\n        }\n        ctx.rendLineNumberStart = startLineNumber;\n        if (ctx.rendLineNumberStart + ctx.linesLength - 1 < stopLineNumber) {\n            // Insert lines after\n            const fromLineNumber = ctx.rendLineNumberStart + ctx.linesLength;\n            const toLineNumber = stopLineNumber;\n            if (fromLineNumber <= toLineNumber) {\n                this._insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);\n                ctx.linesLength += toLineNumber - fromLineNumber + 1;\n            }\n        }\n        else if (ctx.rendLineNumberStart + ctx.linesLength - 1 > stopLineNumber) {\n            // Remove lines after\n            const fromLineNumber = Math.max(0, stopLineNumber - ctx.rendLineNumberStart + 1);\n            const toLineNumber = ctx.linesLength - 1;\n            const removeCnt = toLineNumber - fromLineNumber + 1;\n            if (removeCnt > 0) {\n                this._removeLinesAfter(ctx, removeCnt);\n                ctx.linesLength -= removeCnt;\n            }\n        }\n        this._finishRendering(ctx, false, deltaTop);\n        return ctx;\n    }\n    _renderUntouchedLines(ctx, startIndex, endIndex, deltaTop, deltaLN) {\n        const rendLineNumberStart = ctx.rendLineNumberStart;\n        const lines = ctx.lines;\n        for (let i = startIndex; i <= endIndex; i++) {\n            const lineNumber = rendLineNumberStart + i;\n            lines[i].layoutLine(lineNumber, deltaTop[lineNumber - deltaLN], this.viewportData.lineHeight);\n        }\n    }\n    _insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {\n        const newLines = [];\n        let newLinesLen = 0;\n        for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n            newLines[newLinesLen++] = this.host.createVisibleLine();\n        }\n        ctx.lines = newLines.concat(ctx.lines);\n    }\n    _removeLinesBefore(ctx, removeCount) {\n        for (let i = 0; i < removeCount; i++) {\n            const lineDomNode = ctx.lines[i].getDomNode();\n            if (lineDomNode) {\n                this.domNode.removeChild(lineDomNode);\n            }\n        }\n        ctx.lines.splice(0, removeCount);\n    }\n    _insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {\n        const newLines = [];\n        let newLinesLen = 0;\n        for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n            newLines[newLinesLen++] = this.host.createVisibleLine();\n        }\n        ctx.lines = ctx.lines.concat(newLines);\n    }\n    _removeLinesAfter(ctx, removeCount) {\n        const removeIndex = ctx.linesLength - removeCount;\n        for (let i = 0; i < removeCount; i++) {\n            const lineDomNode = ctx.lines[removeIndex + i].getDomNode();\n            if (lineDomNode) {\n                this.domNode.removeChild(lineDomNode);\n            }\n        }\n        ctx.lines.splice(removeIndex, removeCount);\n    }\n    _finishRenderingNewLines(ctx, domNodeIsEmpty, newLinesHTML, wasNew) {\n        if (ViewLayerRenderer._ttPolicy) {\n            newLinesHTML = ViewLayerRenderer._ttPolicy.createHTML(newLinesHTML);\n        }\n        const lastChild = this.domNode.lastChild;\n        if (domNodeIsEmpty || !lastChild) {\n            this.domNode.innerHTML = newLinesHTML; // explains the ugly casts -> https://github.com/microsoft/vscode/issues/106396#issuecomment-692625393;\n        }\n        else {\n            lastChild.insertAdjacentHTML('afterend', newLinesHTML);\n        }\n        let currChild = this.domNode.lastChild;\n        for (let i = ctx.linesLength - 1; i >= 0; i--) {\n            const line = ctx.lines[i];\n            if (wasNew[i]) {\n                line.setDomNode(currChild);\n                currChild = currChild.previousSibling;\n            }\n        }\n    }\n    _finishRenderingInvalidLines(ctx, invalidLinesHTML, wasInvalid) {\n        const hugeDomNode = document.createElement('div');\n        if (ViewLayerRenderer._ttPolicy) {\n            invalidLinesHTML = ViewLayerRenderer._ttPolicy.createHTML(invalidLinesHTML);\n        }\n        hugeDomNode.innerHTML = invalidLinesHTML;\n        for (let i = 0; i < ctx.linesLength; i++) {\n            const line = ctx.lines[i];\n            if (wasInvalid[i]) {\n                const source = hugeDomNode.firstChild;\n                const lineDomNode = line.getDomNode();\n                lineDomNode.parentNode.replaceChild(source, lineDomNode);\n                line.setDomNode(source);\n            }\n        }\n    }\n    _finishRendering(ctx, domNodeIsEmpty, deltaTop) {\n        const sb = ViewLayerRenderer._sb;\n        const linesLength = ctx.linesLength;\n        const lines = ctx.lines;\n        const rendLineNumberStart = ctx.rendLineNumberStart;\n        const wasNew = [];\n        {\n            sb.reset();\n            let hadNewLine = false;\n            for (let i = 0; i < linesLength; i++) {\n                const line = lines[i];\n                wasNew[i] = false;\n                const lineDomNode = line.getDomNode();\n                if (lineDomNode) {\n                    // line is not new\n                    continue;\n                }\n                const renderResult = line.renderLine(i + rendLineNumberStart, deltaTop[i], this.viewportData.lineHeight, this.viewportData, sb);\n                if (!renderResult) {\n                    // line does not need rendering\n                    continue;\n                }\n                wasNew[i] = true;\n                hadNewLine = true;\n            }\n            if (hadNewLine) {\n                this._finishRenderingNewLines(ctx, domNodeIsEmpty, sb.build(), wasNew);\n            }\n        }\n        {\n            sb.reset();\n            let hadInvalidLine = false;\n            const wasInvalid = [];\n            for (let i = 0; i < linesLength; i++) {\n                const line = lines[i];\n                wasInvalid[i] = false;\n                if (wasNew[i]) {\n                    // line was new\n                    continue;\n                }\n                const renderResult = line.renderLine(i + rendLineNumberStart, deltaTop[i], this.viewportData.lineHeight, this.viewportData, sb);\n                if (!renderResult) {\n                    // line does not need rendering\n                    continue;\n                }\n                wasInvalid[i] = true;\n                hadInvalidLine = true;\n            }\n            if (hadInvalidLine) {\n                this._finishRenderingInvalidLines(ctx, sb.build(), wasInvalid);\n            }\n        }\n    }\n}\nViewLayerRenderer._ttPolicy = createTrustedTypesPolicy('editorViewLayer', { createHTML: value => value });\nViewLayerRenderer._sb = new StringBuilder(100000);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}