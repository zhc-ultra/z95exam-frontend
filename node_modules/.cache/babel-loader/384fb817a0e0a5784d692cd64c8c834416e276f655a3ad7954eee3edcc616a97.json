{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from './lineTokens.js';\n/**\n * Represents sparse tokens in a text model.\n */\nexport var SparseTokensStore = /*#__PURE__*/function () {\n  function SparseTokensStore(languageIdCodec) {\n    _classCallCheck(this, SparseTokensStore);\n    this._pieces = [];\n    this._isComplete = false;\n    this._languageIdCodec = languageIdCodec;\n  }\n  return _createClass(SparseTokensStore, [{\n    key: \"flush\",\n    value: function flush() {\n      this._pieces = [];\n      this._isComplete = false;\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this._pieces.length === 0;\n    }\n  }, {\n    key: \"set\",\n    value: function set(pieces, isComplete) {\n      this._pieces = pieces || [];\n      this._isComplete = isComplete;\n    }\n  }, {\n    key: \"setPartial\",\n    value: function setPartial(_range, pieces) {\n      // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n      var range = _range;\n      if (pieces.length > 0) {\n        var _firstRange = pieces[0].getRange();\n        var _lastRange = pieces[pieces.length - 1].getRange();\n        if (!_firstRange || !_lastRange) {\n          return _range;\n        }\n        range = _range.plusRange(_firstRange).plusRange(_lastRange);\n      }\n      var insertPosition = null;\n      for (var i = 0, len = this._pieces.length; i < len; i++) {\n        var piece = this._pieces[i];\n        if (piece.endLineNumber < range.startLineNumber) {\n          // this piece is before the range\n          continue;\n        }\n        if (piece.startLineNumber > range.endLineNumber) {\n          // this piece is after the range, so mark the spot before this piece\n          // as a good insertion position and stop looping\n          insertPosition = insertPosition || {\n            index: i\n          };\n          break;\n        }\n        // this piece might intersect with the range\n        piece.removeTokens(range);\n        if (piece.isEmpty()) {\n          // remove the piece if it became empty\n          this._pieces.splice(i, 1);\n          i--;\n          len--;\n          continue;\n        }\n        if (piece.endLineNumber < range.startLineNumber) {\n          // after removal, this piece is before the range\n          continue;\n        }\n        if (piece.startLineNumber > range.endLineNumber) {\n          // after removal, this piece is after the range\n          insertPosition = insertPosition || {\n            index: i\n          };\n          continue;\n        }\n        // after removal, this piece contains the range\n        var _piece$split = piece.split(range),\n          _piece$split2 = _slicedToArray(_piece$split, 2),\n          a = _piece$split2[0],\n          b = _piece$split2[1];\n        if (a.isEmpty()) {\n          // this piece is actually after the range\n          insertPosition = insertPosition || {\n            index: i\n          };\n          continue;\n        }\n        if (b.isEmpty()) {\n          // this piece is actually before the range\n          continue;\n        }\n        this._pieces.splice(i, 1, a, b);\n        i++;\n        len++;\n        insertPosition = insertPosition || {\n          index: i\n        };\n      }\n      insertPosition = insertPosition || {\n        index: this._pieces.length\n      };\n      if (pieces.length > 0) {\n        this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n      }\n      // console.log(`I HAVE ${this._pieces.length} pieces`);\n      // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n      return range;\n    }\n  }, {\n    key: \"isComplete\",\n    value: function isComplete() {\n      return this._isComplete;\n    }\n  }, {\n    key: \"addSparseTokens\",\n    value: function addSparseTokens(lineNumber, aTokens) {\n      if (aTokens.getLineContent().length === 0) {\n        // Don't do anything for empty lines\n        return aTokens;\n      }\n      var pieces = this._pieces;\n      if (pieces.length === 0) {\n        return aTokens;\n      }\n      var pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);\n      var bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n      if (!bTokens) {\n        return aTokens;\n      }\n      var aLen = aTokens.getCount();\n      var bLen = bTokens.getCount();\n      var aIndex = 0;\n      var result = [];\n      var resultLen = 0;\n      var lastEndOffset = 0;\n      var emitToken = function emitToken(endOffset, metadata) {\n        if (endOffset === lastEndOffset) {\n          return;\n        }\n        lastEndOffset = endOffset;\n        result[resultLen++] = endOffset;\n        result[resultLen++] = metadata;\n      };\n      for (var bIndex = 0; bIndex < bLen; bIndex++) {\n        var bStartCharacter = bTokens.getStartCharacter(bIndex);\n        var bEndCharacter = bTokens.getEndCharacter(bIndex);\n        var bMetadata = bTokens.getMetadata(bIndex);\n        var bMask = ((bMetadata & 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */ ? 2048 /* MetadataConsts.ITALIC_MASK */ : 0) | (bMetadata & 2 /* MetadataConsts.SEMANTIC_USE_BOLD */ ? 4096 /* MetadataConsts.BOLD_MASK */ : 0) | (bMetadata & 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */ ? 8192 /* MetadataConsts.UNDERLINE_MASK */ : 0) | (bMetadata & 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */ ? 16384 /* MetadataConsts.STRIKETHROUGH_MASK */ : 0) | (bMetadata & 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */ ? 16744448 /* MetadataConsts.FOREGROUND_MASK */ : 0) | (bMetadata & 32 /* MetadataConsts.SEMANTIC_USE_BACKGROUND */ ? 4278190080 /* MetadataConsts.BACKGROUND_MASK */ : 0)) >>> 0;\n        var aMask = ~bMask >>> 0;\n        // push any token from `a` that is before `b`\n        while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n          emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n          aIndex++;\n        }\n        // push the token from `a` if it intersects the token from `b`\n        if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n          emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n        }\n        // skip any tokens from `a` that are contained inside `b`\n        while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n          emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex) & aMask | bMetadata & bMask);\n          aIndex++;\n        }\n        if (aIndex < aLen) {\n          emitToken(bEndCharacter, aTokens.getMetadata(aIndex) & aMask | bMetadata & bMask);\n          if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n            // `a` ends exactly at the same spot as `b`!\n            aIndex++;\n          }\n        } else {\n          var aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n          // push the token from `b`\n          emitToken(bEndCharacter, aTokens.getMetadata(aMergeIndex) & aMask | bMetadata & bMask);\n        }\n      }\n      // push the remaining tokens from `a`\n      while (aIndex < aLen) {\n        emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n        aIndex++;\n      }\n      return new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);\n    }\n  }, {\n    key: \"acceptEdit\",\n    value: function acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n      var _iterator = _createForOfIteratorHelper(this._pieces),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var piece = _step.value;\n          piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }], [{\n    key: \"_findFirstPieceWithLine\",\n    value: function _findFirstPieceWithLine(pieces, lineNumber) {\n      var low = 0;\n      var high = pieces.length - 1;\n      while (low < high) {\n        var mid = low + Math.floor((high - low) / 2);\n        if (pieces[mid].endLineNumber < lineNumber) {\n          low = mid + 1;\n        } else if (pieces[mid].startLineNumber > lineNumber) {\n          high = mid - 1;\n        } else {\n          while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n            mid--;\n          }\n          return mid;\n        }\n      }\n      return low;\n    }\n  }]);\n}();","map":{"version":3,"names":["arrays","LineTokens","SparseTokensStore","languageIdCodec","_classCallCheck","_pieces","_isComplete","_languageIdCodec","_createClass","key","value","flush","isEmpty","length","set","pieces","isComplete","setPartial","_range","range","_firstRange","getRange","_lastRange","plusRange","insertPosition","i","len","piece","endLineNumber","startLineNumber","index","removeTokens","splice","_piece$split","split","_piece$split2","_slicedToArray","a","b","arrayInsert","addSparseTokens","lineNumber","aTokens","getLineContent","pieceIndex","_findFirstPieceWithLine","bTokens","getLineTokens","aLen","getCount","bLen","aIndex","result","resultLen","lastEndOffset","emitToken","endOffset","metadata","bIndex","bStartCharacter","getStartCharacter","bEndCharacter","getEndCharacter","bMetadata","getMetadata","bMask","aMask","getEndOffset","getStartOffset","aMergeIndex","Math","min","max","Uint32Array","acceptEdit","eolCount","firstLineLength","lastLineLength","firstCharCode","_iterator","_createForOfIteratorHelper","_step","s","n","done","err","e","f","low","high","mid","floor"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseTokensStore.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from './lineTokens.js';\n/**\n * Represents sparse tokens in a text model.\n */\nexport class SparseTokensStore {\n    constructor(languageIdCodec) {\n        this._pieces = [];\n        this._isComplete = false;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._pieces = [];\n        this._isComplete = false;\n    }\n    isEmpty() {\n        return (this._pieces.length === 0);\n    }\n    set(pieces, isComplete) {\n        this._pieces = pieces || [];\n        this._isComplete = isComplete;\n    }\n    setPartial(_range, pieces) {\n        // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n        let range = _range;\n        if (pieces.length > 0) {\n            const _firstRange = pieces[0].getRange();\n            const _lastRange = pieces[pieces.length - 1].getRange();\n            if (!_firstRange || !_lastRange) {\n                return _range;\n            }\n            range = _range.plusRange(_firstRange).plusRange(_lastRange);\n        }\n        let insertPosition = null;\n        for (let i = 0, len = this._pieces.length; i < len; i++) {\n            const piece = this._pieces[i];\n            if (piece.endLineNumber < range.startLineNumber) {\n                // this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // this piece is after the range, so mark the spot before this piece\n                // as a good insertion position and stop looping\n                insertPosition = insertPosition || { index: i };\n                break;\n            }\n            // this piece might intersect with the range\n            piece.removeTokens(range);\n            if (piece.isEmpty()) {\n                // remove the piece if it became empty\n                this._pieces.splice(i, 1);\n                i--;\n                len--;\n                continue;\n            }\n            if (piece.endLineNumber < range.startLineNumber) {\n                // after removal, this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // after removal, this piece is after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            // after removal, this piece contains the range\n            const [a, b] = piece.split(range);\n            if (a.isEmpty()) {\n                // this piece is actually after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            if (b.isEmpty()) {\n                // this piece is actually before the range\n                continue;\n            }\n            this._pieces.splice(i, 1, a, b);\n            i++;\n            len++;\n            insertPosition = insertPosition || { index: i };\n        }\n        insertPosition = insertPosition || { index: this._pieces.length };\n        if (pieces.length > 0) {\n            this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n        }\n        // console.log(`I HAVE ${this._pieces.length} pieces`);\n        // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n        return range;\n    }\n    isComplete() {\n        return this._isComplete;\n    }\n    addSparseTokens(lineNumber, aTokens) {\n        if (aTokens.getLineContent().length === 0) {\n            // Don't do anything for empty lines\n            return aTokens;\n        }\n        const pieces = this._pieces;\n        if (pieces.length === 0) {\n            return aTokens;\n        }\n        const pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);\n        const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n        if (!bTokens) {\n            return aTokens;\n        }\n        const aLen = aTokens.getCount();\n        const bLen = bTokens.getCount();\n        let aIndex = 0;\n        const result = [];\n        let resultLen = 0;\n        let lastEndOffset = 0;\n        const emitToken = (endOffset, metadata) => {\n            if (endOffset === lastEndOffset) {\n                return;\n            }\n            lastEndOffset = endOffset;\n            result[resultLen++] = endOffset;\n            result[resultLen++] = metadata;\n        };\n        for (let bIndex = 0; bIndex < bLen; bIndex++) {\n            const bStartCharacter = bTokens.getStartCharacter(bIndex);\n            const bEndCharacter = bTokens.getEndCharacter(bIndex);\n            const bMetadata = bTokens.getMetadata(bIndex);\n            const bMask = (((bMetadata & 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */) ? 2048 /* MetadataConsts.ITALIC_MASK */ : 0)\n                | ((bMetadata & 2 /* MetadataConsts.SEMANTIC_USE_BOLD */) ? 4096 /* MetadataConsts.BOLD_MASK */ : 0)\n                | ((bMetadata & 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */) ? 8192 /* MetadataConsts.UNDERLINE_MASK */ : 0)\n                | ((bMetadata & 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */) ? 16384 /* MetadataConsts.STRIKETHROUGH_MASK */ : 0)\n                | ((bMetadata & 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */) ? 16744448 /* MetadataConsts.FOREGROUND_MASK */ : 0)\n                | ((bMetadata & 32 /* MetadataConsts.SEMANTIC_USE_BACKGROUND */) ? 4278190080 /* MetadataConsts.BACKGROUND_MASK */ : 0)) >>> 0;\n            const aMask = (~bMask) >>> 0;\n            // push any token from `a` that is before `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n                aIndex++;\n            }\n            // push the token from `a` if it intersects the token from `b`\n            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n                emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n            }\n            // skip any tokens from `a` that are contained inside `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                aIndex++;\n            }\n            if (aIndex < aLen) {\n                emitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n                    // `a` ends exactly at the same spot as `b`!\n                    aIndex++;\n                }\n            }\n            else {\n                const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n                // push the token from `b`\n                emitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\n            }\n        }\n        // push the remaining tokens from `a`\n        while (aIndex < aLen) {\n            emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n            aIndex++;\n        }\n        return new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);\n    }\n    static _findFirstPieceWithLine(pieces, lineNumber) {\n        let low = 0;\n        let high = pieces.length - 1;\n        while (low < high) {\n            let mid = low + Math.floor((high - low) / 2);\n            if (pieces[mid].endLineNumber < lineNumber) {\n                low = mid + 1;\n            }\n            else if (pieces[mid].startLineNumber > lineNumber) {\n                high = mid - 1;\n            }\n            else {\n                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n                    mid--;\n                }\n                return mid;\n            }\n        }\n        return low;\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        for (const piece of this._pieces) {\n            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}