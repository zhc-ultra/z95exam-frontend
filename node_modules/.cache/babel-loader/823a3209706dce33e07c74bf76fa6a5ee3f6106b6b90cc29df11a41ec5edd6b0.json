{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.trim.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { forEachWithNeighbors } from '../../../../base/common/arrays.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { OffsetPair, SequenceDiff } from './algorithms/diffAlgorithm.js';\nexport function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n  var result = sequenceDiffs;\n  result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n  // Sometimes, calling this function twice improves the result.\n  // Uncomment the second invocation and run the tests to see the difference.\n  result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n  result = shiftSequenceDiffs(sequence1, sequence2, result);\n  return result;\n}\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nfunction joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {\n  if (sequenceDiffs.length === 0) {\n    return sequenceDiffs;\n  }\n  var result = [];\n  result.push(sequenceDiffs[0]);\n  // First move them all to the left as much as possible and join them if possible\n  for (var i = 1; i < sequenceDiffs.length; i++) {\n    var prevResult = result[result.length - 1];\n    var cur = sequenceDiffs[i];\n    if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n      var length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n      var d = void 0;\n      for (d = 1; d <= length; d++) {\n        if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) || sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n          break;\n        }\n      }\n      d--;\n      if (d === length) {\n        // Merge previous and current diff\n        result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n        continue;\n      }\n      cur = cur.delta(-d);\n    }\n    result.push(cur);\n  }\n  var result2 = [];\n  // Then move them all to the right and join them again if possible\n  for (var _i = 0; _i < result.length - 1; _i++) {\n    var nextResult = result[_i + 1];\n    var _cur = result[_i];\n    if (_cur.seq1Range.isEmpty || _cur.seq2Range.isEmpty) {\n      var _length = nextResult.seq1Range.start - _cur.seq1Range.endExclusive;\n      var _d = void 0;\n      for (_d = 0; _d < _length; _d++) {\n        if (!sequence1.isStronglyEqual(_cur.seq1Range.start + _d, _cur.seq1Range.endExclusive + _d) || !sequence2.isStronglyEqual(_cur.seq2Range.start + _d, _cur.seq2Range.endExclusive + _d)) {\n          break;\n        }\n      }\n      if (_d === _length) {\n        // Merge previous and current diff, write to result!\n        result[_i + 1] = new SequenceDiff(new OffsetRange(_cur.seq1Range.start + _length, nextResult.seq1Range.endExclusive), new OffsetRange(_cur.seq2Range.start + _length, nextResult.seq2Range.endExclusive));\n        continue;\n      }\n      if (_d > 0) {\n        _cur = _cur.delta(_d);\n      }\n    }\n    result2.push(_cur);\n  }\n  if (result.length > 0) {\n    result2.push(result[result.length - 1]);\n  }\n  return result2;\n}\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\nfunction shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n  if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n    return sequenceDiffs;\n  }\n  for (var i = 0; i < sequenceDiffs.length; i++) {\n    var prevDiff = i > 0 ? sequenceDiffs[i - 1] : undefined;\n    var diff = sequenceDiffs[i];\n    var nextDiff = i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined;\n    var seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);\n    var seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);\n    if (diff.seq1Range.isEmpty) {\n      sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n    } else if (diff.seq2Range.isEmpty) {\n      sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();\n    }\n  }\n  return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {\n  var maxShiftLimit = 100; // To prevent performance issues\n  // don't touch previous or next!\n  var deltaBefore = 1;\n  while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start && diff.seq2Range.start - deltaBefore >= seq2ValidRange.start && sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n    deltaBefore++;\n  }\n  deltaBefore--;\n  var deltaAfter = 0;\n  while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive && diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive && sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n    deltaAfter++;\n  }\n  if (deltaBefore === 0 && deltaAfter === 0) {\n    return diff;\n  }\n  // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n  // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n  var bestDelta = 0;\n  var bestScore = -1;\n  // find best scored delta\n  for (var delta = -deltaBefore; delta <= deltaAfter; delta++) {\n    var seq2OffsetStart = diff.seq2Range.start + delta;\n    var seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n    var seq1Offset = diff.seq1Range.start + delta;\n    var score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n    if (score > bestScore) {\n      bestScore = score;\n      bestDelta = delta;\n    }\n  }\n  return diff.delta(bestDelta);\n}\nexport function removeShortMatches(sequence1, sequence2, sequenceDiffs) {\n  var result = [];\n  var _iterator = _createForOfIteratorHelper(sequenceDiffs),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var s = _step.value;\n      var last = result[result.length - 1];\n      if (!last) {\n        result.push(s);\n        continue;\n      }\n      if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n        result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n      } else {\n        result.push(s);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return result;\n}\nexport function extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {\n  var equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);\n  var additional = [];\n  var lastPoint = new OffsetPair(0, 0);\n  function scanWord(pair, equalMapping) {\n    if (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {\n      return;\n    }\n    var w1 = sequence1.findWordContaining(pair.offset1);\n    var w2 = sequence2.findWordContaining(pair.offset2);\n    if (!w1 || !w2) {\n      return;\n    }\n    var w = new SequenceDiff(w1, w2);\n    var equalPart = w.intersect(equalMapping);\n    var equalChars1 = equalPart.seq1Range.length;\n    var equalChars2 = equalPart.seq2Range.length;\n    // The words do not touch previous equals mappings, as we would have processed them already.\n    // But they might touch the next ones.\n    while (equalMappings.length > 0) {\n      var next = equalMappings[0];\n      var intersects = next.seq1Range.intersects(w.seq1Range) || next.seq2Range.intersects(w.seq2Range);\n      if (!intersects) {\n        break;\n      }\n      var v1 = sequence1.findWordContaining(next.seq1Range.start);\n      var v2 = sequence2.findWordContaining(next.seq2Range.start);\n      // Because there is an intersection, we know that the words are not empty.\n      var v = new SequenceDiff(v1, v2);\n      var _equalPart = v.intersect(next);\n      equalChars1 += _equalPart.seq1Range.length;\n      equalChars2 += _equalPart.seq2Range.length;\n      w = w.join(v);\n      if (w.seq1Range.endExclusive >= next.seq1Range.endExclusive) {\n        // The word extends beyond the next equal mapping.\n        equalMappings.shift();\n      } else {\n        break;\n      }\n    }\n    if (equalChars1 + equalChars2 < (w.seq1Range.length + w.seq2Range.length) * 2 / 3) {\n      additional.push(w);\n    }\n    lastPoint = w.getEndExclusives();\n  }\n  while (equalMappings.length > 0) {\n    var next = equalMappings.shift();\n    if (next.seq1Range.isEmpty) {\n      continue;\n    }\n    scanWord(next.getStarts(), next);\n    // The equal parts are not empty, so -1 gives us a character that is equal in both parts.\n    scanWord(next.getEndExclusives().delta(-1), next);\n  }\n  var merged = mergeSequenceDiffs(sequenceDiffs, additional);\n  return merged;\n}\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\n  var result = [];\n  while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n    var sd1 = sequenceDiffs1[0];\n    var sd2 = sequenceDiffs2[0];\n    var next = void 0;\n    if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n      next = sequenceDiffs1.shift();\n    } else {\n      next = sequenceDiffs2.shift();\n    }\n    if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n      result[result.length - 1] = result[result.length - 1].join(next);\n    } else {\n      result.push(next);\n    }\n  }\n  return result;\n}\nexport function removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {\n  var diffs = sequenceDiffs;\n  if (diffs.length === 0) {\n    return diffs;\n  }\n  var counter = 0;\n  var shouldRepeat;\n  do {\n    shouldRepeat = false;\n    var result = [diffs[0]];\n    var _loop = function _loop() {\n      var cur = diffs[i];\n      var lastResult = result[result.length - 1];\n      function shouldJoinDiffs(before, after) {\n        var unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n        var unchangedText = sequence1.getText(unchangedRange);\n        var unchangedTextWithoutWs = unchangedText.replace(/\\s/g, '');\n        if (unchangedTextWithoutWs.length <= 4 && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {\n          return true;\n        }\n        return false;\n      }\n      var shouldJoin = shouldJoinDiffs(lastResult, cur);\n      if (shouldJoin) {\n        shouldRepeat = true;\n        result[result.length - 1] = result[result.length - 1].join(cur);\n      } else {\n        result.push(cur);\n      }\n    };\n    for (var i = 1; i < diffs.length; i++) {\n      _loop();\n    }\n    diffs = result;\n  } while (counter++ < 10 && shouldRepeat);\n  return diffs;\n}\nexport function removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {\n  var diffs = sequenceDiffs;\n  if (diffs.length === 0) {\n    return diffs;\n  }\n  var counter = 0;\n  var shouldRepeat;\n  do {\n    shouldRepeat = false;\n    var result = [diffs[0]];\n    var _loop2 = function _loop2() {\n      var cur = diffs[i];\n      var lastResult = result[result.length - 1];\n      function shouldJoinDiffs(before, after) {\n        var unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n        var unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n        if (unchangedLineCount > 5 || unchangedRange.length > 500) {\n          return false;\n        }\n        var unchangedText = sequence1.getText(unchangedRange).trim();\n        if (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\n          return false;\n        }\n        var beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n        var beforeSeq1Length = before.seq1Range.length;\n        var beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n        var beforeSeq2Length = before.seq2Range.length;\n        var afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n        var afterSeq1Length = after.seq1Range.length;\n        var afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n        var afterSeq2Length = after.seq2Range.length;\n        // TODO: Maybe a neural net can be used to derive the result from these numbers\n        var max = 2 * 40 + 50;\n        function cap(v) {\n          return Math.min(v, max);\n        }\n        if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5) + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > Math.pow(Math.pow(max, 1.5), 1.5) * 1.3) {\n          return true;\n        }\n        return false;\n      }\n      var shouldJoin = shouldJoinDiffs(lastResult, cur);\n      if (shouldJoin) {\n        shouldRepeat = true;\n        result[result.length - 1] = result[result.length - 1].join(cur);\n      } else {\n        result.push(cur);\n      }\n    };\n    for (var i = 1; i < diffs.length; i++) {\n      _loop2();\n    }\n    diffs = result;\n  } while (counter++ < 10 && shouldRepeat);\n  var newDiffs = [];\n  // Remove short suffixes/prefixes\n  forEachWithNeighbors(diffs, function (prev, cur, next) {\n    var newDiff = cur;\n    function shouldMarkAsChanged(text) {\n      return text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;\n    }\n    var fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\n    var prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));\n    if (shouldMarkAsChanged(prefix)) {\n      newDiff = newDiff.deltaStart(-prefix.length);\n    }\n    var suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));\n    if (shouldMarkAsChanged(suffix)) {\n      newDiff = newDiff.deltaEnd(suffix.length);\n    }\n    var availableSpace = SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : OffsetPair.zero, next ? next.getStarts() : OffsetPair.max);\n    var result = newDiff.intersect(availableSpace);\n    if (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {\n      newDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);\n    } else {\n      newDiffs.push(result);\n    }\n  });\n  return newDiffs;\n}","map":{"version":3,"names":["forEachWithNeighbors","OffsetRange","OffsetPair","SequenceDiff","optimizeSequenceDiffs","sequence1","sequence2","sequenceDiffs","result","joinSequenceDiffsByShifting","shiftSequenceDiffs","length","push","i","prevResult","cur","seq1Range","isEmpty","seq2Range","start","endExclusive","d","getElement","delta","result2","nextResult","isStronglyEqual","getBoundaryScore","prevDiff","undefined","diff","nextDiff","seq1ValidRange","seq2ValidRange","shiftDiffToBetterPosition","swap","maxShiftLimit","deltaBefore","deltaAfter","bestDelta","bestScore","seq2OffsetStart","seq2OffsetEndExclusive","seq1Offset","score","removeShortMatches","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","last","join","err","e","f","extendDiffsToEntireWordIfAppropriate","equalMappings","invert","additional","lastPoint","scanWord","pair","equalMapping","offset1","offset2","w1","findWordContaining","w2","w","equalPart","intersect","equalChars1","equalChars2","next","intersects","v1","v2","v","shift","getEndExclusives","getStarts","merged","mergeSequenceDiffs","sequenceDiffs1","sequenceDiffs2","sd1","sd2","removeVeryShortMatchingLinesBetweenDiffs","_sequence2","diffs","counter","shouldRepeat","_loop","lastResult","shouldJoinDiffs","before","after","unchangedRange","unchangedText","getText","unchangedTextWithoutWs","replace","shouldJoin","removeVeryShortMatchingTextBetweenLongDiffs","_loop2","unchangedLineCount","countLinesIn","trim","split","beforeLineCount1","beforeSeq1Length","beforeLineCount2","beforeSeq2Length","afterLineCount1","afterSeq1Length","afterLineCount2","afterSeq2Length","max","cap","Math","min","pow","newDiffs","prev","newDiff","shouldMarkAsChanged","text","fullRange1","extendToFullLines","prefix","deltaStart","suffix","deltaEnd","availableSpace","fromOffsetPairs","zero","equals"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { forEachWithNeighbors } from '../../../../base/common/arrays.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { OffsetPair, SequenceDiff } from './algorithms/diffAlgorithm.js';\nexport function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    let result = sequenceDiffs;\n    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n    // Sometimes, calling this function twice improves the result.\n    // Uncomment the second invocation and run the tests to see the difference.\n    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n    result = shiftSequenceDiffs(sequence1, sequence2, result);\n    return result;\n}\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nfunction joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {\n    if (sequenceDiffs.length === 0) {\n        return sequenceDiffs;\n    }\n    const result = [];\n    result.push(sequenceDiffs[0]);\n    // First move them all to the left as much as possible and join them if possible\n    for (let i = 1; i < sequenceDiffs.length; i++) {\n        const prevResult = result[result.length - 1];\n        let cur = sequenceDiffs[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n            let d;\n            for (d = 1; d <= length; d++) {\n                if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) ||\n                    sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n                    break;\n                }\n            }\n            d--;\n            if (d === length) {\n                // Merge previous and current diff\n                result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n                continue;\n            }\n            cur = cur.delta(-d);\n        }\n        result.push(cur);\n    }\n    const result2 = [];\n    // Then move them all to the right and join them again if possible\n    for (let i = 0; i < result.length - 1; i++) {\n        const nextResult = result[i + 1];\n        let cur = result[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n            let d;\n            for (d = 0; d < length; d++) {\n                if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) ||\n                    !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {\n                    break;\n                }\n            }\n            if (d === length) {\n                // Merge previous and current diff, write to result!\n                result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));\n                continue;\n            }\n            if (d > 0) {\n                cur = cur.delta(d);\n            }\n        }\n        result2.push(cur);\n    }\n    if (result.length > 0) {\n        result2.push(result[result.length - 1]);\n    }\n    return result2;\n}\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\nfunction shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n        return sequenceDiffs;\n    }\n    for (let i = 0; i < sequenceDiffs.length; i++) {\n        const prevDiff = (i > 0 ? sequenceDiffs[i - 1] : undefined);\n        const diff = sequenceDiffs[i];\n        const nextDiff = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined);\n        const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);\n        const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);\n        if (diff.seq1Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n        }\n        else if (diff.seq2Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();\n        }\n    }\n    return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {\n    const maxShiftLimit = 100; // To prevent performance issues\n    // don't touch previous or next!\n    let deltaBefore = 1;\n    while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start &&\n        diff.seq2Range.start - deltaBefore >= seq2ValidRange.start &&\n        sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n        deltaBefore++;\n    }\n    deltaBefore--;\n    let deltaAfter = 0;\n    while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive &&\n        diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive &&\n        sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n        deltaAfter++;\n    }\n    if (deltaBefore === 0 && deltaAfter === 0) {\n        return diff;\n    }\n    // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n    // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n    let bestDelta = 0;\n    let bestScore = -1;\n    // find best scored delta\n    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n        const seq2OffsetStart = diff.seq2Range.start + delta;\n        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n        const seq1Offset = diff.seq1Range.start + delta;\n        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n        if (score > bestScore) {\n            bestScore = score;\n            bestDelta = delta;\n        }\n    }\n    return diff.delta(bestDelta);\n}\nexport function removeShortMatches(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    for (const s of sequenceDiffs) {\n        const last = result[result.length - 1];\n        if (!last) {\n            result.push(s);\n            continue;\n        }\n        if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n            result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n        }\n        else {\n            result.push(s);\n        }\n    }\n    return result;\n}\nexport function extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {\n    const equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);\n    const additional = [];\n    let lastPoint = new OffsetPair(0, 0);\n    function scanWord(pair, equalMapping) {\n        if (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {\n            return;\n        }\n        const w1 = sequence1.findWordContaining(pair.offset1);\n        const w2 = sequence2.findWordContaining(pair.offset2);\n        if (!w1 || !w2) {\n            return;\n        }\n        let w = new SequenceDiff(w1, w2);\n        const equalPart = w.intersect(equalMapping);\n        let equalChars1 = equalPart.seq1Range.length;\n        let equalChars2 = equalPart.seq2Range.length;\n        // The words do not touch previous equals mappings, as we would have processed them already.\n        // But they might touch the next ones.\n        while (equalMappings.length > 0) {\n            const next = equalMappings[0];\n            const intersects = next.seq1Range.intersects(w.seq1Range) || next.seq2Range.intersects(w.seq2Range);\n            if (!intersects) {\n                break;\n            }\n            const v1 = sequence1.findWordContaining(next.seq1Range.start);\n            const v2 = sequence2.findWordContaining(next.seq2Range.start);\n            // Because there is an intersection, we know that the words are not empty.\n            const v = new SequenceDiff(v1, v2);\n            const equalPart = v.intersect(next);\n            equalChars1 += equalPart.seq1Range.length;\n            equalChars2 += equalPart.seq2Range.length;\n            w = w.join(v);\n            if (w.seq1Range.endExclusive >= next.seq1Range.endExclusive) {\n                // The word extends beyond the next equal mapping.\n                equalMappings.shift();\n            }\n            else {\n                break;\n            }\n        }\n        if (equalChars1 + equalChars2 < (w.seq1Range.length + w.seq2Range.length) * 2 / 3) {\n            additional.push(w);\n        }\n        lastPoint = w.getEndExclusives();\n    }\n    while (equalMappings.length > 0) {\n        const next = equalMappings.shift();\n        if (next.seq1Range.isEmpty) {\n            continue;\n        }\n        scanWord(next.getStarts(), next);\n        // The equal parts are not empty, so -1 gives us a character that is equal in both parts.\n        scanWord(next.getEndExclusives().delta(-1), next);\n    }\n    const merged = mergeSequenceDiffs(sequenceDiffs, additional);\n    return merged;\n}\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\n    const result = [];\n    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n        const sd1 = sequenceDiffs1[0];\n        const sd2 = sequenceDiffs2[0];\n        let next;\n        if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n            next = sequenceDiffs1.shift();\n        }\n        else {\n            next = sequenceDiffs2.shift();\n        }\n        if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n            result[result.length - 1] = result[result.length - 1].join(next);\n        }\n        else {\n            result.push(next);\n        }\n    }\n    return result;\n}\nexport function removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n                const unchangedText = sequence1.getText(unchangedRange);\n                const unchangedTextWithoutWs = unchangedText.replace(/\\s/g, '');\n                if (unchangedTextWithoutWs.length <= 4\n                    && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    return diffs;\n}\nexport function removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n                const unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n                if (unchangedLineCount > 5 || unchangedRange.length > 500) {\n                    return false;\n                }\n                const unchangedText = sequence1.getText(unchangedRange).trim();\n                if (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\n                    return false;\n                }\n                const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n                const beforeSeq1Length = before.seq1Range.length;\n                const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n                const beforeSeq2Length = before.seq2Range.length;\n                const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n                const afterSeq1Length = after.seq1Range.length;\n                const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n                const afterSeq2Length = after.seq2Range.length;\n                // TODO: Maybe a neural net can be used to derive the result from these numbers\n                const max = 2 * 40 + 50;\n                function cap(v) {\n                    return Math.min(v, max);\n                }\n                if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5)\n                    + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > ((max ** 1.5) ** 1.5) * 1.3) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    const newDiffs = [];\n    // Remove short suffixes/prefixes\n    forEachWithNeighbors(diffs, (prev, cur, next) => {\n        let newDiff = cur;\n        function shouldMarkAsChanged(text) {\n            return text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;\n        }\n        const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\n        const prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));\n        if (shouldMarkAsChanged(prefix)) {\n            newDiff = newDiff.deltaStart(-prefix.length);\n        }\n        const suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));\n        if (shouldMarkAsChanged(suffix)) {\n            newDiff = newDiff.deltaEnd(suffix.length);\n        }\n        const availableSpace = SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : OffsetPair.zero, next ? next.getStarts() : OffsetPair.max);\n        const result = newDiff.intersect(availableSpace);\n        if (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {\n            newDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);\n        }\n        else {\n            newDiffs.push(result);\n        }\n    });\n    return newDiffs;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}