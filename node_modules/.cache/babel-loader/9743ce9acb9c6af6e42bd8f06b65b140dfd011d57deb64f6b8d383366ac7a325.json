{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.find-last.js\";\nimport \"core-js/modules/es.date.now.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CallbackIterable, compareBy } from '../../../../base/common/arrays.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nexport var BracketPairsTextModelPart = /*#__PURE__*/function (_Disposable) {\n  function BracketPairsTextModelPart(textModel, languageConfigurationService) {\n    var _this;\n    _classCallCheck(this, BracketPairsTextModelPart);\n    _this = _callSuper(this, BracketPairsTextModelPart);\n    _this.textModel = textModel;\n    _this.languageConfigurationService = languageConfigurationService;\n    _this.bracketPairsTree = _this._register(new MutableDisposable());\n    _this.onDidChangeEmitter = new Emitter();\n    _this.onDidChange = _this.onDidChangeEmitter.event;\n    _this.bracketsRequested = false;\n    _this._register(_this.languageConfigurationService.onDidChange(function (e) {\n      var _a;\n      if (!e.languageId || ((_a = _this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.didLanguageChange(e.languageId))) {\n        _this.bracketPairsTree.clear();\n        _this.updateBracketPairsTree();\n      }\n    }));\n    return _this;\n  }\n  //#region TextModel events\n  _inherits(BracketPairsTextModelPart, _Disposable);\n  return _createClass(BracketPairsTextModelPart, [{\n    key: \"canBuildAST\",\n    get: function get() {\n      var maxSupportedDocumentLength = /* max lines */50000 * /* average column count */100;\n      return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n  }, {\n    key: \"handleDidChangeOptions\",\n    value: function handleDidChangeOptions(e) {\n      this.bracketPairsTree.clear();\n      this.updateBracketPairsTree();\n    }\n  }, {\n    key: \"handleDidChangeLanguage\",\n    value: function handleDidChangeLanguage(e) {\n      this.bracketPairsTree.clear();\n      this.updateBracketPairsTree();\n    }\n  }, {\n    key: \"handleDidChangeContent\",\n    value: function handleDidChangeContent(change) {\n      var _a;\n      (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleContentChanged(change);\n    }\n  }, {\n    key: \"handleDidChangeBackgroundTokenizationState\",\n    value: function handleDidChangeBackgroundTokenizationState() {\n      var _a;\n      (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeBackgroundTokenizationState();\n    }\n  }, {\n    key: \"handleDidChangeTokens\",\n    value: function handleDidChangeTokens(e) {\n      var _a;\n      (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeTokens(e);\n    }\n    //#endregion\n  }, {\n    key: \"updateBracketPairsTree\",\n    value: function updateBracketPairsTree() {\n      var _this2 = this;\n      if (this.bracketsRequested && this.canBuildAST) {\n        if (!this.bracketPairsTree.value) {\n          var store = new DisposableStore();\n          this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, function (languageId) {\n            return _this2.languageConfigurationService.getLanguageConfiguration(languageId);\n          })), store);\n          store.add(this.bracketPairsTree.value.object.onDidChange(function (e) {\n            return _this2.onDidChangeEmitter.fire(e);\n          }));\n          this.onDidChangeEmitter.fire();\n        }\n      } else {\n        if (this.bracketPairsTree.value) {\n          this.bracketPairsTree.clear();\n          // Important: Don't call fire if there was no change!\n          this.onDidChangeEmitter.fire();\n        }\n      }\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n  }, {\n    key: \"getBracketPairsInRange\",\n    value: function getBracketPairsInRange(range) {\n      var _a;\n      this.bracketsRequested = true;\n      this.updateBracketPairsTree();\n      return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, false)) || CallbackIterable.empty;\n    }\n  }, {\n    key: \"getBracketPairsInRangeWithMinIndentation\",\n    value: function getBracketPairsInRangeWithMinIndentation(range) {\n      var _a;\n      this.bracketsRequested = true;\n      this.updateBracketPairsTree();\n      return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, true)) || CallbackIterable.empty;\n    }\n  }, {\n    key: \"getBracketsInRange\",\n    value: function getBracketsInRange(range) {\n      var onlyColorizedBrackets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var _a;\n      this.bracketsRequested = true;\n      this.updateBracketPairsTree();\n      return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketsInRange(range, onlyColorizedBrackets)) || CallbackIterable.empty;\n    }\n  }, {\n    key: \"findMatchingBracketUp\",\n    value: function findMatchingBracketUp(_bracket, _position, maxDuration) {\n      var position = this.textModel.validatePosition(_position);\n      var languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n      if (this.canBuildAST) {\n        var closingBracketInfo = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew.getClosingBracketInfo(_bracket);\n        if (!closingBracketInfo) {\n          return null;\n        }\n        var bracketPair = this.getBracketPairsInRange(Range.fromPositions(_position, _position)).findLast(function (b) {\n          return closingBracketInfo.closes(b.openingBracketInfo);\n        });\n        if (bracketPair) {\n          return bracketPair.openingBracketRange;\n        }\n        return null;\n      } else {\n        // Fallback to old bracket matching code:\n        var bracket = _bracket.toLowerCase();\n        var bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n        if (!bracketsSupport) {\n          return null;\n        }\n        var data = bracketsSupport.textIsBracket[bracket];\n        if (!data) {\n          return null;\n        }\n        return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n      }\n    }\n  }, {\n    key: \"matchBracket\",\n    value: function matchBracket(position, maxDuration) {\n      if (this.canBuildAST) {\n        var bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).filter(function (item) {\n          return item.closingBracketRange !== undefined && (item.openingBracketRange.containsPosition(position) || item.closingBracketRange.containsPosition(position));\n        }).findLastMaxBy(compareBy(function (item) {\n          return item.openingBracketRange.containsPosition(position) ? item.openingBracketRange : item.closingBracketRange;\n        }, Range.compareRangesUsingStarts));\n        if (bracketPair) {\n          return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n        }\n        return null;\n      } else {\n        // Fallback to old bracket matching code:\n        var continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n        return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n      }\n    }\n  }, {\n    key: \"_establishBracketSearchOffsets\",\n    value: function _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n      var tokenCount = lineTokens.getCount();\n      var currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n      // limit search to not go before `maxBracketLength`\n      var searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n      for (var i = tokenIndex - 1; i >= 0; i--) {\n        var tokenEndOffset = lineTokens.getEndOffset(i);\n        if (tokenEndOffset <= searchStartOffset) {\n          break;\n        }\n        if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n          searchStartOffset = tokenEndOffset;\n          break;\n        }\n      }\n      // limit search to not go after `maxBracketLength`\n      var searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n      for (var _i = tokenIndex + 1; _i < tokenCount; _i++) {\n        var tokenStartOffset = lineTokens.getStartOffset(_i);\n        if (tokenStartOffset >= searchEndOffset) {\n          break;\n        }\n        if (ignoreBracketsInToken(lineTokens.getStandardTokenType(_i)) || lineTokens.getLanguageId(_i) !== currentLanguageId) {\n          searchEndOffset = tokenStartOffset;\n          break;\n        }\n      }\n      return {\n        searchStartOffset: searchStartOffset,\n        searchEndOffset: searchEndOffset\n      };\n    }\n  }, {\n    key: \"_matchBracket\",\n    value: function _matchBracket(position, continueSearchPredicate) {\n      var lineNumber = position.lineNumber;\n      var lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n      var lineText = this.textModel.getLineContent(lineNumber);\n      var tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n      if (tokenIndex < 0) {\n        return null;\n      }\n      var currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n      // check that the token is not to be ignored\n      if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n        var _this$_establishBrack = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex),\n          searchStartOffset = _this$_establishBrack.searchStartOffset,\n          searchEndOffset = _this$_establishBrack.searchEndOffset;\n        // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n        // `bestResult` will contain the most right-side result\n        var bestResult = null;\n        while (true) {\n          var foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n          if (!foundBracket) {\n            // there are no more brackets in this text\n            break;\n          }\n          // check that we didn't hit a bracket too far away from position\n          if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n            var foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n            var r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n            if (r) {\n              if (r instanceof BracketSearchCanceled) {\n                return null;\n              }\n              bestResult = r;\n            }\n          }\n          searchStartOffset = foundBracket.endColumn - 1;\n        }\n        if (bestResult) {\n          return bestResult;\n        }\n      }\n      // If position is in between two tokens, try also looking in the previous token\n      if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n        var prevTokenIndex = tokenIndex - 1;\n        var prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n        // check that previous token is not to be ignored\n        if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n          var _this$_establishBrack2 = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex),\n            _searchStartOffset = _this$_establishBrack2.searchStartOffset,\n            _searchEndOffset = _this$_establishBrack2.searchEndOffset;\n          var _foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, _searchStartOffset, _searchEndOffset);\n          // check that we didn't hit a bracket too far away from position\n          if (_foundBracket && _foundBracket.startColumn <= position.column && position.column <= _foundBracket.endColumn) {\n            var _foundBracketText = lineText.substring(_foundBracket.startColumn - 1, _foundBracket.endColumn - 1).toLowerCase();\n            var _r = this._matchFoundBracket(_foundBracket, prevModeBrackets.textIsBracket[_foundBracketText], prevModeBrackets.textIsOpenBracket[_foundBracketText], continueSearchPredicate);\n            if (_r) {\n              if (_r instanceof BracketSearchCanceled) {\n                return null;\n              }\n              return _r;\n            }\n          }\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_matchFoundBracket\",\n    value: function _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n      if (!data) {\n        return null;\n      }\n      var matched = isOpen ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate) : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate);\n      if (!matched) {\n        return null;\n      }\n      if (matched instanceof BracketSearchCanceled) {\n        return matched;\n      }\n      return [foundBracket, matched];\n    }\n  }, {\n    key: \"_findMatchingBracketUp\",\n    value: function _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n      // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n      var languageId = bracket.languageId;\n      var reversedBracketRegex = bracket.reversedRegex;\n      var count = -1;\n      var totalCallCount = 0;\n      var searchPrevMatchingBracketInRange = function searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset) {\n        while (true) {\n          if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {\n            return BracketSearchCanceled.INSTANCE;\n          }\n          var r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n          if (!r) {\n            break;\n          }\n          var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n          if (bracket.isOpen(hitText)) {\n            count++;\n          } else if (bracket.isClose(hitText)) {\n            count--;\n          }\n          if (count === 0) {\n            return r;\n          }\n          searchEndOffset = r.startColumn - 1;\n        }\n        return null;\n      };\n      for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n        var lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        var tokenCount = lineTokens.getCount();\n        var lineText = this.textModel.getLineContent(lineNumber);\n        var tokenIndex = tokenCount - 1;\n        var searchStartOffset = lineText.length;\n        var searchEndOffset = lineText.length;\n        if (lineNumber === position.lineNumber) {\n          tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n          searchStartOffset = position.column - 1;\n          searchEndOffset = position.column - 1;\n        }\n        var prevSearchInToken = true;\n        for (; tokenIndex >= 0; tokenIndex--) {\n          var searchInToken = lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n          if (searchInToken) {\n            // this token should be searched\n            if (prevSearchInToken) {\n              // the previous token should be searched, simply extend searchStartOffset\n              searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            } else {\n              // the previous token should not be searched\n              searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n              searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n            }\n          } else {\n            // this token should not be searched\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n              var r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n              if (r) {\n                return r;\n              }\n            }\n          }\n          prevSearchInToken = searchInToken;\n        }\n        if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n          var _r2 = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n          if (_r2) {\n            return _r2;\n          }\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_findMatchingBracketDown\",\n    value: function _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n      // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n      var languageId = bracket.languageId;\n      var bracketRegex = bracket.forwardRegex;\n      var count = 1;\n      var totalCallCount = 0;\n      var searchNextMatchingBracketInRange = function searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset) {\n        while (true) {\n          if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {\n            return BracketSearchCanceled.INSTANCE;\n          }\n          var r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n          if (!r) {\n            break;\n          }\n          var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n          if (bracket.isOpen(hitText)) {\n            count++;\n          } else if (bracket.isClose(hitText)) {\n            count--;\n          }\n          if (count === 0) {\n            return r;\n          }\n          searchStartOffset = r.endColumn - 1;\n        }\n        return null;\n      };\n      var lineCount = this.textModel.getLineCount();\n      for (var lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n        var lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        var tokenCount = lineTokens.getCount();\n        var lineText = this.textModel.getLineContent(lineNumber);\n        var tokenIndex = 0;\n        var searchStartOffset = 0;\n        var searchEndOffset = 0;\n        if (lineNumber === position.lineNumber) {\n          tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n          searchStartOffset = position.column - 1;\n          searchEndOffset = position.column - 1;\n        }\n        var prevSearchInToken = true;\n        for (; tokenIndex < tokenCount; tokenIndex++) {\n          var searchInToken = lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n          if (searchInToken) {\n            // this token should be searched\n            if (prevSearchInToken) {\n              // the previous token should be searched, simply extend searchEndOffset\n              searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n            } else {\n              // the previous token should not be searched\n              searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n              searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n            }\n          } else {\n            // this token should not be searched\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n              var r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n              if (r) {\n                return r;\n              }\n            }\n          }\n          prevSearchInToken = searchInToken;\n        }\n        if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n          var _r3 = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n          if (_r3) {\n            return _r3;\n          }\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"findPrevBracket\",\n    value: function findPrevBracket(_position) {\n      var _a;\n      var position = this.textModel.validatePosition(_position);\n      if (this.canBuildAST) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketBefore(position)) || null;\n      }\n      var languageId = null;\n      var modeBrackets = null;\n      var bracketConfig = null;\n      for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n        var lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        var tokenCount = lineTokens.getCount();\n        var lineText = this.textModel.getLineContent(lineNumber);\n        var tokenIndex = tokenCount - 1;\n        var searchStartOffset = lineText.length;\n        var searchEndOffset = lineText.length;\n        if (lineNumber === position.lineNumber) {\n          tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n          searchStartOffset = position.column - 1;\n          searchEndOffset = position.column - 1;\n          var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n          if (languageId !== tokenLanguageId) {\n            languageId = tokenLanguageId;\n            modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n          }\n        }\n        var prevSearchInToken = true;\n        for (; tokenIndex >= 0; tokenIndex--) {\n          var _tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n          if (languageId !== _tokenLanguageId) {\n            // language id change!\n            if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n              var r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n              if (r) {\n                return this._toFoundBracket(bracketConfig, r);\n              }\n              prevSearchInToken = false;\n            }\n            languageId = _tokenLanguageId;\n            modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n          }\n          var searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n          if (searchInToken) {\n            // this token should be searched\n            if (prevSearchInToken) {\n              // the previous token should be searched, simply extend searchStartOffset\n              searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            } else {\n              // the previous token should not be searched\n              searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n              searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n            }\n          } else {\n            // this token should not be searched\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n              var _r4 = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n              if (_r4) {\n                return this._toFoundBracket(bracketConfig, _r4);\n              }\n            }\n          }\n          prevSearchInToken = searchInToken;\n        }\n        if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n          var _r5 = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n          if (_r5) {\n            return this._toFoundBracket(bracketConfig, _r5);\n          }\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"findNextBracket\",\n    value: function findNextBracket(_position) {\n      var _a;\n      var position = this.textModel.validatePosition(_position);\n      if (this.canBuildAST) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketAfter(position)) || null;\n      }\n      var lineCount = this.textModel.getLineCount();\n      var languageId = null;\n      var modeBrackets = null;\n      var bracketConfig = null;\n      for (var lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n        var lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        var tokenCount = lineTokens.getCount();\n        var lineText = this.textModel.getLineContent(lineNumber);\n        var tokenIndex = 0;\n        var searchStartOffset = 0;\n        var searchEndOffset = 0;\n        if (lineNumber === position.lineNumber) {\n          tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n          searchStartOffset = position.column - 1;\n          searchEndOffset = position.column - 1;\n          var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n          if (languageId !== tokenLanguageId) {\n            languageId = tokenLanguageId;\n            modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n          }\n        }\n        var prevSearchInToken = true;\n        for (; tokenIndex < tokenCount; tokenIndex++) {\n          var _tokenLanguageId2 = lineTokens.getLanguageId(tokenIndex);\n          if (languageId !== _tokenLanguageId2) {\n            // language id change!\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n              var r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n              if (r) {\n                return this._toFoundBracket(bracketConfig, r);\n              }\n              prevSearchInToken = false;\n            }\n            languageId = _tokenLanguageId2;\n            modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n          }\n          var searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n          if (searchInToken) {\n            // this token should be searched\n            if (prevSearchInToken) {\n              // the previous token should be searched, simply extend searchEndOffset\n              searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n            } else {\n              // the previous token should not be searched\n              searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n              searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n            }\n          } else {\n            // this token should not be searched\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n              var _r6 = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n              if (_r6) {\n                return this._toFoundBracket(bracketConfig, _r6);\n              }\n            }\n          }\n          prevSearchInToken = searchInToken;\n        }\n        if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n          var _r7 = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n          if (_r7) {\n            return this._toFoundBracket(bracketConfig, _r7);\n          }\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"findEnclosingBrackets\",\n    value: function findEnclosingBrackets(_position, maxDuration) {\n      var _this3 = this;\n      var position = this.textModel.validatePosition(_position);\n      if (this.canBuildAST) {\n        var range = Range.fromPositions(position);\n        var bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).findLast(function (item) {\n          return item.closingBracketRange !== undefined && item.range.strictContainsRange(range);\n        });\n        if (bracketPair) {\n          return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n        }\n        return null;\n      }\n      var continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n      var lineCount = this.textModel.getLineCount();\n      var savedCounts = new Map();\n      var counts = [];\n      var resetCounts = function resetCounts(languageId, modeBrackets) {\n        if (!savedCounts.has(languageId)) {\n          var tmp = [];\n          for (var i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n            tmp[i] = 0;\n          }\n          savedCounts.set(languageId, tmp);\n        }\n        counts = savedCounts.get(languageId);\n      };\n      var totalCallCount = 0;\n      var searchInRange = function searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) {\n        while (true) {\n          if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {\n            return BracketSearchCanceled.INSTANCE;\n          }\n          var r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n          if (!r) {\n            break;\n          }\n          var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n          var bracket = modeBrackets.textIsBracket[hitText];\n          if (bracket) {\n            if (bracket.isOpen(hitText)) {\n              counts[bracket.index]++;\n            } else if (bracket.isClose(hitText)) {\n              counts[bracket.index]--;\n            }\n            if (counts[bracket.index] === -1) {\n              return _this3._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n            }\n          }\n          searchStartOffset = r.endColumn - 1;\n        }\n        return null;\n      };\n      var languageId = null;\n      var modeBrackets = null;\n      for (var lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n        var lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        var tokenCount = lineTokens.getCount();\n        var lineText = this.textModel.getLineContent(lineNumber);\n        var tokenIndex = 0;\n        var searchStartOffset = 0;\n        var searchEndOffset = 0;\n        if (lineNumber === position.lineNumber) {\n          tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n          searchStartOffset = position.column - 1;\n          searchEndOffset = position.column - 1;\n          var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n          if (languageId !== tokenLanguageId) {\n            languageId = tokenLanguageId;\n            modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            resetCounts(languageId, modeBrackets);\n          }\n        }\n        var prevSearchInToken = true;\n        for (; tokenIndex < tokenCount; tokenIndex++) {\n          var _tokenLanguageId3 = lineTokens.getLanguageId(tokenIndex);\n          if (languageId !== _tokenLanguageId3) {\n            // language id change!\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n              var r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n              if (r) {\n                return stripBracketSearchCanceled(r);\n              }\n              prevSearchInToken = false;\n            }\n            languageId = _tokenLanguageId3;\n            modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            resetCounts(languageId, modeBrackets);\n          }\n          var searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n          if (searchInToken) {\n            // this token should be searched\n            if (prevSearchInToken) {\n              // the previous token should be searched, simply extend searchEndOffset\n              searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n            } else {\n              // the previous token should not be searched\n              searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n              searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n            }\n          } else {\n            // this token should not be searched\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n              var _r8 = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n              if (_r8) {\n                return stripBracketSearchCanceled(_r8);\n              }\n            }\n          }\n          prevSearchInToken = searchInToken;\n        }\n        if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n          var _r9 = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n          if (_r9) {\n            return stripBracketSearchCanceled(_r9);\n          }\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_toFoundBracket\",\n    value: function _toFoundBracket(bracketConfig, r) {\n      if (!r) {\n        return null;\n      }\n      var text = this.textModel.getValueInRange(r);\n      text = text.toLowerCase();\n      var bracketInfo = bracketConfig.getBracketInfo(text);\n      if (!bracketInfo) {\n        return null;\n      }\n      return {\n        range: r,\n        bracketInfo: bracketInfo\n      };\n    }\n  }]);\n}(Disposable);\nfunction createDisposableRef(object, disposable) {\n  return {\n    object: object,\n    dispose: function dispose() {\n      return disposable === null || disposable === void 0 ? void 0 : disposable.dispose();\n    }\n  };\n}\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration) {\n  if (typeof maxDuration === 'undefined') {\n    return function () {\n      return true;\n    };\n  } else {\n    var startTime = Date.now();\n    return function () {\n      return Date.now() - startTime <= maxDuration;\n    };\n  }\n}\nvar BracketSearchCanceled = /*#__PURE__*/_createClass(function BracketSearchCanceled() {\n  _classCallCheck(this, BracketSearchCanceled);\n  this._searchCanceledBrand = undefined;\n});\nBracketSearchCanceled.INSTANCE = new BracketSearchCanceled();\nfunction stripBracketSearchCanceled(result) {\n  if (result instanceof BracketSearchCanceled) {\n    return null;\n  }\n  return result;\n}","map":{"version":3,"names":["CallbackIterable","compareBy","Emitter","Disposable","DisposableStore","MutableDisposable","Range","ignoreBracketsInToken","BracketsUtils","BracketPairsTree","BracketPairsTextModelPart","_Disposable","textModel","languageConfigurationService","_this","_classCallCheck","_callSuper","bracketPairsTree","_register","onDidChangeEmitter","onDidChange","event","bracketsRequested","e","_a","languageId","value","object","didLanguageChange","clear","updateBracketPairsTree","_inherits","_createClass","key","get","maxSupportedDocumentLength","getValueLength","handleDidChangeOptions","handleDidChangeLanguage","handleDidChangeContent","change","handleContentChanged","handleDidChangeBackgroundTokenizationState","handleDidChangeTokens","_this2","canBuildAST","store","createDisposableRef","add","getLanguageConfiguration","fire","getBracketPairsInRange","range","empty","getBracketPairsInRangeWithMinIndentation","getBracketsInRange","onlyColorizedBrackets","arguments","length","undefined","findMatchingBracketUp","_bracket","_position","maxDuration","position","validatePosition","getLanguageIdAtPosition","lineNumber","column","closingBracketInfo","bracketsNew","getClosingBracketInfo","bracketPair","fromPositions","findLast","b","closes","openingBracketInfo","openingBracketRange","bracket","toLowerCase","bracketsSupport","brackets","data","textIsBracket","stripBracketSearchCanceled","_findMatchingBracketUp","createTimeBasedContinueBracketSearchPredicate","matchBracket","filter","item","closingBracketRange","containsPosition","findLastMaxBy","compareRangesUsingStarts","continueSearchPredicate","_matchBracket","_establishBracketSearchOffsets","lineTokens","modeBrackets","tokenIndex","tokenCount","getCount","currentLanguageId","getLanguageId","searchStartOffset","Math","max","maxBracketLength","i","tokenEndOffset","getEndOffset","getStandardTokenType","searchEndOffset","min","getLineContent","tokenStartOffset","getStartOffset","tokenization","getLineTokens","lineText","findTokenIndexAtOffset","currentModeBrackets","_this$_establishBrack","bestResult","foundBracket","findNextBracketInRange","forwardRegex","startColumn","endColumn","foundBracketText","substring","r","_matchFoundBracket","textIsOpenBracket","BracketSearchCanceled","prevTokenIndex","prevModeBrackets","_this$_establishBrack2","findPrevBracketInRange","reversedRegex","isOpen","matched","_findMatchingBracketDown","getEndPosition","getStartPosition","reversedBracketRegex","count","totalCallCount","searchPrevMatchingBracketInRange","INSTANCE","hitText","isClose","prevSearchInToken","searchInToken","bracketRegex","searchNextMatchingBracketInRange","lineCount","getLineCount","findPrevBracket","getFirstBracketBefore","bracketConfig","tokenLanguageId","_toFoundBracket","findNextBracket","getFirstBracketAfter","findEnclosingBrackets","_this3","strictContainsRange","savedCounts","Map","counts","resetCounts","has","tmp","len","set","searchInRange","index","text","getValueInRange","bracketInfo","getBracketInfo","disposable","dispose","startTime","Date","now","_searchCanceledBrand","result"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CallbackIterable, compareBy } from '../../../../base/common/arrays.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nexport class BracketPairsTextModelPart extends Disposable {\n    get canBuildAST() {\n        const maxSupportedDocumentLength = /* max lines */ 50000 * /* average column count */ 100;\n        return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.bracketPairsTree = this._register(new MutableDisposable());\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.bracketsRequested = false;\n        this._register(this.languageConfigurationService.onDidChange(e => {\n            var _a;\n            if (!e.languageId || ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.didLanguageChange(e.languageId))) {\n                this.bracketPairsTree.clear();\n                this.updateBracketPairsTree();\n            }\n        }));\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeLanguage(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeContent(change) {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleContentChanged(change);\n    }\n    handleDidChangeBackgroundTokenizationState() {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeBackgroundTokenizationState();\n    }\n    handleDidChangeTokens(e) {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeTokens(e);\n    }\n    //#endregion\n    updateBracketPairsTree() {\n        if (this.bracketsRequested && this.canBuildAST) {\n            if (!this.bracketPairsTree.value) {\n                const store = new DisposableStore();\n                this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {\n                    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n                })), store);\n                store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n                this.onDidChangeEmitter.fire();\n            }\n        }\n        else {\n            if (this.bracketPairsTree.value) {\n                this.bracketPairsTree.clear();\n                // Important: Don't call fire if there was no change!\n                this.onDidChangeEmitter.fire();\n            }\n        }\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n    getBracketPairsInRange(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, false)) || CallbackIterable.empty;\n    }\n    getBracketPairsInRangeWithMinIndentation(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, true)) || CallbackIterable.empty;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets = false) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketsInRange(range, onlyColorizedBrackets)) || CallbackIterable.empty;\n    }\n    findMatchingBracketUp(_bracket, _position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n        if (this.canBuildAST) {\n            const closingBracketInfo = this.languageConfigurationService\n                .getLanguageConfiguration(languageId)\n                .bracketsNew.getClosingBracketInfo(_bracket);\n            if (!closingBracketInfo) {\n                return null;\n            }\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(_position, _position)).findLast((b) => closingBracketInfo.closes(b.openingBracketInfo));\n            if (bracketPair) {\n                return bracketPair.openingBracketRange;\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const bracket = _bracket.toLowerCase();\n            const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            if (!bracketsSupport) {\n                return null;\n            }\n            const data = bracketsSupport.textIsBracket[bracket];\n            if (!data) {\n                return null;\n            }\n            return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n        }\n    }\n    matchBracket(position, maxDuration) {\n        if (this.canBuildAST) {\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).filter((item) => item.closingBracketRange !== undefined &&\n                (item.openingBracketRange.containsPosition(position) ||\n                    item.closingBracketRange.containsPosition(position))).findLastMaxBy(compareBy((item) => item.openingBracketRange.containsPosition(position)\n                ? item.openingBracketRange\n                : item.closingBracketRange, Range.compareRangesUsingStarts));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n            return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n        }\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position, continueSearchPredicate) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        const lineText = this.textModel.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.textModel.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        var _a;\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketBefore(position)) || null;\n        }\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        var _a;\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketAfter(position)) || null;\n        }\n        const lineCount = this.textModel.getLineCount();\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            const range = Range.fromPositions(position);\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).findLast((item) => item.closingBracketRange !== undefined && item.range.strictContainsRange(range));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n        const lineCount = this.textModel.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                const tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(bracketConfig, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.textModel.getValueInRange(r);\n        text = text.toLowerCase();\n        const bracketInfo = bracketConfig.getBracketInfo(text);\n        if (!bracketInfo) {\n            return null;\n        }\n        return {\n            range: r,\n            bracketInfo\n        };\n    }\n}\nfunction createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose(),\n    };\n}\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration) {\n    if (typeof maxDuration === 'undefined') {\n        return () => true;\n    }\n    else {\n        const startTime = Date.now();\n        return () => {\n            return (Date.now() - startTime <= maxDuration);\n        };\n    }\n}\nclass BracketSearchCanceled {\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nBracketSearchCanceled.INSTANCE = new BracketSearchCanceled();\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}