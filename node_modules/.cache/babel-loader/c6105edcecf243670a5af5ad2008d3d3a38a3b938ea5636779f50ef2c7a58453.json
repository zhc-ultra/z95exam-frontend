{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.substr.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nvar AverageBufferSize = 65535;\nfunction createUintArray(arr) {\n  var r;\n  if (arr[arr.length - 1] < 65536) {\n    r = new Uint16Array(arr.length);\n  } else {\n    r = new Uint32Array(arr.length);\n  }\n  r.set(arr, 0);\n  return r;\n}\nvar LineStarts = /*#__PURE__*/_createClass(function LineStarts(lineStarts, cr, lf, crlf, isBasicASCII) {\n  _classCallCheck(this, LineStarts);\n  this.lineStarts = lineStarts;\n  this.cr = cr;\n  this.lf = lf;\n  this.crlf = crlf;\n  this.isBasicASCII = isBasicASCII;\n});\nexport function createLineStartsFast(str) {\n  var readonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var r = [0];\n  var rLength = 1;\n  for (var i = 0, len = str.length; i < len; i++) {\n    var chr = str.charCodeAt(i);\n    if (chr === 13 /* CharCode.CarriageReturn */) {\n      if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n        // \\r\\n... case\n        r[rLength++] = i + 2;\n        i++; // skip \\n\n      } else {\n        // \\r... case\n        r[rLength++] = i + 1;\n      }\n    } else if (chr === 10 /* CharCode.LineFeed */) {\n      r[rLength++] = i + 1;\n    }\n  }\n  if (readonly) {\n    return createUintArray(r);\n  } else {\n    return r;\n  }\n}\nexport function createLineStarts(r, str) {\n  r.length = 0;\n  r[0] = 0;\n  var rLength = 1;\n  var cr = 0,\n    lf = 0,\n    crlf = 0;\n  var isBasicASCII = true;\n  for (var i = 0, len = str.length; i < len; i++) {\n    var chr = str.charCodeAt(i);\n    if (chr === 13 /* CharCode.CarriageReturn */) {\n      if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n        // \\r\\n... case\n        crlf++;\n        r[rLength++] = i + 2;\n        i++; // skip \\n\n      } else {\n        cr++;\n        // \\r... case\n        r[rLength++] = i + 1;\n      }\n    } else if (chr === 10 /* CharCode.LineFeed */) {\n      lf++;\n      r[rLength++] = i + 1;\n    } else {\n      if (isBasicASCII) {\n        if (chr !== 9 /* CharCode.Tab */ && (chr < 32 || chr > 126)) {\n          isBasicASCII = false;\n        }\n      }\n    }\n  }\n  var result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n  r.length = 0;\n  return result;\n}\nexport var Piece = /*#__PURE__*/_createClass(function Piece(bufferIndex, start, end, lineFeedCnt, length) {\n  _classCallCheck(this, Piece);\n  this.bufferIndex = bufferIndex;\n  this.start = start;\n  this.end = end;\n  this.lineFeedCnt = lineFeedCnt;\n  this.length = length;\n});\nexport var StringBuffer = /*#__PURE__*/_createClass(function StringBuffer(buffer, lineStarts) {\n  _classCallCheck(this, StringBuffer);\n  this.buffer = buffer;\n  this.lineStarts = lineStarts;\n});\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nvar PieceTreeSnapshot = /*#__PURE__*/function () {\n  function PieceTreeSnapshot(tree, BOM) {\n    var _this = this;\n    _classCallCheck(this, PieceTreeSnapshot);\n    this._pieces = [];\n    this._tree = tree;\n    this._BOM = BOM;\n    this._index = 0;\n    if (tree.root !== SENTINEL) {\n      tree.iterate(tree.root, function (node) {\n        if (node !== SENTINEL) {\n          _this._pieces.push(node.piece);\n        }\n        return true;\n      });\n    }\n  }\n  return _createClass(PieceTreeSnapshot, [{\n    key: \"read\",\n    value: function read() {\n      if (this._pieces.length === 0) {\n        if (this._index === 0) {\n          this._index++;\n          return this._BOM;\n        } else {\n          return null;\n        }\n      }\n      if (this._index > this._pieces.length - 1) {\n        return null;\n      }\n      if (this._index === 0) {\n        return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n      }\n      return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n  }]);\n}();\nvar PieceTreeSearchCache = /*#__PURE__*/function () {\n  function PieceTreeSearchCache(limit) {\n    _classCallCheck(this, PieceTreeSearchCache);\n    this._limit = limit;\n    this._cache = [];\n  }\n  return _createClass(PieceTreeSearchCache, [{\n    key: \"get\",\n    value: function get(offset) {\n      for (var i = this._cache.length - 1; i >= 0; i--) {\n        var nodePos = this._cache[i];\n        if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n          return nodePos;\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"get2\",\n    value: function get2(lineNumber) {\n      for (var i = this._cache.length - 1; i >= 0; i--) {\n        var nodePos = this._cache[i];\n        if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n          return nodePos;\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"set\",\n    value: function set(nodePosition) {\n      if (this._cache.length >= this._limit) {\n        this._cache.shift();\n      }\n      this._cache.push(nodePosition);\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(offset) {\n      var hasInvalidVal = false;\n      var tmp = this._cache;\n      for (var i = 0; i < tmp.length; i++) {\n        var nodePos = tmp[i];\n        if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n          tmp[i] = null;\n          hasInvalidVal = true;\n          continue;\n        }\n      }\n      if (hasInvalidVal) {\n        var newArr = [];\n        var _iterator = _createForOfIteratorHelper(tmp),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var entry = _step.value;\n            if (entry !== null) {\n              newArr.push(entry);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        this._cache = newArr;\n      }\n    }\n  }]);\n}();\nexport var PieceTreeBase = /*#__PURE__*/function () {\n  function PieceTreeBase(chunks, eol, eolNormalized) {\n    _classCallCheck(this, PieceTreeBase);\n    this.create(chunks, eol, eolNormalized);\n  }\n  return _createClass(PieceTreeBase, [{\n    key: \"create\",\n    value: function create(chunks, eol, eolNormalized) {\n      this._buffers = [new StringBuffer('', [0])];\n      this._lastChangeBufferPos = {\n        line: 0,\n        column: 0\n      };\n      this.root = SENTINEL;\n      this._lineCnt = 1;\n      this._length = 0;\n      this._EOL = eol;\n      this._EOLLength = eol.length;\n      this._EOLNormalized = eolNormalized;\n      var lastNode = null;\n      for (var i = 0, len = chunks.length; i < len; i++) {\n        if (chunks[i].buffer.length > 0) {\n          if (!chunks[i].lineStarts) {\n            chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n          }\n          var piece = new Piece(i + 1, {\n            line: 0,\n            column: 0\n          }, {\n            line: chunks[i].lineStarts.length - 1,\n            column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1]\n          }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n          this._buffers.push(chunks[i]);\n          lastNode = this.rbInsertRight(lastNode, piece);\n        }\n      }\n      this._searchCache = new PieceTreeSearchCache(1);\n      this._lastVisitedLine = {\n        lineNumber: 0,\n        value: ''\n      };\n      this.computeBufferMetadata();\n    }\n  }, {\n    key: \"normalizeEOL\",\n    value: function normalizeEOL(eol) {\n      var _this2 = this;\n      var averageBufferSize = AverageBufferSize;\n      var min = averageBufferSize - Math.floor(averageBufferSize / 3);\n      var max = min * 2;\n      var tempChunk = '';\n      var tempChunkLen = 0;\n      var chunks = [];\n      this.iterate(this.root, function (node) {\n        var str = _this2.getNodeContent(node);\n        var len = str.length;\n        if (tempChunkLen <= min || tempChunkLen + len < max) {\n          tempChunk += str;\n          tempChunkLen += len;\n          return true;\n        }\n        // flush anyways\n        var text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n        chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        tempChunk = str;\n        tempChunkLen = len;\n        return true;\n      });\n      if (tempChunkLen > 0) {\n        var text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n        chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n      }\n      this.create(chunks, eol, true);\n    }\n    // #region Buffer API\n  }, {\n    key: \"getEOL\",\n    value: function getEOL() {\n      return this._EOL;\n    }\n  }, {\n    key: \"setEOL\",\n    value: function setEOL(newEOL) {\n      this._EOL = newEOL;\n      this._EOLLength = this._EOL.length;\n      this.normalizeEOL(newEOL);\n    }\n  }, {\n    key: \"createSnapshot\",\n    value: function createSnapshot(BOM) {\n      return new PieceTreeSnapshot(this, BOM);\n    }\n  }, {\n    key: \"getOffsetAt\",\n    value: function getOffsetAt(lineNumber, column) {\n      var leftLen = 0; // inorder\n      var x = this.root;\n      while (x !== SENTINEL) {\n        if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n          x = x.left;\n        } else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n          leftLen += x.size_left;\n          // lineNumber >= 2\n          var accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n          return leftLen += accumualtedValInCurrentIndex + column - 1;\n        } else {\n          lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n          leftLen += x.size_left + x.piece.length;\n          x = x.right;\n        }\n      }\n      return leftLen;\n    }\n  }, {\n    key: \"getPositionAt\",\n    value: function getPositionAt(offset) {\n      offset = Math.floor(offset);\n      offset = Math.max(0, offset);\n      var x = this.root;\n      var lfCnt = 0;\n      var originalOffset = offset;\n      while (x !== SENTINEL) {\n        if (x.size_left !== 0 && x.size_left >= offset) {\n          x = x.left;\n        } else if (x.size_left + x.piece.length >= offset) {\n          var out = this.getIndexOf(x, offset - x.size_left);\n          lfCnt += x.lf_left + out.index;\n          if (out.index === 0) {\n            var lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n            var column = originalOffset - lineStartOffset;\n            return new Position(lfCnt + 1, column + 1);\n          }\n          return new Position(lfCnt + 1, out.remainder + 1);\n        } else {\n          offset -= x.size_left + x.piece.length;\n          lfCnt += x.lf_left + x.piece.lineFeedCnt;\n          if (x.right === SENTINEL) {\n            // last node\n            var _lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n            var _column = originalOffset - offset - _lineStartOffset;\n            return new Position(lfCnt + 1, _column + 1);\n          } else {\n            x = x.right;\n          }\n        }\n      }\n      return new Position(1, 1);\n    }\n  }, {\n    key: \"getValueInRange\",\n    value: function getValueInRange(range, eol) {\n      if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n        return '';\n      }\n      var startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n      var endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n      var value = this.getValueInRange2(startPosition, endPosition);\n      if (eol) {\n        if (eol !== this._EOL || !this._EOLNormalized) {\n          return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        if (eol === this.getEOL() && this._EOLNormalized) {\n          if (eol === '\\r\\n') {}\n          return value;\n        }\n        return value.replace(/\\r\\n|\\r|\\n/g, eol);\n      }\n      return value;\n    }\n  }, {\n    key: \"getValueInRange2\",\n    value: function getValueInRange2(startPosition, endPosition) {\n      if (startPosition.node === endPosition.node) {\n        var node = startPosition.node;\n        var _buffer = this._buffers[node.piece.bufferIndex].buffer;\n        var _startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        return _buffer.substring(_startOffset + startPosition.remainder, _startOffset + endPosition.remainder);\n      }\n      var x = startPosition.node;\n      var buffer = this._buffers[x.piece.bufferIndex].buffer;\n      var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n      var ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n      x = x.next();\n      while (x !== SENTINEL) {\n        var _buffer2 = this._buffers[x.piece.bufferIndex].buffer;\n        var _startOffset2 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        if (x === endPosition.node) {\n          ret += _buffer2.substring(_startOffset2, _startOffset2 + endPosition.remainder);\n          break;\n        } else {\n          ret += _buffer2.substr(_startOffset2, x.piece.length);\n        }\n        x = x.next();\n      }\n      return ret;\n    }\n  }, {\n    key: \"getLinesContent\",\n    value: function getLinesContent() {\n      var _this3 = this;\n      var lines = [];\n      var linesLength = 0;\n      var currentLine = '';\n      var danglingCR = false;\n      this.iterate(this.root, function (node) {\n        if (node === SENTINEL) {\n          return true;\n        }\n        var piece = node.piece;\n        var pieceLength = piece.length;\n        if (pieceLength === 0) {\n          return true;\n        }\n        var buffer = _this3._buffers[piece.bufferIndex].buffer;\n        var lineStarts = _this3._buffers[piece.bufferIndex].lineStarts;\n        var pieceStartLine = piece.start.line;\n        var pieceEndLine = piece.end.line;\n        var pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n        if (danglingCR) {\n          if (buffer.charCodeAt(pieceStartOffset) === 10 /* CharCode.LineFeed */) {\n            // pretend the \\n was in the previous piece..\n            pieceStartOffset++;\n            pieceLength--;\n          }\n          lines[linesLength++] = currentLine;\n          currentLine = '';\n          danglingCR = false;\n          if (pieceLength === 0) {\n            return true;\n          }\n        }\n        if (pieceStartLine === pieceEndLine) {\n          // this piece has no new lines\n          if (!_this3._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CharCode.CarriageReturn */) {\n            danglingCR = true;\n            currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n          } else {\n            currentLine += buffer.substr(pieceStartOffset, pieceLength);\n          }\n          return true;\n        }\n        // add the text before the first line start in this piece\n        currentLine += _this3._EOLNormalized ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - _this3._EOLLength)) : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, '');\n        lines[linesLength++] = currentLine;\n        for (var line = pieceStartLine + 1; line < pieceEndLine; line++) {\n          currentLine = _this3._EOLNormalized ? buffer.substring(lineStarts[line], lineStarts[line + 1] - _this3._EOLLength) : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, '');\n          lines[linesLength++] = currentLine;\n        }\n        if (!_this3._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CharCode.CarriageReturn */) {\n          danglingCR = true;\n          if (piece.end.column === 0) {\n            // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n            linesLength--;\n          } else {\n            currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n          }\n        } else {\n          currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n        }\n        return true;\n      });\n      if (danglingCR) {\n        lines[linesLength++] = currentLine;\n        currentLine = '';\n      }\n      lines[linesLength++] = currentLine;\n      return lines;\n    }\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return this._length;\n    }\n  }, {\n    key: \"getLineCount\",\n    value: function getLineCount() {\n      return this._lineCnt;\n    }\n  }, {\n    key: \"getLineContent\",\n    value: function getLineContent(lineNumber) {\n      if (this._lastVisitedLine.lineNumber === lineNumber) {\n        return this._lastVisitedLine.value;\n      }\n      this._lastVisitedLine.lineNumber = lineNumber;\n      if (lineNumber === this._lineCnt) {\n        this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n      } else if (this._EOLNormalized) {\n        this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n      } else {\n        this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n      }\n      return this._lastVisitedLine.value;\n    }\n  }, {\n    key: \"_getCharCode\",\n    value: function _getCharCode(nodePos) {\n      if (nodePos.remainder === nodePos.node.piece.length) {\n        // the char we want to fetch is at the head of next node.\n        var matchingNode = nodePos.node.next();\n        if (!matchingNode) {\n          return 0;\n        }\n        var buffer = this._buffers[matchingNode.piece.bufferIndex];\n        var startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n        return buffer.buffer.charCodeAt(startOffset);\n      } else {\n        var _buffer3 = this._buffers[nodePos.node.piece.bufferIndex];\n        var _startOffset3 = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n        var targetOffset = _startOffset3 + nodePos.remainder;\n        return _buffer3.buffer.charCodeAt(targetOffset);\n      }\n    }\n  }, {\n    key: \"getLineCharCode\",\n    value: function getLineCharCode(lineNumber, index) {\n      var nodePos = this.nodeAt2(lineNumber, index + 1);\n      return this._getCharCode(nodePos);\n    }\n  }, {\n    key: \"getLineLength\",\n    value: function getLineLength(lineNumber) {\n      if (lineNumber === this.getLineCount()) {\n        var startOffset = this.getOffsetAt(lineNumber, 1);\n        return this.getLength() - startOffset;\n      }\n      return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n  }, {\n    key: \"findMatchesInNode\",\n    value: function findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n      var buffer = this._buffers[node.piece.bufferIndex];\n      var startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n      var start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n      var end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n      var m;\n      // Reset regex to search from the beginning\n      var ret = {\n        line: 0,\n        column: 0\n      };\n      var searchText;\n      var offsetInBuffer;\n      if (searcher._wordSeparators) {\n        searchText = buffer.buffer.substring(start, end);\n        offsetInBuffer = function offsetInBuffer(offset) {\n          return offset + start;\n        };\n        searcher.reset(0);\n      } else {\n        searchText = buffer.buffer;\n        offsetInBuffer = function offsetInBuffer(offset) {\n          return offset;\n        };\n        searcher.reset(start);\n      }\n      do {\n        m = searcher.next(searchText);\n        if (m) {\n          if (offsetInBuffer(m.index) >= end) {\n            return resultLen;\n          }\n          this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n          var lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n          var retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n          var retEndColumn = retStartColumn + m[0].length;\n          result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n          if (offsetInBuffer(m.index) + m[0].length >= end) {\n            return resultLen;\n          }\n          if (resultLen >= limitResultCount) {\n            return resultLen;\n          }\n        }\n      } while (m);\n      return resultLen;\n    }\n  }, {\n    key: \"findMatchesLineByLine\",\n    value: function findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n      var result = [];\n      var resultLen = 0;\n      var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n      var startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n      if (startPosition === null) {\n        return [];\n      }\n      var endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n      if (endPosition === null) {\n        return [];\n      }\n      var start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n      var end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n      if (startPosition.node === endPosition.node) {\n        this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n      }\n      var startLineNumber = searchRange.startLineNumber;\n      var currentNode = startPosition.node;\n      while (currentNode !== endPosition.node) {\n        var lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n        if (lineBreakCnt >= 1) {\n          // last line break position\n          var lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n          var startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n          var nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n          var _startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n          resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, _startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n          if (resultLen >= limitResultCount) {\n            return result;\n          }\n          startLineNumber += lineBreakCnt;\n        }\n        var _startColumn2 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n        // search for the remaining content\n        if (startLineNumber === searchRange.endLineNumber) {\n          var text = this.getLineContent(startLineNumber).substring(_startColumn2, searchRange.endColumn - 1);\n          resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, _startColumn2, resultLen, result, captureMatches, limitResultCount);\n          return result;\n        }\n        resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(_startColumn2), startLineNumber, _startColumn2, resultLen, result, captureMatches, limitResultCount);\n        if (resultLen >= limitResultCount) {\n          return result;\n        }\n        startLineNumber++;\n        startPosition = this.nodeAt2(startLineNumber, 1);\n        currentNode = startPosition.node;\n        start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n      }\n      if (startLineNumber === searchRange.endLineNumber) {\n        var _startColumn3 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n        var _text = this.getLineContent(startLineNumber).substring(_startColumn3, searchRange.endColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, searcher, _text, searchRange.endLineNumber, _startColumn3, resultLen, result, captureMatches, limitResultCount);\n        return result;\n      }\n      var startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n      resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n      return result;\n    }\n  }, {\n    key: \"_findMatchesInLine\",\n    value: function _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n      var wordSeparators = searchData.wordSeparators;\n      if (!captureMatches && searchData.simpleSearch) {\n        var searchString = searchData.simpleSearch;\n        var searchStringLen = searchString.length;\n        var textLength = text.length;\n        var lastMatchIndex = -searchStringLen;\n        while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n          if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n            result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n            if (resultLen >= limitResultCount) {\n              return resultLen;\n            }\n          }\n        }\n        return resultLen;\n      }\n      var m;\n      // Reset regex to search from the beginning\n      searcher.reset(0);\n      do {\n        m = searcher.next(text);\n        if (m) {\n          result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n          if (resultLen >= limitResultCount) {\n            return resultLen;\n          }\n        }\n      } while (m);\n      return resultLen;\n    }\n    // #endregion\n    // #region Piece Table\n  }, {\n    key: \"insert\",\n    value: function insert(offset, value) {\n      var eolNormalized = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this._EOLNormalized = this._EOLNormalized && eolNormalized;\n      this._lastVisitedLine.lineNumber = 0;\n      this._lastVisitedLine.value = '';\n      if (this.root !== SENTINEL) {\n        var _this$nodeAt = this.nodeAt(offset),\n          node = _this$nodeAt.node,\n          remainder = _this$nodeAt.remainder,\n          nodeStartOffset = _this$nodeAt.nodeStartOffset;\n        var piece = node.piece;\n        var bufferIndex = piece.bufferIndex;\n        var insertPosInBuffer = this.positionInBuffer(node, remainder);\n        if (node.piece.bufferIndex === 0 && piece.end.line === this._lastChangeBufferPos.line && piece.end.column === this._lastChangeBufferPos.column && nodeStartOffset + piece.length === offset && value.length < AverageBufferSize) {\n          // changed buffer\n          this.appendToNode(node, value);\n          this.computeBufferMetadata();\n          return;\n        }\n        if (nodeStartOffset === offset) {\n          this.insertContentToNodeLeft(value, node);\n          this._searchCache.validate(offset);\n        } else if (nodeStartOffset + node.piece.length > offset) {\n          // we are inserting into the middle of a node.\n          var nodesToDel = [];\n          var newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n          if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            var headOfRight = this.nodeCharCodeAt(node, remainder);\n            if (headOfRight === 10 /** \\n */) {\n              var newStart = {\n                line: newRightPiece.start.line + 1,\n                column: 0\n              };\n              newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n              value += '\\n';\n            }\n          }\n          // reuse node for content before insertion point.\n          if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n            var tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n            if (tailOfLeft === 13 /** \\r */) {\n              var previousPos = this.positionInBuffer(node, remainder - 1);\n              this.deleteNodeTail(node, previousPos);\n              value = '\\r' + value;\n              if (node.piece.length === 0) {\n                nodesToDel.push(node);\n              }\n            } else {\n              this.deleteNodeTail(node, insertPosInBuffer);\n            }\n          } else {\n            this.deleteNodeTail(node, insertPosInBuffer);\n          }\n          var newPieces = this.createNewPieces(value);\n          if (newRightPiece.length > 0) {\n            this.rbInsertRight(node, newRightPiece);\n          }\n          var tmpNode = node;\n          for (var k = 0; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n          }\n          this.deleteNodes(nodesToDel);\n        } else {\n          this.insertContentToNodeRight(value, node);\n        }\n      } else {\n        // insert new node\n        var pieces = this.createNewPieces(value);\n        var _node = this.rbInsertLeft(null, pieces[0]);\n        for (var _k = 1; _k < pieces.length; _k++) {\n          _node = this.rbInsertRight(_node, pieces[_k]);\n        }\n      }\n      // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n      this.computeBufferMetadata();\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(offset, cnt) {\n      this._lastVisitedLine.lineNumber = 0;\n      this._lastVisitedLine.value = '';\n      if (cnt <= 0 || this.root === SENTINEL) {\n        return;\n      }\n      var startPosition = this.nodeAt(offset);\n      var endPosition = this.nodeAt(offset + cnt);\n      var startNode = startPosition.node;\n      var endNode = endPosition.node;\n      if (startNode === endNode) {\n        var _startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        var _endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n        if (startPosition.nodeStartOffset === offset) {\n          if (cnt === startNode.piece.length) {\n            // delete node\n            var next = startNode.next();\n            rbDelete(this, startNode);\n            this.validateCRLFWithPrevNode(next);\n            this.computeBufferMetadata();\n            return;\n          }\n          this.deleteNodeHead(startNode, _endSplitPosInBuffer);\n          this._searchCache.validate(offset);\n          this.validateCRLFWithPrevNode(startNode);\n          this.computeBufferMetadata();\n          return;\n        }\n        if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n          this.deleteNodeTail(startNode, _startSplitPosInBuffer);\n          this.validateCRLFWithNextNode(startNode);\n          this.computeBufferMetadata();\n          return;\n        }\n        // delete content in the middle, this node will be splitted to nodes\n        this.shrinkNode(startNode, _startSplitPosInBuffer, _endSplitPosInBuffer);\n        this.computeBufferMetadata();\n        return;\n      }\n      var nodesToDel = [];\n      var startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n      this.deleteNodeTail(startNode, startSplitPosInBuffer);\n      this._searchCache.validate(offset);\n      if (startNode.piece.length === 0) {\n        nodesToDel.push(startNode);\n      }\n      // update last touched node\n      var endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n      this.deleteNodeHead(endNode, endSplitPosInBuffer);\n      if (endNode.piece.length === 0) {\n        nodesToDel.push(endNode);\n      }\n      // delete nodes in between\n      var secondNode = startNode.next();\n      for (var node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n        nodesToDel.push(node);\n      }\n      var prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n      this.deleteNodes(nodesToDel);\n      this.validateCRLFWithNextNode(prev);\n      this.computeBufferMetadata();\n    }\n  }, {\n    key: \"insertContentToNodeLeft\",\n    value: function insertContentToNodeLeft(value, node) {\n      // we are inserting content to the beginning of node\n      var nodesToDel = [];\n      if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n        // move `\\n` to new node.\n        var piece = node.piece;\n        var newStart = {\n          line: piece.start.line + 1,\n          column: 0\n        };\n        var nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n        node.piece = nPiece;\n        value += '\\n';\n        updateTreeMetadata(this, node, -1, -1);\n        if (node.piece.length === 0) {\n          nodesToDel.push(node);\n        }\n      }\n      var newPieces = this.createNewPieces(value);\n      var newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n      for (var k = newPieces.length - 2; k >= 0; k--) {\n        newNode = this.rbInsertLeft(newNode, newPieces[k]);\n      }\n      this.validateCRLFWithPrevNode(newNode);\n      this.deleteNodes(nodesToDel);\n    }\n  }, {\n    key: \"insertContentToNodeRight\",\n    value: function insertContentToNodeRight(value, node) {\n      // we are inserting to the right of this node.\n      if (this.adjustCarriageReturnFromNext(value, node)) {\n        // move \\n to the new node.\n        value += '\\n';\n      }\n      var newPieces = this.createNewPieces(value);\n      var newNode = this.rbInsertRight(node, newPieces[0]);\n      var tmpNode = newNode;\n      for (var k = 1; k < newPieces.length; k++) {\n        tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n      }\n      this.validateCRLFWithPrevNode(newNode);\n    }\n  }, {\n    key: \"positionInBuffer\",\n    value: function positionInBuffer(node, remainder, ret) {\n      var piece = node.piece;\n      var bufferIndex = node.piece.bufferIndex;\n      var lineStarts = this._buffers[bufferIndex].lineStarts;\n      var startOffset = lineStarts[piece.start.line] + piece.start.column;\n      var offset = startOffset + remainder;\n      // binary search offset between startOffset and endOffset\n      var low = piece.start.line;\n      var high = piece.end.line;\n      var mid = 0;\n      var midStop = 0;\n      var midStart = 0;\n      while (low <= high) {\n        mid = low + (high - low) / 2 | 0;\n        midStart = lineStarts[mid];\n        if (mid === high) {\n          break;\n        }\n        midStop = lineStarts[mid + 1];\n        if (offset < midStart) {\n          high = mid - 1;\n        } else if (offset >= midStop) {\n          low = mid + 1;\n        } else {\n          break;\n        }\n      }\n      if (ret) {\n        ret.line = mid;\n        ret.column = offset - midStart;\n        return null;\n      }\n      return {\n        line: mid,\n        column: offset - midStart\n      };\n    }\n  }, {\n    key: \"getLineFeedCnt\",\n    value: function getLineFeedCnt(bufferIndex, start, end) {\n      // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n      // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n      if (end.column === 0) {\n        return end.line - start.line;\n      }\n      var lineStarts = this._buffers[bufferIndex].lineStarts;\n      if (end.line === lineStarts.length - 1) {\n        // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n        return end.line - start.line;\n      }\n      var nextLineStartOffset = lineStarts[end.line + 1];\n      var endOffset = lineStarts[end.line] + end.column;\n      if (nextLineStartOffset > endOffset + 1) {\n        // there are more than 1 character after end, which means it can't be \\n\n        return end.line - start.line;\n      }\n      // endOffset + 1 === nextLineStartOffset\n      // character at endOffset is \\n, so we check the character before first\n      // if character at endOffset is \\r, end.column is 0 and we can't get here.\n      var previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n      var buffer = this._buffers[bufferIndex].buffer;\n      if (buffer.charCodeAt(previousCharOffset) === 13) {\n        return end.line - start.line + 1;\n      } else {\n        return end.line - start.line;\n      }\n    }\n  }, {\n    key: \"offsetInBuffer\",\n    value: function offsetInBuffer(bufferIndex, cursor) {\n      var lineStarts = this._buffers[bufferIndex].lineStarts;\n      return lineStarts[cursor.line] + cursor.column;\n    }\n  }, {\n    key: \"deleteNodes\",\n    value: function deleteNodes(nodes) {\n      for (var i = 0; i < nodes.length; i++) {\n        rbDelete(this, nodes[i]);\n      }\n    }\n  }, {\n    key: \"createNewPieces\",\n    value: function createNewPieces(text) {\n      if (text.length > AverageBufferSize) {\n        // the content is large, operations like substring, charCode becomes slow\n        // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n        var newPieces = [];\n        while (text.length > AverageBufferSize) {\n          var lastChar = text.charCodeAt(AverageBufferSize - 1);\n          var splitText = void 0;\n          if (lastChar === 13 /* CharCode.CarriageReturn */ || lastChar >= 0xD800 && lastChar <= 0xDBFF) {\n            // last character is \\r or a high surrogate => keep it back\n            splitText = text.substring(0, AverageBufferSize - 1);\n            text = text.substring(AverageBufferSize - 1);\n          } else {\n            splitText = text.substring(0, AverageBufferSize);\n            text = text.substring(AverageBufferSize);\n          }\n          var _lineStarts = createLineStartsFast(splitText);\n          newPieces.push(new Piece(this._buffers.length, /* buffer index */{\n            line: 0,\n            column: 0\n          }, {\n            line: _lineStarts.length - 1,\n            column: splitText.length - _lineStarts[_lineStarts.length - 1]\n          }, _lineStarts.length - 1, splitText.length));\n          this._buffers.push(new StringBuffer(splitText, _lineStarts));\n        }\n        var _lineStarts2 = createLineStartsFast(text);\n        newPieces.push(new Piece(this._buffers.length, /* buffer index */{\n          line: 0,\n          column: 0\n        }, {\n          line: _lineStarts2.length - 1,\n          column: text.length - _lineStarts2[_lineStarts2.length - 1]\n        }, _lineStarts2.length - 1, text.length));\n        this._buffers.push(new StringBuffer(text, _lineStarts2));\n        return newPieces;\n      }\n      var startOffset = this._buffers[0].buffer.length;\n      var lineStarts = createLineStartsFast(text, false);\n      var start = this._lastChangeBufferPos;\n      if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset && startOffset !== 0 && this.startWithLF(text) && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n      ) {\n        this._lastChangeBufferPos = {\n          line: this._lastChangeBufferPos.line,\n          column: this._lastChangeBufferPos.column + 1\n        };\n        start = this._lastChangeBufferPos;\n        for (var i = 0; i < lineStarts.length; i++) {\n          lineStarts[i] += startOffset + 1;\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        this._buffers[0].buffer += '_' + text;\n        startOffset += 1;\n      } else {\n        if (startOffset !== 0) {\n          for (var _i = 0; _i < lineStarts.length; _i++) {\n            lineStarts[_i] += startOffset;\n          }\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        this._buffers[0].buffer += text;\n      }\n      var endOffset = this._buffers[0].buffer.length;\n      var endIndex = this._buffers[0].lineStarts.length - 1;\n      var endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n      var endPos = {\n        line: endIndex,\n        column: endColumn\n      };\n      var newPiece = new Piece(0, /** todo@peng */start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n      this._lastChangeBufferPos = endPos;\n      return [newPiece];\n    }\n  }, {\n    key: \"getLineRawContent\",\n    value: function getLineRawContent(lineNumber) {\n      var endOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var x = this.root;\n      var ret = '';\n      var cache = this._searchCache.get2(lineNumber);\n      if (cache) {\n        x = cache.node;\n        var prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n        var buffer = this._buffers[x.piece.bufferIndex].buffer;\n        var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n          ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n        } else {\n          var accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n          return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n        }\n      } else {\n        var nodeStartOffset = 0;\n        var originalLineNumber = lineNumber;\n        while (x !== SENTINEL) {\n          if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n            x = x.left;\n          } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n            var _prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n            var _accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n            var _buffer4 = this._buffers[x.piece.bufferIndex].buffer;\n            var _startOffset4 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            nodeStartOffset += x.size_left;\n            this._searchCache.set({\n              node: x,\n              nodeStartOffset: nodeStartOffset,\n              nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n            });\n            return _buffer4.substring(_startOffset4 + _prevAccumulatedValue, _startOffset4 + _accumulatedValue - endOffset);\n          } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n            var _prevAccumulatedValue2 = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n            var _buffer5 = this._buffers[x.piece.bufferIndex].buffer;\n            var _startOffset5 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            ret = _buffer5.substring(_startOffset5 + _prevAccumulatedValue2, _startOffset5 + x.piece.length);\n            break;\n          } else {\n            lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n            nodeStartOffset += x.size_left + x.piece.length;\n            x = x.right;\n          }\n        }\n      }\n      // search in order, to find the node contains end column\n      x = x.next();\n      while (x !== SENTINEL) {\n        var _buffer6 = this._buffers[x.piece.bufferIndex].buffer;\n        if (x.piece.lineFeedCnt > 0) {\n          var _accumulatedValue2 = this.getAccumulatedValue(x, 0);\n          var _startOffset6 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n          ret += _buffer6.substring(_startOffset6, _startOffset6 + _accumulatedValue2 - endOffset);\n          return ret;\n        } else {\n          var _startOffset7 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n          ret += _buffer6.substr(_startOffset7, x.piece.length);\n        }\n        x = x.next();\n      }\n      return ret;\n    }\n  }, {\n    key: \"computeBufferMetadata\",\n    value: function computeBufferMetadata() {\n      var x = this.root;\n      var lfCnt = 1;\n      var len = 0;\n      while (x !== SENTINEL) {\n        lfCnt += x.lf_left + x.piece.lineFeedCnt;\n        len += x.size_left + x.piece.length;\n        x = x.right;\n      }\n      this._lineCnt = lfCnt;\n      this._length = len;\n      this._searchCache.validate(this._length);\n    }\n    // #region node operations\n  }, {\n    key: \"getIndexOf\",\n    value: function getIndexOf(node, accumulatedValue) {\n      var piece = node.piece;\n      var pos = this.positionInBuffer(node, accumulatedValue);\n      var lineCnt = pos.line - piece.start.line;\n      if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n        // we are checking the end of this node, so a CRLF check is necessary.\n        var realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n        if (realLineCnt !== lineCnt) {\n          // aha yes, CRLF\n          return {\n            index: realLineCnt,\n            remainder: 0\n          };\n        }\n      }\n      return {\n        index: lineCnt,\n        remainder: pos.column\n      };\n    }\n  }, {\n    key: \"getAccumulatedValue\",\n    value: function getAccumulatedValue(node, index) {\n      if (index < 0) {\n        return 0;\n      }\n      var piece = node.piece;\n      var lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n      var expectedLineStartIndex = piece.start.line + index + 1;\n      if (expectedLineStartIndex > piece.end.line) {\n        return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n      } else {\n        return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n      }\n    }\n  }, {\n    key: \"deleteNodeTail\",\n    value: function deleteNodeTail(node, pos) {\n      var piece = node.piece;\n      var originalLFCnt = piece.lineFeedCnt;\n      var originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n      var newEnd = pos;\n      var newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n      var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n      var lf_delta = newLineFeedCnt - originalLFCnt;\n      var size_delta = newEndOffset - originalEndOffset;\n      var newLength = piece.length + size_delta;\n      node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n      updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n  }, {\n    key: \"deleteNodeHead\",\n    value: function deleteNodeHead(node, pos) {\n      var piece = node.piece;\n      var originalLFCnt = piece.lineFeedCnt;\n      var originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n      var newStart = pos;\n      var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n      var newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n      var lf_delta = newLineFeedCnt - originalLFCnt;\n      var size_delta = originalStartOffset - newStartOffset;\n      var newLength = piece.length + size_delta;\n      node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n      updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n  }, {\n    key: \"shrinkNode\",\n    value: function shrinkNode(node, start, end) {\n      var piece = node.piece;\n      var originalStartPos = piece.start;\n      var originalEndPos = piece.end;\n      // old piece, originalStartPos, start\n      var oldLength = piece.length;\n      var oldLFCnt = piece.lineFeedCnt;\n      var newEnd = start;\n      var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n      var newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n      node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n      updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n      // new right piece, end, originalEndPos\n      var newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n      var newNode = this.rbInsertRight(node, newPiece);\n      this.validateCRLFWithPrevNode(newNode);\n    }\n  }, {\n    key: \"appendToNode\",\n    value: function appendToNode(node, value) {\n      if (this.adjustCarriageReturnFromNext(value, node)) {\n        value += '\\n';\n      }\n      var hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n      var startOffset = this._buffers[0].buffer.length;\n      this._buffers[0].buffer += value;\n      var lineStarts = createLineStartsFast(value, false);\n      for (var i = 0; i < lineStarts.length; i++) {\n        lineStarts[i] += startOffset;\n      }\n      if (hitCRLF) {\n        var prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n        this._buffers[0].lineStarts.pop();\n        // _lastChangeBufferPos is already wrong\n        this._lastChangeBufferPos = {\n          line: this._lastChangeBufferPos.line - 1,\n          column: startOffset - prevStartOffset\n        };\n      }\n      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n      var endIndex = this._buffers[0].lineStarts.length - 1;\n      var endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n      var newEnd = {\n        line: endIndex,\n        column: endColumn\n      };\n      var newLength = node.piece.length + value.length;\n      var oldLineFeedCnt = node.piece.lineFeedCnt;\n      var newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n      var lf_delta = newLineFeedCnt - oldLineFeedCnt;\n      node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n      this._lastChangeBufferPos = newEnd;\n      updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n  }, {\n    key: \"nodeAt\",\n    value: function nodeAt(offset) {\n      var x = this.root;\n      var cache = this._searchCache.get(offset);\n      if (cache) {\n        return {\n          node: cache.node,\n          nodeStartOffset: cache.nodeStartOffset,\n          remainder: offset - cache.nodeStartOffset\n        };\n      }\n      var nodeStartOffset = 0;\n      while (x !== SENTINEL) {\n        if (x.size_left > offset) {\n          x = x.left;\n        } else if (x.size_left + x.piece.length >= offset) {\n          nodeStartOffset += x.size_left;\n          var ret = {\n            node: x,\n            remainder: offset - x.size_left,\n            nodeStartOffset: nodeStartOffset\n          };\n          this._searchCache.set(ret);\n          return ret;\n        } else {\n          offset -= x.size_left + x.piece.length;\n          nodeStartOffset += x.size_left + x.piece.length;\n          x = x.right;\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"nodeAt2\",\n    value: function nodeAt2(lineNumber, column) {\n      var x = this.root;\n      var nodeStartOffset = 0;\n      while (x !== SENTINEL) {\n        if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n          x = x.left;\n        } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n          var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n          var accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n          nodeStartOffset += x.size_left;\n          return {\n            node: x,\n            remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n            nodeStartOffset: nodeStartOffset\n          };\n        } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n          var _prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n          if (_prevAccumualtedValue + column - 1 <= x.piece.length) {\n            return {\n              node: x,\n              remainder: _prevAccumualtedValue + column - 1,\n              nodeStartOffset: nodeStartOffset\n            };\n          } else {\n            column -= x.piece.length - _prevAccumualtedValue;\n            break;\n          }\n        } else {\n          lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n          nodeStartOffset += x.size_left + x.piece.length;\n          x = x.right;\n        }\n      }\n      // search in order, to find the node contains position.column\n      x = x.next();\n      while (x !== SENTINEL) {\n        if (x.piece.lineFeedCnt > 0) {\n          var _accumulatedValue3 = this.getAccumulatedValue(x, 0);\n          var _nodeStartOffset = this.offsetOfNode(x);\n          return {\n            node: x,\n            remainder: Math.min(column - 1, _accumulatedValue3),\n            nodeStartOffset: _nodeStartOffset\n          };\n        } else {\n          if (x.piece.length >= column - 1) {\n            var _nodeStartOffset2 = this.offsetOfNode(x);\n            return {\n              node: x,\n              remainder: column - 1,\n              nodeStartOffset: _nodeStartOffset2\n            };\n          } else {\n            column -= x.piece.length;\n          }\n        }\n        x = x.next();\n      }\n      return null;\n    }\n  }, {\n    key: \"nodeCharCodeAt\",\n    value: function nodeCharCodeAt(node, offset) {\n      if (node.piece.lineFeedCnt < 1) {\n        return -1;\n      }\n      var buffer = this._buffers[node.piece.bufferIndex];\n      var newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n      return buffer.buffer.charCodeAt(newOffset);\n    }\n  }, {\n    key: \"offsetOfNode\",\n    value: function offsetOfNode(node) {\n      if (!node) {\n        return 0;\n      }\n      var pos = node.size_left;\n      while (node !== this.root) {\n        if (node.parent.right === node) {\n          pos += node.parent.size_left + node.parent.piece.length;\n        }\n        node = node.parent;\n      }\n      return pos;\n    }\n    // #endregion\n    // #region CRLF\n  }, {\n    key: \"shouldCheckCRLF\",\n    value: function shouldCheckCRLF() {\n      return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n  }, {\n    key: \"startWithLF\",\n    value: function startWithLF(val) {\n      if (typeof val === 'string') {\n        return val.charCodeAt(0) === 10;\n      }\n      if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n        return false;\n      }\n      var piece = val.piece;\n      var lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n      var line = piece.start.line;\n      var startOffset = lineStarts[line] + piece.start.column;\n      if (line === lineStarts.length - 1) {\n        // last line, so there is no line feed at the end of this line\n        return false;\n      }\n      var nextLineOffset = lineStarts[line + 1];\n      if (nextLineOffset > startOffset + 1) {\n        return false;\n      }\n      return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n  }, {\n    key: \"endWithCR\",\n    value: function endWithCR(val) {\n      if (typeof val === 'string') {\n        return val.charCodeAt(val.length - 1) === 13;\n      }\n      if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n        return false;\n      }\n      return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n  }, {\n    key: \"validateCRLFWithPrevNode\",\n    value: function validateCRLFWithPrevNode(nextNode) {\n      if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n        var node = nextNode.prev();\n        if (this.endWithCR(node)) {\n          this.fixCRLF(node, nextNode);\n        }\n      }\n    }\n  }, {\n    key: \"validateCRLFWithNextNode\",\n    value: function validateCRLFWithNextNode(node) {\n      if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n        var nextNode = node.next();\n        if (this.startWithLF(nextNode)) {\n          this.fixCRLF(node, nextNode);\n        }\n      }\n    }\n  }, {\n    key: \"fixCRLF\",\n    value: function fixCRLF(prev, next) {\n      var nodesToDel = [];\n      // update node\n      var lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n      var newEnd;\n      if (prev.piece.end.column === 0) {\n        // it means, last line ends with \\r, not \\r\\n\n        newEnd = {\n          line: prev.piece.end.line - 1,\n          column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1\n        };\n      } else {\n        // \\r\\n\n        newEnd = {\n          line: prev.piece.end.line,\n          column: prev.piece.end.column - 1\n        };\n      }\n      var prevNewLength = prev.piece.length - 1;\n      var prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n      prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n      updateTreeMetadata(this, prev, -1, -1);\n      if (prev.piece.length === 0) {\n        nodesToDel.push(prev);\n      }\n      // update nextNode\n      var newStart = {\n        line: next.piece.start.line + 1,\n        column: 0\n      };\n      var newLength = next.piece.length - 1;\n      var newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n      next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n      updateTreeMetadata(this, next, -1, -1);\n      if (next.piece.length === 0) {\n        nodesToDel.push(next);\n      }\n      // create new piece which contains \\r\\n\n      var pieces = this.createNewPieces('\\r\\n');\n      this.rbInsertRight(prev, pieces[0]);\n      // delete empty nodes\n      for (var i = 0; i < nodesToDel.length; i++) {\n        rbDelete(this, nodesToDel[i]);\n      }\n    }\n  }, {\n    key: \"adjustCarriageReturnFromNext\",\n    value: function adjustCarriageReturnFromNext(value, node) {\n      if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n        var nextNode = node.next();\n        if (this.startWithLF(nextNode)) {\n          // move `\\n` forward\n          value += '\\n';\n          if (nextNode.piece.length === 1) {\n            rbDelete(this, nextNode);\n          } else {\n            var piece = nextNode.piece;\n            var newStart = {\n              line: piece.start.line + 1,\n              column: 0\n            };\n            var newLength = piece.length - 1;\n            var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n            nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n            updateTreeMetadata(this, nextNode, -1, -1);\n          }\n          return true;\n        }\n      }\n      return false;\n    }\n    // #endregion\n    // #endregion\n    // #region Tree operations\n  }, {\n    key: \"iterate\",\n    value: function iterate(node, callback) {\n      if (node === SENTINEL) {\n        return callback(SENTINEL);\n      }\n      var leftRet = this.iterate(node.left, callback);\n      if (!leftRet) {\n        return leftRet;\n      }\n      return callback(node) && this.iterate(node.right, callback);\n    }\n  }, {\n    key: \"getNodeContent\",\n    value: function getNodeContent(node) {\n      if (node === SENTINEL) {\n        return '';\n      }\n      var buffer = this._buffers[node.piece.bufferIndex];\n      var piece = node.piece;\n      var startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n      var endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n      var currentContent = buffer.buffer.substring(startOffset, endOffset);\n      return currentContent;\n    }\n  }, {\n    key: \"getPieceContent\",\n    value: function getPieceContent(piece) {\n      var buffer = this._buffers[piece.bufferIndex];\n      var startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n      var endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n      var currentContent = buffer.buffer.substring(startOffset, endOffset);\n      return currentContent;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b    <----   a    b\n     *                         /\n     *                        z\n     */\n  }, {\n    key: \"rbInsertRight\",\n    value: function rbInsertRight(node, p) {\n      var z = new TreeNode(p, 1 /* NodeColor.Red */);\n      z.left = SENTINEL;\n      z.right = SENTINEL;\n      z.parent = SENTINEL;\n      z.size_left = 0;\n      z.lf_left = 0;\n      var x = this.root;\n      if (x === SENTINEL) {\n        this.root = z;\n        z.color = 0 /* NodeColor.Black */;\n      } else if (node.right === SENTINEL) {\n        node.right = z;\n        z.parent = node;\n      } else {\n        var nextNode = leftest(node.right);\n        nextNode.left = z;\n        z.parent = nextNode;\n      }\n      fixInsert(this, z);\n      return z;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b     ---->   a    b\n     *                       \\\n     *                        z\n     */\n  }, {\n    key: \"rbInsertLeft\",\n    value: function rbInsertLeft(node, p) {\n      var z = new TreeNode(p, 1 /* NodeColor.Red */);\n      z.left = SENTINEL;\n      z.right = SENTINEL;\n      z.parent = SENTINEL;\n      z.size_left = 0;\n      z.lf_left = 0;\n      if (this.root === SENTINEL) {\n        this.root = z;\n        z.color = 0 /* NodeColor.Black */;\n      } else if (node.left === SENTINEL) {\n        node.left = z;\n        z.parent = node;\n      } else {\n        var prevNode = righttest(node.left); // a\n        prevNode.right = z;\n        z.parent = prevNode;\n      }\n      fixInsert(this, z);\n      return z;\n    }\n  }]);\n}();","map":{"version":3,"names":["Position","Range","FindMatch","SENTINEL","TreeNode","fixInsert","leftest","rbDelete","righttest","updateTreeMetadata","Searcher","createFindMatch","isValidMatch","AverageBufferSize","createUintArray","arr","r","length","Uint16Array","Uint32Array","set","LineStarts","_createClass","lineStarts","cr","lf","crlf","isBasicASCII","_classCallCheck","createLineStartsFast","str","readonly","arguments","undefined","rLength","i","len","chr","charCodeAt","createLineStarts","result","Piece","bufferIndex","start","end","lineFeedCnt","StringBuffer","buffer","PieceTreeSnapshot","tree","BOM","_this","_pieces","_tree","_BOM","_index","root","iterate","node","push","piece","key","value","read","getPieceContent","PieceTreeSearchCache","limit","_limit","_cache","get","offset","nodePos","nodeStartOffset","get2","lineNumber","nodeStartLineNumber","nodePosition","shift","validate","hasInvalidVal","tmp","parent","newArr","_iterator","_createForOfIteratorHelper","_step","s","n","done","entry","err","e","f","PieceTreeBase","chunks","eol","eolNormalized","create","_buffers","_lastChangeBufferPos","line","column","_lineCnt","_length","_EOL","_EOLLength","_EOLNormalized","lastNode","rbInsertRight","_searchCache","_lastVisitedLine","computeBufferMetadata","normalizeEOL","_this2","averageBufferSize","min","Math","floor","max","tempChunk","tempChunkLen","getNodeContent","text","replace","getEOL","setEOL","newEOL","createSnapshot","getOffsetAt","leftLen","x","left","lf_left","size_left","accumualtedValInCurrentIndex","getAccumulatedValue","right","getPositionAt","lfCnt","originalOffset","out","getIndexOf","index","lineStartOffset","remainder","getValueInRange","range","startLineNumber","endLineNumber","startColumn","endColumn","startPosition","nodeAt2","endPosition","getValueInRange2","startOffset","offsetInBuffer","substring","ret","next","substr","getLinesContent","_this3","lines","linesLength","currentLine","danglingCR","pieceLength","pieceStartLine","pieceEndLine","pieceStartOffset","getLength","getLineCount","getLineContent","getLineRawContent","_getCharCode","matchingNode","targetOffset","getLineCharCode","getLineLength","findMatchesInNode","searcher","startCursor","endCursor","searchData","captureMatches","limitResultCount","resultLen","startOffsetInBuffer","m","searchText","_wordSeparators","reset","positionInBuffer","getLineFeedCnt","retStartColumn","retEndColumn","findMatchesLineByLine","searchRange","wordSeparators","regex","currentNode","lineBreakCnt","nextLineStartOffset","_findMatchesInLine","deltaOffset","simpleSearch","searchString","searchStringLen","textLength","lastMatchIndex","indexOf","insert","_this$nodeAt","nodeAt","insertPosInBuffer","appendToNode","insertContentToNodeLeft","nodesToDel","newRightPiece","shouldCheckCRLF","endWithCR","headOfRight","nodeCharCodeAt","newStart","startWithLF","tailOfLeft","previousPos","deleteNodeTail","newPieces","createNewPieces","tmpNode","k","deleteNodes","insertContentToNodeRight","pieces","rbInsertLeft","_delete","cnt","startNode","endNode","startSplitPosInBuffer","endSplitPosInBuffer","validateCRLFWithPrevNode","deleteNodeHead","validateCRLFWithNextNode","shrinkNode","secondNode","prev","nPiece","newNode","adjustCarriageReturnFromNext","low","high","mid","midStop","midStart","endOffset","previousCharOffset","cursor","nodes","lastChar","splitText","concat","slice","endIndex","endPos","newPiece","cache","prevAccumulatedValue","accumulatedValue","originalLineNumber","pos","lineCnt","realLineCnt","expectedLineStartIndex","originalLFCnt","originalEndOffset","newEnd","newEndOffset","newLineFeedCnt","lf_delta","size_delta","newLength","originalStartOffset","newStartOffset","originalStartPos","originalEndPos","oldLength","oldLFCnt","hitCRLF","prevStartOffset","pop","oldLineFeedCnt","prevAccumualtedValue","offsetOfNode","newOffset","val","nextLineOffset","nextNode","fixCRLF","prevNewLength","prevNewLFCnt","callback","leftRet","currentContent","p","z","color","prevNode"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nconst AverageBufferSize = 65535;\nfunction createUintArray(arr) {\n    let r;\n    if (arr[arr.length - 1] < 65536) {\n        r = new Uint16Array(arr.length);\n    }\n    else {\n        r = new Uint32Array(arr.length);\n    }\n    r.set(arr, 0);\n    return r;\n}\nclass LineStarts {\n    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n        this.lineStarts = lineStarts;\n        this.cr = cr;\n        this.lf = lf;\n        this.crlf = crlf;\n        this.isBasicASCII = isBasicASCII;\n    }\n}\nexport function createLineStartsFast(str, readonly = true) {\n    const r = [0];\n    let rLength = 1;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            r[rLength++] = i + 1;\n        }\n    }\n    if (readonly) {\n        return createUintArray(r);\n    }\n    else {\n        return r;\n    }\n}\nexport function createLineStarts(r, str) {\n    r.length = 0;\n    r[0] = 0;\n    let rLength = 1;\n    let cr = 0, lf = 0, crlf = 0;\n    let isBasicASCII = true;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                crlf++;\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                cr++;\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            lf++;\n            r[rLength++] = i + 1;\n        }\n        else {\n            if (isBasicASCII) {\n                if (chr !== 9 /* CharCode.Tab */ && (chr < 32 || chr > 126)) {\n                    isBasicASCII = false;\n                }\n            }\n        }\n    }\n    const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n    r.length = 0;\n    return result;\n}\nexport class Piece {\n    constructor(bufferIndex, start, end, lineFeedCnt, length) {\n        this.bufferIndex = bufferIndex;\n        this.start = start;\n        this.end = end;\n        this.lineFeedCnt = lineFeedCnt;\n        this.length = length;\n    }\n}\nexport class StringBuffer {\n    constructor(buffer, lineStarts) {\n        this.buffer = buffer;\n        this.lineStarts = lineStarts;\n    }\n}\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot {\n    constructor(tree, BOM) {\n        this._pieces = [];\n        this._tree = tree;\n        this._BOM = BOM;\n        this._index = 0;\n        if (tree.root !== SENTINEL) {\n            tree.iterate(tree.root, node => {\n                if (node !== SENTINEL) {\n                    this._pieces.push(node.piece);\n                }\n                return true;\n            });\n        }\n    }\n    read() {\n        if (this._pieces.length === 0) {\n            if (this._index === 0) {\n                this._index++;\n                return this._BOM;\n            }\n            else {\n                return null;\n            }\n        }\n        if (this._index > this._pieces.length - 1) {\n            return null;\n        }\n        if (this._index === 0) {\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n        return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n}\nclass PieceTreeSearchCache {\n    constructor(limit) {\n        this._limit = limit;\n        this._cache = [];\n    }\n    get(offset) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    get2(lineNumber) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    set(nodePosition) {\n        if (this._cache.length >= this._limit) {\n            this._cache.shift();\n        }\n        this._cache.push(nodePosition);\n    }\n    validate(offset) {\n        let hasInvalidVal = false;\n        const tmp = this._cache;\n        for (let i = 0; i < tmp.length; i++) {\n            const nodePos = tmp[i];\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                tmp[i] = null;\n                hasInvalidVal = true;\n                continue;\n            }\n        }\n        if (hasInvalidVal) {\n            const newArr = [];\n            for (const entry of tmp) {\n                if (entry !== null) {\n                    newArr.push(entry);\n                }\n            }\n            this._cache = newArr;\n        }\n    }\n}\nexport class PieceTreeBase {\n    constructor(chunks, eol, eolNormalized) {\n        this.create(chunks, eol, eolNormalized);\n    }\n    create(chunks, eol, eolNormalized) {\n        this._buffers = [\n            new StringBuffer('', [0])\n        ];\n        this._lastChangeBufferPos = { line: 0, column: 0 };\n        this.root = SENTINEL;\n        this._lineCnt = 1;\n        this._length = 0;\n        this._EOL = eol;\n        this._EOLLength = eol.length;\n        this._EOLNormalized = eolNormalized;\n        let lastNode = null;\n        for (let i = 0, len = chunks.length; i < len; i++) {\n            if (chunks[i].buffer.length > 0) {\n                if (!chunks[i].lineStarts) {\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                }\n                const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n                this._buffers.push(chunks[i]);\n                lastNode = this.rbInsertRight(lastNode, piece);\n            }\n        }\n        this._searchCache = new PieceTreeSearchCache(1);\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\n        this.computeBufferMetadata();\n    }\n    normalizeEOL(eol) {\n        const averageBufferSize = AverageBufferSize;\n        const min = averageBufferSize - Math.floor(averageBufferSize / 3);\n        const max = min * 2;\n        let tempChunk = '';\n        let tempChunkLen = 0;\n        const chunks = [];\n        this.iterate(this.root, node => {\n            const str = this.getNodeContent(node);\n            const len = str.length;\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\n                tempChunk += str;\n                tempChunkLen += len;\n                return true;\n            }\n            // flush anyways\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n            tempChunk = str;\n            tempChunkLen = len;\n            return true;\n        });\n        if (tempChunkLen > 0) {\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        }\n        this.create(chunks, eol, true);\n    }\n    // #region Buffer API\n    getEOL() {\n        return this._EOL;\n    }\n    setEOL(newEOL) {\n        this._EOL = newEOL;\n        this._EOLLength = this._EOL.length;\n        this.normalizeEOL(newEOL);\n    }\n    createSnapshot(BOM) {\n        return new PieceTreeSnapshot(this, BOM);\n    }\n    getOffsetAt(lineNumber, column) {\n        let leftLen = 0; // inorder\n        let x = this.root;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                leftLen += x.size_left;\n                // lineNumber >= 2\n                const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                leftLen += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return leftLen;\n    }\n    getPositionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        let x = this.root;\n        let lfCnt = 0;\n        const originalOffset = offset;\n        while (x !== SENTINEL) {\n            if (x.size_left !== 0 && x.size_left >= offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                const out = this.getIndexOf(x, offset - x.size_left);\n                lfCnt += x.lf_left + out.index;\n                if (out.index === 0) {\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                return new Position(lfCnt + 1, out.remainder + 1);\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                if (x.right === SENTINEL) {\n                    // last node\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - offset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                else {\n                    x = x.right;\n                }\n            }\n        }\n        return new Position(1, 1);\n    }\n    getValueInRange(range, eol) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            return '';\n        }\n        const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n        const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n        const value = this.getValueInRange2(startPosition, endPosition);\n        if (eol) {\n            if (eol !== this._EOL || !this._EOLNormalized) {\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            if (eol === this.getEOL() && this._EOLNormalized) {\n                if (eol === '\\r\\n') {\n                }\n                return value;\n            }\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        return value;\n    }\n    getValueInRange2(startPosition, endPosition) {\n        if (startPosition.node === endPosition.node) {\n            const node = startPosition.node;\n            const buffer = this._buffers[node.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n        }\n        let x = startPosition.node;\n        const buffer = this._buffers[x.piece.bufferIndex].buffer;\n        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (x === endPosition.node) {\n                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n                break;\n            }\n            else {\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    getLinesContent() {\n        const lines = [];\n        let linesLength = 0;\n        let currentLine = '';\n        let danglingCR = false;\n        this.iterate(this.root, node => {\n            if (node === SENTINEL) {\n                return true;\n            }\n            const piece = node.piece;\n            let pieceLength = piece.length;\n            if (pieceLength === 0) {\n                return true;\n            }\n            const buffer = this._buffers[piece.bufferIndex].buffer;\n            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            const pieceStartLine = piece.start.line;\n            const pieceEndLine = piece.end.line;\n            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n            if (danglingCR) {\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* CharCode.LineFeed */) {\n                    // pretend the \\n was in the previous piece..\n                    pieceStartOffset++;\n                    pieceLength--;\n                }\n                lines[linesLength++] = currentLine;\n                currentLine = '';\n                danglingCR = false;\n                if (pieceLength === 0) {\n                    return true;\n                }\n            }\n            if (pieceStartLine === pieceEndLine) {\n                // this piece has no new lines\n                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CharCode.CarriageReturn */) {\n                    danglingCR = true;\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n                }\n                else {\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\n                }\n                return true;\n            }\n            // add the text before the first line start in this piece\n            currentLine += (this._EOLNormalized\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n            lines[linesLength++] = currentLine;\n            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n                currentLine = (this._EOLNormalized\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n                lines[linesLength++] = currentLine;\n            }\n            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CharCode.CarriageReturn */) {\n                danglingCR = true;\n                if (piece.end.column === 0) {\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n                    linesLength--;\n                }\n                else {\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n                }\n            }\n            else {\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n            }\n            return true;\n        });\n        if (danglingCR) {\n            lines[linesLength++] = currentLine;\n            currentLine = '';\n        }\n        lines[linesLength++] = currentLine;\n        return lines;\n    }\n    getLength() {\n        return this._length;\n    }\n    getLineCount() {\n        return this._lineCnt;\n    }\n    getLineContent(lineNumber) {\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\n            return this._lastVisitedLine.value;\n        }\n        this._lastVisitedLine.lineNumber = lineNumber;\n        if (lineNumber === this._lineCnt) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n        }\n        else if (this._EOLNormalized) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n        }\n        else {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n        }\n        return this._lastVisitedLine.value;\n    }\n    _getCharCode(nodePos) {\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            // the char we want to fetch is at the head of next node.\n            const matchingNode = nodePos.node.next();\n            if (!matchingNode) {\n                return 0;\n            }\n            const buffer = this._buffers[matchingNode.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.charCodeAt(startOffset);\n        }\n        else {\n            const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            const targetOffset = startOffset + nodePos.remainder;\n            return buffer.buffer.charCodeAt(targetOffset);\n        }\n    }\n    getLineCharCode(lineNumber, index) {\n        const nodePos = this.nodeAt2(lineNumber, index + 1);\n        return this._getCharCode(nodePos);\n    }\n    getLineLength(lineNumber) {\n        if (lineNumber === this.getLineCount()) {\n            const startOffset = this.getOffsetAt(lineNumber, 1);\n            return this.getLength() - startOffset;\n        }\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n        const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n        let m;\n        // Reset regex to search from the beginning\n        const ret = { line: 0, column: 0 };\n        let searchText;\n        let offsetInBuffer;\n        if (searcher._wordSeparators) {\n            searchText = buffer.buffer.substring(start, end);\n            offsetInBuffer = (offset) => offset + start;\n            searcher.reset(0);\n        }\n        else {\n            searchText = buffer.buffer;\n            offsetInBuffer = (offset) => offset;\n            searcher.reset(start);\n        }\n        do {\n            m = searcher.next(searchText);\n            if (m) {\n                if (offsetInBuffer(m.index) >= end) {\n                    return resultLen;\n                }\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n                const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                const retEndColumn = retStartColumn + m[0].length;\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\n                    return resultLen;\n                }\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n        if (startPosition === null) {\n            return [];\n        }\n        const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n        if (endPosition === null) {\n            return [];\n        }\n        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        const end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n        if (startPosition.node === endPosition.node) {\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        let startLineNumber = searchRange.startLineNumber;\n        let currentNode = startPosition.node;\n        while (currentNode !== endPosition.node) {\n            const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n            if (lineBreakCnt >= 1) {\n                // last line break position\n                const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber += lineBreakCnt;\n            }\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            // search for the remaining content\n            if (startLineNumber === searchRange.endLineNumber) {\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            if (resultLen >= limitResultCount) {\n                return result;\n            }\n            startLineNumber++;\n            startPosition = this.nodeAt2(startLineNumber, 1);\n            currentNode = startPosition.node;\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        }\n        if (startLineNumber === searchRange.endLineNumber) {\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n    }\n    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    // #endregion\n    // #region Piece Table\n    insert(offset, value, eolNormalized = false) {\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (this.root !== SENTINEL) {\n            const { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n            const piece = node.piece;\n            const bufferIndex = piece.bufferIndex;\n            const insertPosInBuffer = this.positionInBuffer(node, remainder);\n            if (node.piece.bufferIndex === 0 &&\n                piece.end.line === this._lastChangeBufferPos.line &&\n                piece.end.column === this._lastChangeBufferPos.column &&\n                (nodeStartOffset + piece.length === offset) &&\n                value.length < AverageBufferSize) {\n                // changed buffer\n                this.appendToNode(node, value);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (nodeStartOffset === offset) {\n                this.insertContentToNodeLeft(value, node);\n                this._searchCache.validate(offset);\n            }\n            else if (nodeStartOffset + node.piece.length > offset) {\n                // we are inserting into the middle of a node.\n                const nodesToDel = [];\n                let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                    const headOfRight = this.nodeCharCodeAt(node, remainder);\n                    if (headOfRight === 10 /** \\n */) {\n                        const newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                        value += '\\n';\n                    }\n                }\n                // reuse node for content before insertion point.\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                    const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                    if (tailOfLeft === 13 /** \\r */) {\n                        const previousPos = this.positionInBuffer(node, remainder - 1);\n                        this.deleteNodeTail(node, previousPos);\n                        value = '\\r' + value;\n                        if (node.piece.length === 0) {\n                            nodesToDel.push(node);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                }\n                else {\n                    this.deleteNodeTail(node, insertPosInBuffer);\n                }\n                const newPieces = this.createNewPieces(value);\n                if (newRightPiece.length > 0) {\n                    this.rbInsertRight(node, newRightPiece);\n                }\n                let tmpNode = node;\n                for (let k = 0; k < newPieces.length; k++) {\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                }\n                this.deleteNodes(nodesToDel);\n            }\n            else {\n                this.insertContentToNodeRight(value, node);\n            }\n        }\n        else {\n            // insert new node\n            const pieces = this.createNewPieces(value);\n            let node = this.rbInsertLeft(null, pieces[0]);\n            for (let k = 1; k < pieces.length; k++) {\n                node = this.rbInsertRight(node, pieces[k]);\n            }\n        }\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n        this.computeBufferMetadata();\n    }\n    delete(offset, cnt) {\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (cnt <= 0 || this.root === SENTINEL) {\n            return;\n        }\n        const startPosition = this.nodeAt(offset);\n        const endPosition = this.nodeAt(offset + cnt);\n        const startNode = startPosition.node;\n        const endNode = endPosition.node;\n        if (startNode === endNode) {\n            const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n            const endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n            if (startPosition.nodeStartOffset === offset) {\n                if (cnt === startNode.piece.length) { // delete node\n                    const next = startNode.next();\n                    rbDelete(this, startNode);\n                    this.validateCRLFWithPrevNode(next);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                this.deleteNodeHead(startNode, endSplitPosInBuffer);\n                this._searchCache.validate(offset);\n                this.validateCRLFWithPrevNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                this.deleteNodeTail(startNode, startSplitPosInBuffer);\n                this.validateCRLFWithNextNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            // delete content in the middle, this node will be splitted to nodes\n            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n            this.computeBufferMetadata();\n            return;\n        }\n        const nodesToDel = [];\n        const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this._searchCache.validate(offset);\n        if (startNode.piece.length === 0) {\n            nodesToDel.push(startNode);\n        }\n        // update last touched node\n        const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\n        if (endNode.piece.length === 0) {\n            nodesToDel.push(endNode);\n        }\n        // delete nodes in between\n        const secondNode = startNode.next();\n        for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n            nodesToDel.push(node);\n        }\n        const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n        this.deleteNodes(nodesToDel);\n        this.validateCRLFWithNextNode(prev);\n        this.computeBufferMetadata();\n    }\n    insertContentToNodeLeft(value, node) {\n        // we are inserting content to the beginning of node\n        const nodesToDel = [];\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n            // move `\\n` to new node.\n            const piece = node.piece;\n            const newStart = { line: piece.start.line + 1, column: 0 };\n            const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n            node.piece = nPiece;\n            value += '\\n';\n            updateTreeMetadata(this, node, -1, -1);\n            if (node.piece.length === 0) {\n                nodesToDel.push(node);\n            }\n        }\n        const newPieces = this.createNewPieces(value);\n        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n        for (let k = newPieces.length - 2; k >= 0; k--) {\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n        this.deleteNodes(nodesToDel);\n    }\n    insertContentToNodeRight(value, node) {\n        // we are inserting to the right of this node.\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            // move \\n to the new node.\n            value += '\\n';\n        }\n        const newPieces = this.createNewPieces(value);\n        const newNode = this.rbInsertRight(node, newPieces[0]);\n        let tmpNode = newNode;\n        for (let k = 1; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    positionInBuffer(node, remainder, ret) {\n        const piece = node.piece;\n        const bufferIndex = node.piece.bufferIndex;\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        const startOffset = lineStarts[piece.start.line] + piece.start.column;\n        const offset = startOffset + remainder;\n        // binary search offset between startOffset and endOffset\n        let low = piece.start.line;\n        let high = piece.end.line;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStart = lineStarts[mid];\n            if (mid === high) {\n                break;\n            }\n            midStop = lineStarts[mid + 1];\n            if (offset < midStart) {\n                high = mid - 1;\n            }\n            else if (offset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        if (ret) {\n            ret.line = mid;\n            ret.column = offset - midStart;\n            return null;\n        }\n        return {\n            line: mid,\n            column: offset - midStart\n        };\n    }\n    getLineFeedCnt(bufferIndex, start, end) {\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n        if (end.column === 0) {\n            return end.line - start.line;\n        }\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n            return end.line - start.line;\n        }\n        const nextLineStartOffset = lineStarts[end.line + 1];\n        const endOffset = lineStarts[end.line] + end.column;\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n            return end.line - start.line;\n        }\n        // endOffset + 1 === nextLineStartOffset\n        // character at endOffset is \\n, so we check the character before first\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\n        const previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n        const buffer = this._buffers[bufferIndex].buffer;\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\n            return end.line - start.line + 1;\n        }\n        else {\n            return end.line - start.line;\n        }\n    }\n    offsetInBuffer(bufferIndex, cursor) {\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        return lineStarts[cursor.line] + cursor.column;\n    }\n    deleteNodes(nodes) {\n        for (let i = 0; i < nodes.length; i++) {\n            rbDelete(this, nodes[i]);\n        }\n    }\n    createNewPieces(text) {\n        if (text.length > AverageBufferSize) {\n            // the content is large, operations like substring, charCode becomes slow\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n            const newPieces = [];\n            while (text.length > AverageBufferSize) {\n                const lastChar = text.charCodeAt(AverageBufferSize - 1);\n                let splitText;\n                if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                    // last character is \\r or a high surrogate => keep it back\n                    splitText = text.substring(0, AverageBufferSize - 1);\n                    text = text.substring(AverageBufferSize - 1);\n                }\n                else {\n                    splitText = text.substring(0, AverageBufferSize);\n                    text = text.substring(AverageBufferSize);\n                }\n                const lineStarts = createLineStartsFast(splitText);\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));\n                this._buffers.push(new StringBuffer(splitText, lineStarts));\n            }\n            const lineStarts = createLineStartsFast(text);\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));\n            this._buffers.push(new StringBuffer(text, lineStarts));\n            return newPieces;\n        }\n        let startOffset = this._buffers[0].buffer.length;\n        const lineStarts = createLineStartsFast(text, false);\n        let start = this._lastChangeBufferPos;\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n            && startOffset !== 0\n            && this.startWithLF(text)\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n        ) {\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n            start = this._lastChangeBufferPos;\n            for (let i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset + 1;\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += '_' + text;\n            startOffset += 1;\n        }\n        else {\n            if (startOffset !== 0) {\n                for (let i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset;\n                }\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += text;\n        }\n        const endOffset = this._buffers[0].buffer.length;\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n        const endPos = { line: endIndex, column: endColumn };\n        const newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n        this._lastChangeBufferPos = endPos;\n        return [newPiece];\n    }\n    getLineRawContent(lineNumber, endOffset = 0) {\n        let x = this.root;\n        let ret = '';\n        const cache = this._searchCache.get2(lineNumber);\n        if (cache) {\n            x = cache.node;\n            const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n            }\n            else {\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n            }\n        }\n        else {\n            let nodeStartOffset = 0;\n            const originalLineNumber = lineNumber;\n            while (x !== SENTINEL) {\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    nodeStartOffset += x.size_left;\n                    this._searchCache.set({\n                        node: x,\n                        nodeStartOffset,\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                    });\n                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n                    break;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n        }\n        // search in order, to find the node contains end column\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n                return ret;\n            }\n            else {\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    computeBufferMetadata() {\n        let x = this.root;\n        let lfCnt = 1;\n        let len = 0;\n        while (x !== SENTINEL) {\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\n            len += x.size_left + x.piece.length;\n            x = x.right;\n        }\n        this._lineCnt = lfCnt;\n        this._length = len;\n        this._searchCache.validate(this._length);\n    }\n    // #region node operations\n    getIndexOf(node, accumulatedValue) {\n        const piece = node.piece;\n        const pos = this.positionInBuffer(node, accumulatedValue);\n        const lineCnt = pos.line - piece.start.line;\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n            // we are checking the end of this node, so a CRLF check is necessary.\n            const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n            if (realLineCnt !== lineCnt) {\n                // aha yes, CRLF\n                return { index: realLineCnt, remainder: 0 };\n            }\n        }\n        return { index: lineCnt, remainder: pos.column };\n    }\n    getAccumulatedValue(node, index) {\n        if (index < 0) {\n            return 0;\n        }\n        const piece = node.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const expectedLineStartIndex = piece.start.line + index + 1;\n        if (expectedLineStartIndex > piece.end.line) {\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n        }\n        else {\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n        }\n    }\n    deleteNodeTail(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const newEnd = pos;\n        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = newEndOffset - originalEndOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    deleteNodeHead(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const newStart = pos;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = originalStartOffset - newStartOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    shrinkNode(node, start, end) {\n        const piece = node.piece;\n        const originalStartPos = piece.start;\n        const originalEndPos = piece.end;\n        // old piece, originalStartPos, start\n        const oldLength = piece.length;\n        const oldLFCnt = piece.lineFeedCnt;\n        const newEnd = start;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n        // new right piece, end, originalEndPos\n        const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n        const newNode = this.rbInsertRight(node, newPiece);\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    appendToNode(node, value) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n        const startOffset = this._buffers[0].buffer.length;\n        this._buffers[0].buffer += value;\n        const lineStarts = createLineStartsFast(value, false);\n        for (let i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset;\n        }\n        if (hitCRLF) {\n            const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n            this._buffers[0].lineStarts.pop();\n            // _lastChangeBufferPos is already wrong\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n        const newEnd = { line: endIndex, column: endColumn };\n        const newLength = node.piece.length + value.length;\n        const oldLineFeedCnt = node.piece.lineFeedCnt;\n        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n        this._lastChangeBufferPos = newEnd;\n        updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n    nodeAt(offset) {\n        let x = this.root;\n        const cache = this._searchCache.get(offset);\n        if (cache) {\n            return {\n                node: cache.node,\n                nodeStartOffset: cache.nodeStartOffset,\n                remainder: offset - cache.nodeStartOffset\n            };\n        }\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.size_left > offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                nodeStartOffset += x.size_left;\n                const ret = {\n                    node: x,\n                    remainder: offset - x.size_left,\n                    nodeStartOffset\n                };\n                this._searchCache.set(ret);\n                return ret;\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return null;\n    }\n    nodeAt2(lineNumber, column) {\n        let x = this.root;\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                nodeStartOffset += x.size_left;\n                return {\n                    node: x,\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                    return {\n                        node: x,\n                        remainder: prevAccumualtedValue + column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length - prevAccumualtedValue;\n                    break;\n                }\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        // search in order, to find the node contains position.column\n        x = x.next();\n        while (x !== SENTINEL) {\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const nodeStartOffset = this.offsetOfNode(x);\n                return {\n                    node: x,\n                    remainder: Math.min(column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else {\n                if (x.piece.length >= column - 1) {\n                    const nodeStartOffset = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length;\n                }\n            }\n            x = x.next();\n        }\n        return null;\n    }\n    nodeCharCodeAt(node, offset) {\n        if (node.piece.lineFeedCnt < 1) {\n            return -1;\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n        return buffer.buffer.charCodeAt(newOffset);\n    }\n    offsetOfNode(node) {\n        if (!node) {\n            return 0;\n        }\n        let pos = node.size_left;\n        while (node !== this.root) {\n            if (node.parent.right === node) {\n                pos += node.parent.size_left + node.parent.piece.length;\n            }\n            node = node.parent;\n        }\n        return pos;\n    }\n    // #endregion\n    // #region CRLF\n    shouldCheckCRLF() {\n        return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n    startWithLF(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(0) === 10;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        const piece = val.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const line = piece.start.line;\n        const startOffset = lineStarts[line] + piece.start.column;\n        if (line === lineStarts.length - 1) {\n            // last line, so there is no line feed at the end of this line\n            return false;\n        }\n        const nextLineOffset = lineStarts[line + 1];\n        if (nextLineOffset > startOffset + 1) {\n            return false;\n        }\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n    endWithCR(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(val.length - 1) === 13;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n    validateCRLFWithPrevNode(nextNode) {\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n            const node = nextNode.prev();\n            if (this.endWithCR(node)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    validateCRLFWithNextNode(node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    fixCRLF(prev, next) {\n        const nodesToDel = [];\n        // update node\n        const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n        let newEnd;\n        if (prev.piece.end.column === 0) {\n            // it means, last line ends with \\r, not \\r\\n\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n        }\n        else {\n            // \\r\\n\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n        }\n        const prevNewLength = prev.piece.length - 1;\n        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n        updateTreeMetadata(this, prev, -1, -1);\n        if (prev.piece.length === 0) {\n            nodesToDel.push(prev);\n        }\n        // update nextNode\n        const newStart = { line: next.piece.start.line + 1, column: 0 };\n        const newLength = next.piece.length - 1;\n        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, next, -1, -1);\n        if (next.piece.length === 0) {\n            nodesToDel.push(next);\n        }\n        // create new piece which contains \\r\\n\n        const pieces = this.createNewPieces('\\r\\n');\n        this.rbInsertRight(prev, pieces[0]);\n        // delete empty nodes\n        for (let i = 0; i < nodesToDel.length; i++) {\n            rbDelete(this, nodesToDel[i]);\n        }\n    }\n    adjustCarriageReturnFromNext(value, node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                // move `\\n` forward\n                value += '\\n';\n                if (nextNode.piece.length === 1) {\n                    rbDelete(this, nextNode);\n                }\n                else {\n                    const piece = nextNode.piece;\n                    const newStart = { line: piece.start.line + 1, column: 0 };\n                    const newLength = piece.length - 1;\n                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n                    updateTreeMetadata(this, nextNode, -1, -1);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // #endregion\n    // #endregion\n    // #region Tree operations\n    iterate(node, callback) {\n        if (node === SENTINEL) {\n            return callback(SENTINEL);\n        }\n        const leftRet = this.iterate(node.left, callback);\n        if (!leftRet) {\n            return leftRet;\n        }\n        return callback(node) && this.iterate(node.right, callback);\n    }\n    getNodeContent(node) {\n        if (node === SENTINEL) {\n            return '';\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const piece = node.piece;\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    getPieceContent(piece) {\n        const buffer = this._buffers[piece.bufferIndex];\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b    <----   a    b\n     *                         /\n     *                        z\n     */\n    rbInsertRight(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        const x = this.root;\n        if (x === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.right === SENTINEL) {\n            node.right = z;\n            z.parent = node;\n        }\n        else {\n            const nextNode = leftest(node.right);\n            nextNode.left = z;\n            z.parent = nextNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b     ---->   a    b\n     *                       \\\n     *                        z\n     */\n    rbInsertLeft(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        if (this.root === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.left === SENTINEL) {\n            node.left = z;\n            z.parent = node;\n        }\n        else {\n            const prevNode = righttest(node.left); // a\n            prevNode.right = z;\n            z.parent = prevNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}