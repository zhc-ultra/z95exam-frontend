{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { computeIndentLevel } from '../../../common/model/utils.js';\nimport { FoldingRegions, MAX_LINE_NUMBER } from './foldingRanges.js';\nvar MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT = 5000;\nvar ID_INDENT_PROVIDER = 'indent';\nexport var IndentRangeProvider = /*#__PURE__*/function () {\n  function IndentRangeProvider(editorModel, languageConfigurationService, foldingRangesLimit) {\n    _classCallCheck(this, IndentRangeProvider);\n    this.editorModel = editorModel;\n    this.languageConfigurationService = languageConfigurationService;\n    this.foldingRangesLimit = foldingRangesLimit;\n    this.id = ID_INDENT_PROVIDER;\n  }\n  return _createClass(IndentRangeProvider, [{\n    key: \"dispose\",\n    value: function dispose() {}\n  }, {\n    key: \"compute\",\n    value: function compute(cancelationToken) {\n      var foldingRules = this.languageConfigurationService.getLanguageConfiguration(this.editorModel.getLanguageId()).foldingRules;\n      var offSide = foldingRules && !!foldingRules.offSide;\n      var markers = foldingRules && foldingRules.markers;\n      return Promise.resolve(computeRanges(this.editorModel, offSide, markers, this.foldingRangesLimit));\n    }\n  }]);\n}();\n// public only for testing\nexport var RangesCollector = /*#__PURE__*/function () {\n  function RangesCollector(foldingRangesLimit) {\n    _classCallCheck(this, RangesCollector);\n    this._startIndexes = [];\n    this._endIndexes = [];\n    this._indentOccurrences = [];\n    this._length = 0;\n    this._foldingRangesLimit = foldingRangesLimit;\n  }\n  return _createClass(RangesCollector, [{\n    key: \"insertFirst\",\n    value: function insertFirst(startLineNumber, endLineNumber, indent) {\n      if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n        return;\n      }\n      var index = this._length;\n      this._startIndexes[index] = startLineNumber;\n      this._endIndexes[index] = endLineNumber;\n      this._length++;\n      if (indent < 1000) {\n        this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;\n      }\n    }\n  }, {\n    key: \"toIndentRanges\",\n    value: function toIndentRanges(model) {\n      var limit = this._foldingRangesLimit.limit;\n      if (this._length <= limit) {\n        this._foldingRangesLimit.update(this._length, false);\n        // reverse and create arrays of the exact length\n        var startIndexes = new Uint32Array(this._length);\n        var endIndexes = new Uint32Array(this._length);\n        for (var i = this._length - 1, k = 0; i >= 0; i--, k++) {\n          startIndexes[k] = this._startIndexes[i];\n          endIndexes[k] = this._endIndexes[i];\n        }\n        return new FoldingRegions(startIndexes, endIndexes);\n      } else {\n        this._foldingRangesLimit.update(this._length, limit);\n        var entries = 0;\n        var maxIndent = this._indentOccurrences.length;\n        for (var _i = 0; _i < this._indentOccurrences.length; _i++) {\n          var n = this._indentOccurrences[_i];\n          if (n) {\n            if (n + entries > limit) {\n              maxIndent = _i;\n              break;\n            }\n            entries += n;\n          }\n        }\n        var tabSize = model.getOptions().tabSize;\n        // reverse and create arrays of the exact length\n        var _startIndexes = new Uint32Array(limit);\n        var _endIndexes = new Uint32Array(limit);\n        for (var _i2 = this._length - 1, _k = 0; _i2 >= 0; _i2--) {\n          var startIndex = this._startIndexes[_i2];\n          var lineContent = model.getLineContent(startIndex);\n          var indent = computeIndentLevel(lineContent, tabSize);\n          if (indent < maxIndent || indent === maxIndent && entries++ < limit) {\n            _startIndexes[_k] = startIndex;\n            _endIndexes[_k] = this._endIndexes[_i2];\n            _k++;\n          }\n        }\n        return new FoldingRegions(_startIndexes, _endIndexes);\n      }\n    }\n  }]);\n}();\nvar foldingRangesLimitDefault = {\n  limit: MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT,\n  update: function update() {}\n};\nexport function computeRanges(model, offSide, markers) {\n  var foldingRangesLimit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : foldingRangesLimitDefault;\n  var tabSize = model.getOptions().tabSize;\n  var result = new RangesCollector(foldingRangesLimit);\n  var pattern = undefined;\n  if (markers) {\n    pattern = new RegExp(\"(\".concat(markers.start.source, \")|(?:\").concat(markers.end.source, \")\"));\n  }\n  var previousRegions = [];\n  var line = model.getLineCount() + 1;\n  previousRegions.push({\n    indent: -1,\n    endAbove: line,\n    line: line\n  }); // sentinel, to make sure there's at least one entry\n  for (var _line = model.getLineCount(); _line > 0; _line--) {\n    var lineContent = model.getLineContent(_line);\n    var indent = computeIndentLevel(lineContent, tabSize);\n    var previous = previousRegions[previousRegions.length - 1];\n    if (indent === -1) {\n      if (offSide) {\n        // for offSide languages, empty lines are associated to the previous block\n        // note: the next block is already written to the results, so this only\n        // impacts the end position of the block before\n        previous.endAbove = _line;\n      }\n      continue; // only whitespace\n    }\n    var m = void 0;\n    if (pattern && (m = lineContent.match(pattern))) {\n      // folding pattern match\n      if (m[1]) {\n        // start pattern match\n        // discard all regions until the folding pattern\n        var i = previousRegions.length - 1;\n        while (i > 0 && previousRegions[i].indent !== -2) {\n          i--;\n        }\n        if (i > 0) {\n          previousRegions.length = i + 1;\n          previous = previousRegions[i];\n          // new folding range from pattern, includes the end line\n          result.insertFirst(_line, previous.line, indent);\n          previous.line = _line;\n          previous.indent = indent;\n          previous.endAbove = _line;\n          continue;\n        } else {\n          // no end marker found, treat line as a regular line\n        }\n      } else {\n        // end pattern match\n        previousRegions.push({\n          indent: -2,\n          endAbove: _line,\n          line: _line\n        });\n        continue;\n      }\n    }\n    if (previous.indent > indent) {\n      // discard all regions with larger indent\n      do {\n        previousRegions.pop();\n        previous = previousRegions[previousRegions.length - 1];\n      } while (previous.indent > indent);\n      // new folding range\n      var endLineNumber = previous.endAbove - 1;\n      if (endLineNumber - _line >= 1) {\n        // needs at east size 1\n        result.insertFirst(_line, endLineNumber, indent);\n      }\n    }\n    if (previous.indent === indent) {\n      previous.endAbove = _line;\n    } else {\n      // previous.indent < indent\n      // new region with a bigger indent\n      previousRegions.push({\n        indent: indent,\n        endAbove: _line,\n        line: _line\n      });\n    }\n  }\n  return result.toIndentRanges(model);\n}","map":{"version":3,"names":["computeIndentLevel","FoldingRegions","MAX_LINE_NUMBER","MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT","ID_INDENT_PROVIDER","IndentRangeProvider","editorModel","languageConfigurationService","foldingRangesLimit","_classCallCheck","id","_createClass","key","value","dispose","compute","cancelationToken","foldingRules","getLanguageConfiguration","getLanguageId","offSide","markers","Promise","resolve","computeRanges","RangesCollector","_startIndexes","_endIndexes","_indentOccurrences","_length","_foldingRangesLimit","insertFirst","startLineNumber","endLineNumber","indent","index","toIndentRanges","model","limit","update","startIndexes","Uint32Array","endIndexes","i","k","entries","maxIndent","length","n","tabSize","getOptions","startIndex","lineContent","getLineContent","foldingRangesLimitDefault","arguments","undefined","result","pattern","RegExp","concat","start","source","end","previousRegions","line","getLineCount","push","endAbove","previous","m","match","pop"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/indentRangeProvider.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { computeIndentLevel } from '../../../common/model/utils.js';\nimport { FoldingRegions, MAX_LINE_NUMBER } from './foldingRanges.js';\nconst MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT = 5000;\nconst ID_INDENT_PROVIDER = 'indent';\nexport class IndentRangeProvider {\n    constructor(editorModel, languageConfigurationService, foldingRangesLimit) {\n        this.editorModel = editorModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.foldingRangesLimit = foldingRangesLimit;\n        this.id = ID_INDENT_PROVIDER;\n    }\n    dispose() { }\n    compute(cancelationToken) {\n        const foldingRules = this.languageConfigurationService.getLanguageConfiguration(this.editorModel.getLanguageId()).foldingRules;\n        const offSide = foldingRules && !!foldingRules.offSide;\n        const markers = foldingRules && foldingRules.markers;\n        return Promise.resolve(computeRanges(this.editorModel, offSide, markers, this.foldingRangesLimit));\n    }\n}\n// public only for testing\nexport class RangesCollector {\n    constructor(foldingRangesLimit) {\n        this._startIndexes = [];\n        this._endIndexes = [];\n        this._indentOccurrences = [];\n        this._length = 0;\n        this._foldingRangesLimit = foldingRangesLimit;\n    }\n    insertFirst(startLineNumber, endLineNumber, indent) {\n        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n            return;\n        }\n        const index = this._length;\n        this._startIndexes[index] = startLineNumber;\n        this._endIndexes[index] = endLineNumber;\n        this._length++;\n        if (indent < 1000) {\n            this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;\n        }\n    }\n    toIndentRanges(model) {\n        const limit = this._foldingRangesLimit.limit;\n        if (this._length <= limit) {\n            this._foldingRangesLimit.update(this._length, false);\n            // reverse and create arrays of the exact length\n            const startIndexes = new Uint32Array(this._length);\n            const endIndexes = new Uint32Array(this._length);\n            for (let i = this._length - 1, k = 0; i >= 0; i--, k++) {\n                startIndexes[k] = this._startIndexes[i];\n                endIndexes[k] = this._endIndexes[i];\n            }\n            return new FoldingRegions(startIndexes, endIndexes);\n        }\n        else {\n            this._foldingRangesLimit.update(this._length, limit);\n            let entries = 0;\n            let maxIndent = this._indentOccurrences.length;\n            for (let i = 0; i < this._indentOccurrences.length; i++) {\n                const n = this._indentOccurrences[i];\n                if (n) {\n                    if (n + entries > limit) {\n                        maxIndent = i;\n                        break;\n                    }\n                    entries += n;\n                }\n            }\n            const tabSize = model.getOptions().tabSize;\n            // reverse and create arrays of the exact length\n            const startIndexes = new Uint32Array(limit);\n            const endIndexes = new Uint32Array(limit);\n            for (let i = this._length - 1, k = 0; i >= 0; i--) {\n                const startIndex = this._startIndexes[i];\n                const lineContent = model.getLineContent(startIndex);\n                const indent = computeIndentLevel(lineContent, tabSize);\n                if (indent < maxIndent || (indent === maxIndent && entries++ < limit)) {\n                    startIndexes[k] = startIndex;\n                    endIndexes[k] = this._endIndexes[i];\n                    k++;\n                }\n            }\n            return new FoldingRegions(startIndexes, endIndexes);\n        }\n    }\n}\nconst foldingRangesLimitDefault = {\n    limit: MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT,\n    update: () => { }\n};\nexport function computeRanges(model, offSide, markers, foldingRangesLimit = foldingRangesLimitDefault) {\n    const tabSize = model.getOptions().tabSize;\n    const result = new RangesCollector(foldingRangesLimit);\n    let pattern = undefined;\n    if (markers) {\n        pattern = new RegExp(`(${markers.start.source})|(?:${markers.end.source})`);\n    }\n    const previousRegions = [];\n    const line = model.getLineCount() + 1;\n    previousRegions.push({ indent: -1, endAbove: line, line }); // sentinel, to make sure there's at least one entry\n    for (let line = model.getLineCount(); line > 0; line--) {\n        const lineContent = model.getLineContent(line);\n        const indent = computeIndentLevel(lineContent, tabSize);\n        let previous = previousRegions[previousRegions.length - 1];\n        if (indent === -1) {\n            if (offSide) {\n                // for offSide languages, empty lines are associated to the previous block\n                // note: the next block is already written to the results, so this only\n                // impacts the end position of the block before\n                previous.endAbove = line;\n            }\n            continue; // only whitespace\n        }\n        let m;\n        if (pattern && (m = lineContent.match(pattern))) {\n            // folding pattern match\n            if (m[1]) { // start pattern match\n                // discard all regions until the folding pattern\n                let i = previousRegions.length - 1;\n                while (i > 0 && previousRegions[i].indent !== -2) {\n                    i--;\n                }\n                if (i > 0) {\n                    previousRegions.length = i + 1;\n                    previous = previousRegions[i];\n                    // new folding range from pattern, includes the end line\n                    result.insertFirst(line, previous.line, indent);\n                    previous.line = line;\n                    previous.indent = indent;\n                    previous.endAbove = line;\n                    continue;\n                }\n                else {\n                    // no end marker found, treat line as a regular line\n                }\n            }\n            else { // end pattern match\n                previousRegions.push({ indent: -2, endAbove: line, line });\n                continue;\n            }\n        }\n        if (previous.indent > indent) {\n            // discard all regions with larger indent\n            do {\n                previousRegions.pop();\n                previous = previousRegions[previousRegions.length - 1];\n            } while (previous.indent > indent);\n            // new folding range\n            const endLineNumber = previous.endAbove - 1;\n            if (endLineNumber - line >= 1) { // needs at east size 1\n                result.insertFirst(line, endLineNumber, indent);\n            }\n        }\n        if (previous.indent === indent) {\n            previous.endAbove = line;\n        }\n        else { // previous.indent < indent\n            // new region with a bigger indent\n            previousRegions.push({ indent, endAbove: line, line });\n        }\n    }\n    return result.toIndentRanges(model);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}