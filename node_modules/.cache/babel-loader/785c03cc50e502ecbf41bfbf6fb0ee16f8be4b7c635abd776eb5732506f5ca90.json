{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { SingleLineInlineDecoration, ViewLineData } from '../viewModel.js';\nexport function createModelLineProjection(lineBreakData, isVisible) {\n  if (lineBreakData === null) {\n    // No mapping needed\n    if (isVisible) {\n      return IdentityModelLineProjection.INSTANCE;\n    }\n    return HiddenModelLineProjection.INSTANCE;\n  } else {\n    return new ModelLineProjection(lineBreakData, isVisible);\n  }\n}\n/**\n * This projection is used to\n * * wrap model lines\n * * inject text\n */\nvar ModelLineProjection = /*#__PURE__*/function () {\n  function ModelLineProjection(lineBreakData, isVisible) {\n    _classCallCheck(this, ModelLineProjection);\n    this._projectionData = lineBreakData;\n    this._isVisible = isVisible;\n  }\n  return _createClass(ModelLineProjection, [{\n    key: \"isVisible\",\n    value: function isVisible() {\n      return this._isVisible;\n    }\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(isVisible) {\n      this._isVisible = isVisible;\n      return this;\n    }\n  }, {\n    key: \"getProjectionData\",\n    value: function getProjectionData() {\n      return this._projectionData;\n    }\n  }, {\n    key: \"getViewLineCount\",\n    value: function getViewLineCount() {\n      if (!this._isVisible) {\n        return 0;\n      }\n      return this._projectionData.getOutputLineCount();\n    }\n  }, {\n    key: \"getViewLineContent\",\n    value: function getViewLineContent(model, modelLineNumber, outputLineIndex) {\n      var _this = this;\n      this._assertVisible();\n      var startOffsetInInputWithInjections = outputLineIndex > 0 ? this._projectionData.breakOffsets[outputLineIndex - 1] : 0;\n      var endOffsetInInputWithInjections = this._projectionData.breakOffsets[outputLineIndex];\n      var r;\n      if (this._projectionData.injectionOffsets !== null) {\n        var injectedTexts = this._projectionData.injectionOffsets.map(function (offset, idx) {\n          return new LineInjectedText(0, 0, offset + 1, _this._projectionData.injectionOptions[idx], 0);\n        });\n        var lineWithInjections = LineInjectedText.applyInjectedText(model.getLineContent(modelLineNumber), injectedTexts);\n        r = lineWithInjections.substring(startOffsetInInputWithInjections, endOffsetInInputWithInjections);\n      } else {\n        r = model.getValueInRange({\n          startLineNumber: modelLineNumber,\n          startColumn: startOffsetInInputWithInjections + 1,\n          endLineNumber: modelLineNumber,\n          endColumn: endOffsetInInputWithInjections + 1\n        });\n      }\n      if (outputLineIndex > 0) {\n        r = spaces(this._projectionData.wrappedTextIndentLength) + r;\n      }\n      return r;\n    }\n  }, {\n    key: \"getViewLineLength\",\n    value: function getViewLineLength(model, modelLineNumber, outputLineIndex) {\n      this._assertVisible();\n      return this._projectionData.getLineLength(outputLineIndex);\n    }\n  }, {\n    key: \"getViewLineMinColumn\",\n    value: function getViewLineMinColumn(_model, _modelLineNumber, outputLineIndex) {\n      this._assertVisible();\n      return this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n    }\n  }, {\n    key: \"getViewLineMaxColumn\",\n    value: function getViewLineMaxColumn(model, modelLineNumber, outputLineIndex) {\n      this._assertVisible();\n      return this._projectionData.getMaxOutputOffset(outputLineIndex) + 1;\n    }\n    /**\n     * Try using {@link getViewLinesData} instead.\n    */\n  }, {\n    key: \"getViewLineData\",\n    value: function getViewLineData(model, modelLineNumber, outputLineIndex) {\n      var arr = new Array();\n      this.getViewLinesData(model, modelLineNumber, outputLineIndex, 1, 0, [true], arr);\n      return arr[0];\n    }\n  }, {\n    key: \"getViewLinesData\",\n    value: function getViewLinesData(model, modelLineNumber, outputLineIdx, lineCount, globalStartIndex, needed, result) {\n      this._assertVisible();\n      var lineBreakData = this._projectionData;\n      var injectionOffsets = lineBreakData.injectionOffsets;\n      var injectionOptions = lineBreakData.injectionOptions;\n      var inlineDecorationsPerOutputLine = null;\n      if (injectionOffsets) {\n        inlineDecorationsPerOutputLine = [];\n        var totalInjectedTextLengthBefore = 0;\n        var currentInjectedOffset = 0;\n        for (var outputLineIndex = 0; outputLineIndex < lineBreakData.getOutputLineCount(); outputLineIndex++) {\n          var inlineDecorations = new Array();\n          inlineDecorationsPerOutputLine[outputLineIndex] = inlineDecorations;\n          var lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n          var lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n          while (currentInjectedOffset < injectionOffsets.length) {\n            var length = injectionOptions[currentInjectedOffset].content.length;\n            var injectedTextStartOffsetInInputWithInjections = injectionOffsets[currentInjectedOffset] + totalInjectedTextLengthBefore;\n            var injectedTextEndOffsetInInputWithInjections = injectedTextStartOffsetInInputWithInjections + length;\n            if (injectedTextStartOffsetInInputWithInjections > lineEndOffsetInInputWithInjections) {\n              // Injected text only starts in later wrapped lines.\n              break;\n            }\n            if (lineStartOffsetInInputWithInjections < injectedTextEndOffsetInInputWithInjections) {\n              // Injected text ends after or in this line (but also starts in or before this line).\n              var options = injectionOptions[currentInjectedOffset];\n              if (options.inlineClassName) {\n                var offset = outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0;\n                var start = offset + Math.max(injectedTextStartOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, 0);\n                var end = offset + Math.min(injectedTextEndOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections - lineStartOffsetInInputWithInjections);\n                if (start !== end) {\n                  inlineDecorations.push(new SingleLineInlineDecoration(start, end, options.inlineClassName, options.inlineClassNameAffectsLetterSpacing));\n                }\n              }\n            }\n            if (injectedTextEndOffsetInInputWithInjections <= lineEndOffsetInInputWithInjections) {\n              totalInjectedTextLengthBefore += length;\n              currentInjectedOffset++;\n            } else {\n              // injected text breaks into next line, process it again\n              break;\n            }\n          }\n        }\n      }\n      var lineWithInjections;\n      if (injectionOffsets) {\n        lineWithInjections = model.tokenization.getLineTokens(modelLineNumber).withInserted(injectionOffsets.map(function (offset, idx) {\n          return {\n            offset: offset,\n            text: injectionOptions[idx].content,\n            tokenMetadata: LineTokens.defaultTokenMetadata\n          };\n        }));\n      } else {\n        lineWithInjections = model.tokenization.getLineTokens(modelLineNumber);\n      }\n      for (var _outputLineIndex2 = outputLineIdx; _outputLineIndex2 < outputLineIdx + lineCount; _outputLineIndex2++) {\n        var globalIndex = globalStartIndex + _outputLineIndex2 - outputLineIdx;\n        if (!needed[globalIndex]) {\n          result[globalIndex] = null;\n          continue;\n        }\n        result[globalIndex] = this._getViewLineData(lineWithInjections, inlineDecorationsPerOutputLine ? inlineDecorationsPerOutputLine[_outputLineIndex2] : null, _outputLineIndex2);\n      }\n    }\n  }, {\n    key: \"_getViewLineData\",\n    value: function _getViewLineData(lineWithInjections, inlineDecorations, outputLineIndex) {\n      this._assertVisible();\n      var lineBreakData = this._projectionData;\n      var deltaStartIndex = outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0;\n      var lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n      var lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n      var tokens = lineWithInjections.sliceAndInflate(lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections, deltaStartIndex);\n      var lineContent = tokens.getLineContent();\n      if (outputLineIndex > 0) {\n        lineContent = spaces(lineBreakData.wrappedTextIndentLength) + lineContent;\n      }\n      var minColumn = this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n      var maxColumn = lineContent.length + 1;\n      var continuesWithWrappedLine = outputLineIndex + 1 < this.getViewLineCount();\n      var startVisibleColumn = outputLineIndex === 0 ? 0 : lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1];\n      return new ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens, inlineDecorations);\n    }\n  }, {\n    key: \"getModelColumnOfViewPosition\",\n    value: function getModelColumnOfViewPosition(outputLineIndex, outputColumn) {\n      this._assertVisible();\n      return this._projectionData.translateToInputOffset(outputLineIndex, outputColumn - 1) + 1;\n    }\n  }, {\n    key: \"getViewPositionOfModelPosition\",\n    value: function getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n      var affinity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n      this._assertVisible();\n      var r = this._projectionData.translateToOutputPosition(inputColumn - 1, affinity);\n      return r.toPosition(deltaLineNumber);\n    }\n  }, {\n    key: \"getViewLineNumberOfModelPosition\",\n    value: function getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn) {\n      this._assertVisible();\n      var r = this._projectionData.translateToOutputPosition(inputColumn - 1);\n      return deltaLineNumber + r.outputLineIndex;\n    }\n  }, {\n    key: \"normalizePosition\",\n    value: function normalizePosition(outputLineIndex, outputPosition, affinity) {\n      var baseViewLineNumber = outputPosition.lineNumber - outputLineIndex;\n      var normalizedOutputPosition = this._projectionData.normalizeOutputPosition(outputLineIndex, outputPosition.column - 1, affinity);\n      var result = normalizedOutputPosition.toPosition(baseViewLineNumber);\n      return result;\n    }\n  }, {\n    key: \"getInjectedTextAt\",\n    value: function getInjectedTextAt(outputLineIndex, outputColumn) {\n      return this._projectionData.getInjectedText(outputLineIndex, outputColumn - 1);\n    }\n  }, {\n    key: \"_assertVisible\",\n    value: function _assertVisible() {\n      if (!this._isVisible) {\n        throw new Error('Not supported');\n      }\n    }\n  }]);\n}();\n/**\n * This projection does not change the model line.\n*/\nvar IdentityModelLineProjection = /*#__PURE__*/function () {\n  function IdentityModelLineProjection() {\n    _classCallCheck(this, IdentityModelLineProjection);\n  }\n  return _createClass(IdentityModelLineProjection, [{\n    key: \"isVisible\",\n    value: function isVisible() {\n      return true;\n    }\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(isVisible) {\n      if (isVisible) {\n        return this;\n      }\n      return HiddenModelLineProjection.INSTANCE;\n    }\n  }, {\n    key: \"getProjectionData\",\n    value: function getProjectionData() {\n      return null;\n    }\n  }, {\n    key: \"getViewLineCount\",\n    value: function getViewLineCount() {\n      return 1;\n    }\n  }, {\n    key: \"getViewLineContent\",\n    value: function getViewLineContent(model, modelLineNumber, _outputLineIndex) {\n      return model.getLineContent(modelLineNumber);\n    }\n  }, {\n    key: \"getViewLineLength\",\n    value: function getViewLineLength(model, modelLineNumber, _outputLineIndex) {\n      return model.getLineLength(modelLineNumber);\n    }\n  }, {\n    key: \"getViewLineMinColumn\",\n    value: function getViewLineMinColumn(model, modelLineNumber, _outputLineIndex) {\n      return model.getLineMinColumn(modelLineNumber);\n    }\n  }, {\n    key: \"getViewLineMaxColumn\",\n    value: function getViewLineMaxColumn(model, modelLineNumber, _outputLineIndex) {\n      return model.getLineMaxColumn(modelLineNumber);\n    }\n  }, {\n    key: \"getViewLineData\",\n    value: function getViewLineData(model, modelLineNumber, _outputLineIndex) {\n      var lineTokens = model.tokenization.getLineTokens(modelLineNumber);\n      var lineContent = lineTokens.getLineContent();\n      return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n  }, {\n    key: \"getViewLinesData\",\n    value: function getViewLinesData(model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {\n      if (!needed[globalStartIndex]) {\n        result[globalStartIndex] = null;\n        return;\n      }\n      result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\n    }\n  }, {\n    key: \"getModelColumnOfViewPosition\",\n    value: function getModelColumnOfViewPosition(_outputLineIndex, outputColumn) {\n      return outputColumn;\n    }\n  }, {\n    key: \"getViewPositionOfModelPosition\",\n    value: function getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n      return new Position(deltaLineNumber, inputColumn);\n    }\n  }, {\n    key: \"getViewLineNumberOfModelPosition\",\n    value: function getViewLineNumberOfModelPosition(deltaLineNumber, _inputColumn) {\n      return deltaLineNumber;\n    }\n  }, {\n    key: \"normalizePosition\",\n    value: function normalizePosition(outputLineIndex, outputPosition, affinity) {\n      return outputPosition;\n    }\n  }, {\n    key: \"getInjectedTextAt\",\n    value: function getInjectedTextAt(_outputLineIndex, _outputColumn) {\n      return null;\n    }\n  }]);\n}();\nIdentityModelLineProjection.INSTANCE = new IdentityModelLineProjection();\n/**\n * This projection hides the model line.\n */\nvar HiddenModelLineProjection = /*#__PURE__*/function () {\n  function HiddenModelLineProjection() {\n    _classCallCheck(this, HiddenModelLineProjection);\n  }\n  return _createClass(HiddenModelLineProjection, [{\n    key: \"isVisible\",\n    value: function isVisible() {\n      return false;\n    }\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(isVisible) {\n      if (!isVisible) {\n        return this;\n      }\n      return IdentityModelLineProjection.INSTANCE;\n    }\n  }, {\n    key: \"getProjectionData\",\n    value: function getProjectionData() {\n      return null;\n    }\n  }, {\n    key: \"getViewLineCount\",\n    value: function getViewLineCount() {\n      return 0;\n    }\n  }, {\n    key: \"getViewLineContent\",\n    value: function getViewLineContent(_model, _modelLineNumber, _outputLineIndex) {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"getViewLineLength\",\n    value: function getViewLineLength(_model, _modelLineNumber, _outputLineIndex) {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"getViewLineMinColumn\",\n    value: function getViewLineMinColumn(_model, _modelLineNumber, _outputLineIndex) {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"getViewLineMaxColumn\",\n    value: function getViewLineMaxColumn(_model, _modelLineNumber, _outputLineIndex) {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"getViewLineData\",\n    value: function getViewLineData(_model, _modelLineNumber, _outputLineIndex) {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"getViewLinesData\",\n    value: function getViewLinesData(_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"getModelColumnOfViewPosition\",\n    value: function getModelColumnOfViewPosition(_outputLineIndex, _outputColumn) {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"getViewPositionOfModelPosition\",\n    value: function getViewPositionOfModelPosition(_deltaLineNumber, _inputColumn) {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"getViewLineNumberOfModelPosition\",\n    value: function getViewLineNumberOfModelPosition(_deltaLineNumber, _inputColumn) {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"normalizePosition\",\n    value: function normalizePosition(outputLineIndex, outputPosition, affinity) {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"getInjectedTextAt\",\n    value: function getInjectedTextAt(_outputLineIndex, _outputColumn) {\n      throw new Error('Not supported');\n    }\n  }]);\n}();\nHiddenModelLineProjection.INSTANCE = new HiddenModelLineProjection();\nvar _spaces = [''];\nfunction spaces(count) {\n  if (count >= _spaces.length) {\n    for (var i = 1; i <= count; i++) {\n      _spaces[i] = _makeSpaces(i);\n    }\n  }\n  return _spaces[count];\n}\nfunction _makeSpaces(count) {\n  return new Array(count + 1).join(' ');\n}","map":{"version":3,"names":["LineTokens","Position","LineInjectedText","SingleLineInlineDecoration","ViewLineData","createModelLineProjection","lineBreakData","isVisible","IdentityModelLineProjection","INSTANCE","HiddenModelLineProjection","ModelLineProjection","_classCallCheck","_projectionData","_isVisible","_createClass","key","value","setVisible","getProjectionData","getViewLineCount","getOutputLineCount","getViewLineContent","model","modelLineNumber","outputLineIndex","_this","_assertVisible","startOffsetInInputWithInjections","breakOffsets","endOffsetInInputWithInjections","r","injectionOffsets","injectedTexts","map","offset","idx","injectionOptions","lineWithInjections","applyInjectedText","getLineContent","substring","getValueInRange","startLineNumber","startColumn","endLineNumber","endColumn","spaces","wrappedTextIndentLength","getViewLineLength","getLineLength","getViewLineMinColumn","_model","_modelLineNumber","getMinOutputOffset","getViewLineMaxColumn","getMaxOutputOffset","getViewLineData","arr","Array","getViewLinesData","outputLineIdx","lineCount","globalStartIndex","needed","result","inlineDecorationsPerOutputLine","totalInjectedTextLengthBefore","currentInjectedOffset","inlineDecorations","lineStartOffsetInInputWithInjections","lineEndOffsetInInputWithInjections","length","content","injectedTextStartOffsetInInputWithInjections","injectedTextEndOffsetInInputWithInjections","options","inlineClassName","start","Math","max","end","min","push","inlineClassNameAffectsLetterSpacing","tokenization","getLineTokens","withInserted","text","tokenMetadata","defaultTokenMetadata","globalIndex","_getViewLineData","deltaStartIndex","tokens","sliceAndInflate","lineContent","minColumn","maxColumn","continuesWithWrappedLine","startVisibleColumn","breakOffsetsVisibleColumn","getModelColumnOfViewPosition","outputColumn","translateToInputOffset","getViewPositionOfModelPosition","deltaLineNumber","inputColumn","affinity","arguments","undefined","translateToOutputPosition","toPosition","getViewLineNumberOfModelPosition","normalizePosition","outputPosition","baseViewLineNumber","lineNumber","normalizedOutputPosition","normalizeOutputPosition","column","getInjectedTextAt","getInjectedText","Error","_outputLineIndex","getLineMinColumn","getLineMaxColumn","lineTokens","inflate","_fromOuputLineIndex","_toOutputLineIndex","_inputColumn","_outputColumn","_globalStartIndex","_needed","_result","_deltaLineNumber","_spaces","count","i","_makeSpaces","join"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/viewModel/modelLineProjection.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { SingleLineInlineDecoration, ViewLineData } from '../viewModel.js';\nexport function createModelLineProjection(lineBreakData, isVisible) {\n    if (lineBreakData === null) {\n        // No mapping needed\n        if (isVisible) {\n            return IdentityModelLineProjection.INSTANCE;\n        }\n        return HiddenModelLineProjection.INSTANCE;\n    }\n    else {\n        return new ModelLineProjection(lineBreakData, isVisible);\n    }\n}\n/**\n * This projection is used to\n * * wrap model lines\n * * inject text\n */\nclass ModelLineProjection {\n    constructor(lineBreakData, isVisible) {\n        this._projectionData = lineBreakData;\n        this._isVisible = isVisible;\n    }\n    isVisible() {\n        return this._isVisible;\n    }\n    setVisible(isVisible) {\n        this._isVisible = isVisible;\n        return this;\n    }\n    getProjectionData() {\n        return this._projectionData;\n    }\n    getViewLineCount() {\n        if (!this._isVisible) {\n            return 0;\n        }\n        return this._projectionData.getOutputLineCount();\n    }\n    getViewLineContent(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        const startOffsetInInputWithInjections = outputLineIndex > 0 ? this._projectionData.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffsetInInputWithInjections = this._projectionData.breakOffsets[outputLineIndex];\n        let r;\n        if (this._projectionData.injectionOffsets !== null) {\n            const injectedTexts = this._projectionData.injectionOffsets.map((offset, idx) => new LineInjectedText(0, 0, offset + 1, this._projectionData.injectionOptions[idx], 0));\n            const lineWithInjections = LineInjectedText.applyInjectedText(model.getLineContent(modelLineNumber), injectedTexts);\n            r = lineWithInjections.substring(startOffsetInInputWithInjections, endOffsetInInputWithInjections);\n        }\n        else {\n            r = model.getValueInRange({\n                startLineNumber: modelLineNumber,\n                startColumn: startOffsetInInputWithInjections + 1,\n                endLineNumber: modelLineNumber,\n                endColumn: endOffsetInInputWithInjections + 1\n            });\n        }\n        if (outputLineIndex > 0) {\n            r = spaces(this._projectionData.wrappedTextIndentLength) + r;\n        }\n        return r;\n    }\n    getViewLineLength(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getLineLength(outputLineIndex);\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n    }\n    getViewLineMaxColumn(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getMaxOutputOffset(outputLineIndex) + 1;\n    }\n    /**\n     * Try using {@link getViewLinesData} instead.\n    */\n    getViewLineData(model, modelLineNumber, outputLineIndex) {\n        const arr = new Array();\n        this.getViewLinesData(model, modelLineNumber, outputLineIndex, 1, 0, [true], arr);\n        return arr[0];\n    }\n    getViewLinesData(model, modelLineNumber, outputLineIdx, lineCount, globalStartIndex, needed, result) {\n        this._assertVisible();\n        const lineBreakData = this._projectionData;\n        const injectionOffsets = lineBreakData.injectionOffsets;\n        const injectionOptions = lineBreakData.injectionOptions;\n        let inlineDecorationsPerOutputLine = null;\n        if (injectionOffsets) {\n            inlineDecorationsPerOutputLine = [];\n            let totalInjectedTextLengthBefore = 0;\n            let currentInjectedOffset = 0;\n            for (let outputLineIndex = 0; outputLineIndex < lineBreakData.getOutputLineCount(); outputLineIndex++) {\n                const inlineDecorations = new Array();\n                inlineDecorationsPerOutputLine[outputLineIndex] = inlineDecorations;\n                const lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n                const lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n                while (currentInjectedOffset < injectionOffsets.length) {\n                    const length = injectionOptions[currentInjectedOffset].content.length;\n                    const injectedTextStartOffsetInInputWithInjections = injectionOffsets[currentInjectedOffset] + totalInjectedTextLengthBefore;\n                    const injectedTextEndOffsetInInputWithInjections = injectedTextStartOffsetInInputWithInjections + length;\n                    if (injectedTextStartOffsetInInputWithInjections > lineEndOffsetInInputWithInjections) {\n                        // Injected text only starts in later wrapped lines.\n                        break;\n                    }\n                    if (lineStartOffsetInInputWithInjections < injectedTextEndOffsetInInputWithInjections) {\n                        // Injected text ends after or in this line (but also starts in or before this line).\n                        const options = injectionOptions[currentInjectedOffset];\n                        if (options.inlineClassName) {\n                            const offset = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n                            const start = offset + Math.max(injectedTextStartOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, 0);\n                            const end = offset + Math.min(injectedTextEndOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections - lineStartOffsetInInputWithInjections);\n                            if (start !== end) {\n                                inlineDecorations.push(new SingleLineInlineDecoration(start, end, options.inlineClassName, options.inlineClassNameAffectsLetterSpacing));\n                            }\n                        }\n                    }\n                    if (injectedTextEndOffsetInInputWithInjections <= lineEndOffsetInInputWithInjections) {\n                        totalInjectedTextLengthBefore += length;\n                        currentInjectedOffset++;\n                    }\n                    else {\n                        // injected text breaks into next line, process it again\n                        break;\n                    }\n                }\n            }\n        }\n        let lineWithInjections;\n        if (injectionOffsets) {\n            lineWithInjections = model.tokenization.getLineTokens(modelLineNumber).withInserted(injectionOffsets.map((offset, idx) => ({\n                offset,\n                text: injectionOptions[idx].content,\n                tokenMetadata: LineTokens.defaultTokenMetadata\n            })));\n        }\n        else {\n            lineWithInjections = model.tokenization.getLineTokens(modelLineNumber);\n        }\n        for (let outputLineIndex = outputLineIdx; outputLineIndex < outputLineIdx + lineCount; outputLineIndex++) {\n            const globalIndex = globalStartIndex + outputLineIndex - outputLineIdx;\n            if (!needed[globalIndex]) {\n                result[globalIndex] = null;\n                continue;\n            }\n            result[globalIndex] = this._getViewLineData(lineWithInjections, inlineDecorationsPerOutputLine ? inlineDecorationsPerOutputLine[outputLineIndex] : null, outputLineIndex);\n        }\n    }\n    _getViewLineData(lineWithInjections, inlineDecorations, outputLineIndex) {\n        this._assertVisible();\n        const lineBreakData = this._projectionData;\n        const deltaStartIndex = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n        const lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n        const lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n        const tokens = lineWithInjections.sliceAndInflate(lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections, deltaStartIndex);\n        let lineContent = tokens.getLineContent();\n        if (outputLineIndex > 0) {\n            lineContent = spaces(lineBreakData.wrappedTextIndentLength) + lineContent;\n        }\n        const minColumn = this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n        const maxColumn = lineContent.length + 1;\n        const continuesWithWrappedLine = (outputLineIndex + 1 < this.getViewLineCount());\n        const startVisibleColumn = (outputLineIndex === 0 ? 0 : lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1]);\n        return new ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens, inlineDecorations);\n    }\n    getModelColumnOfViewPosition(outputLineIndex, outputColumn) {\n        this._assertVisible();\n        return this._projectionData.translateToInputOffset(outputLineIndex, outputColumn - 1) + 1;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity = 2 /* PositionAffinity.None */) {\n        this._assertVisible();\n        const r = this._projectionData.translateToOutputPosition(inputColumn - 1, affinity);\n        return r.toPosition(deltaLineNumber);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn) {\n        this._assertVisible();\n        const r = this._projectionData.translateToOutputPosition(inputColumn - 1);\n        return deltaLineNumber + r.outputLineIndex;\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        const baseViewLineNumber = outputPosition.lineNumber - outputLineIndex;\n        const normalizedOutputPosition = this._projectionData.normalizeOutputPosition(outputLineIndex, outputPosition.column - 1, affinity);\n        const result = normalizedOutputPosition.toPosition(baseViewLineNumber);\n        return result;\n    }\n    getInjectedTextAt(outputLineIndex, outputColumn) {\n        return this._projectionData.getInjectedText(outputLineIndex, outputColumn - 1);\n    }\n    _assertVisible() {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n    }\n}\n/**\n * This projection does not change the model line.\n*/\nclass IdentityModelLineProjection {\n    constructor() { }\n    isVisible() {\n        return true;\n    }\n    setVisible(isVisible) {\n        if (isVisible) {\n            return this;\n        }\n        return HiddenModelLineProjection.INSTANCE;\n    }\n    getProjectionData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 1;\n    }\n    getViewLineContent(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineContent(modelLineNumber);\n    }\n    getViewLineLength(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineLength(modelLineNumber);\n    }\n    getViewLineMinColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMinColumn(modelLineNumber);\n    }\n    getViewLineMaxColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMaxColumn(modelLineNumber);\n    }\n    getViewLineData(model, modelLineNumber, _outputLineIndex) {\n        const lineTokens = model.tokenization.getLineTokens(modelLineNumber);\n        const lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {\n        if (!needed[globalStartIndex]) {\n            result[globalStartIndex] = null;\n            return;\n        }\n        result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, outputColumn) {\n        return outputColumn;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n        return new Position(deltaLineNumber, inputColumn);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, _inputColumn) {\n        return deltaLineNumber;\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        return outputPosition;\n    }\n    getInjectedTextAt(_outputLineIndex, _outputColumn) {\n        return null;\n    }\n}\nIdentityModelLineProjection.INSTANCE = new IdentityModelLineProjection();\n/**\n * This projection hides the model line.\n */\nclass HiddenModelLineProjection {\n    constructor() { }\n    isVisible() {\n        return false;\n    }\n    setVisible(isVisible) {\n        if (!isVisible) {\n            return this;\n        }\n        return IdentityModelLineProjection.INSTANCE;\n    }\n    getProjectionData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 0;\n    }\n    getViewLineContent(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineLength(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMaxColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineData(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLinesData(_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {\n        throw new Error('Not supported');\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewPositionOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewLineNumberOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        throw new Error('Not supported');\n    }\n    getInjectedTextAt(_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    }\n}\nHiddenModelLineProjection.INSTANCE = new HiddenModelLineProjection();\nconst _spaces = [''];\nfunction spaces(count) {\n    if (count >= _spaces.length) {\n        for (let i = 1; i <= count; i++) {\n            _spaces[i] = _makeSpaces(i);\n        }\n    }\n    return _spaces[count];\n}\nfunction _makeSpaces(count) {\n    return new Array(count + 1).join(' ');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}