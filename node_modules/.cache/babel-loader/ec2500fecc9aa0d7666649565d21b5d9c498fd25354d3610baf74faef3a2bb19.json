{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n  return (node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */;\n}\nfunction setNodeColor(node, color) {\n  node.metadata = node.metadata & 254 /* Constants.ColorMaskInverse */ | color << 0 /* Constants.ColorOffset */;\n}\nfunction getNodeIsVisited(node) {\n  return (node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */ === 1;\n}\nfunction setNodeIsVisited(node, value) {\n  node.metadata = node.metadata & 253 /* Constants.IsVisitedMaskInverse */ | (value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */;\n}\nfunction getNodeIsForValidation(node) {\n  return (node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */ === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n  node.metadata = node.metadata & 251 /* Constants.IsForValidationMaskInverse */ | (value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */;\n}\nfunction getNodeIsInGlyphMargin(node) {\n  return (node.metadata & 64 /* Constants.IsMarginMask */) >>> 6 /* Constants.IsMarginOffset */ === 1;\n}\nfunction setNodeIsInGlyphMargin(node, value) {\n  node.metadata = node.metadata & 191 /* Constants.IsMarginMaskInverse */ | (value ? 1 : 0) << 6 /* Constants.IsMarginOffset */;\n}\nfunction getNodeStickiness(node) {\n  return (node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */;\n}\nfunction _setNodeStickiness(node, stickiness) {\n  node.metadata = node.metadata & 231 /* Constants.StickinessMaskInverse */ | stickiness << 3 /* Constants.StickinessOffset */;\n}\nfunction getCollapseOnReplaceEdit(node) {\n  return (node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */ === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n  node.metadata = node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */ | (value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */;\n}\nexport var IntervalNode = /*#__PURE__*/function () {\n  function IntervalNode(id, start, end) {\n    _classCallCheck(this, IntervalNode);\n    this.metadata = 0;\n    this.parent = this;\n    this.left = this;\n    this.right = this;\n    setNodeColor(this, 1 /* NodeColor.Red */);\n    this.start = start;\n    this.end = end;\n    // FORCE_OVERFLOWING_TEST: this.delta = start;\n    this.delta = 0;\n    this.maxEnd = end;\n    this.id = id;\n    this.ownerId = 0;\n    this.options = null;\n    setNodeIsForValidation(this, false);\n    setNodeIsInGlyphMargin(this, false);\n    _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n    setCollapseOnReplaceEdit(this, false);\n    this.cachedVersionId = 0;\n    this.cachedAbsoluteStart = start;\n    this.cachedAbsoluteEnd = end;\n    this.range = null;\n    setNodeIsVisited(this, false);\n  }\n  return _createClass(IntervalNode, [{\n    key: \"reset\",\n    value: function reset(versionId, start, end, range) {\n      this.start = start;\n      this.end = end;\n      this.maxEnd = end;\n      this.cachedVersionId = versionId;\n      this.cachedAbsoluteStart = start;\n      this.cachedAbsoluteEnd = end;\n      this.range = range;\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n      var className = this.options.className;\n      setNodeIsForValidation(this, className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */ || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */ || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */);\n      setNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);\n      _setNodeStickiness(this, this.options.stickiness);\n      setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n  }, {\n    key: \"setCachedOffsets\",\n    value: function setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n      if (this.cachedVersionId !== cachedVersionId) {\n        this.range = null;\n      }\n      this.cachedVersionId = cachedVersionId;\n      this.cachedAbsoluteStart = absoluteStart;\n      this.cachedAbsoluteEnd = absoluteEnd;\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      this.parent = null;\n      this.left = null;\n      this.right = null;\n    }\n  }]);\n}();\nexport var SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nexport var IntervalTree = /*#__PURE__*/function () {\n  function IntervalTree() {\n    _classCallCheck(this, IntervalTree);\n    this.root = SENTINEL;\n    this.requestNormalizeDelta = false;\n  }\n  return _createClass(IntervalTree, [{\n    key: \"intervalSearch\",\n    value: function intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n      if (this.root === SENTINEL) {\n        return [];\n      }\n      return _intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n  }, {\n    key: \"search\",\n    value: function search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n      if (this.root === SENTINEL) {\n        return [];\n      }\n      return _search(this, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n  }, {\n    key: \"collectNodesFromOwner\",\n    value: function collectNodesFromOwner(ownerId) {\n      return _collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n  }, {\n    key: \"collectNodesPostOrder\",\n    value: function collectNodesPostOrder() {\n      return _collectNodesPostOrder(this);\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(node) {\n      rbTreeInsert(this, node);\n      this._normalizeDeltaIfNecessary();\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(node) {\n      rbTreeDelete(this, node);\n      this._normalizeDeltaIfNecessary();\n    }\n  }, {\n    key: \"resolveNode\",\n    value: function resolveNode(node, cachedVersionId) {\n      var initialNode = node;\n      var delta = 0;\n      while (node !== this.root) {\n        if (node === node.parent.right) {\n          delta += node.parent.delta;\n        }\n        node = node.parent;\n      }\n      var nodeStart = initialNode.start + delta;\n      var nodeEnd = initialNode.end + delta;\n      initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n  }, {\n    key: \"acceptReplace\",\n    value: function acceptReplace(offset, length, textLength, forceMoveMarkers) {\n      // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n      // (1) collect all nodes that are intersecting this edit as nodes of interest\n      var nodesOfInterest = searchForEditing(this, offset, offset + length);\n      // (2) remove all nodes that are intersecting this edit\n      for (var i = 0, len = nodesOfInterest.length; i < len; i++) {\n        var node = nodesOfInterest[i];\n        rbTreeDelete(this, node);\n      }\n      this._normalizeDeltaIfNecessary();\n      // (3) edit all tree nodes except the nodes of interest\n      noOverlapReplace(this, offset, offset + length, textLength);\n      this._normalizeDeltaIfNecessary();\n      // (4) edit the nodes of interest and insert them back in the tree\n      for (var _i = 0, _len = nodesOfInterest.length; _i < _len; _i++) {\n        var _node = nodesOfInterest[_i];\n        _node.start = _node.cachedAbsoluteStart;\n        _node.end = _node.cachedAbsoluteEnd;\n        nodeAcceptEdit(_node, offset, offset + length, textLength, forceMoveMarkers);\n        _node.maxEnd = _node.end;\n        rbTreeInsert(this, _node);\n      }\n      this._normalizeDeltaIfNecessary();\n    }\n  }, {\n    key: \"_normalizeDeltaIfNecessary\",\n    value: function _normalizeDeltaIfNecessary() {\n      if (!this.requestNormalizeDelta) {\n        return;\n      }\n      this.requestNormalizeDelta = false;\n      normalizeDelta(this);\n    }\n  }]);\n}();\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n  var node = T.root;\n  var delta = 0;\n  while (node !== SENTINEL) {\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n    // handle current node\n    node.start = delta + node.start;\n    node.end = delta + node.end;\n    node.delta = 0;\n    recomputeMaxEnd(node);\n    setNodeIsVisited(node, true);\n    // going up from this node\n    setNodeIsVisited(node.left, false);\n    setNodeIsVisited(node.right, false);\n    if (node === node.parent.right) {\n      delta -= node.parent.delta;\n    }\n    node = node.parent;\n  }\n  setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n  if (markerOffset < checkOffset) {\n    return true;\n  }\n  if (markerOffset > checkOffset) {\n    return false;\n  }\n  if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n    return false;\n  }\n  if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n    return true;\n  }\n  return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n  var nodeStickiness = getNodeStickiness(node);\n  var startStickToPreviousCharacter = nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n  var endStickToPreviousCharacter = nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n  var deletingCnt = end - start;\n  var insertingCnt = textLength;\n  var commonLength = Math.min(deletingCnt, insertingCnt);\n  var nodeStart = node.start;\n  var startDone = false;\n  var nodeEnd = node.end;\n  var endDone = false;\n  if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n    // This edit encompasses the entire decoration range\n    // and the decoration has asked to become collapsed\n    node.start = start;\n    startDone = true;\n    node.end = start;\n    endDone = true;\n  }\n  {\n    var moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n      startDone = true;\n    }\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n      endDone = true;\n    }\n  }\n  if (commonLength > 0 && !forceMoveMarkers) {\n    var _moveSemantics = deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, _moveSemantics)) {\n      startDone = true;\n    }\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, _moveSemantics)) {\n      endDone = true;\n    }\n  }\n  {\n    var _moveSemantics2 = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, _moveSemantics2)) {\n      node.start = start + insertingCnt;\n      startDone = true;\n    }\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, _moveSemantics2)) {\n      node.end = start + insertingCnt;\n      endDone = true;\n    }\n  }\n  // Finish\n  var deltaColumn = insertingCnt - deletingCnt;\n  if (!startDone) {\n    node.start = Math.max(0, nodeStart + deltaColumn);\n  }\n  if (!endDone) {\n    node.end = Math.max(0, nodeEnd + deltaColumn);\n  }\n  if (node.start > node.end) {\n    node.end = node.start;\n  }\n}\nfunction searchForEditing(T, start, end) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  var node = T.root;\n  var delta = 0;\n  var nodeMaxEnd = 0;\n  var nodeStart = 0;\n  var nodeEnd = 0;\n  var result = [];\n  var resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n      node = node.parent;\n      continue;\n    }\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n      if (nodeMaxEnd < start) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    }\n    // handle current node\n    nodeStart = delta + node.start;\n    if (nodeStart > end) {\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n    nodeEnd = delta + node.end;\n    if (nodeEnd >= start) {\n      node.setCachedOffsets(nodeStart, nodeEnd, 0);\n      result[resultLen++] = node;\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  var node = T.root;\n  var delta = 0;\n  var nodeMaxEnd = 0;\n  var nodeStart = 0;\n  var editDelta = textLength - (end - start);\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n      recomputeMaxEnd(node);\n      node = node.parent;\n      continue;\n    }\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n      if (nodeMaxEnd < start) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    }\n    // handle current node\n    nodeStart = delta + node.start;\n    if (nodeStart > end) {\n      node.start += editDelta;\n      node.end += editDelta;\n      node.delta += editDelta;\n      if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n      }\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction _collectNodesFromOwner(T, ownerId) {\n  var node = T.root;\n  var result = [];\n  var resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      node = node.parent;\n      continue;\n    }\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n    // handle current node\n    if (node.ownerId === ownerId) {\n      result[resultLen++] = node;\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\nfunction _collectNodesPostOrder(T) {\n  var node = T.root;\n  var result = [];\n  var resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      node = node.parent;\n      continue;\n    }\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      node = node.right;\n      continue;\n    }\n    // handle current node\n    result[resultLen++] = node;\n    setNodeIsVisited(node, true);\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\nfunction _search(T, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n  var node = T.root;\n  var delta = 0;\n  var nodeStart = 0;\n  var nodeEnd = 0;\n  var result = [];\n  var resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n      node = node.parent;\n      continue;\n    }\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n    // handle current node\n    nodeStart = delta + node.start;\n    nodeEnd = delta + node.end;\n    node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    var include = true;\n    if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n      include = false;\n    }\n    if (filterOutValidation && getNodeIsForValidation(node)) {\n      include = false;\n    }\n    if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n      include = false;\n    }\n    if (include) {\n      result[resultLen++] = node;\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\nfunction _intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  var node = T.root;\n  var delta = 0;\n  var nodeMaxEnd = 0;\n  var nodeStart = 0;\n  var nodeEnd = 0;\n  var result = [];\n  var resultLen = 0;\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n      node = node.parent;\n      continue;\n    }\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n      if (nodeMaxEnd < intervalStart) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    }\n    // handle current node\n    nodeStart = delta + node.start;\n    if (nodeStart > intervalEnd) {\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n    nodeEnd = delta + node.end;\n    if (nodeEnd >= intervalStart) {\n      // There is overlap\n      node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n      var include = true;\n      if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n        include = false;\n      }\n      if (filterOutValidation && getNodeIsForValidation(node)) {\n        include = false;\n      }\n      if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n        include = false;\n      }\n      if (include) {\n        result[resultLen++] = node;\n      }\n    }\n    setNodeIsVisited(node, true);\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n  setNodeIsVisited(T.root, false);\n  return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n  if (T.root === SENTINEL) {\n    newNode.parent = SENTINEL;\n    newNode.left = SENTINEL;\n    newNode.right = SENTINEL;\n    setNodeColor(newNode, 0 /* NodeColor.Black */);\n    T.root = newNode;\n    return T.root;\n  }\n  treeInsert(T, newNode);\n  recomputeMaxEndWalkToRoot(newNode.parent);\n  // repair tree\n  var x = newNode;\n  while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n    if (x.parent === x.parent.parent.left) {\n      var y = x.parent.parent.right;\n      if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n        setNodeColor(x.parent, 0 /* NodeColor.Black */);\n        setNodeColor(y, 0 /* NodeColor.Black */);\n        setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n        x = x.parent.parent;\n      } else {\n        if (x === x.parent.right) {\n          x = x.parent;\n          leftRotate(T, x);\n        }\n        setNodeColor(x.parent, 0 /* NodeColor.Black */);\n        setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n        rightRotate(T, x.parent.parent);\n      }\n    } else {\n      var _y = x.parent.parent.left;\n      if (getNodeColor(_y) === 1 /* NodeColor.Red */) {\n        setNodeColor(x.parent, 0 /* NodeColor.Black */);\n        setNodeColor(_y, 0 /* NodeColor.Black */);\n        setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n        x = x.parent.parent;\n      } else {\n        if (x === x.parent.left) {\n          x = x.parent;\n          rightRotate(T, x);\n        }\n        setNodeColor(x.parent, 0 /* NodeColor.Black */);\n        setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n        leftRotate(T, x.parent.parent);\n      }\n    }\n  }\n  setNodeColor(T.root, 0 /* NodeColor.Black */);\n  return newNode;\n}\nfunction treeInsert(T, z) {\n  var delta = 0;\n  var x = T.root;\n  var zAbsoluteStart = z.start;\n  var zAbsoluteEnd = z.end;\n  while (true) {\n    var cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n    if (cmp < 0) {\n      // this node should be inserted to the left\n      // => it is not affected by the node's delta\n      if (x.left === SENTINEL) {\n        z.start -= delta;\n        z.end -= delta;\n        z.maxEnd -= delta;\n        x.left = z;\n        break;\n      } else {\n        x = x.left;\n      }\n    } else {\n      // this node should be inserted to the right\n      // => it is not affected by the node's delta\n      if (x.right === SENTINEL) {\n        z.start -= delta + x.delta;\n        z.end -= delta + x.delta;\n        z.maxEnd -= delta + x.delta;\n        x.right = z;\n        break;\n      } else {\n        delta += x.delta;\n        x = x.right;\n      }\n    }\n  }\n  z.parent = x;\n  z.left = SENTINEL;\n  z.right = SENTINEL;\n  setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n  var x;\n  var y;\n  // RB-DELETE except we don't swap z and y in case c)\n  // i.e. we always delete what's pointed at by z.\n  if (z.left === SENTINEL) {\n    x = z.right;\n    y = z;\n    // x's delta is no longer influenced by z's delta\n    x.delta += z.delta;\n    if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n      T.requestNormalizeDelta = true;\n    }\n    x.start += z.delta;\n    x.end += z.delta;\n  } else if (z.right === SENTINEL) {\n    x = z.left;\n    y = z;\n  } else {\n    y = leftest(z.right);\n    x = y.right;\n    // y's delta is no longer influenced by z's delta,\n    // but we don't want to walk the entire right-hand-side subtree of x.\n    // we therefore maintain z's delta in y, and adjust only x\n    x.start += y.delta;\n    x.end += y.delta;\n    x.delta += y.delta;\n    if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n      T.requestNormalizeDelta = true;\n    }\n    y.start += z.delta;\n    y.end += z.delta;\n    y.delta = z.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n      T.requestNormalizeDelta = true;\n    }\n  }\n  if (y === T.root) {\n    T.root = x;\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    z.detach();\n    resetSentinel();\n    recomputeMaxEnd(x);\n    T.root.parent = SENTINEL;\n    return;\n  }\n  var yWasRed = getNodeColor(y) === 1 /* NodeColor.Red */;\n  if (y === y.parent.left) {\n    y.parent.left = x;\n  } else {\n    y.parent.right = x;\n  }\n  if (y === z) {\n    x.parent = y.parent;\n  } else {\n    if (y.parent === z) {\n      x.parent = y;\n    } else {\n      x.parent = y.parent;\n    }\n    y.left = z.left;\n    y.right = z.right;\n    y.parent = z.parent;\n    setNodeColor(y, getNodeColor(z));\n    if (z === T.root) {\n      T.root = y;\n    } else {\n      if (z === z.parent.left) {\n        z.parent.left = y;\n      } else {\n        z.parent.right = y;\n      }\n    }\n    if (y.left !== SENTINEL) {\n      y.left.parent = y;\n    }\n    if (y.right !== SENTINEL) {\n      y.right.parent = y;\n    }\n  }\n  z.detach();\n  if (yWasRed) {\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n      recomputeMaxEndWalkToRoot(y);\n      recomputeMaxEndWalkToRoot(y.parent);\n    }\n    resetSentinel();\n    return;\n  }\n  recomputeMaxEndWalkToRoot(x);\n  recomputeMaxEndWalkToRoot(x.parent);\n  if (y !== z) {\n    recomputeMaxEndWalkToRoot(y);\n    recomputeMaxEndWalkToRoot(y.parent);\n  }\n  // RB-DELETE-FIXUP\n  var w;\n  while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n    if (x === x.parent.left) {\n      w = x.parent.right;\n      if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n        setNodeColor(w, 0 /* NodeColor.Black */);\n        setNodeColor(x.parent, 1 /* NodeColor.Red */);\n        leftRotate(T, x.parent);\n        w = x.parent.right;\n      }\n      if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n        setNodeColor(w, 1 /* NodeColor.Red */);\n        x = x.parent;\n      } else {\n        if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n          setNodeColor(w.left, 0 /* NodeColor.Black */);\n          setNodeColor(w, 1 /* NodeColor.Red */);\n          rightRotate(T, w);\n          w = x.parent.right;\n        }\n        setNodeColor(w, getNodeColor(x.parent));\n        setNodeColor(x.parent, 0 /* NodeColor.Black */);\n        setNodeColor(w.right, 0 /* NodeColor.Black */);\n        leftRotate(T, x.parent);\n        x = T.root;\n      }\n    } else {\n      w = x.parent.left;\n      if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n        setNodeColor(w, 0 /* NodeColor.Black */);\n        setNodeColor(x.parent, 1 /* NodeColor.Red */);\n        rightRotate(T, x.parent);\n        w = x.parent.left;\n      }\n      if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n        setNodeColor(w, 1 /* NodeColor.Red */);\n        x = x.parent;\n      } else {\n        if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n          setNodeColor(w.right, 0 /* NodeColor.Black */);\n          setNodeColor(w, 1 /* NodeColor.Red */);\n          leftRotate(T, w);\n          w = x.parent.left;\n        }\n        setNodeColor(w, getNodeColor(x.parent));\n        setNodeColor(x.parent, 0 /* NodeColor.Black */);\n        setNodeColor(w.left, 0 /* NodeColor.Black */);\n        rightRotate(T, x.parent);\n        x = T.root;\n      }\n    }\n  }\n  setNodeColor(x, 0 /* NodeColor.Black */);\n  resetSentinel();\n}\nfunction leftest(node) {\n  while (node.left !== SENTINEL) {\n    node = node.left;\n  }\n  return node;\n}\nfunction resetSentinel() {\n  SENTINEL.parent = SENTINEL;\n  SENTINEL.delta = 0; // optional\n  SENTINEL.start = 0; // optional\n  SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n  var y = x.right; // set y.\n  y.delta += x.delta; // y's delta is no longer influenced by x's delta\n  if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n    T.requestNormalizeDelta = true;\n  }\n  y.start += x.delta;\n  y.end += x.delta;\n  x.right = y.left; // turn y's left subtree into x's right subtree.\n  if (y.left !== SENTINEL) {\n    y.left.parent = x;\n  }\n  y.parent = x.parent; // link x's parent to y.\n  if (x.parent === SENTINEL) {\n    T.root = y;\n  } else if (x === x.parent.left) {\n    x.parent.left = y;\n  } else {\n    x.parent.right = y;\n  }\n  y.left = x; // put x on y's left.\n  x.parent = y;\n  recomputeMaxEnd(x);\n  recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n  var x = y.left;\n  y.delta -= x.delta;\n  if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n    T.requestNormalizeDelta = true;\n  }\n  y.start -= x.delta;\n  y.end -= x.delta;\n  y.left = x.right;\n  if (x.right !== SENTINEL) {\n    x.right.parent = y;\n  }\n  x.parent = y.parent;\n  if (y.parent === SENTINEL) {\n    T.root = x;\n  } else if (y === y.parent.right) {\n    y.parent.right = x;\n  } else {\n    y.parent.left = x;\n  }\n  x.right = y;\n  y.parent = x;\n  recomputeMaxEnd(y);\n  recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n  var maxEnd = node.end;\n  if (node.left !== SENTINEL) {\n    var leftMaxEnd = node.left.maxEnd;\n    if (leftMaxEnd > maxEnd) {\n      maxEnd = leftMaxEnd;\n    }\n  }\n  if (node.right !== SENTINEL) {\n    var rightMaxEnd = node.right.maxEnd + node.delta;\n    if (rightMaxEnd > maxEnd) {\n      maxEnd = rightMaxEnd;\n    }\n  }\n  return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n  node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n  while (node !== SENTINEL) {\n    var maxEnd = computeMaxEnd(node);\n    if (node.maxEnd === maxEnd) {\n      // no need to go further\n      return;\n    }\n    node.maxEnd = maxEnd;\n    node = node.parent;\n  }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n  if (aStart === bStart) {\n    return aEnd - bEnd;\n  }\n  return aStart - bStart;\n}\n//#endregion","map":{"version":3,"names":["getNodeColor","node","metadata","setNodeColor","color","getNodeIsVisited","setNodeIsVisited","value","getNodeIsForValidation","setNodeIsForValidation","getNodeIsInGlyphMargin","setNodeIsInGlyphMargin","getNodeStickiness","_setNodeStickiness","stickiness","getCollapseOnReplaceEdit","setCollapseOnReplaceEdit","IntervalNode","id","start","end","_classCallCheck","parent","left","right","delta","maxEnd","ownerId","options","cachedVersionId","cachedAbsoluteStart","cachedAbsoluteEnd","range","_createClass","key","reset","versionId","setOptions","className","glyphMarginClassName","collapseOnReplaceEdit","setCachedOffsets","absoluteStart","absoluteEnd","detach","SENTINEL","IntervalTree","root","requestNormalizeDelta","intervalSearch","filterOwnerId","filterOutValidation","onlyMarginDecorations","search","collectNodesFromOwner","collectNodesPostOrder","insert","rbTreeInsert","_normalizeDeltaIfNecessary","_delete","rbTreeDelete","resolveNode","initialNode","nodeStart","nodeEnd","acceptReplace","offset","length","textLength","forceMoveMarkers","nodesOfInterest","searchForEditing","i","len","noOverlapReplace","nodeAcceptEdit","normalizeDelta","T","recomputeMaxEnd","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","Math","min","startDone","endDone","deltaColumn","max","nodeMaxEnd","result","resultLen","editDelta","include","intervalStart","intervalEnd","newNode","treeInsert","recomputeMaxEndWalkToRoot","x","y","leftRotate","rightRotate","z","zAbsoluteStart","zAbsoluteEnd","cmp","intervalCompare","leftest","resetSentinel","yWasRed","w","computeMaxEnd","leftMaxEnd","rightMaxEnd","aStart","aEnd","bStart","bEnd"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n    return ((node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* Constants.ColorMaskInverse */) | (color << 0 /* Constants.ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* Constants.IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* Constants.IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */));\n}\nfunction getNodeIsInGlyphMargin(node) {\n    return ((node.metadata & 64 /* Constants.IsMarginMask */) >>> 6 /* Constants.IsMarginOffset */) === 1;\n}\nfunction setNodeIsInGlyphMargin(node, value) {\n    node.metadata = ((node.metadata & 191 /* Constants.IsMarginMaskInverse */) | ((value ? 1 : 0) << 6 /* Constants.IsMarginOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 231 /* Constants.StickinessMaskInverse */) | (stickiness << 3 /* Constants.StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));\n}\nexport class IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* NodeColor.Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        setNodeIsInGlyphMargin(this, false);\n        _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        const className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */\n            || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */));\n        setNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);\n        _setNodeStickiness(this, this.options.stickiness);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nexport class IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : (deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* NodeColor.Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* NodeColor.Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* NodeColor.Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (getNodeColor(y) === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.left, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.right, 0 /* NodeColor.Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.right, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.left, 0 /* NodeColor.Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA,OAAO,SAASA,YAAYA,CAACC,IAAI,EAAE;EAC/B,OAAQ,CAACA,IAAI,CAACC,QAAQ,GAAG,CAAC,CAAC,+BAA+B,CAAC,CAAC;AAChE;AACA,SAASC,YAAYA,CAACF,IAAI,EAAEG,KAAK,EAAE;EAC/BH,IAAI,CAACC,QAAQ,GAAKD,IAAI,CAACC,QAAQ,GAAG,GAAG,CAAC,mCAAqCE,KAAK,IAAI,CAAC,CAAC,2BAA6B;AACvH;AACA,SAASC,gBAAgBA,CAACJ,IAAI,EAAE;EAC5B,OAAQ,CAACA,IAAI,CAACC,QAAQ,GAAG,CAAC,CAAC,mCAAmC,CAAC,CAAC,oCAAqC,CAAC;AAC1G;AACA,SAASI,gBAAgBA,CAACL,IAAI,EAAEM,KAAK,EAAE;EACnCN,IAAI,CAACC,QAAQ,GAAKD,IAAI,CAACC,QAAQ,GAAG,GAAG,CAAC,uCAAyC,CAACK,KAAK,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,+BAAiC;AACzI;AACA,SAASC,sBAAsBA,CAACP,IAAI,EAAE;EAClC,OAAQ,CAACA,IAAI,CAACC,QAAQ,GAAG,CAAC,CAAC,yCAAyC,CAAC,CAAC,0CAA2C,CAAC;AACtH;AACA,SAASO,sBAAsBA,CAACR,IAAI,EAAEM,KAAK,EAAE;EACzCN,IAAI,CAACC,QAAQ,GAAKD,IAAI,CAACC,QAAQ,GAAG,GAAG,CAAC,6CAA+C,CAACK,KAAK,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,qCAAuC;AACrJ;AACA,SAASG,sBAAsBA,CAACT,IAAI,EAAE;EAClC,OAAQ,CAACA,IAAI,CAACC,QAAQ,GAAG,EAAE,CAAC,kCAAkC,CAAC,CAAC,mCAAoC,CAAC;AACzG;AACA,SAASS,sBAAsBA,CAACV,IAAI,EAAEM,KAAK,EAAE;EACzCN,IAAI,CAACC,QAAQ,GAAKD,IAAI,CAACC,QAAQ,GAAG,GAAG,CAAC,sCAAwC,CAACK,KAAK,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,8BAAgC;AACvI;AACA,SAASK,iBAAiBA,CAACX,IAAI,EAAE;EAC7B,OAAQ,CAACA,IAAI,CAACC,QAAQ,GAAG,EAAE,CAAC,oCAAoC,CAAC,CAAC;AACtE;AACA,SAASW,kBAAkBA,CAACZ,IAAI,EAAEa,UAAU,EAAE;EAC1Cb,IAAI,CAACC,QAAQ,GAAKD,IAAI,CAACC,QAAQ,GAAG,GAAG,CAAC,wCAA0CY,UAAU,IAAI,CAAC,CAAC,gCAAkC;AACtI;AACA,SAASC,wBAAwBA,CAACd,IAAI,EAAE;EACpC,OAAQ,CAACA,IAAI,CAACC,QAAQ,GAAG,EAAE,CAAC,+CAA+C,CAAC,CAAC,gDAAiD,CAAC;AACnI;AACA,SAASc,wBAAwBA,CAACf,IAAI,EAAEM,KAAK,EAAE;EAC3CN,IAAI,CAACC,QAAQ,GAAKD,IAAI,CAACC,QAAQ,GAAG,GAAG,CAAC,mDAAqD,CAACK,KAAK,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,2CAA6C;AACjK;AACA,WAAaU,YAAY;EACrB,SAAAA,aAAYC,EAAE,EAAEC,KAAK,EAAEC,GAAG,EAAE;IAAAC,eAAA,OAAAJ,YAAA;IACxB,IAAI,CAACf,QAAQ,GAAG,CAAC;IACjB,IAAI,CAACoB,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,IAAI,GAAG,IAAI;IAChB,IAAI,CAACC,KAAK,GAAG,IAAI;IACjBrB,YAAY,CAAC,IAAI,EAAE,CAAC,CAAC,mBAAmB,CAAC;IACzC,IAAI,CAACgB,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,GAAG,GAAGA,GAAG;IACd;IACA,IAAI,CAACK,KAAK,GAAG,CAAC;IACd,IAAI,CAACC,MAAM,GAAGN,GAAG;IACjB,IAAI,CAACF,EAAE,GAAGA,EAAE;IACZ,IAAI,CAACS,OAAO,GAAG,CAAC;IAChB,IAAI,CAACC,OAAO,GAAG,IAAI;IACnBnB,sBAAsB,CAAC,IAAI,EAAE,KAAK,CAAC;IACnCE,sBAAsB,CAAC,IAAI,EAAE,KAAK,CAAC;IACnCE,kBAAkB,CAAC,IAAI,EAAE,CAAC,CAAC,wDAAwD,CAAC;IACpFG,wBAAwB,CAAC,IAAI,EAAE,KAAK,CAAC;IACrC,IAAI,CAACa,eAAe,GAAG,CAAC;IACxB,IAAI,CAACC,mBAAmB,GAAGX,KAAK;IAChC,IAAI,CAACY,iBAAiB,GAAGX,GAAG;IAC5B,IAAI,CAACY,KAAK,GAAG,IAAI;IACjB1B,gBAAgB,CAAC,IAAI,EAAE,KAAK,CAAC;EACjC;EAAC,OAAA2B,YAAA,CAAAhB,YAAA;IAAAiB,GAAA;IAAA3B,KAAA,EACD,SAAA4B,MAAMC,SAAS,EAAEjB,KAAK,EAAEC,GAAG,EAAEY,KAAK,EAAE;MAChC,IAAI,CAACb,KAAK,GAAGA,KAAK;MAClB,IAAI,CAACC,GAAG,GAAGA,GAAG;MACd,IAAI,CAACM,MAAM,GAAGN,GAAG;MACjB,IAAI,CAACS,eAAe,GAAGO,SAAS;MAChC,IAAI,CAACN,mBAAmB,GAAGX,KAAK;MAChC,IAAI,CAACY,iBAAiB,GAAGX,GAAG;MAC5B,IAAI,CAACY,KAAK,GAAGA,KAAK;IACtB;EAAC;IAAAE,GAAA;IAAA3B,KAAA,EACD,SAAA8B,WAAWT,OAAO,EAAE;MAChB,IAAI,CAACA,OAAO,GAAGA,OAAO;MACtB,IAAMU,SAAS,GAAG,IAAI,CAACV,OAAO,CAACU,SAAS;MACxC7B,sBAAsB,CAAC,IAAI,EAAG6B,SAAS,KAAK,gBAAgB,CAAC,yCACtDA,SAAS,KAAK,kBAAkB,CAAC,2CACjCA,SAAS,KAAK,eAAe,CAAC,oCAAqC,CAAC;MAC3E3B,sBAAsB,CAAC,IAAI,EAAE,IAAI,CAACiB,OAAO,CAACW,oBAAoB,KAAK,IAAI,CAAC;MACxE1B,kBAAkB,CAAC,IAAI,EAAE,IAAI,CAACe,OAAO,CAACd,UAAU,CAAC;MACjDE,wBAAwB,CAAC,IAAI,EAAE,IAAI,CAACY,OAAO,CAACY,qBAAqB,CAAC;IACtE;EAAC;IAAAN,GAAA;IAAA3B,KAAA,EACD,SAAAkC,iBAAiBC,aAAa,EAAEC,WAAW,EAAEd,eAAe,EAAE;MAC1D,IAAI,IAAI,CAACA,eAAe,KAAKA,eAAe,EAAE;QAC1C,IAAI,CAACG,KAAK,GAAG,IAAI;MACrB;MACA,IAAI,CAACH,eAAe,GAAGA,eAAe;MACtC,IAAI,CAACC,mBAAmB,GAAGY,aAAa;MACxC,IAAI,CAACX,iBAAiB,GAAGY,WAAW;IACxC;EAAC;IAAAT,GAAA;IAAA3B,KAAA,EACD,SAAAqC,OAAA,EAAS;MACL,IAAI,CAACtB,MAAM,GAAG,IAAI;MAClB,IAAI,CAACC,IAAI,GAAG,IAAI;MAChB,IAAI,CAACC,KAAK,GAAG,IAAI;IACrB;EAAC;AAAA;AAEL,OAAO,IAAMqB,QAAQ,GAAG,IAAI5B,YAAY,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC;AACpD4B,QAAQ,CAACvB,MAAM,GAAGuB,QAAQ;AAC1BA,QAAQ,CAACtB,IAAI,GAAGsB,QAAQ;AACxBA,QAAQ,CAACrB,KAAK,GAAGqB,QAAQ;AACzB1C,YAAY,CAAC0C,QAAQ,EAAE,CAAC,CAAC,qBAAqB,CAAC;AAC/C,WAAaC,YAAY;EACrB,SAAAA,aAAA,EAAc;IAAAzB,eAAA,OAAAyB,YAAA;IACV,IAAI,CAACC,IAAI,GAAGF,QAAQ;IACpB,IAAI,CAACG,qBAAqB,GAAG,KAAK;EACtC;EAAC,OAAAf,YAAA,CAAAa,YAAA;IAAAZ,GAAA;IAAA3B,KAAA,EACD,SAAA0C,eAAe9B,KAAK,EAAEC,GAAG,EAAE8B,aAAa,EAAEC,mBAAmB,EAAEtB,eAAe,EAAEuB,qBAAqB,EAAE;MACnG,IAAI,IAAI,CAACL,IAAI,KAAKF,QAAQ,EAAE;QACxB,OAAO,EAAE;MACb;MACA,OAAOI,eAAc,CAAC,IAAI,EAAE9B,KAAK,EAAEC,GAAG,EAAE8B,aAAa,EAAEC,mBAAmB,EAAEtB,eAAe,EAAEuB,qBAAqB,CAAC;IACvH;EAAC;IAAAlB,GAAA;IAAA3B,KAAA,EACD,SAAA8C,OAAOH,aAAa,EAAEC,mBAAmB,EAAEtB,eAAe,EAAEuB,qBAAqB,EAAE;MAC/E,IAAI,IAAI,CAACL,IAAI,KAAKF,QAAQ,EAAE;QACxB,OAAO,EAAE;MACb;MACA,OAAOQ,OAAM,CAAC,IAAI,EAAEH,aAAa,EAAEC,mBAAmB,EAAEtB,eAAe,EAAEuB,qBAAqB,CAAC;IACnG;IACA;AACJ;AACA;EAFI;IAAAlB,GAAA;IAAA3B,KAAA,EAGA,SAAA+C,sBAAsB3B,OAAO,EAAE;MAC3B,OAAO2B,sBAAqB,CAAC,IAAI,EAAE3B,OAAO,CAAC;IAC/C;IACA;AACJ;AACA;EAFI;IAAAO,GAAA;IAAA3B,KAAA,EAGA,SAAAgD,sBAAA,EAAwB;MACpB,OAAOA,sBAAqB,CAAC,IAAI,CAAC;IACtC;EAAC;IAAArB,GAAA;IAAA3B,KAAA,EACD,SAAAiD,OAAOvD,IAAI,EAAE;MACTwD,YAAY,CAAC,IAAI,EAAExD,IAAI,CAAC;MACxB,IAAI,CAACyD,0BAA0B,CAAC,CAAC;IACrC;EAAC;IAAAxB,GAAA;IAAA3B,KAAA,EACD,SAAAoD,QAAO1D,IAAI,EAAE;MACT2D,YAAY,CAAC,IAAI,EAAE3D,IAAI,CAAC;MACxB,IAAI,CAACyD,0BAA0B,CAAC,CAAC;IACrC;EAAC;IAAAxB,GAAA;IAAA3B,KAAA,EACD,SAAAsD,YAAY5D,IAAI,EAAE4B,eAAe,EAAE;MAC/B,IAAMiC,WAAW,GAAG7D,IAAI;MACxB,IAAIwB,KAAK,GAAG,CAAC;MACb,OAAOxB,IAAI,KAAK,IAAI,CAAC8C,IAAI,EAAE;QACvB,IAAI9C,IAAI,KAAKA,IAAI,CAACqB,MAAM,CAACE,KAAK,EAAE;UAC5BC,KAAK,IAAIxB,IAAI,CAACqB,MAAM,CAACG,KAAK;QAC9B;QACAxB,IAAI,GAAGA,IAAI,CAACqB,MAAM;MACtB;MACA,IAAMyC,SAAS,GAAGD,WAAW,CAAC3C,KAAK,GAAGM,KAAK;MAC3C,IAAMuC,OAAO,GAAGF,WAAW,CAAC1C,GAAG,GAAGK,KAAK;MACvCqC,WAAW,CAACrB,gBAAgB,CAACsB,SAAS,EAAEC,OAAO,EAAEnC,eAAe,CAAC;IACrE;EAAC;IAAAK,GAAA;IAAA3B,KAAA,EACD,SAAA0D,cAAcC,MAAM,EAAEC,MAAM,EAAEC,UAAU,EAAEC,gBAAgB,EAAE;MACxD;MACA;MACA,IAAMC,eAAe,GAAGC,gBAAgB,CAAC,IAAI,EAAEL,MAAM,EAAEA,MAAM,GAAGC,MAAM,CAAC;MACvE;MACA,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,eAAe,CAACH,MAAM,EAAEK,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QACxD,IAAMvE,IAAI,GAAGqE,eAAe,CAACE,CAAC,CAAC;QAC/BZ,YAAY,CAAC,IAAI,EAAE3D,IAAI,CAAC;MAC5B;MACA,IAAI,CAACyD,0BAA0B,CAAC,CAAC;MACjC;MACAgB,gBAAgB,CAAC,IAAI,EAAER,MAAM,EAAEA,MAAM,GAAGC,MAAM,EAAEC,UAAU,CAAC;MAC3D,IAAI,CAACV,0BAA0B,CAAC,CAAC;MACjC;MACA,KAAK,IAAIc,EAAC,GAAG,CAAC,EAAEC,IAAG,GAAGH,eAAe,CAACH,MAAM,EAAEK,EAAC,GAAGC,IAAG,EAAED,EAAC,EAAE,EAAE;QACxD,IAAMvE,KAAI,GAAGqE,eAAe,CAACE,EAAC,CAAC;QAC/BvE,KAAI,CAACkB,KAAK,GAAGlB,KAAI,CAAC6B,mBAAmB;QACrC7B,KAAI,CAACmB,GAAG,GAAGnB,KAAI,CAAC8B,iBAAiB;QACjC4C,cAAc,CAAC1E,KAAI,EAAEiE,MAAM,EAAGA,MAAM,GAAGC,MAAM,EAAGC,UAAU,EAAEC,gBAAgB,CAAC;QAC7EpE,KAAI,CAACyB,MAAM,GAAGzB,KAAI,CAACmB,GAAG;QACtBqC,YAAY,CAAC,IAAI,EAAExD,KAAI,CAAC;MAC5B;MACA,IAAI,CAACyD,0BAA0B,CAAC,CAAC;IACrC;EAAC;IAAAxB,GAAA;IAAA3B,KAAA,EACD,SAAAmD,2BAAA,EAA6B;MACzB,IAAI,CAAC,IAAI,CAACV,qBAAqB,EAAE;QAC7B;MACJ;MACA,IAAI,CAACA,qBAAqB,GAAG,KAAK;MAClC4B,cAAc,CAAC,IAAI,CAAC;IACxB;EAAC;AAAA;AAEL;AACA,SAASA,cAAcA,CAACC,CAAC,EAAE;EACvB,IAAI5E,IAAI,GAAG4E,CAAC,CAAC9B,IAAI;EACjB,IAAItB,KAAK,GAAG,CAAC;EACb,OAAOxB,IAAI,KAAK4C,QAAQ,EAAE;IACtB,IAAI5C,IAAI,CAACsB,IAAI,KAAKsB,QAAQ,IAAI,CAACxC,gBAAgB,CAACJ,IAAI,CAACsB,IAAI,CAAC,EAAE;MACxD;MACAtB,IAAI,GAAGA,IAAI,CAACsB,IAAI;MAChB;IACJ;IACA,IAAItB,IAAI,CAACuB,KAAK,KAAKqB,QAAQ,IAAI,CAACxC,gBAAgB,CAACJ,IAAI,CAACuB,KAAK,CAAC,EAAE;MAC1D;MACAC,KAAK,IAAIxB,IAAI,CAACwB,KAAK;MACnBxB,IAAI,GAAGA,IAAI,CAACuB,KAAK;MACjB;IACJ;IACA;IACAvB,IAAI,CAACkB,KAAK,GAAGM,KAAK,GAAGxB,IAAI,CAACkB,KAAK;IAC/BlB,IAAI,CAACmB,GAAG,GAAGK,KAAK,GAAGxB,IAAI,CAACmB,GAAG;IAC3BnB,IAAI,CAACwB,KAAK,GAAG,CAAC;IACdqD,eAAe,CAAC7E,IAAI,CAAC;IACrBK,gBAAgB,CAACL,IAAI,EAAE,IAAI,CAAC;IAC5B;IACAK,gBAAgB,CAACL,IAAI,CAACsB,IAAI,EAAE,KAAK,CAAC;IAClCjB,gBAAgB,CAACL,IAAI,CAACuB,KAAK,EAAE,KAAK,CAAC;IACnC,IAAIvB,IAAI,KAAKA,IAAI,CAACqB,MAAM,CAACE,KAAK,EAAE;MAC5BC,KAAK,IAAIxB,IAAI,CAACqB,MAAM,CAACG,KAAK;IAC9B;IACAxB,IAAI,GAAGA,IAAI,CAACqB,MAAM;EACtB;EACAhB,gBAAgB,CAACuE,CAAC,CAAC9B,IAAI,EAAE,KAAK,CAAC;AACnC;AACA,SAASgC,wBAAwBA,CAACC,YAAY,EAAEC,8BAA8B,EAAEC,WAAW,EAAEC,aAAa,EAAE;EACxG,IAAIH,YAAY,GAAGE,WAAW,EAAE;IAC5B,OAAO,IAAI;EACf;EACA,IAAIF,YAAY,GAAGE,WAAW,EAAE;IAC5B,OAAO,KAAK;EAChB;EACA,IAAIC,aAAa,KAAK,CAAC,CAAC,qCAAqC;IACzD,OAAO,KAAK;EAChB;EACA,IAAIA,aAAa,KAAK,CAAC,CAAC,qCAAqC;IACzD,OAAO,IAAI;EACf;EACA,OAAOF,8BAA8B;AACzC;AACA;AACA;AACA;AACA;AACA,OAAO,SAASN,cAAcA,CAAC1E,IAAI,EAAEkB,KAAK,EAAEC,GAAG,EAAEgD,UAAU,EAAEC,gBAAgB,EAAE;EAC3E,IAAMe,cAAc,GAAGxE,iBAAiB,CAACX,IAAI,CAAC;EAC9C,IAAMoF,6BAA6B,GAAID,cAAc,KAAK,CAAC,CAAC,6DACrDA,cAAc,KAAK,CAAC,CAAC,sDAAuD;EACnF,IAAME,2BAA2B,GAAIF,cAAc,KAAK,CAAC,CAAC,4DACnDA,cAAc,KAAK,CAAC,CAAC,sDAAuD;EACnF,IAAMG,WAAW,GAAInE,GAAG,GAAGD,KAAM;EACjC,IAAMqE,YAAY,GAAGpB,UAAU;EAC/B,IAAMqB,YAAY,GAAGC,IAAI,CAACC,GAAG,CAACJ,WAAW,EAAEC,YAAY,CAAC;EACxD,IAAMzB,SAAS,GAAG9D,IAAI,CAACkB,KAAK;EAC5B,IAAIyE,SAAS,GAAG,KAAK;EACrB,IAAM5B,OAAO,GAAG/D,IAAI,CAACmB,GAAG;EACxB,IAAIyE,OAAO,GAAG,KAAK;EACnB,IAAI1E,KAAK,IAAI4C,SAAS,IAAIC,OAAO,IAAI5C,GAAG,IAAIL,wBAAwB,CAACd,IAAI,CAAC,EAAE;IACxE;IACA;IACAA,IAAI,CAACkB,KAAK,GAAGA,KAAK;IAClByE,SAAS,GAAG,IAAI;IAChB3F,IAAI,CAACmB,GAAG,GAAGD,KAAK;IAChB0E,OAAO,GAAG,IAAI;EAClB;EACA;IACI,IAAMV,aAAa,GAAGd,gBAAgB,GAAG,CAAC,CAAC,sCAAuCkB,WAAW,GAAG,CAAC,GAAG,CAAC,CAAC,sCAAsC,CAAC,CAAC,uCAAwC;IACtL,IAAI,CAACK,SAAS,IAAIb,wBAAwB,CAAChB,SAAS,EAAEsB,6BAA6B,EAAElE,KAAK,EAAEgE,aAAa,CAAC,EAAE;MACxGS,SAAS,GAAG,IAAI;IACpB;IACA,IAAI,CAACC,OAAO,IAAId,wBAAwB,CAACf,OAAO,EAAEsB,2BAA2B,EAAEnE,KAAK,EAAEgE,aAAa,CAAC,EAAE;MAClGU,OAAO,GAAG,IAAI;IAClB;EACJ;EACA,IAAIJ,YAAY,GAAG,CAAC,IAAI,CAACpB,gBAAgB,EAAE;IACvC,IAAMc,cAAa,GAAII,WAAW,GAAGC,YAAY,GAAG,CAAC,CAAC,sCAAsC,CAAC,CAAC,uCAAwC;IACtI,IAAI,CAACI,SAAS,IAAIb,wBAAwB,CAAChB,SAAS,EAAEsB,6BAA6B,EAAElE,KAAK,GAAGsE,YAAY,EAAEN,cAAa,CAAC,EAAE;MACvHS,SAAS,GAAG,IAAI;IACpB;IACA,IAAI,CAACC,OAAO,IAAId,wBAAwB,CAACf,OAAO,EAAEsB,2BAA2B,EAAEnE,KAAK,GAAGsE,YAAY,EAAEN,cAAa,CAAC,EAAE;MACjHU,OAAO,GAAG,IAAI;IAClB;EACJ;EACA;IACI,IAAMV,eAAa,GAAGd,gBAAgB,GAAG,CAAC,CAAC,sCAAsC,CAAC,CAAC;IACnF,IAAI,CAACuB,SAAS,IAAIb,wBAAwB,CAAChB,SAAS,EAAEsB,6BAA6B,EAAEjE,GAAG,EAAE+D,eAAa,CAAC,EAAE;MACtGlF,IAAI,CAACkB,KAAK,GAAGA,KAAK,GAAGqE,YAAY;MACjCI,SAAS,GAAG,IAAI;IACpB;IACA,IAAI,CAACC,OAAO,IAAId,wBAAwB,CAACf,OAAO,EAAEsB,2BAA2B,EAAElE,GAAG,EAAE+D,eAAa,CAAC,EAAE;MAChGlF,IAAI,CAACmB,GAAG,GAAGD,KAAK,GAAGqE,YAAY;MAC/BK,OAAO,GAAG,IAAI;IAClB;EACJ;EACA;EACA,IAAMC,WAAW,GAAIN,YAAY,GAAGD,WAAY;EAChD,IAAI,CAACK,SAAS,EAAE;IACZ3F,IAAI,CAACkB,KAAK,GAAGuE,IAAI,CAACK,GAAG,CAAC,CAAC,EAAEhC,SAAS,GAAG+B,WAAW,CAAC;EACrD;EACA,IAAI,CAACD,OAAO,EAAE;IACV5F,IAAI,CAACmB,GAAG,GAAGsE,IAAI,CAACK,GAAG,CAAC,CAAC,EAAE/B,OAAO,GAAG8B,WAAW,CAAC;EACjD;EACA,IAAI7F,IAAI,CAACkB,KAAK,GAAGlB,IAAI,CAACmB,GAAG,EAAE;IACvBnB,IAAI,CAACmB,GAAG,GAAGnB,IAAI,CAACkB,KAAK;EACzB;AACJ;AACA,SAASoD,gBAAgBA,CAACM,CAAC,EAAE1D,KAAK,EAAEC,GAAG,EAAE;EACrC;EACA;EACA;EACA;EACA;EACA;EACA,IAAInB,IAAI,GAAG4E,CAAC,CAAC9B,IAAI;EACjB,IAAItB,KAAK,GAAG,CAAC;EACb,IAAIuE,UAAU,GAAG,CAAC;EAClB,IAAIjC,SAAS,GAAG,CAAC;EACjB,IAAIC,OAAO,GAAG,CAAC;EACf,IAAMiC,MAAM,GAAG,EAAE;EACjB,IAAIC,SAAS,GAAG,CAAC;EACjB,OAAOjG,IAAI,KAAK4C,QAAQ,EAAE;IACtB,IAAIxC,gBAAgB,CAACJ,IAAI,CAAC,EAAE;MACxB;MACAK,gBAAgB,CAACL,IAAI,CAACsB,IAAI,EAAE,KAAK,CAAC;MAClCjB,gBAAgB,CAACL,IAAI,CAACuB,KAAK,EAAE,KAAK,CAAC;MACnC,IAAIvB,IAAI,KAAKA,IAAI,CAACqB,MAAM,CAACE,KAAK,EAAE;QAC5BC,KAAK,IAAIxB,IAAI,CAACqB,MAAM,CAACG,KAAK;MAC9B;MACAxB,IAAI,GAAGA,IAAI,CAACqB,MAAM;MAClB;IACJ;IACA,IAAI,CAACjB,gBAAgB,CAACJ,IAAI,CAACsB,IAAI,CAAC,EAAE;MAC9B;MACAyE,UAAU,GAAGvE,KAAK,GAAGxB,IAAI,CAACyB,MAAM;MAChC,IAAIsE,UAAU,GAAG7E,KAAK,EAAE;QACpB;QACA;QACAb,gBAAgB,CAACL,IAAI,EAAE,IAAI,CAAC;QAC5B;MACJ;MACA,IAAIA,IAAI,CAACsB,IAAI,KAAKsB,QAAQ,EAAE;QACxB;QACA5C,IAAI,GAAGA,IAAI,CAACsB,IAAI;QAChB;MACJ;IACJ;IACA;IACAwC,SAAS,GAAGtC,KAAK,GAAGxB,IAAI,CAACkB,KAAK;IAC9B,IAAI4C,SAAS,GAAG3C,GAAG,EAAE;MACjB;MACA;MACAd,gBAAgB,CAACL,IAAI,EAAE,IAAI,CAAC;MAC5B;IACJ;IACA+D,OAAO,GAAGvC,KAAK,GAAGxB,IAAI,CAACmB,GAAG;IAC1B,IAAI4C,OAAO,IAAI7C,KAAK,EAAE;MAClBlB,IAAI,CAACwC,gBAAgB,CAACsB,SAAS,EAAEC,OAAO,EAAE,CAAC,CAAC;MAC5CiC,MAAM,CAACC,SAAS,EAAE,CAAC,GAAGjG,IAAI;IAC9B;IACAK,gBAAgB,CAACL,IAAI,EAAE,IAAI,CAAC;IAC5B,IAAIA,IAAI,CAACuB,KAAK,KAAKqB,QAAQ,IAAI,CAACxC,gBAAgB,CAACJ,IAAI,CAACuB,KAAK,CAAC,EAAE;MAC1D;MACAC,KAAK,IAAIxB,IAAI,CAACwB,KAAK;MACnBxB,IAAI,GAAGA,IAAI,CAACuB,KAAK;MACjB;IACJ;EACJ;EACAlB,gBAAgB,CAACuE,CAAC,CAAC9B,IAAI,EAAE,KAAK,CAAC;EAC/B,OAAOkD,MAAM;AACjB;AACA,SAASvB,gBAAgBA,CAACG,CAAC,EAAE1D,KAAK,EAAEC,GAAG,EAAEgD,UAAU,EAAE;EACjD;EACA;EACA;EACA;EACA;EACA;EACA,IAAInE,IAAI,GAAG4E,CAAC,CAAC9B,IAAI;EACjB,IAAItB,KAAK,GAAG,CAAC;EACb,IAAIuE,UAAU,GAAG,CAAC;EAClB,IAAIjC,SAAS,GAAG,CAAC;EACjB,IAAMoC,SAAS,GAAI/B,UAAU,IAAIhD,GAAG,GAAGD,KAAK,CAAE;EAC9C,OAAOlB,IAAI,KAAK4C,QAAQ,EAAE;IACtB,IAAIxC,gBAAgB,CAACJ,IAAI,CAAC,EAAE;MACxB;MACAK,gBAAgB,CAACL,IAAI,CAACsB,IAAI,EAAE,KAAK,CAAC;MAClCjB,gBAAgB,CAACL,IAAI,CAACuB,KAAK,EAAE,KAAK,CAAC;MACnC,IAAIvB,IAAI,KAAKA,IAAI,CAACqB,MAAM,CAACE,KAAK,EAAE;QAC5BC,KAAK,IAAIxB,IAAI,CAACqB,MAAM,CAACG,KAAK;MAC9B;MACAqD,eAAe,CAAC7E,IAAI,CAAC;MACrBA,IAAI,GAAGA,IAAI,CAACqB,MAAM;MAClB;IACJ;IACA,IAAI,CAACjB,gBAAgB,CAACJ,IAAI,CAACsB,IAAI,CAAC,EAAE;MAC9B;MACAyE,UAAU,GAAGvE,KAAK,GAAGxB,IAAI,CAACyB,MAAM;MAChC,IAAIsE,UAAU,GAAG7E,KAAK,EAAE;QACpB;QACA;QACAb,gBAAgB,CAACL,IAAI,EAAE,IAAI,CAAC;QAC5B;MACJ;MACA,IAAIA,IAAI,CAACsB,IAAI,KAAKsB,QAAQ,EAAE;QACxB;QACA5C,IAAI,GAAGA,IAAI,CAACsB,IAAI;QAChB;MACJ;IACJ;IACA;IACAwC,SAAS,GAAGtC,KAAK,GAAGxB,IAAI,CAACkB,KAAK;IAC9B,IAAI4C,SAAS,GAAG3C,GAAG,EAAE;MACjBnB,IAAI,CAACkB,KAAK,IAAIgF,SAAS;MACvBlG,IAAI,CAACmB,GAAG,IAAI+E,SAAS;MACrBlG,IAAI,CAACwB,KAAK,IAAI0E,SAAS;MACvB,IAAIlG,IAAI,CAACwB,KAAK,GAAG,CAAC,UAAU,CAAC,kCAAkCxB,IAAI,CAACwB,KAAK,GAAG,UAAU,CAAC,gCAAgC;QACnHoD,CAAC,CAAC7B,qBAAqB,GAAG,IAAI;MAClC;MACA;MACA;MACA1C,gBAAgB,CAACL,IAAI,EAAE,IAAI,CAAC;MAC5B;IACJ;IACAK,gBAAgB,CAACL,IAAI,EAAE,IAAI,CAAC;IAC5B,IAAIA,IAAI,CAACuB,KAAK,KAAKqB,QAAQ,IAAI,CAACxC,gBAAgB,CAACJ,IAAI,CAACuB,KAAK,CAAC,EAAE;MAC1D;MACAC,KAAK,IAAIxB,IAAI,CAACwB,KAAK;MACnBxB,IAAI,GAAGA,IAAI,CAACuB,KAAK;MACjB;IACJ;EACJ;EACAlB,gBAAgB,CAACuE,CAAC,CAAC9B,IAAI,EAAE,KAAK,CAAC;AACnC;AACA;AACA;AACA,SAASO,sBAAqBA,CAACuB,CAAC,EAAElD,OAAO,EAAE;EACvC,IAAI1B,IAAI,GAAG4E,CAAC,CAAC9B,IAAI;EACjB,IAAMkD,MAAM,GAAG,EAAE;EACjB,IAAIC,SAAS,GAAG,CAAC;EACjB,OAAOjG,IAAI,KAAK4C,QAAQ,EAAE;IACtB,IAAIxC,gBAAgB,CAACJ,IAAI,CAAC,EAAE;MACxB;MACAK,gBAAgB,CAACL,IAAI,CAACsB,IAAI,EAAE,KAAK,CAAC;MAClCjB,gBAAgB,CAACL,IAAI,CAACuB,KAAK,EAAE,KAAK,CAAC;MACnCvB,IAAI,GAAGA,IAAI,CAACqB,MAAM;MAClB;IACJ;IACA,IAAIrB,IAAI,CAACsB,IAAI,KAAKsB,QAAQ,IAAI,CAACxC,gBAAgB,CAACJ,IAAI,CAACsB,IAAI,CAAC,EAAE;MACxD;MACAtB,IAAI,GAAGA,IAAI,CAACsB,IAAI;MAChB;IACJ;IACA;IACA,IAAItB,IAAI,CAAC0B,OAAO,KAAKA,OAAO,EAAE;MAC1BsE,MAAM,CAACC,SAAS,EAAE,CAAC,GAAGjG,IAAI;IAC9B;IACAK,gBAAgB,CAACL,IAAI,EAAE,IAAI,CAAC;IAC5B,IAAIA,IAAI,CAACuB,KAAK,KAAKqB,QAAQ,IAAI,CAACxC,gBAAgB,CAACJ,IAAI,CAACuB,KAAK,CAAC,EAAE;MAC1D;MACAvB,IAAI,GAAGA,IAAI,CAACuB,KAAK;MACjB;IACJ;EACJ;EACAlB,gBAAgB,CAACuE,CAAC,CAAC9B,IAAI,EAAE,KAAK,CAAC;EAC/B,OAAOkD,MAAM;AACjB;AACA,SAAS1C,sBAAqBA,CAACsB,CAAC,EAAE;EAC9B,IAAI5E,IAAI,GAAG4E,CAAC,CAAC9B,IAAI;EACjB,IAAMkD,MAAM,GAAG,EAAE;EACjB,IAAIC,SAAS,GAAG,CAAC;EACjB,OAAOjG,IAAI,KAAK4C,QAAQ,EAAE;IACtB,IAAIxC,gBAAgB,CAACJ,IAAI,CAAC,EAAE;MACxB;MACAK,gBAAgB,CAACL,IAAI,CAACsB,IAAI,EAAE,KAAK,CAAC;MAClCjB,gBAAgB,CAACL,IAAI,CAACuB,KAAK,EAAE,KAAK,CAAC;MACnCvB,IAAI,GAAGA,IAAI,CAACqB,MAAM;MAClB;IACJ;IACA,IAAIrB,IAAI,CAACsB,IAAI,KAAKsB,QAAQ,IAAI,CAACxC,gBAAgB,CAACJ,IAAI,CAACsB,IAAI,CAAC,EAAE;MACxD;MACAtB,IAAI,GAAGA,IAAI,CAACsB,IAAI;MAChB;IACJ;IACA,IAAItB,IAAI,CAACuB,KAAK,KAAKqB,QAAQ,IAAI,CAACxC,gBAAgB,CAACJ,IAAI,CAACuB,KAAK,CAAC,EAAE;MAC1D;MACAvB,IAAI,GAAGA,IAAI,CAACuB,KAAK;MACjB;IACJ;IACA;IACAyE,MAAM,CAACC,SAAS,EAAE,CAAC,GAAGjG,IAAI;IAC1BK,gBAAgB,CAACL,IAAI,EAAE,IAAI,CAAC;EAChC;EACAK,gBAAgB,CAACuE,CAAC,CAAC9B,IAAI,EAAE,KAAK,CAAC;EAC/B,OAAOkD,MAAM;AACjB;AACA,SAAS5C,OAAMA,CAACwB,CAAC,EAAE3B,aAAa,EAAEC,mBAAmB,EAAEtB,eAAe,EAAEuB,qBAAqB,EAAE;EAC3F,IAAInD,IAAI,GAAG4E,CAAC,CAAC9B,IAAI;EACjB,IAAItB,KAAK,GAAG,CAAC;EACb,IAAIsC,SAAS,GAAG,CAAC;EACjB,IAAIC,OAAO,GAAG,CAAC;EACf,IAAMiC,MAAM,GAAG,EAAE;EACjB,IAAIC,SAAS,GAAG,CAAC;EACjB,OAAOjG,IAAI,KAAK4C,QAAQ,EAAE;IACtB,IAAIxC,gBAAgB,CAACJ,IAAI,CAAC,EAAE;MACxB;MACAK,gBAAgB,CAACL,IAAI,CAACsB,IAAI,EAAE,KAAK,CAAC;MAClCjB,gBAAgB,CAACL,IAAI,CAACuB,KAAK,EAAE,KAAK,CAAC;MACnC,IAAIvB,IAAI,KAAKA,IAAI,CAACqB,MAAM,CAACE,KAAK,EAAE;QAC5BC,KAAK,IAAIxB,IAAI,CAACqB,MAAM,CAACG,KAAK;MAC9B;MACAxB,IAAI,GAAGA,IAAI,CAACqB,MAAM;MAClB;IACJ;IACA,IAAIrB,IAAI,CAACsB,IAAI,KAAKsB,QAAQ,IAAI,CAACxC,gBAAgB,CAACJ,IAAI,CAACsB,IAAI,CAAC,EAAE;MACxD;MACAtB,IAAI,GAAGA,IAAI,CAACsB,IAAI;MAChB;IACJ;IACA;IACAwC,SAAS,GAAGtC,KAAK,GAAGxB,IAAI,CAACkB,KAAK;IAC9B6C,OAAO,GAAGvC,KAAK,GAAGxB,IAAI,CAACmB,GAAG;IAC1BnB,IAAI,CAACwC,gBAAgB,CAACsB,SAAS,EAAEC,OAAO,EAAEnC,eAAe,CAAC;IAC1D,IAAIuE,OAAO,GAAG,IAAI;IAClB,IAAIlD,aAAa,IAAIjD,IAAI,CAAC0B,OAAO,IAAI1B,IAAI,CAAC0B,OAAO,KAAKuB,aAAa,EAAE;MACjEkD,OAAO,GAAG,KAAK;IACnB;IACA,IAAIjD,mBAAmB,IAAI3C,sBAAsB,CAACP,IAAI,CAAC,EAAE;MACrDmG,OAAO,GAAG,KAAK;IACnB;IACA,IAAIhD,qBAAqB,IAAI,CAAC1C,sBAAsB,CAACT,IAAI,CAAC,EAAE;MACxDmG,OAAO,GAAG,KAAK;IACnB;IACA,IAAIA,OAAO,EAAE;MACTH,MAAM,CAACC,SAAS,EAAE,CAAC,GAAGjG,IAAI;IAC9B;IACAK,gBAAgB,CAACL,IAAI,EAAE,IAAI,CAAC;IAC5B,IAAIA,IAAI,CAACuB,KAAK,KAAKqB,QAAQ,IAAI,CAACxC,gBAAgB,CAACJ,IAAI,CAACuB,KAAK,CAAC,EAAE;MAC1D;MACAC,KAAK,IAAIxB,IAAI,CAACwB,KAAK;MACnBxB,IAAI,GAAGA,IAAI,CAACuB,KAAK;MACjB;IACJ;EACJ;EACAlB,gBAAgB,CAACuE,CAAC,CAAC9B,IAAI,EAAE,KAAK,CAAC;EAC/B,OAAOkD,MAAM;AACjB;AACA,SAAShD,eAAcA,CAAC4B,CAAC,EAAEwB,aAAa,EAAEC,WAAW,EAAEpD,aAAa,EAAEC,mBAAmB,EAAEtB,eAAe,EAAEuB,qBAAqB,EAAE;EAC/H;EACA;EACA;EACA;EACA;EACA;EACA,IAAInD,IAAI,GAAG4E,CAAC,CAAC9B,IAAI;EACjB,IAAItB,KAAK,GAAG,CAAC;EACb,IAAIuE,UAAU,GAAG,CAAC;EAClB,IAAIjC,SAAS,GAAG,CAAC;EACjB,IAAIC,OAAO,GAAG,CAAC;EACf,IAAMiC,MAAM,GAAG,EAAE;EACjB,IAAIC,SAAS,GAAG,CAAC;EACjB,OAAOjG,IAAI,KAAK4C,QAAQ,EAAE;IACtB,IAAIxC,gBAAgB,CAACJ,IAAI,CAAC,EAAE;MACxB;MACAK,gBAAgB,CAACL,IAAI,CAACsB,IAAI,EAAE,KAAK,CAAC;MAClCjB,gBAAgB,CAACL,IAAI,CAACuB,KAAK,EAAE,KAAK,CAAC;MACnC,IAAIvB,IAAI,KAAKA,IAAI,CAACqB,MAAM,CAACE,KAAK,EAAE;QAC5BC,KAAK,IAAIxB,IAAI,CAACqB,MAAM,CAACG,KAAK;MAC9B;MACAxB,IAAI,GAAGA,IAAI,CAACqB,MAAM;MAClB;IACJ;IACA,IAAI,CAACjB,gBAAgB,CAACJ,IAAI,CAACsB,IAAI,CAAC,EAAE;MAC9B;MACAyE,UAAU,GAAGvE,KAAK,GAAGxB,IAAI,CAACyB,MAAM;MAChC,IAAIsE,UAAU,GAAGK,aAAa,EAAE;QAC5B;QACA;QACA/F,gBAAgB,CAACL,IAAI,EAAE,IAAI,CAAC;QAC5B;MACJ;MACA,IAAIA,IAAI,CAACsB,IAAI,KAAKsB,QAAQ,EAAE;QACxB;QACA5C,IAAI,GAAGA,IAAI,CAACsB,IAAI;QAChB;MACJ;IACJ;IACA;IACAwC,SAAS,GAAGtC,KAAK,GAAGxB,IAAI,CAACkB,KAAK;IAC9B,IAAI4C,SAAS,GAAGuC,WAAW,EAAE;MACzB;MACA;MACAhG,gBAAgB,CAACL,IAAI,EAAE,IAAI,CAAC;MAC5B;IACJ;IACA+D,OAAO,GAAGvC,KAAK,GAAGxB,IAAI,CAACmB,GAAG;IAC1B,IAAI4C,OAAO,IAAIqC,aAAa,EAAE;MAC1B;MACApG,IAAI,CAACwC,gBAAgB,CAACsB,SAAS,EAAEC,OAAO,EAAEnC,eAAe,CAAC;MAC1D,IAAIuE,OAAO,GAAG,IAAI;MAClB,IAAIlD,aAAa,IAAIjD,IAAI,CAAC0B,OAAO,IAAI1B,IAAI,CAAC0B,OAAO,KAAKuB,aAAa,EAAE;QACjEkD,OAAO,GAAG,KAAK;MACnB;MACA,IAAIjD,mBAAmB,IAAI3C,sBAAsB,CAACP,IAAI,CAAC,EAAE;QACrDmG,OAAO,GAAG,KAAK;MACnB;MACA,IAAIhD,qBAAqB,IAAI,CAAC1C,sBAAsB,CAACT,IAAI,CAAC,EAAE;QACxDmG,OAAO,GAAG,KAAK;MACnB;MACA,IAAIA,OAAO,EAAE;QACTH,MAAM,CAACC,SAAS,EAAE,CAAC,GAAGjG,IAAI;MAC9B;IACJ;IACAK,gBAAgB,CAACL,IAAI,EAAE,IAAI,CAAC;IAC5B,IAAIA,IAAI,CAACuB,KAAK,KAAKqB,QAAQ,IAAI,CAACxC,gBAAgB,CAACJ,IAAI,CAACuB,KAAK,CAAC,EAAE;MAC1D;MACAC,KAAK,IAAIxB,IAAI,CAACwB,KAAK;MACnBxB,IAAI,GAAGA,IAAI,CAACuB,KAAK;MACjB;IACJ;EACJ;EACAlB,gBAAgB,CAACuE,CAAC,CAAC9B,IAAI,EAAE,KAAK,CAAC;EAC/B,OAAOkD,MAAM;AACjB;AACA;AACA;AACA,SAASxC,YAAYA,CAACoB,CAAC,EAAE0B,OAAO,EAAE;EAC9B,IAAI1B,CAAC,CAAC9B,IAAI,KAAKF,QAAQ,EAAE;IACrB0D,OAAO,CAACjF,MAAM,GAAGuB,QAAQ;IACzB0D,OAAO,CAAChF,IAAI,GAAGsB,QAAQ;IACvB0D,OAAO,CAAC/E,KAAK,GAAGqB,QAAQ;IACxB1C,YAAY,CAACoG,OAAO,EAAE,CAAC,CAAC,qBAAqB,CAAC;IAC9C1B,CAAC,CAAC9B,IAAI,GAAGwD,OAAO;IAChB,OAAO1B,CAAC,CAAC9B,IAAI;EACjB;EACAyD,UAAU,CAAC3B,CAAC,EAAE0B,OAAO,CAAC;EACtBE,yBAAyB,CAACF,OAAO,CAACjF,MAAM,CAAC;EACzC;EACA,IAAIoF,CAAC,GAAGH,OAAO;EACf,OAAOG,CAAC,KAAK7B,CAAC,CAAC9B,IAAI,IAAI/C,YAAY,CAAC0G,CAAC,CAACpF,MAAM,CAAC,KAAK,CAAC,CAAC,qBAAqB;IACrE,IAAIoF,CAAC,CAACpF,MAAM,KAAKoF,CAAC,CAACpF,MAAM,CAACA,MAAM,CAACC,IAAI,EAAE;MACnC,IAAMoF,CAAC,GAAGD,CAAC,CAACpF,MAAM,CAACA,MAAM,CAACE,KAAK;MAC/B,IAAIxB,YAAY,CAAC2G,CAAC,CAAC,KAAK,CAAC,CAAC,qBAAqB;QAC3CxG,YAAY,CAACuG,CAAC,CAACpF,MAAM,EAAE,CAAC,CAAC,qBAAqB,CAAC;QAC/CnB,YAAY,CAACwG,CAAC,EAAE,CAAC,CAAC,qBAAqB,CAAC;QACxCxG,YAAY,CAACuG,CAAC,CAACpF,MAAM,CAACA,MAAM,EAAE,CAAC,CAAC,mBAAmB,CAAC;QACpDoF,CAAC,GAAGA,CAAC,CAACpF,MAAM,CAACA,MAAM;MACvB,CAAC,MACI;QACD,IAAIoF,CAAC,KAAKA,CAAC,CAACpF,MAAM,CAACE,KAAK,EAAE;UACtBkF,CAAC,GAAGA,CAAC,CAACpF,MAAM;UACZsF,UAAU,CAAC/B,CAAC,EAAE6B,CAAC,CAAC;QACpB;QACAvG,YAAY,CAACuG,CAAC,CAACpF,MAAM,EAAE,CAAC,CAAC,qBAAqB,CAAC;QAC/CnB,YAAY,CAACuG,CAAC,CAACpF,MAAM,CAACA,MAAM,EAAE,CAAC,CAAC,mBAAmB,CAAC;QACpDuF,WAAW,CAAChC,CAAC,EAAE6B,CAAC,CAACpF,MAAM,CAACA,MAAM,CAAC;MACnC;IACJ,CAAC,MACI;MACD,IAAMqF,EAAC,GAAGD,CAAC,CAACpF,MAAM,CAACA,MAAM,CAACC,IAAI;MAC9B,IAAIvB,YAAY,CAAC2G,EAAC,CAAC,KAAK,CAAC,CAAC,qBAAqB;QAC3CxG,YAAY,CAACuG,CAAC,CAACpF,MAAM,EAAE,CAAC,CAAC,qBAAqB,CAAC;QAC/CnB,YAAY,CAACwG,EAAC,EAAE,CAAC,CAAC,qBAAqB,CAAC;QACxCxG,YAAY,CAACuG,CAAC,CAACpF,MAAM,CAACA,MAAM,EAAE,CAAC,CAAC,mBAAmB,CAAC;QACpDoF,CAAC,GAAGA,CAAC,CAACpF,MAAM,CAACA,MAAM;MACvB,CAAC,MACI;QACD,IAAIoF,CAAC,KAAKA,CAAC,CAACpF,MAAM,CAACC,IAAI,EAAE;UACrBmF,CAAC,GAAGA,CAAC,CAACpF,MAAM;UACZuF,WAAW,CAAChC,CAAC,EAAE6B,CAAC,CAAC;QACrB;QACAvG,YAAY,CAACuG,CAAC,CAACpF,MAAM,EAAE,CAAC,CAAC,qBAAqB,CAAC;QAC/CnB,YAAY,CAACuG,CAAC,CAACpF,MAAM,CAACA,MAAM,EAAE,CAAC,CAAC,mBAAmB,CAAC;QACpDsF,UAAU,CAAC/B,CAAC,EAAE6B,CAAC,CAACpF,MAAM,CAACA,MAAM,CAAC;MAClC;IACJ;EACJ;EACAnB,YAAY,CAAC0E,CAAC,CAAC9B,IAAI,EAAE,CAAC,CAAC,qBAAqB,CAAC;EAC7C,OAAOwD,OAAO;AAClB;AACA,SAASC,UAAUA,CAAC3B,CAAC,EAAEiC,CAAC,EAAE;EACtB,IAAIrF,KAAK,GAAG,CAAC;EACb,IAAIiF,CAAC,GAAG7B,CAAC,CAAC9B,IAAI;EACd,IAAMgE,cAAc,GAAGD,CAAC,CAAC3F,KAAK;EAC9B,IAAM6F,YAAY,GAAGF,CAAC,CAAC1F,GAAG;EAC1B,OAAO,IAAI,EAAE;IACT,IAAM6F,GAAG,GAAGC,eAAe,CAACH,cAAc,EAAEC,YAAY,EAAEN,CAAC,CAACvF,KAAK,GAAGM,KAAK,EAAEiF,CAAC,CAACtF,GAAG,GAAGK,KAAK,CAAC;IACzF,IAAIwF,GAAG,GAAG,CAAC,EAAE;MACT;MACA;MACA,IAAIP,CAAC,CAACnF,IAAI,KAAKsB,QAAQ,EAAE;QACrBiE,CAAC,CAAC3F,KAAK,IAAIM,KAAK;QAChBqF,CAAC,CAAC1F,GAAG,IAAIK,KAAK;QACdqF,CAAC,CAACpF,MAAM,IAAID,KAAK;QACjBiF,CAAC,CAACnF,IAAI,GAAGuF,CAAC;QACV;MACJ,CAAC,MACI;QACDJ,CAAC,GAAGA,CAAC,CAACnF,IAAI;MACd;IACJ,CAAC,MACI;MACD;MACA;MACA,IAAImF,CAAC,CAAClF,KAAK,KAAKqB,QAAQ,EAAE;QACtBiE,CAAC,CAAC3F,KAAK,IAAKM,KAAK,GAAGiF,CAAC,CAACjF,KAAM;QAC5BqF,CAAC,CAAC1F,GAAG,IAAKK,KAAK,GAAGiF,CAAC,CAACjF,KAAM;QAC1BqF,CAAC,CAACpF,MAAM,IAAKD,KAAK,GAAGiF,CAAC,CAACjF,KAAM;QAC7BiF,CAAC,CAAClF,KAAK,GAAGsF,CAAC;QACX;MACJ,CAAC,MACI;QACDrF,KAAK,IAAIiF,CAAC,CAACjF,KAAK;QAChBiF,CAAC,GAAGA,CAAC,CAAClF,KAAK;MACf;IACJ;EACJ;EACAsF,CAAC,CAACxF,MAAM,GAAGoF,CAAC;EACZI,CAAC,CAACvF,IAAI,GAAGsB,QAAQ;EACjBiE,CAAC,CAACtF,KAAK,GAAGqB,QAAQ;EAClB1C,YAAY,CAAC2G,CAAC,EAAE,CAAC,CAAC,mBAAmB,CAAC;AAC1C;AACA;AACA;AACA,SAASlD,YAAYA,CAACiB,CAAC,EAAEiC,CAAC,EAAE;EACxB,IAAIJ,CAAC;EACL,IAAIC,CAAC;EACL;EACA;EACA,IAAIG,CAAC,CAACvF,IAAI,KAAKsB,QAAQ,EAAE;IACrB6D,CAAC,GAAGI,CAAC,CAACtF,KAAK;IACXmF,CAAC,GAAGG,CAAC;IACL;IACAJ,CAAC,CAACjF,KAAK,IAAIqF,CAAC,CAACrF,KAAK;IAClB,IAAIiF,CAAC,CAACjF,KAAK,GAAG,CAAC,UAAU,CAAC,kCAAkCiF,CAAC,CAACjF,KAAK,GAAG,UAAU,CAAC,gCAAgC;MAC7GoD,CAAC,CAAC7B,qBAAqB,GAAG,IAAI;IAClC;IACA0D,CAAC,CAACvF,KAAK,IAAI2F,CAAC,CAACrF,KAAK;IAClBiF,CAAC,CAACtF,GAAG,IAAI0F,CAAC,CAACrF,KAAK;EACpB,CAAC,MACI,IAAIqF,CAAC,CAACtF,KAAK,KAAKqB,QAAQ,EAAE;IAC3B6D,CAAC,GAAGI,CAAC,CAACvF,IAAI;IACVoF,CAAC,GAAGG,CAAC;EACT,CAAC,MACI;IACDH,CAAC,GAAGQ,OAAO,CAACL,CAAC,CAACtF,KAAK,CAAC;IACpBkF,CAAC,GAAGC,CAAC,CAACnF,KAAK;IACX;IACA;IACA;IACAkF,CAAC,CAACvF,KAAK,IAAIwF,CAAC,CAAClF,KAAK;IAClBiF,CAAC,CAACtF,GAAG,IAAIuF,CAAC,CAAClF,KAAK;IAChBiF,CAAC,CAACjF,KAAK,IAAIkF,CAAC,CAAClF,KAAK;IAClB,IAAIiF,CAAC,CAACjF,KAAK,GAAG,CAAC,UAAU,CAAC,kCAAkCiF,CAAC,CAACjF,KAAK,GAAG,UAAU,CAAC,gCAAgC;MAC7GoD,CAAC,CAAC7B,qBAAqB,GAAG,IAAI;IAClC;IACA2D,CAAC,CAACxF,KAAK,IAAI2F,CAAC,CAACrF,KAAK;IAClBkF,CAAC,CAACvF,GAAG,IAAI0F,CAAC,CAACrF,KAAK;IAChBkF,CAAC,CAAClF,KAAK,GAAGqF,CAAC,CAACrF,KAAK;IACjB,IAAIkF,CAAC,CAAClF,KAAK,GAAG,CAAC,UAAU,CAAC,kCAAkCkF,CAAC,CAAClF,KAAK,GAAG,UAAU,CAAC,gCAAgC;MAC7GoD,CAAC,CAAC7B,qBAAqB,GAAG,IAAI;IAClC;EACJ;EACA,IAAI2D,CAAC,KAAK9B,CAAC,CAAC9B,IAAI,EAAE;IACd8B,CAAC,CAAC9B,IAAI,GAAG2D,CAAC;IACVvG,YAAY,CAACuG,CAAC,EAAE,CAAC,CAAC,qBAAqB,CAAC;IACxCI,CAAC,CAAClE,MAAM,CAAC,CAAC;IACVwE,aAAa,CAAC,CAAC;IACftC,eAAe,CAAC4B,CAAC,CAAC;IAClB7B,CAAC,CAAC9B,IAAI,CAACzB,MAAM,GAAGuB,QAAQ;IACxB;EACJ;EACA,IAAMwE,OAAO,GAAIrH,YAAY,CAAC2G,CAAC,CAAC,KAAK,CAAC,CAAC,mBAAoB;EAC3D,IAAIA,CAAC,KAAKA,CAAC,CAACrF,MAAM,CAACC,IAAI,EAAE;IACrBoF,CAAC,CAACrF,MAAM,CAACC,IAAI,GAAGmF,CAAC;EACrB,CAAC,MACI;IACDC,CAAC,CAACrF,MAAM,CAACE,KAAK,GAAGkF,CAAC;EACtB;EACA,IAAIC,CAAC,KAAKG,CAAC,EAAE;IACTJ,CAAC,CAACpF,MAAM,GAAGqF,CAAC,CAACrF,MAAM;EACvB,CAAC,MACI;IACD,IAAIqF,CAAC,CAACrF,MAAM,KAAKwF,CAAC,EAAE;MAChBJ,CAAC,CAACpF,MAAM,GAAGqF,CAAC;IAChB,CAAC,MACI;MACDD,CAAC,CAACpF,MAAM,GAAGqF,CAAC,CAACrF,MAAM;IACvB;IACAqF,CAAC,CAACpF,IAAI,GAAGuF,CAAC,CAACvF,IAAI;IACfoF,CAAC,CAACnF,KAAK,GAAGsF,CAAC,CAACtF,KAAK;IACjBmF,CAAC,CAACrF,MAAM,GAAGwF,CAAC,CAACxF,MAAM;IACnBnB,YAAY,CAACwG,CAAC,EAAE3G,YAAY,CAAC8G,CAAC,CAAC,CAAC;IAChC,IAAIA,CAAC,KAAKjC,CAAC,CAAC9B,IAAI,EAAE;MACd8B,CAAC,CAAC9B,IAAI,GAAG4D,CAAC;IACd,CAAC,MACI;MACD,IAAIG,CAAC,KAAKA,CAAC,CAACxF,MAAM,CAACC,IAAI,EAAE;QACrBuF,CAAC,CAACxF,MAAM,CAACC,IAAI,GAAGoF,CAAC;MACrB,CAAC,MACI;QACDG,CAAC,CAACxF,MAAM,CAACE,KAAK,GAAGmF,CAAC;MACtB;IACJ;IACA,IAAIA,CAAC,CAACpF,IAAI,KAAKsB,QAAQ,EAAE;MACrB8D,CAAC,CAACpF,IAAI,CAACD,MAAM,GAAGqF,CAAC;IACrB;IACA,IAAIA,CAAC,CAACnF,KAAK,KAAKqB,QAAQ,EAAE;MACtB8D,CAAC,CAACnF,KAAK,CAACF,MAAM,GAAGqF,CAAC;IACtB;EACJ;EACAG,CAAC,CAAClE,MAAM,CAAC,CAAC;EACV,IAAIyE,OAAO,EAAE;IACTZ,yBAAyB,CAACC,CAAC,CAACpF,MAAM,CAAC;IACnC,IAAIqF,CAAC,KAAKG,CAAC,EAAE;MACTL,yBAAyB,CAACE,CAAC,CAAC;MAC5BF,yBAAyB,CAACE,CAAC,CAACrF,MAAM,CAAC;IACvC;IACA8F,aAAa,CAAC,CAAC;IACf;EACJ;EACAX,yBAAyB,CAACC,CAAC,CAAC;EAC5BD,yBAAyB,CAACC,CAAC,CAACpF,MAAM,CAAC;EACnC,IAAIqF,CAAC,KAAKG,CAAC,EAAE;IACTL,yBAAyB,CAACE,CAAC,CAAC;IAC5BF,yBAAyB,CAACE,CAAC,CAACrF,MAAM,CAAC;EACvC;EACA;EACA,IAAIgG,CAAC;EACL,OAAOZ,CAAC,KAAK7B,CAAC,CAAC9B,IAAI,IAAI/C,YAAY,CAAC0G,CAAC,CAAC,KAAK,CAAC,CAAC,uBAAuB;IAChE,IAAIA,CAAC,KAAKA,CAAC,CAACpF,MAAM,CAACC,IAAI,EAAE;MACrB+F,CAAC,GAAGZ,CAAC,CAACpF,MAAM,CAACE,KAAK;MAClB,IAAIxB,YAAY,CAACsH,CAAC,CAAC,KAAK,CAAC,CAAC,qBAAqB;QAC3CnH,YAAY,CAACmH,CAAC,EAAE,CAAC,CAAC,qBAAqB,CAAC;QACxCnH,YAAY,CAACuG,CAAC,CAACpF,MAAM,EAAE,CAAC,CAAC,mBAAmB,CAAC;QAC7CsF,UAAU,CAAC/B,CAAC,EAAE6B,CAAC,CAACpF,MAAM,CAAC;QACvBgG,CAAC,GAAGZ,CAAC,CAACpF,MAAM,CAACE,KAAK;MACtB;MACA,IAAIxB,YAAY,CAACsH,CAAC,CAAC/F,IAAI,CAAC,KAAK,CAAC,CAAC,yBAAyBvB,YAAY,CAACsH,CAAC,CAAC9F,KAAK,CAAC,KAAK,CAAC,CAAC,uBAAuB;QACvGrB,YAAY,CAACmH,CAAC,EAAE,CAAC,CAAC,mBAAmB,CAAC;QACtCZ,CAAC,GAAGA,CAAC,CAACpF,MAAM;MAChB,CAAC,MACI;QACD,IAAItB,YAAY,CAACsH,CAAC,CAAC9F,KAAK,CAAC,KAAK,CAAC,CAAC,uBAAuB;UACnDrB,YAAY,CAACmH,CAAC,CAAC/F,IAAI,EAAE,CAAC,CAAC,qBAAqB,CAAC;UAC7CpB,YAAY,CAACmH,CAAC,EAAE,CAAC,CAAC,mBAAmB,CAAC;UACtCT,WAAW,CAAChC,CAAC,EAAEyC,CAAC,CAAC;UACjBA,CAAC,GAAGZ,CAAC,CAACpF,MAAM,CAACE,KAAK;QACtB;QACArB,YAAY,CAACmH,CAAC,EAAEtH,YAAY,CAAC0G,CAAC,CAACpF,MAAM,CAAC,CAAC;QACvCnB,YAAY,CAACuG,CAAC,CAACpF,MAAM,EAAE,CAAC,CAAC,qBAAqB,CAAC;QAC/CnB,YAAY,CAACmH,CAAC,CAAC9F,KAAK,EAAE,CAAC,CAAC,qBAAqB,CAAC;QAC9CoF,UAAU,CAAC/B,CAAC,EAAE6B,CAAC,CAACpF,MAAM,CAAC;QACvBoF,CAAC,GAAG7B,CAAC,CAAC9B,IAAI;MACd;IACJ,CAAC,MACI;MACDuE,CAAC,GAAGZ,CAAC,CAACpF,MAAM,CAACC,IAAI;MACjB,IAAIvB,YAAY,CAACsH,CAAC,CAAC,KAAK,CAAC,CAAC,qBAAqB;QAC3CnH,YAAY,CAACmH,CAAC,EAAE,CAAC,CAAC,qBAAqB,CAAC;QACxCnH,YAAY,CAACuG,CAAC,CAACpF,MAAM,EAAE,CAAC,CAAC,mBAAmB,CAAC;QAC7CuF,WAAW,CAAChC,CAAC,EAAE6B,CAAC,CAACpF,MAAM,CAAC;QACxBgG,CAAC,GAAGZ,CAAC,CAACpF,MAAM,CAACC,IAAI;MACrB;MACA,IAAIvB,YAAY,CAACsH,CAAC,CAAC/F,IAAI,CAAC,KAAK,CAAC,CAAC,yBAAyBvB,YAAY,CAACsH,CAAC,CAAC9F,KAAK,CAAC,KAAK,CAAC,CAAC,uBAAuB;QACvGrB,YAAY,CAACmH,CAAC,EAAE,CAAC,CAAC,mBAAmB,CAAC;QACtCZ,CAAC,GAAGA,CAAC,CAACpF,MAAM;MAChB,CAAC,MACI;QACD,IAAItB,YAAY,CAACsH,CAAC,CAAC/F,IAAI,CAAC,KAAK,CAAC,CAAC,uBAAuB;UAClDpB,YAAY,CAACmH,CAAC,CAAC9F,KAAK,EAAE,CAAC,CAAC,qBAAqB,CAAC;UAC9CrB,YAAY,CAACmH,CAAC,EAAE,CAAC,CAAC,mBAAmB,CAAC;UACtCV,UAAU,CAAC/B,CAAC,EAAEyC,CAAC,CAAC;UAChBA,CAAC,GAAGZ,CAAC,CAACpF,MAAM,CAACC,IAAI;QACrB;QACApB,YAAY,CAACmH,CAAC,EAAEtH,YAAY,CAAC0G,CAAC,CAACpF,MAAM,CAAC,CAAC;QACvCnB,YAAY,CAACuG,CAAC,CAACpF,MAAM,EAAE,CAAC,CAAC,qBAAqB,CAAC;QAC/CnB,YAAY,CAACmH,CAAC,CAAC/F,IAAI,EAAE,CAAC,CAAC,qBAAqB,CAAC;QAC7CsF,WAAW,CAAChC,CAAC,EAAE6B,CAAC,CAACpF,MAAM,CAAC;QACxBoF,CAAC,GAAG7B,CAAC,CAAC9B,IAAI;MACd;IACJ;EACJ;EACA5C,YAAY,CAACuG,CAAC,EAAE,CAAC,CAAC,qBAAqB,CAAC;EACxCU,aAAa,CAAC,CAAC;AACnB;AACA,SAASD,OAAOA,CAAClH,IAAI,EAAE;EACnB,OAAOA,IAAI,CAACsB,IAAI,KAAKsB,QAAQ,EAAE;IAC3B5C,IAAI,GAAGA,IAAI,CAACsB,IAAI;EACpB;EACA,OAAOtB,IAAI;AACf;AACA,SAASmH,aAAaA,CAAA,EAAG;EACrBvE,QAAQ,CAACvB,MAAM,GAAGuB,QAAQ;EAC1BA,QAAQ,CAACpB,KAAK,GAAG,CAAC,CAAC,CAAC;EACpBoB,QAAQ,CAAC1B,KAAK,GAAG,CAAC,CAAC,CAAC;EACpB0B,QAAQ,CAACzB,GAAG,GAAG,CAAC,CAAC,CAAC;AACtB;AACA;AACA;AACA,SAASwF,UAAUA,CAAC/B,CAAC,EAAE6B,CAAC,EAAE;EACtB,IAAMC,CAAC,GAAGD,CAAC,CAAClF,KAAK,CAAC,CAAC;EACnBmF,CAAC,CAAClF,KAAK,IAAIiF,CAAC,CAACjF,KAAK,CAAC,CAAC;EACpB,IAAIkF,CAAC,CAAClF,KAAK,GAAG,CAAC,UAAU,CAAC,kCAAkCkF,CAAC,CAAClF,KAAK,GAAG,UAAU,CAAC,gCAAgC;IAC7GoD,CAAC,CAAC7B,qBAAqB,GAAG,IAAI;EAClC;EACA2D,CAAC,CAACxF,KAAK,IAAIuF,CAAC,CAACjF,KAAK;EAClBkF,CAAC,CAACvF,GAAG,IAAIsF,CAAC,CAACjF,KAAK;EAChBiF,CAAC,CAAClF,KAAK,GAAGmF,CAAC,CAACpF,IAAI,CAAC,CAAC;EAClB,IAAIoF,CAAC,CAACpF,IAAI,KAAKsB,QAAQ,EAAE;IACrB8D,CAAC,CAACpF,IAAI,CAACD,MAAM,GAAGoF,CAAC;EACrB;EACAC,CAAC,CAACrF,MAAM,GAAGoF,CAAC,CAACpF,MAAM,CAAC,CAAC;EACrB,IAAIoF,CAAC,CAACpF,MAAM,KAAKuB,QAAQ,EAAE;IACvBgC,CAAC,CAAC9B,IAAI,GAAG4D,CAAC;EACd,CAAC,MACI,IAAID,CAAC,KAAKA,CAAC,CAACpF,MAAM,CAACC,IAAI,EAAE;IAC1BmF,CAAC,CAACpF,MAAM,CAACC,IAAI,GAAGoF,CAAC;EACrB,CAAC,MACI;IACDD,CAAC,CAACpF,MAAM,CAACE,KAAK,GAAGmF,CAAC;EACtB;EACAA,CAAC,CAACpF,IAAI,GAAGmF,CAAC,CAAC,CAAC;EACZA,CAAC,CAACpF,MAAM,GAAGqF,CAAC;EACZ7B,eAAe,CAAC4B,CAAC,CAAC;EAClB5B,eAAe,CAAC6B,CAAC,CAAC;AACtB;AACA,SAASE,WAAWA,CAAChC,CAAC,EAAE8B,CAAC,EAAE;EACvB,IAAMD,CAAC,GAAGC,CAAC,CAACpF,IAAI;EAChBoF,CAAC,CAAClF,KAAK,IAAIiF,CAAC,CAACjF,KAAK;EAClB,IAAIkF,CAAC,CAAClF,KAAK,GAAG,CAAC,UAAU,CAAC,kCAAkCkF,CAAC,CAAClF,KAAK,GAAG,UAAU,CAAC,gCAAgC;IAC7GoD,CAAC,CAAC7B,qBAAqB,GAAG,IAAI;EAClC;EACA2D,CAAC,CAACxF,KAAK,IAAIuF,CAAC,CAACjF,KAAK;EAClBkF,CAAC,CAACvF,GAAG,IAAIsF,CAAC,CAACjF,KAAK;EAChBkF,CAAC,CAACpF,IAAI,GAAGmF,CAAC,CAAClF,KAAK;EAChB,IAAIkF,CAAC,CAAClF,KAAK,KAAKqB,QAAQ,EAAE;IACtB6D,CAAC,CAAClF,KAAK,CAACF,MAAM,GAAGqF,CAAC;EACtB;EACAD,CAAC,CAACpF,MAAM,GAAGqF,CAAC,CAACrF,MAAM;EACnB,IAAIqF,CAAC,CAACrF,MAAM,KAAKuB,QAAQ,EAAE;IACvBgC,CAAC,CAAC9B,IAAI,GAAG2D,CAAC;EACd,CAAC,MACI,IAAIC,CAAC,KAAKA,CAAC,CAACrF,MAAM,CAACE,KAAK,EAAE;IAC3BmF,CAAC,CAACrF,MAAM,CAACE,KAAK,GAAGkF,CAAC;EACtB,CAAC,MACI;IACDC,CAAC,CAACrF,MAAM,CAACC,IAAI,GAAGmF,CAAC;EACrB;EACAA,CAAC,CAAClF,KAAK,GAAGmF,CAAC;EACXA,CAAC,CAACrF,MAAM,GAAGoF,CAAC;EACZ5B,eAAe,CAAC6B,CAAC,CAAC;EAClB7B,eAAe,CAAC4B,CAAC,CAAC;AACtB;AACA;AACA;AACA,SAASa,aAAaA,CAACtH,IAAI,EAAE;EACzB,IAAIyB,MAAM,GAAGzB,IAAI,CAACmB,GAAG;EACrB,IAAInB,IAAI,CAACsB,IAAI,KAAKsB,QAAQ,EAAE;IACxB,IAAM2E,UAAU,GAAGvH,IAAI,CAACsB,IAAI,CAACG,MAAM;IACnC,IAAI8F,UAAU,GAAG9F,MAAM,EAAE;MACrBA,MAAM,GAAG8F,UAAU;IACvB;EACJ;EACA,IAAIvH,IAAI,CAACuB,KAAK,KAAKqB,QAAQ,EAAE;IACzB,IAAM4E,WAAW,GAAGxH,IAAI,CAACuB,KAAK,CAACE,MAAM,GAAGzB,IAAI,CAACwB,KAAK;IAClD,IAAIgG,WAAW,GAAG/F,MAAM,EAAE;MACtBA,MAAM,GAAG+F,WAAW;IACxB;EACJ;EACA,OAAO/F,MAAM;AACjB;AACA,OAAO,SAASoD,eAAeA,CAAC7E,IAAI,EAAE;EAClCA,IAAI,CAACyB,MAAM,GAAG6F,aAAa,CAACtH,IAAI,CAAC;AACrC;AACA,SAASwG,yBAAyBA,CAACxG,IAAI,EAAE;EACrC,OAAOA,IAAI,KAAK4C,QAAQ,EAAE;IACtB,IAAMnB,MAAM,GAAG6F,aAAa,CAACtH,IAAI,CAAC;IAClC,IAAIA,IAAI,CAACyB,MAAM,KAAKA,MAAM,EAAE;MACxB;MACA;IACJ;IACAzB,IAAI,CAACyB,MAAM,GAAGA,MAAM;IACpBzB,IAAI,GAAGA,IAAI,CAACqB,MAAM;EACtB;AACJ;AACA;AACA;AACA,OAAO,SAAS4F,eAAeA,CAACQ,MAAM,EAAEC,IAAI,EAAEC,MAAM,EAAEC,IAAI,EAAE;EACxD,IAAIH,MAAM,KAAKE,MAAM,EAAE;IACnB,OAAOD,IAAI,GAAGE,IAAI;EACtB;EACA,OAAOH,MAAM,GAAGE,MAAM;AAC1B;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}