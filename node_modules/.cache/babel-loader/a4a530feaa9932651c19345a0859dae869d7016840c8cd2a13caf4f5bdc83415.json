{"ast":null,"code":"import _defineProperty from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _callSuper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _typeof from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar _encodeTable;\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.last-index-of.js\";\nimport \"core-js/modules/es.array.with.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.substr.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as paths from './path.js';\nimport { isWindows } from './platform.js';\nvar _schemePattern = /^\\w[\\w\\d+.-]*$/;\nvar _singleSlashStart = /^\\//;\nvar _doubleSlashStart = /^\\/\\//;\nfunction _validateUri(ret, _strict) {\n  // scheme, must be set\n  if (!ret.scheme && _strict) {\n    throw new Error(\"[UriError]: Scheme is missing: {scheme: \\\"\\\", authority: \\\"\".concat(ret.authority, \"\\\", path: \\\"\").concat(ret.path, \"\\\", query: \\\"\").concat(ret.query, \"\\\", fragment: \\\"\").concat(ret.fragment, \"\\\"}\"));\n  }\n  // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n  // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n  if (ret.scheme && !_schemePattern.test(ret.scheme)) {\n    throw new Error('[UriError]: Scheme contains illegal characters.');\n  }\n  // path, http://tools.ietf.org/html/rfc3986#section-3.3\n  // If a URI contains an authority component, then the path component\n  // must either be empty or begin with a slash (\"/\") character.  If a URI\n  // does not contain an authority component, then the path cannot begin\n  // with two slash characters (\"//\").\n  if (ret.path) {\n    if (ret.authority) {\n      if (!_singleSlashStart.test(ret.path)) {\n        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n      }\n    } else {\n      if (_doubleSlashStart.test(ret.path)) {\n        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n      }\n    }\n  }\n}\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme, _strict) {\n  if (!scheme && !_strict) {\n    return 'file';\n  }\n  return scheme;\n}\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme, path) {\n  // the slash-character is our 'default base' as we don't\n  // support constructing URIs relative to other URIs. This\n  // also means that we alter and potentially break paths.\n  // see https://tools.ietf.org/html/rfc3986#section-5.1.4\n  switch (scheme) {\n    case 'https':\n    case 'http':\n    case 'file':\n      if (!path) {\n        path = _slash;\n      } else if (path[0] !== _slash) {\n        path = _slash + path;\n      }\n      break;\n  }\n  return path;\n}\nvar _empty = '';\nvar _slash = '/';\nvar _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport var URI = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function URI(schemeOrData, authority, path, query, fragment) {\n    var _strict = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    _classCallCheck(this, URI);\n    if (_typeof(schemeOrData) === 'object') {\n      this.scheme = schemeOrData.scheme || _empty;\n      this.authority = schemeOrData.authority || _empty;\n      this.path = schemeOrData.path || _empty;\n      this.query = schemeOrData.query || _empty;\n      this.fragment = schemeOrData.fragment || _empty;\n      // no validation because it's this URI\n      // that creates uri components.\n      // _validateUri(this);\n    } else {\n      this.scheme = _schemeFix(schemeOrData, _strict);\n      this.authority = authority || _empty;\n      this.path = _referenceResolution(this.scheme, path || _empty);\n      this.query = query || _empty;\n      this.fragment = fragment || _empty;\n      _validateUri(this, _strict);\n    }\n  }\n  // ---- filesystem path -----------------------\n  /**\n   * Returns a string representing the corresponding file system path of this URI.\n   * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n   * platform specific path separator.\n   *\n   * * Will *not* validate the path for invalid characters and semantics.\n   * * Will *not* look at the scheme of this URI.\n   * * The result shall *not* be used for display purposes but for accessing a file on disk.\n   *\n   *\n   * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n   * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n   *\n   * ```ts\n      const u = URI.parse('file://server/c$/folder/file.txt')\n      u.authority === 'server'\n      u.path === '/shares/c$/file.txt'\n      u.fsPath === '\\\\server\\c$\\folder\\file.txt'\n  ```\n   *\n   * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n   * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n   * with URIs that represent files on disk (`file` scheme).\n   */\n  return _createClass(URI, [{\n    key: \"fsPath\",\n    get: function get() {\n      // if (this.scheme !== 'file') {\n      // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n      // }\n      return uriToFsPath(this, false);\n    }\n    // ---- modify to new -------------------------\n  }, {\n    key: \"with\",\n    value: function _with(change) {\n      if (!change) {\n        return this;\n      }\n      var scheme = change.scheme,\n        authority = change.authority,\n        path = change.path,\n        query = change.query,\n        fragment = change.fragment;\n      if (scheme === undefined) {\n        scheme = this.scheme;\n      } else if (scheme === null) {\n        scheme = _empty;\n      }\n      if (authority === undefined) {\n        authority = this.authority;\n      } else if (authority === null) {\n        authority = _empty;\n      }\n      if (path === undefined) {\n        path = this.path;\n      } else if (path === null) {\n        path = _empty;\n      }\n      if (query === undefined) {\n        query = this.query;\n      } else if (query === null) {\n        query = _empty;\n      }\n      if (fragment === undefined) {\n        fragment = this.fragment;\n      } else if (fragment === null) {\n        fragment = _empty;\n      }\n      if (scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment) {\n        return this;\n      }\n      return new Uri(scheme, authority, path, query, fragment);\n    }\n    // ---- parse & validate ------------------------\n    /**\n     * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,\n     * `file:///usr/home`, or `scheme:with/path`.\n     *\n     * @param value A string which represents an URI (see `URI#toString`).\n     */\n  }, {\n    key: \"toString\",\n    value:\n    // ---- printing/externalize ---------------------------\n    /**\n     * Creates a string representation for this URI. It's guaranteed that calling\n     * `URI.parse` with the result of this function creates an URI which is equal\n     * to this URI.\n     *\n     * * The result shall *not* be used for display purposes but for externalization or transport.\n     * * The result will be encoded using the percentage encoding and encoding happens mostly\n     * ignore the scheme-specific encoding rules.\n     *\n     * @param skipEncoding Do not encode the result, default is `false`\n     */\n    function toString() {\n      var skipEncoding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return _asFormatted(this, skipEncoding);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this;\n    }\n  }], [{\n    key: \"isUri\",\n    value: function isUri(thing) {\n      if (thing instanceof URI) {\n        return true;\n      }\n      if (!thing) {\n        return false;\n      }\n      return typeof thing.authority === 'string' && typeof thing.fragment === 'string' && typeof thing.path === 'string' && typeof thing.query === 'string' && typeof thing.scheme === 'string' && typeof thing.fsPath === 'string' && typeof thing[\"with\"] === 'function' && typeof thing.toString === 'function';\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(value) {\n      var _strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var match = _regexp.exec(value);\n      if (!match) {\n        return new Uri(_empty, _empty, _empty, _empty, _empty);\n      }\n      return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);\n    }\n    /**\n     * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n     * `/usr/home`, or `\\\\server\\share\\some\\path`.\n     *\n     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n     * `URI.parse('file://' + path)` because the path might contain characters that are\n     * interpreted (# and ?). See the following sample:\n     * ```ts\n    const good = URI.file('/coding/c#/project1');\n    good.scheme === 'file';\n    good.path === '/coding/c#/project1';\n    good.fragment === '';\n    const bad = URI.parse('file://' + '/coding/c#/project1');\n    bad.scheme === 'file';\n    bad.path === '/coding/c'; // path is now broken\n    bad.fragment === '/project1';\n    ```\n     *\n     * @param path A file system path (see `URI#fsPath`)\n     */\n  }, {\n    key: \"file\",\n    value: function file(path) {\n      var authority = _empty;\n      // normalize to fwd-slashes on windows,\n      // on other systems bwd-slashes are valid\n      // filename character, eg /f\\oo/ba\\r.txt\n      if (isWindows) {\n        path = path.replace(/\\\\/g, _slash);\n      }\n      // check for authority as used in UNC shares\n      // or use the path as given\n      if (path[0] === _slash && path[1] === _slash) {\n        var idx = path.indexOf(_slash, 2);\n        if (idx === -1) {\n          authority = path.substring(2);\n          path = _slash;\n        } else {\n          authority = path.substring(2, idx);\n          path = path.substring(idx) || _slash;\n        }\n      }\n      return new Uri('file', authority, path, _empty, _empty);\n    }\n    /**\n     * Creates new URI from uri components.\n     *\n     * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs\n     * validation and should be used for untrusted uri components retrieved from storage,\n     * user input, command arguments etc\n     */\n  }, {\n    key: \"from\",\n    value: function from(components, strict) {\n      var result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment, strict);\n      return result;\n    }\n    /**\n     * Join a URI path with path fragments and normalizes the resulting path.\n     *\n     * @param uri The input URI.\n     * @param pathFragment The path fragment to add to the URI path.\n     * @returns The resulting URI.\n     */\n  }, {\n    key: \"joinPath\",\n    value: function joinPath(uri) {\n      if (!uri.path) {\n        throw new Error(\"[UriError]: cannot call joinPath on URI without path\");\n      }\n      var newPath;\n      for (var _len = arguments.length, pathFragment = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        pathFragment[_key - 1] = arguments[_key];\n      }\n      if (isWindows && uri.scheme === 'file') {\n        var _paths$win;\n        newPath = URI.file((_paths$win = paths.win32).join.apply(_paths$win, [uriToFsPath(uri, true)].concat(pathFragment))).path;\n      } else {\n        var _paths$posix;\n        newPath = (_paths$posix = paths.posix).join.apply(_paths$posix, [uri.path].concat(pathFragment));\n      }\n      return uri[\"with\"]({\n        path: newPath\n      });\n    }\n  }, {\n    key: \"revive\",\n    value: function revive(data) {\n      var _a, _b;\n      if (!data) {\n        return data;\n      } else if (data instanceof URI) {\n        return data;\n      } else {\n        var result = new Uri(data);\n        result._formatted = (_a = data.external) !== null && _a !== void 0 ? _a : null;\n        result._fsPath = data._sep === _pathSepMarker ? (_b = data.fsPath) !== null && _b !== void 0 ? _b : null : null;\n        return result;\n      }\n    }\n  }]);\n}();\nvar _pathSepMarker = isWindows ? 1 : undefined;\n// This class exists so that URI is compatible with vscode.Uri (API).\nvar Uri = /*#__PURE__*/function (_URI) {\n  function Uri() {\n    var _this;\n    _classCallCheck(this, Uri);\n    _this = _callSuper(this, Uri, arguments);\n    _this._formatted = null;\n    _this._fsPath = null;\n    return _this;\n  }\n  _inherits(Uri, _URI);\n  return _createClass(Uri, [{\n    key: \"fsPath\",\n    get: function get() {\n      if (!this._fsPath) {\n        this._fsPath = uriToFsPath(this, false);\n      }\n      return this._fsPath;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var skipEncoding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (!skipEncoding) {\n        if (!this._formatted) {\n          this._formatted = _asFormatted(this, false);\n        }\n        return this._formatted;\n      } else {\n        // we don't cache that\n        return _asFormatted(this, true);\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var res = {\n        $mid: 1 /* MarshalledId.Uri */\n      };\n      // cached state\n      if (this._fsPath) {\n        res.fsPath = this._fsPath;\n        res._sep = _pathSepMarker;\n      }\n      if (this._formatted) {\n        res.external = this._formatted;\n      }\n      //--- uri components\n      if (this.path) {\n        res.path = this.path;\n      }\n      // TODO\n      // this isn't correct and can violate the UriComponents contract but\n      // this is part of the vscode.Uri API and we shouldn't change how that\n      // works anymore\n      if (this.scheme) {\n        res.scheme = this.scheme;\n      }\n      if (this.authority) {\n        res.authority = this.authority;\n      }\n      if (this.query) {\n        res.query = this.query;\n      }\n      if (this.fragment) {\n        res.fragment = this.fragment;\n      }\n      return res;\n    }\n  }]);\n}(URI); // reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nvar encodeTable = (_encodeTable = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_encodeTable, 58 /* CharCode.Colon */, '%3A'), 47 /* CharCode.Slash */, '%2F'), 63 /* CharCode.QuestionMark */, '%3F'), 35 /* CharCode.Hash */, '%23'), 91 /* CharCode.OpenSquareBracket */, '%5B'), 93 /* CharCode.CloseSquareBracket */, '%5D'), 64 /* CharCode.AtSign */, '%40'), 33 /* CharCode.ExclamationMark */, '%21'), 36 /* CharCode.DollarSign */, '%24'), 38 /* CharCode.Ampersand */, '%26'), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_encodeTable, 39 /* CharCode.SingleQuote */, '%27'), 40 /* CharCode.OpenParen */, '%28'), 41 /* CharCode.CloseParen */, '%29'), 42 /* CharCode.Asterisk */, '%2A'), 43 /* CharCode.Plus */, '%2B'), 44 /* CharCode.Comma */, '%2C'), 59 /* CharCode.Semicolon */, '%3B'), 61 /* CharCode.Equals */, '%3D'), 32 /* CharCode.Space */, '%20'));\nfunction encodeURIComponentFast(uriComponent, isPath, isAuthority) {\n  var res = undefined;\n  var nativeEncodePos = -1;\n  for (var pos = 0; pos < uriComponent.length; pos++) {\n    var code = uriComponent.charCodeAt(pos);\n    // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n    if (code >= 97 /* CharCode.a */ && code <= 122 /* CharCode.z */ || code >= 65 /* CharCode.A */ && code <= 90 /* CharCode.Z */ || code >= 48 /* CharCode.Digit0 */ && code <= 57 /* CharCode.Digit9 */ || code === 45 /* CharCode.Dash */ || code === 46 /* CharCode.Period */ || code === 95 /* CharCode.Underline */ || code === 126 /* CharCode.Tilde */ || isPath && code === 47 /* CharCode.Slash */ || isAuthority && code === 91 /* CharCode.OpenSquareBracket */ || isAuthority && code === 93 /* CharCode.CloseSquareBracket */ || isAuthority && code === 58 /* CharCode.Colon */) {\n      // check if we are delaying native encode\n      if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n        nativeEncodePos = -1;\n      }\n      // check if we write into a new string (by default we try to return the param)\n      if (res !== undefined) {\n        res += uriComponent.charAt(pos);\n      }\n    } else {\n      // encoding needed, we need to allocate a new string\n      if (res === undefined) {\n        res = uriComponent.substr(0, pos);\n      }\n      // check with default table first\n      var escaped = encodeTable[code];\n      if (escaped !== undefined) {\n        // check if we are delaying native encode\n        if (nativeEncodePos !== -1) {\n          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n          nativeEncodePos = -1;\n        }\n        // append escaped variant to result\n        res += escaped;\n      } else if (nativeEncodePos === -1) {\n        // use native encode only when needed\n        nativeEncodePos = pos;\n      }\n    }\n  }\n  if (nativeEncodePos !== -1) {\n    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n  }\n  return res !== undefined ? res : uriComponent;\n}\nfunction encodeURIComponentMinimal(path) {\n  var res = undefined;\n  for (var pos = 0; pos < path.length; pos++) {\n    var code = path.charCodeAt(pos);\n    if (code === 35 /* CharCode.Hash */ || code === 63 /* CharCode.QuestionMark */) {\n      if (res === undefined) {\n        res = path.substr(0, pos);\n      }\n      res += encodeTable[code];\n    } else {\n      if (res !== undefined) {\n        res += path[pos];\n      }\n    }\n  }\n  return res !== undefined ? res : path;\n}\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri, keepDriveLetterCasing) {\n  var value;\n  if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n    // unc path: file://shares/c$/far/boo\n    value = \"//\".concat(uri.authority).concat(uri.path);\n  } else if (uri.path.charCodeAt(0) === 47 /* CharCode.Slash */ && (uri.path.charCodeAt(1) >= 65 /* CharCode.A */ && uri.path.charCodeAt(1) <= 90 /* CharCode.Z */ || uri.path.charCodeAt(1) >= 97 /* CharCode.a */ && uri.path.charCodeAt(1) <= 122 /* CharCode.z */) && uri.path.charCodeAt(2) === 58 /* CharCode.Colon */) {\n    if (!keepDriveLetterCasing) {\n      // windows drive letter: file:///c:/far/boo\n      value = uri.path[1].toLowerCase() + uri.path.substr(2);\n    } else {\n      value = uri.path.substr(1);\n    }\n  } else {\n    // other path\n    value = uri.path;\n  }\n  if (isWindows) {\n    value = value.replace(/\\//g, '\\\\');\n  }\n  return value;\n}\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri, skipEncoding) {\n  var encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;\n  var res = '';\n  var scheme = uri.scheme,\n    authority = uri.authority,\n    path = uri.path,\n    query = uri.query,\n    fragment = uri.fragment;\n  if (scheme) {\n    res += scheme;\n    res += ':';\n  }\n  if (authority || scheme === 'file') {\n    res += _slash;\n    res += _slash;\n  }\n  if (authority) {\n    var idx = authority.indexOf('@');\n    if (idx !== -1) {\n      // <user>@<auth>\n      var userinfo = authority.substr(0, idx);\n      authority = authority.substr(idx + 1);\n      idx = userinfo.lastIndexOf(':');\n      if (idx === -1) {\n        res += encoder(userinfo, false, false);\n      } else {\n        // <user>:<pass>@<auth>\n        res += encoder(userinfo.substr(0, idx), false, false);\n        res += ':';\n        res += encoder(userinfo.substr(idx + 1), false, true);\n      }\n      res += '@';\n    }\n    authority = authority.toLowerCase();\n    idx = authority.lastIndexOf(':');\n    if (idx === -1) {\n      res += encoder(authority, false, true);\n    } else {\n      // <auth>:<port>\n      res += encoder(authority.substr(0, idx), false, true);\n      res += authority.substr(idx);\n    }\n  }\n  if (path) {\n    // lower-case windows drive letters in /C:/fff or C:/fff\n    if (path.length >= 3 && path.charCodeAt(0) === 47 /* CharCode.Slash */ && path.charCodeAt(2) === 58 /* CharCode.Colon */) {\n      var code = path.charCodeAt(1);\n      if (code >= 65 /* CharCode.A */ && code <= 90 /* CharCode.Z */) {\n        path = \"/\".concat(String.fromCharCode(code + 32), \":\").concat(path.substr(3)); // \"/c:\".length === 3\n      }\n    } else if (path.length >= 2 && path.charCodeAt(1) === 58 /* CharCode.Colon */) {\n      var _code = path.charCodeAt(0);\n      if (_code >= 65 /* CharCode.A */ && _code <= 90 /* CharCode.Z */) {\n        path = \"\".concat(String.fromCharCode(_code + 32), \":\").concat(path.substr(2)); // \"/c:\".length === 3\n      }\n    }\n    // encode the rest of the path\n    res += encoder(path, true, false);\n  }\n  if (query) {\n    res += '?';\n    res += encoder(query, false, false);\n  }\n  if (fragment) {\n    res += '#';\n    res += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;\n  }\n  return res;\n}\n// --- decode\nfunction decodeURIComponentGraceful(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (_a) {\n    if (str.length > 3) {\n      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n    } else {\n      return str;\n    }\n  }\n}\nvar _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\nfunction percentDecode(str) {\n  if (!str.match(_rEncodedAsHex)) {\n    return str;\n  }\n  return str.replace(_rEncodedAsHex, function (match) {\n    return decodeURIComponentGraceful(match);\n  });\n}","map":{"version":3,"names":["paths","isWindows","_schemePattern","_singleSlashStart","_doubleSlashStart","_validateUri","ret","_strict","scheme","Error","concat","authority","path","query","fragment","test","_schemeFix","_referenceResolution","_slash","_empty","_regexp","URI","schemeOrData","arguments","length","undefined","_classCallCheck","_typeof","_createClass","key","get","uriToFsPath","value","_with","change","Uri","toString","skipEncoding","_asFormatted","toJSON","isUri","thing","fsPath","parse","match","exec","percentDecode","file","replace","idx","indexOf","substring","from","components","strict","result","joinPath","uri","newPath","_len","pathFragment","Array","_key","_paths$win","win32","join","apply","_paths$posix","posix","revive","data","_a","_b","_formatted","external","_fsPath","_sep","_pathSepMarker","_URI","_this","_callSuper","_inherits","res","$mid","encodeTable","_encodeTable","_defineProperty","encodeURIComponentFast","uriComponent","isPath","isAuthority","nativeEncodePos","pos","code","charCodeAt","encodeURIComponent","charAt","substr","escaped","encodeURIComponentMinimal","keepDriveLetterCasing","toLowerCase","encoder","userinfo","lastIndexOf","String","fromCharCode","decodeURIComponentGraceful","str","decodeURIComponent","_rEncodedAsHex"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/base/common/uri.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as paths from './path.js';\nimport { isWindows } from './platform.js';\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\nfunction _validateUri(ret, _strict) {\n    // scheme, must be set\n    if (!ret.scheme && _strict) {\n        throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n    }\n    // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n    // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n    if (ret.scheme && !_schemePattern.test(ret.scheme)) {\n        throw new Error('[UriError]: Scheme contains illegal characters.');\n    }\n    // path, http://tools.ietf.org/html/rfc3986#section-3.3\n    // If a URI contains an authority component, then the path component\n    // must either be empty or begin with a slash (\"/\") character.  If a URI\n    // does not contain an authority component, then the path cannot begin\n    // with two slash characters (\"//\").\n    if (ret.path) {\n        if (ret.authority) {\n            if (!_singleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n            }\n        }\n        else {\n            if (_doubleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n            }\n        }\n    }\n}\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme, _strict) {\n    if (!scheme && !_strict) {\n        return 'file';\n    }\n    return scheme;\n}\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme, path) {\n    // the slash-character is our 'default base' as we don't\n    // support constructing URIs relative to other URIs. This\n    // also means that we alter and potentially break paths.\n    // see https://tools.ietf.org/html/rfc3986#section-5.1.4\n    switch (scheme) {\n        case 'https':\n        case 'http':\n        case 'file':\n            if (!path) {\n                path = _slash;\n            }\n            else if (path[0] !== _slash) {\n                path = _slash + path;\n            }\n            break;\n    }\n    return path;\n}\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport class URI {\n    static isUri(thing) {\n        if (thing instanceof URI) {\n            return true;\n        }\n        if (!thing) {\n            return false;\n        }\n        return typeof thing.authority === 'string'\n            && typeof thing.fragment === 'string'\n            && typeof thing.path === 'string'\n            && typeof thing.query === 'string'\n            && typeof thing.scheme === 'string'\n            && typeof thing.fsPath === 'string'\n            && typeof thing.with === 'function'\n            && typeof thing.toString === 'function';\n    }\n    /**\n     * @internal\n     */\n    constructor(schemeOrData, authority, path, query, fragment, _strict = false) {\n        if (typeof schemeOrData === 'object') {\n            this.scheme = schemeOrData.scheme || _empty;\n            this.authority = schemeOrData.authority || _empty;\n            this.path = schemeOrData.path || _empty;\n            this.query = schemeOrData.query || _empty;\n            this.fragment = schemeOrData.fragment || _empty;\n            // no validation because it's this URI\n            // that creates uri components.\n            // _validateUri(this);\n        }\n        else {\n            this.scheme = _schemeFix(schemeOrData, _strict);\n            this.authority = authority || _empty;\n            this.path = _referenceResolution(this.scheme, path || _empty);\n            this.query = query || _empty;\n            this.fragment = fragment || _empty;\n            _validateUri(this, _strict);\n        }\n    }\n    // ---- filesystem path -----------------------\n    /**\n     * Returns a string representing the corresponding file system path of this URI.\n     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n     * platform specific path separator.\n     *\n     * * Will *not* validate the path for invalid characters and semantics.\n     * * Will *not* look at the scheme of this URI.\n     * * The result shall *not* be used for display purposes but for accessing a file on disk.\n     *\n     *\n     * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n     *\n     * ```ts\n        const u = URI.parse('file://server/c$/folder/file.txt')\n        u.authority === 'server'\n        u.path === '/shares/c$/file.txt'\n        u.fsPath === '\\\\server\\c$\\folder\\file.txt'\n    ```\n     *\n     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n     * with URIs that represent files on disk (`file` scheme).\n     */\n    get fsPath() {\n        // if (this.scheme !== 'file') {\n        // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n        // }\n        return uriToFsPath(this, false);\n    }\n    // ---- modify to new -------------------------\n    with(change) {\n        if (!change) {\n            return this;\n        }\n        let { scheme, authority, path, query, fragment } = change;\n        if (scheme === undefined) {\n            scheme = this.scheme;\n        }\n        else if (scheme === null) {\n            scheme = _empty;\n        }\n        if (authority === undefined) {\n            authority = this.authority;\n        }\n        else if (authority === null) {\n            authority = _empty;\n        }\n        if (path === undefined) {\n            path = this.path;\n        }\n        else if (path === null) {\n            path = _empty;\n        }\n        if (query === undefined) {\n            query = this.query;\n        }\n        else if (query === null) {\n            query = _empty;\n        }\n        if (fragment === undefined) {\n            fragment = this.fragment;\n        }\n        else if (fragment === null) {\n            fragment = _empty;\n        }\n        if (scheme === this.scheme\n            && authority === this.authority\n            && path === this.path\n            && query === this.query\n            && fragment === this.fragment) {\n            return this;\n        }\n        return new Uri(scheme, authority, path, query, fragment);\n    }\n    // ---- parse & validate ------------------------\n    /**\n     * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,\n     * `file:///usr/home`, or `scheme:with/path`.\n     *\n     * @param value A string which represents an URI (see `URI#toString`).\n     */\n    static parse(value, _strict = false) {\n        const match = _regexp.exec(value);\n        if (!match) {\n            return new Uri(_empty, _empty, _empty, _empty, _empty);\n        }\n        return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);\n    }\n    /**\n     * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n     * `/usr/home`, or `\\\\server\\share\\some\\path`.\n     *\n     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n     * `URI.parse('file://' + path)` because the path might contain characters that are\n     * interpreted (# and ?). See the following sample:\n     * ```ts\n    const good = URI.file('/coding/c#/project1');\n    good.scheme === 'file';\n    good.path === '/coding/c#/project1';\n    good.fragment === '';\n    const bad = URI.parse('file://' + '/coding/c#/project1');\n    bad.scheme === 'file';\n    bad.path === '/coding/c'; // path is now broken\n    bad.fragment === '/project1';\n    ```\n     *\n     * @param path A file system path (see `URI#fsPath`)\n     */\n    static file(path) {\n        let authority = _empty;\n        // normalize to fwd-slashes on windows,\n        // on other systems bwd-slashes are valid\n        // filename character, eg /f\\oo/ba\\r.txt\n        if (isWindows) {\n            path = path.replace(/\\\\/g, _slash);\n        }\n        // check for authority as used in UNC shares\n        // or use the path as given\n        if (path[0] === _slash && path[1] === _slash) {\n            const idx = path.indexOf(_slash, 2);\n            if (idx === -1) {\n                authority = path.substring(2);\n                path = _slash;\n            }\n            else {\n                authority = path.substring(2, idx);\n                path = path.substring(idx) || _slash;\n            }\n        }\n        return new Uri('file', authority, path, _empty, _empty);\n    }\n    /**\n     * Creates new URI from uri components.\n     *\n     * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs\n     * validation and should be used for untrusted uri components retrieved from storage,\n     * user input, command arguments etc\n     */\n    static from(components, strict) {\n        const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment, strict);\n        return result;\n    }\n    /**\n     * Join a URI path with path fragments and normalizes the resulting path.\n     *\n     * @param uri The input URI.\n     * @param pathFragment The path fragment to add to the URI path.\n     * @returns The resulting URI.\n     */\n    static joinPath(uri, ...pathFragment) {\n        if (!uri.path) {\n            throw new Error(`[UriError]: cannot call joinPath on URI without path`);\n        }\n        let newPath;\n        if (isWindows && uri.scheme === 'file') {\n            newPath = URI.file(paths.win32.join(uriToFsPath(uri, true), ...pathFragment)).path;\n        }\n        else {\n            newPath = paths.posix.join(uri.path, ...pathFragment);\n        }\n        return uri.with({ path: newPath });\n    }\n    // ---- printing/externalize ---------------------------\n    /**\n     * Creates a string representation for this URI. It's guaranteed that calling\n     * `URI.parse` with the result of this function creates an URI which is equal\n     * to this URI.\n     *\n     * * The result shall *not* be used for display purposes but for externalization or transport.\n     * * The result will be encoded using the percentage encoding and encoding happens mostly\n     * ignore the scheme-specific encoding rules.\n     *\n     * @param skipEncoding Do not encode the result, default is `false`\n     */\n    toString(skipEncoding = false) {\n        return _asFormatted(this, skipEncoding);\n    }\n    toJSON() {\n        return this;\n    }\n    static revive(data) {\n        var _a, _b;\n        if (!data) {\n            return data;\n        }\n        else if (data instanceof URI) {\n            return data;\n        }\n        else {\n            const result = new Uri(data);\n            result._formatted = (_a = data.external) !== null && _a !== void 0 ? _a : null;\n            result._fsPath = data._sep === _pathSepMarker ? (_b = data.fsPath) !== null && _b !== void 0 ? _b : null : null;\n            return result;\n        }\n    }\n}\nconst _pathSepMarker = isWindows ? 1 : undefined;\n// This class exists so that URI is compatible with vscode.Uri (API).\nclass Uri extends URI {\n    constructor() {\n        super(...arguments);\n        this._formatted = null;\n        this._fsPath = null;\n    }\n    get fsPath() {\n        if (!this._fsPath) {\n            this._fsPath = uriToFsPath(this, false);\n        }\n        return this._fsPath;\n    }\n    toString(skipEncoding = false) {\n        if (!skipEncoding) {\n            if (!this._formatted) {\n                this._formatted = _asFormatted(this, false);\n            }\n            return this._formatted;\n        }\n        else {\n            // we don't cache that\n            return _asFormatted(this, true);\n        }\n    }\n    toJSON() {\n        const res = {\n            $mid: 1 /* MarshalledId.Uri */\n        };\n        // cached state\n        if (this._fsPath) {\n            res.fsPath = this._fsPath;\n            res._sep = _pathSepMarker;\n        }\n        if (this._formatted) {\n            res.external = this._formatted;\n        }\n        //--- uri components\n        if (this.path) {\n            res.path = this.path;\n        }\n        // TODO\n        // this isn't correct and can violate the UriComponents contract but\n        // this is part of the vscode.Uri API and we shouldn't change how that\n        // works anymore\n        if (this.scheme) {\n            res.scheme = this.scheme;\n        }\n        if (this.authority) {\n            res.authority = this.authority;\n        }\n        if (this.query) {\n            res.query = this.query;\n        }\n        if (this.fragment) {\n            res.fragment = this.fragment;\n        }\n        return res;\n    }\n}\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable = {\n    [58 /* CharCode.Colon */]: '%3A', // gen-delims\n    [47 /* CharCode.Slash */]: '%2F',\n    [63 /* CharCode.QuestionMark */]: '%3F',\n    [35 /* CharCode.Hash */]: '%23',\n    [91 /* CharCode.OpenSquareBracket */]: '%5B',\n    [93 /* CharCode.CloseSquareBracket */]: '%5D',\n    [64 /* CharCode.AtSign */]: '%40',\n    [33 /* CharCode.ExclamationMark */]: '%21', // sub-delims\n    [36 /* CharCode.DollarSign */]: '%24',\n    [38 /* CharCode.Ampersand */]: '%26',\n    [39 /* CharCode.SingleQuote */]: '%27',\n    [40 /* CharCode.OpenParen */]: '%28',\n    [41 /* CharCode.CloseParen */]: '%29',\n    [42 /* CharCode.Asterisk */]: '%2A',\n    [43 /* CharCode.Plus */]: '%2B',\n    [44 /* CharCode.Comma */]: '%2C',\n    [59 /* CharCode.Semicolon */]: '%3B',\n    [61 /* CharCode.Equals */]: '%3D',\n    [32 /* CharCode.Space */]: '%20',\n};\nfunction encodeURIComponentFast(uriComponent, isPath, isAuthority) {\n    let res = undefined;\n    let nativeEncodePos = -1;\n    for (let pos = 0; pos < uriComponent.length; pos++) {\n        const code = uriComponent.charCodeAt(pos);\n        // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n        if ((code >= 97 /* CharCode.a */ && code <= 122 /* CharCode.z */)\n            || (code >= 65 /* CharCode.A */ && code <= 90 /* CharCode.Z */)\n            || (code >= 48 /* CharCode.Digit0 */ && code <= 57 /* CharCode.Digit9 */)\n            || code === 45 /* CharCode.Dash */\n            || code === 46 /* CharCode.Period */\n            || code === 95 /* CharCode.Underline */\n            || code === 126 /* CharCode.Tilde */\n            || (isPath && code === 47 /* CharCode.Slash */)\n            || (isAuthority && code === 91 /* CharCode.OpenSquareBracket */)\n            || (isAuthority && code === 93 /* CharCode.CloseSquareBracket */)\n            || (isAuthority && code === 58 /* CharCode.Colon */)) {\n            // check if we are delaying native encode\n            if (nativeEncodePos !== -1) {\n                res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n                nativeEncodePos = -1;\n            }\n            // check if we write into a new string (by default we try to return the param)\n            if (res !== undefined) {\n                res += uriComponent.charAt(pos);\n            }\n        }\n        else {\n            // encoding needed, we need to allocate a new string\n            if (res === undefined) {\n                res = uriComponent.substr(0, pos);\n            }\n            // check with default table first\n            const escaped = encodeTable[code];\n            if (escaped !== undefined) {\n                // check if we are delaying native encode\n                if (nativeEncodePos !== -1) {\n                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n                    nativeEncodePos = -1;\n                }\n                // append escaped variant to result\n                res += escaped;\n            }\n            else if (nativeEncodePos === -1) {\n                // use native encode only when needed\n                nativeEncodePos = pos;\n            }\n        }\n    }\n    if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n    }\n    return res !== undefined ? res : uriComponent;\n}\nfunction encodeURIComponentMinimal(path) {\n    let res = undefined;\n    for (let pos = 0; pos < path.length; pos++) {\n        const code = path.charCodeAt(pos);\n        if (code === 35 /* CharCode.Hash */ || code === 63 /* CharCode.QuestionMark */) {\n            if (res === undefined) {\n                res = path.substr(0, pos);\n            }\n            res += encodeTable[code];\n        }\n        else {\n            if (res !== undefined) {\n                res += path[pos];\n            }\n        }\n    }\n    return res !== undefined ? res : path;\n}\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri, keepDriveLetterCasing) {\n    let value;\n    if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n        // unc path: file://shares/c$/far/boo\n        value = `//${uri.authority}${uri.path}`;\n    }\n    else if (uri.path.charCodeAt(0) === 47 /* CharCode.Slash */\n        && (uri.path.charCodeAt(1) >= 65 /* CharCode.A */ && uri.path.charCodeAt(1) <= 90 /* CharCode.Z */ || uri.path.charCodeAt(1) >= 97 /* CharCode.a */ && uri.path.charCodeAt(1) <= 122 /* CharCode.z */)\n        && uri.path.charCodeAt(2) === 58 /* CharCode.Colon */) {\n        if (!keepDriveLetterCasing) {\n            // windows drive letter: file:///c:/far/boo\n            value = uri.path[1].toLowerCase() + uri.path.substr(2);\n        }\n        else {\n            value = uri.path.substr(1);\n        }\n    }\n    else {\n        // other path\n        value = uri.path;\n    }\n    if (isWindows) {\n        value = value.replace(/\\//g, '\\\\');\n    }\n    return value;\n}\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri, skipEncoding) {\n    const encoder = !skipEncoding\n        ? encodeURIComponentFast\n        : encodeURIComponentMinimal;\n    let res = '';\n    let { scheme, authority, path, query, fragment } = uri;\n    if (scheme) {\n        res += scheme;\n        res += ':';\n    }\n    if (authority || scheme === 'file') {\n        res += _slash;\n        res += _slash;\n    }\n    if (authority) {\n        let idx = authority.indexOf('@');\n        if (idx !== -1) {\n            // <user>@<auth>\n            const userinfo = authority.substr(0, idx);\n            authority = authority.substr(idx + 1);\n            idx = userinfo.lastIndexOf(':');\n            if (idx === -1) {\n                res += encoder(userinfo, false, false);\n            }\n            else {\n                // <user>:<pass>@<auth>\n                res += encoder(userinfo.substr(0, idx), false, false);\n                res += ':';\n                res += encoder(userinfo.substr(idx + 1), false, true);\n            }\n            res += '@';\n        }\n        authority = authority.toLowerCase();\n        idx = authority.lastIndexOf(':');\n        if (idx === -1) {\n            res += encoder(authority, false, true);\n        }\n        else {\n            // <auth>:<port>\n            res += encoder(authority.substr(0, idx), false, true);\n            res += authority.substr(idx);\n        }\n    }\n    if (path) {\n        // lower-case windows drive letters in /C:/fff or C:/fff\n        if (path.length >= 3 && path.charCodeAt(0) === 47 /* CharCode.Slash */ && path.charCodeAt(2) === 58 /* CharCode.Colon */) {\n            const code = path.charCodeAt(1);\n            if (code >= 65 /* CharCode.A */ && code <= 90 /* CharCode.Z */) {\n                path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n            }\n        }\n        else if (path.length >= 2 && path.charCodeAt(1) === 58 /* CharCode.Colon */) {\n            const code = path.charCodeAt(0);\n            if (code >= 65 /* CharCode.A */ && code <= 90 /* CharCode.Z */) {\n                path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n            }\n        }\n        // encode the rest of the path\n        res += encoder(path, true, false);\n    }\n    if (query) {\n        res += '?';\n        res += encoder(query, false, false);\n    }\n    if (fragment) {\n        res += '#';\n        res += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;\n    }\n    return res;\n}\n// --- decode\nfunction decodeURIComponentGraceful(str) {\n    try {\n        return decodeURIComponent(str);\n    }\n    catch (_a) {\n        if (str.length > 3) {\n            return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n        }\n        else {\n            return str;\n        }\n    }\n}\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\nfunction percentDecode(str) {\n    if (!str.match(_rEncodedAsHex)) {\n        return str;\n    }\n    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}