{"ast":null,"code":"import _slicedToArray from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.typed-array.uint16-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport var RichEditBracket = /*#__PURE__*/function () {\n  function RichEditBracket(languageId, index, open, close, forwardRegex, reversedRegex) {\n    _classCallCheck(this, RichEditBracket);\n    this._richEditBracketBrand = undefined;\n    this.languageId = languageId;\n    this.index = index;\n    this.open = open;\n    this.close = close;\n    this.forwardRegex = forwardRegex;\n    this.reversedRegex = reversedRegex;\n    this._openSet = RichEditBracket._toSet(this.open);\n    this._closeSet = RichEditBracket._toSet(this.close);\n  }\n  /**\n   * Check if the provided `text` is an open bracket in this group.\n   */\n  return _createClass(RichEditBracket, [{\n    key: \"isOpen\",\n    value: function isOpen(text) {\n      return this._openSet.has(text);\n    }\n    /**\n     * Check if the provided `text` is a close bracket in this group.\n     */\n  }, {\n    key: \"isClose\",\n    value: function isClose(text) {\n      return this._closeSet.has(text);\n    }\n  }], [{\n    key: \"_toSet\",\n    value: function _toSet(arr) {\n      var result = new Set();\n      var _iterator = _createForOfIteratorHelper(arr),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var element = _step.value;\n          result.add(element);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return result;\n    }\n  }]);\n}();\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets) {\n  var N = brackets.length;\n  brackets = brackets.map(function (b) {\n    return [b[0].toLowerCase(), b[1].toLowerCase()];\n  });\n  var group = [];\n  for (var i = 0; i < N; i++) {\n    group[i] = i;\n  }\n  var areOverlapping = function areOverlapping(a, b) {\n    var _a = _slicedToArray(a, 2),\n      aOpen = _a[0],\n      aClose = _a[1];\n    var _b = _slicedToArray(b, 2),\n      bOpen = _b[0],\n      bClose = _b[1];\n    return aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose;\n  };\n  var mergeGroups = function mergeGroups(g1, g2) {\n    var newG = Math.min(g1, g2);\n    var oldG = Math.max(g1, g2);\n    for (var _i = 0; _i < N; _i++) {\n      if (group[_i] === oldG) {\n        group[_i] = newG;\n      }\n    }\n  };\n  // group together brackets that have the same open or the same close sequence\n  for (var _i2 = 0; _i2 < N; _i2++) {\n    var a = brackets[_i2];\n    for (var j = _i2 + 1; j < N; j++) {\n      var b = brackets[j];\n      if (areOverlapping(a, b)) {\n        mergeGroups(group[_i2], group[j]);\n      }\n    }\n  }\n  var result = [];\n  for (var g = 0; g < N; g++) {\n    var currentOpen = [];\n    var currentClose = [];\n    for (var _i3 = 0; _i3 < N; _i3++) {\n      if (group[_i3] === g) {\n        var _brackets$_i = _slicedToArray(brackets[_i3], 2),\n          open = _brackets$_i[0],\n          close = _brackets$_i[1];\n        currentOpen.push(open);\n        currentClose.push(close);\n      }\n    }\n    if (currentOpen.length > 0) {\n      result.push({\n        open: currentOpen,\n        close: currentClose\n      });\n    }\n  }\n  return result;\n}\nexport var RichEditBrackets = /*#__PURE__*/_createClass(function RichEditBrackets(languageId, _brackets) {\n  _classCallCheck(this, RichEditBrackets);\n  this._richEditBracketsBrand = undefined;\n  var brackets = groupFuzzyBrackets(_brackets);\n  this.brackets = brackets.map(function (b, index) {\n    return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n  });\n  this.forwardRegex = getRegexForBrackets(this.brackets);\n  this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n  this.textIsBracket = {};\n  this.textIsOpenBracket = {};\n  this.maxBracketLength = 0;\n  var _iterator2 = _createForOfIteratorHelper(this.brackets),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var bracket = _step2.value;\n      var _iterator3 = _createForOfIteratorHelper(bracket.open),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var open = _step3.value;\n          this.textIsBracket[open] = bracket;\n          this.textIsOpenBracket[open] = true;\n          this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      var _iterator4 = _createForOfIteratorHelper(bracket.close),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var close = _step4.value;\n          this.textIsBracket[close] = bracket;\n          this.textIsOpenBracket[close] = false;\n          this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n});\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n  for (var i = 0, len = brackets.length; i < len; i++) {\n    if (i === currentIndex) {\n      continue;\n    }\n    var bracket = brackets[i];\n    var _iterator5 = _createForOfIteratorHelper(bracket.open),\n      _step5;\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var open = _step5.value;\n        if (open.indexOf(str) >= 0) {\n          dest.push(open);\n        }\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n    var _iterator6 = _createForOfIteratorHelper(bracket.close),\n      _step6;\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var close = _step6.value;\n        if (close.indexOf(str) >= 0) {\n          dest.push(close);\n        }\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n  }\n}\nfunction lengthcmp(a, b) {\n  return a.length - b.length;\n}\nfunction unique(arr) {\n  if (arr.length <= 1) {\n    return arr;\n  }\n  var result = [];\n  var seen = new Set();\n  var _iterator7 = _createForOfIteratorHelper(arr),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var element = _step7.value;\n      if (seen.has(element)) {\n        continue;\n      }\n      result.push(element);\n      seen.add(element);\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  return result;\n}\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n  // search in all brackets for other brackets that are a superstring of these brackets\n  var pieces = [];\n  pieces = pieces.concat(open);\n  pieces = pieces.concat(close);\n  for (var i = 0, len = pieces.length; i < len; i++) {\n    collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n  }\n  pieces = unique(pieces);\n  pieces.sort(lengthcmp);\n  pieces.reverse();\n  return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n  // search in all brackets for other brackets that are a superstring of these brackets\n  var pieces = [];\n  pieces = pieces.concat(open);\n  pieces = pieces.concat(close);\n  for (var i = 0, len = pieces.length; i < len; i++) {\n    collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n  }\n  pieces = unique(pieces);\n  pieces.sort(lengthcmp);\n  pieces.reverse();\n  return createBracketOrRegExp(pieces.map(toReversedString));\n}\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets) {\n  var pieces = [];\n  var _iterator8 = _createForOfIteratorHelper(brackets),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var bracket = _step8.value;\n      var _iterator9 = _createForOfIteratorHelper(bracket.open),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var open = _step9.value;\n          pieces.push(open);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n      var _iterator10 = _createForOfIteratorHelper(bracket.close),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var close = _step10.value;\n          pieces.push(close);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n  pieces = unique(pieces);\n  return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets) {\n  var pieces = [];\n  var _iterator11 = _createForOfIteratorHelper(brackets),\n    _step11;\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var bracket = _step11.value;\n      var _iterator12 = _createForOfIteratorHelper(bracket.open),\n        _step12;\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var open = _step12.value;\n          pieces.push(open);\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n      var _iterator13 = _createForOfIteratorHelper(bracket.close),\n        _step13;\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var close = _step13.value;\n          pieces.push(close);\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n  pieces = unique(pieces);\n  return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n  // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n  var insertWordBoundaries = /^[\\w ]+$/.test(str);\n  str = strings.escapeRegExpCharacters(str);\n  return insertWordBoundaries ? \"\\\\b\".concat(str, \"\\\\b\") : str;\n}\nfunction createBracketOrRegExp(pieces) {\n  var regexStr = \"(\".concat(pieces.map(prepareBracketForRegExp).join(')|('), \")\");\n  return strings.createRegExp(regexStr, true);\n}\nvar toReversedString = function () {\n  function reverse(str) {\n    // create a Uint16Array and then use a TextDecoder to create a string\n    var arr = new Uint16Array(str.length);\n    var offset = 0;\n    for (var i = str.length - 1; i >= 0; i--) {\n      arr[offset++] = str.charCodeAt(i);\n    }\n    return stringBuilder.getPlatformTextDecoder().decode(arr);\n  }\n  var lastInput = null;\n  var lastOutput = null;\n  return function toReversedString(str) {\n    if (lastInput !== str) {\n      lastInput = str;\n      lastOutput = reverse(lastInput);\n    }\n    return lastOutput;\n  };\n}();\nexport var BracketsUtils = /*#__PURE__*/function () {\n  function BracketsUtils() {\n    _classCallCheck(this, BracketsUtils);\n  }\n  return _createClass(BracketsUtils, null, [{\n    key: \"_findPrevBracketInText\",\n    value: function _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n      var m = reversedText.match(reversedBracketRegex);\n      if (!m) {\n        return null;\n      }\n      var matchOffset = reversedText.length - (m.index || 0);\n      var matchLength = m[0].length;\n      var absoluteMatchOffset = offset + matchOffset;\n      return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n    }\n  }, {\n    key: \"findPrevBracketInRange\",\n    value: function findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n      // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n      var reversedLineText = toReversedString(lineText);\n      var reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n      return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n    }\n  }, {\n    key: \"findNextBracketInText\",\n    value: function findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n      var m = text.match(bracketRegex);\n      if (!m) {\n        return null;\n      }\n      var matchOffset = m.index || 0;\n      var matchLength = m[0].length;\n      if (matchLength === 0) {\n        return null;\n      }\n      var absoluteMatchOffset = offset + matchOffset;\n      return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n    }\n  }, {\n    key: \"findNextBracketInRange\",\n    value: function findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n      var substr = lineText.substring(startOffset, endOffset);\n      return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n    }\n  }]);\n}();","map":{"version":3,"names":["strings","stringBuilder","Range","RichEditBracket","languageId","index","open","close","forwardRegex","reversedRegex","_classCallCheck","_richEditBracketBrand","undefined","_openSet","_toSet","_closeSet","_createClass","key","value","isOpen","text","has","isClose","arr","result","Set","_iterator","_createForOfIteratorHelper","_step","s","n","done","element","add","err","e","f","groupFuzzyBrackets","brackets","N","length","map","b","toLowerCase","group","i","areOverlapping","a","_a","_slicedToArray","aOpen","aClose","_b","bOpen","bClose","mergeGroups","g1","g2","newG","Math","min","oldG","max","j","g","currentOpen","currentClose","_brackets$_i","push","RichEditBrackets","_brackets","_richEditBracketsBrand","getRegexForBracketPair","getReversedRegexForBracketPair","getRegexForBrackets","getReversedRegexForBrackets","textIsBracket","textIsOpenBracket","maxBracketLength","_iterator2","_step2","bracket","_iterator3","_step3","_iterator4","_step4","collectSuperstrings","str","currentIndex","dest","len","_iterator5","_step5","indexOf","_iterator6","_step6","lengthcmp","unique","seen","_iterator7","_step7","pieces","concat","sort","reverse","createBracketOrRegExp","toReversedString","_iterator8","_step8","_iterator9","_step9","_iterator10","_step10","_iterator11","_step11","_iterator12","_step12","_iterator13","_step13","prepareBracketForRegExp","insertWordBoundaries","test","escapeRegExpCharacters","regexStr","join","createRegExp","Uint16Array","offset","charCodeAt","getPlatformTextDecoder","decode","lastInput","lastOutput","BracketsUtils","_findPrevBracketInText","reversedBracketRegex","lineNumber","reversedText","m","match","matchOffset","matchLength","absoluteMatchOffset","findPrevBracketInRange","lineText","startOffset","endOffset","reversedLineText","reversedSubstr","substring","findNextBracketInText","bracketRegex","findNextBracketInRange","substr"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n    constructor(languageId, index, open, close, forwardRegex, reversedRegex) {\n        this._richEditBracketBrand = undefined;\n        this.languageId = languageId;\n        this.index = index;\n        this.open = open;\n        this.close = close;\n        this.forwardRegex = forwardRegex;\n        this.reversedRegex = reversedRegex;\n        this._openSet = RichEditBracket._toSet(this.open);\n        this._closeSet = RichEditBracket._toSet(this.close);\n    }\n    /**\n     * Check if the provided `text` is an open bracket in this group.\n     */\n    isOpen(text) {\n        return this._openSet.has(text);\n    }\n    /**\n     * Check if the provided `text` is a close bracket in this group.\n     */\n    isClose(text) {\n        return this._closeSet.has(text);\n    }\n    static _toSet(arr) {\n        const result = new Set();\n        for (const element of arr) {\n            result.add(element);\n        }\n        return result;\n    }\n}\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets) {\n    const N = brackets.length;\n    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n    const group = [];\n    for (let i = 0; i < N; i++) {\n        group[i] = i;\n    }\n    const areOverlapping = (a, b) => {\n        const [aOpen, aClose] = a;\n        const [bOpen, bClose] = b;\n        return (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n    };\n    const mergeGroups = (g1, g2) => {\n        const newG = Math.min(g1, g2);\n        const oldG = Math.max(g1, g2);\n        for (let i = 0; i < N; i++) {\n            if (group[i] === oldG) {\n                group[i] = newG;\n            }\n        }\n    };\n    // group together brackets that have the same open or the same close sequence\n    for (let i = 0; i < N; i++) {\n        const a = brackets[i];\n        for (let j = i + 1; j < N; j++) {\n            const b = brackets[j];\n            if (areOverlapping(a, b)) {\n                mergeGroups(group[i], group[j]);\n            }\n        }\n    }\n    const result = [];\n    for (let g = 0; g < N; g++) {\n        const currentOpen = [];\n        const currentClose = [];\n        for (let i = 0; i < N; i++) {\n            if (group[i] === g) {\n                const [open, close] = brackets[i];\n                currentOpen.push(open);\n                currentClose.push(close);\n            }\n        }\n        if (currentOpen.length > 0) {\n            result.push({\n                open: currentOpen,\n                close: currentClose\n            });\n        }\n    }\n    return result;\n}\nexport class RichEditBrackets {\n    constructor(languageId, _brackets) {\n        this._richEditBracketsBrand = undefined;\n        const brackets = groupFuzzyBrackets(_brackets);\n        this.brackets = brackets.map((b, index) => {\n            return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n        });\n        this.forwardRegex = getRegexForBrackets(this.brackets);\n        this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n        this.textIsBracket = {};\n        this.textIsOpenBracket = {};\n        this.maxBracketLength = 0;\n        for (const bracket of this.brackets) {\n            for (const open of bracket.open) {\n                this.textIsBracket[open] = bracket;\n                this.textIsOpenBracket[open] = true;\n                this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n            }\n            for (const close of bracket.close) {\n                this.textIsBracket[close] = bracket;\n                this.textIsOpenBracket[close] = false;\n                this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n            }\n        }\n    }\n}\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n    for (let i = 0, len = brackets.length; i < len; i++) {\n        if (i === currentIndex) {\n            continue;\n        }\n        const bracket = brackets[i];\n        for (const open of bracket.open) {\n            if (open.indexOf(str) >= 0) {\n                dest.push(open);\n            }\n        }\n        for (const close of bracket.close) {\n            if (close.indexOf(str) >= 0) {\n                dest.push(close);\n            }\n        }\n    }\n}\nfunction lengthcmp(a, b) {\n    return a.length - b.length;\n}\nfunction unique(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const result = [];\n    const seen = new Set();\n    for (const element of arr) {\n        if (seen.has(element)) {\n            continue;\n        }\n        result.push(element);\n        seen.add(element);\n    }\n    return result;\n}\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n    const insertWordBoundaries = (/^[\\w ]+$/.test(str));\n    str = strings.escapeRegExpCharacters(str);\n    return (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\nfunction createBracketOrRegExp(pieces) {\n    const regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n    return strings.createRegExp(regexStr, true);\n}\nconst toReversedString = (function () {\n    function reverse(str) {\n        // create a Uint16Array and then use a TextDecoder to create a string\n        const arr = new Uint16Array(str.length);\n        let offset = 0;\n        for (let i = str.length - 1; i >= 0; i--) {\n            arr[offset++] = str.charCodeAt(i);\n        }\n        return stringBuilder.getPlatformTextDecoder().decode(arr);\n    }\n    let lastInput = null;\n    let lastOutput = null;\n    return function toReversedString(str) {\n        if (lastInput !== str) {\n            lastInput = str;\n            lastOutput = reverse(lastInput);\n        }\n        return lastOutput;\n    };\n})();\nexport class BracketsUtils {\n    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n        const m = reversedText.match(reversedBracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = reversedText.length - (m.index || 0);\n        const matchLength = m[0].length;\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n    }\n    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n        const reversedLineText = toReversedString(lineText);\n        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n    }\n    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n        const m = text.match(bracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = m.index || 0;\n        const matchLength = m[0].length;\n        if (matchLength === 0) {\n            return null;\n        }\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n    }\n    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        const substr = lineText.substring(startOffset, endOffset);\n        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}