{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.reverse.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../core/range.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthOfString, lengthToObj, positionToLength, toLength } from './length.js';\nexport var TextEditInfo = /*#__PURE__*/function () {\n  function TextEditInfo(startOffset, endOffset, newLength) {\n    _classCallCheck(this, TextEditInfo);\n    this.startOffset = startOffset;\n    this.endOffset = endOffset;\n    this.newLength = newLength;\n  }\n  return _createClass(TextEditInfo, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"[\".concat(lengthToObj(this.startOffset), \"...\").concat(lengthToObj(this.endOffset), \") -> \").concat(lengthToObj(this.newLength));\n    }\n  }], [{\n    key: \"fromModelContentChanges\",\n    value: function fromModelContentChanges(changes) {\n      // Must be sorted in ascending order\n      var edits = changes.map(function (c) {\n        var range = Range.lift(c.range);\n        return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n      }).reverse();\n      return edits;\n    }\n  }]);\n}();\nexport var BeforeEditPositionMapper = /*#__PURE__*/function () {\n  /**\n   * @param edits Must be sorted by offset in ascending order.\n  */\n  function BeforeEditPositionMapper(edits) {\n    _classCallCheck(this, BeforeEditPositionMapper);\n    this.nextEditIdx = 0;\n    this.deltaOldToNewLineCount = 0;\n    this.deltaOldToNewColumnCount = 0;\n    this.deltaLineIdxInOld = -1;\n    this.edits = edits.map(function (edit) {\n      return TextEditInfoCache.from(edit);\n    });\n  }\n  /**\n   * @param offset Must be equal to or greater than the last offset this method has been called with.\n  */\n  return _createClass(BeforeEditPositionMapper, [{\n    key: \"getOffsetBeforeChange\",\n    value: function getOffsetBeforeChange(offset) {\n      this.adjustNextEdit(offset);\n      return this.translateCurToOld(offset);\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n     * Returns null if there is no edit anymore.\n    */\n  }, {\n    key: \"getDistanceToNextChange\",\n    value: function getDistanceToNextChange(offset) {\n      this.adjustNextEdit(offset);\n      var nextEdit = this.edits[this.nextEditIdx];\n      var nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : null;\n      if (nextChangeOffset === null) {\n        return null;\n      }\n      return lengthDiffNonNegative(offset, nextChangeOffset);\n    }\n  }, {\n    key: \"translateOldToCur\",\n    value: function translateOldToCur(oldOffsetObj) {\n      if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n        return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n      } else {\n        return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n      }\n    }\n  }, {\n    key: \"translateCurToOld\",\n    value: function translateCurToOld(newOffset) {\n      var offsetObj = lengthToObj(newOffset);\n      if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n        return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n      } else {\n        return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n      }\n    }\n  }, {\n    key: \"adjustNextEdit\",\n    value: function adjustNextEdit(offset) {\n      while (this.nextEditIdx < this.edits.length) {\n        var nextEdit = this.edits[this.nextEditIdx];\n        // After applying the edit, what is its end offset (considering all previous edits)?\n        var nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n        if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n          // We are after the edit, skip it\n          this.nextEditIdx++;\n          var nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n          // Before applying the edit, what is its end offset (considering all previous edits)?\n          var nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n          var lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n          this.deltaOldToNewLineCount += lineDelta;\n          var previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n          var columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n          this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n          this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n        } else {\n          // We are in or before the edit.\n          break;\n        }\n      }\n    }\n  }]);\n}();\nvar TextEditInfoCache = /*#__PURE__*/function () {\n  function TextEditInfoCache(startOffset, endOffset, textLength) {\n    _classCallCheck(this, TextEditInfoCache);\n    this.endOffsetBeforeObj = lengthToObj(endOffset);\n    this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n    this.offsetObj = lengthToObj(startOffset);\n  }\n  return _createClass(TextEditInfoCache, null, [{\n    key: \"from\",\n    value: function from(edit) {\n      return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n    }\n  }]);\n}();","map":{"version":3,"names":["Range","lengthAdd","lengthDiffNonNegative","lengthLessThanEqual","lengthOfString","lengthToObj","positionToLength","toLength","TextEditInfo","startOffset","endOffset","newLength","_classCallCheck","_createClass","key","value","toString","concat","fromModelContentChanges","changes","edits","map","c","range","lift","getStartPosition","getEndPosition","text","reverse","BeforeEditPositionMapper","nextEditIdx","deltaOldToNewLineCount","deltaOldToNewColumnCount","deltaLineIdxInOld","edit","TextEditInfoCache","from","getOffsetBeforeChange","offset","adjustNextEdit","translateCurToOld","getDistanceToNextChange","nextEdit","nextChangeOffset","translateOldToCur","offsetObj","oldOffsetObj","lineCount","columnCount","newOffset","length","nextEditEndOffsetInCur","endOffsetAfterObj","nextEditEndOffsetInCurObj","nextEditEndOffsetBeforeInCurObj","endOffsetBeforeObj","lineDelta","previousColumnDelta","columnDelta","textLength"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../core/range.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthOfString, lengthToObj, positionToLength, toLength } from './length.js';\nexport class TextEditInfo {\n    static fromModelContentChanges(changes) {\n        // Must be sorted in ascending order\n        const edits = changes.map(c => {\n            const range = Range.lift(c.range);\n            return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n        }).reverse();\n        return edits;\n    }\n    constructor(startOffset, endOffset, newLength) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.newLength = newLength;\n    }\n    toString() {\n        return `[${lengthToObj(this.startOffset)}...${lengthToObj(this.endOffset)}) -> ${lengthToObj(this.newLength)}`;\n    }\n}\nexport class BeforeEditPositionMapper {\n    /**\n     * @param edits Must be sorted by offset in ascending order.\n    */\n    constructor(edits) {\n        this.nextEditIdx = 0;\n        this.deltaOldToNewLineCount = 0;\n        this.deltaOldToNewColumnCount = 0;\n        this.deltaLineIdxInOld = -1;\n        this.edits = edits.map(edit => TextEditInfoCache.from(edit));\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getOffsetBeforeChange(offset) {\n        this.adjustNextEdit(offset);\n        return this.translateCurToOld(offset);\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n     * Returns null if there is no edit anymore.\n    */\n    getDistanceToNextChange(offset) {\n        this.adjustNextEdit(offset);\n        const nextEdit = this.edits[this.nextEditIdx];\n        const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : null;\n        if (nextChangeOffset === null) {\n            return null;\n        }\n        return lengthDiffNonNegative(offset, nextChangeOffset);\n    }\n    translateOldToCur(oldOffsetObj) {\n        if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n        }\n    }\n    translateCurToOld(newOffset) {\n        const offsetObj = lengthToObj(newOffset);\n        if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n        }\n    }\n    adjustNextEdit(offset) {\n        while (this.nextEditIdx < this.edits.length) {\n            const nextEdit = this.edits[this.nextEditIdx];\n            // After applying the edit, what is its end offset (considering all previous edits)?\n            const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n            if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n                // We are after the edit, skip it\n                this.nextEditIdx++;\n                const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n                // Before applying the edit, what is its end offset (considering all previous edits)?\n                const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n                const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n                this.deltaOldToNewLineCount += lineDelta;\n                const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n                const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n                this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n                this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n            }\n            else {\n                // We are in or before the edit.\n                break;\n            }\n        }\n    }\n}\nclass TextEditInfoCache {\n    static from(edit) {\n        return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n    }\n    constructor(startOffset, endOffset, textLength) {\n        this.endOffsetBeforeObj = lengthToObj(endOffset);\n        this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n        this.offsetObj = lengthToObj(startOffset);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}