{"ast":null,"code":"import _slicedToArray from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _callSuper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _wrapNativeSuper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.date.now.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.number.to-fixed.js\";\nimport \"core-js/modules/es.object.create.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.reflect.construct.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.starts-with.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { GlobalIdleValue } from '../../../base/common/async.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport { SyncDescriptor } from './descriptors.js';\nimport { Graph } from './graph.js';\nimport { IInstantiationService, _util } from './instantiation.js';\nimport { ServiceCollection } from './serviceCollection.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\n// TRACING\nvar _enableAllTracing = false;\nvar CyclicDependencyError = /*#__PURE__*/function (_Error) {\n  function CyclicDependencyError(graph) {\n    var _this;\n    _classCallCheck(this, CyclicDependencyError);\n    var _a;\n    _this = _callSuper(this, CyclicDependencyError, ['cyclic dependency between services']);\n    _this.message = (_a = graph.findCycleSlow()) !== null && _a !== void 0 ? _a : \"UNABLE to detect cycle, dumping graph: \\n\".concat(graph.toString());\n    return _this;\n  }\n  _inherits(CyclicDependencyError, _Error);\n  return _createClass(CyclicDependencyError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nexport var InstantiationService = /*#__PURE__*/function () {\n  function InstantiationService() {\n    var _services = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new ServiceCollection();\n    var _strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var _parent = arguments.length > 2 ? arguments[2] : undefined;\n    var _enableTracing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _enableAllTracing;\n    _classCallCheck(this, InstantiationService);\n    var _a;\n    this._services = _services;\n    this._strict = _strict;\n    this._parent = _parent;\n    this._enableTracing = _enableTracing;\n    this._activeInstantiations = new Set();\n    this._services.set(IInstantiationService, this);\n    this._globalGraph = _enableTracing ? (_a = _parent === null || _parent === void 0 ? void 0 : _parent._globalGraph) !== null && _a !== void 0 ? _a : new Graph(function (e) {\n      return e;\n    }) : undefined;\n  }\n  return _createClass(InstantiationService, [{\n    key: \"createChild\",\n    value: function createChild(services) {\n      return new InstantiationService(services, this._strict, this, this._enableTracing);\n    }\n  }, {\n    key: \"invokeFunction\",\n    value: function invokeFunction(fn) {\n      var _this2 = this;\n      var _trace = Trace.traceInvocation(this._enableTracing, fn);\n      var _done = false;\n      try {\n        var accessor = {\n          get: function get(id) {\n            if (_done) {\n              throw illegalState('service accessor is only valid during the invocation of its target method');\n            }\n            var result = _this2._getOrCreateServiceInstance(id, _trace);\n            if (!result) {\n              throw new Error(\"[invokeFunction] unknown service '\".concat(id, \"'\"));\n            }\n            return result;\n          }\n        };\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        return fn.apply(void 0, [accessor].concat(args));\n      } finally {\n        _done = true;\n        _trace.stop();\n      }\n    }\n  }, {\n    key: \"createInstance\",\n    value: function createInstance(ctorOrDescriptor) {\n      var _trace;\n      var result;\n      for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        rest[_key2 - 1] = arguments[_key2];\n      }\n      if (ctorOrDescriptor instanceof SyncDescriptor) {\n        _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor.ctor);\n        result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n      } else {\n        _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor);\n        result = this._createInstance(ctorOrDescriptor, rest, _trace);\n      }\n      _trace.stop();\n      return result;\n    }\n  }, {\n    key: \"_createInstance\",\n    value: function _createInstance(ctor) {\n      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var _trace = arguments.length > 2 ? arguments[2] : undefined;\n      // arguments defined by service decorators\n      var serviceDependencies = _util.getServiceDependencies(ctor).sort(function (a, b) {\n        return a.index - b.index;\n      });\n      var serviceArgs = [];\n      var _iterator = _createForOfIteratorHelper(serviceDependencies),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var dependency = _step.value;\n          var service = this._getOrCreateServiceInstance(dependency.id, _trace);\n          if (!service) {\n            this._throwIfStrict(\"[createInstance] \".concat(ctor.name, \" depends on UNKNOWN service \").concat(dependency.id, \".\"), false);\n          }\n          serviceArgs.push(service);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n      // check for argument mismatches, adjust static args if needed\n      if (args.length !== firstServiceArgPos) {\n        console.trace(\"[createInstance] First service dependency of \".concat(ctor.name, \" at position \").concat(firstServiceArgPos + 1, \" conflicts with \").concat(args.length, \" static arguments\"));\n        var delta = firstServiceArgPos - args.length;\n        if (delta > 0) {\n          args = args.concat(new Array(delta));\n        } else {\n          args = args.slice(0, firstServiceArgPos);\n        }\n      }\n      // now create the instance\n      return Reflect.construct(ctor, args.concat(serviceArgs));\n    }\n  }, {\n    key: \"_setServiceInstance\",\n    value: function _setServiceInstance(id, instance) {\n      if (this._services.get(id) instanceof SyncDescriptor) {\n        this._services.set(id, instance);\n      } else if (this._parent) {\n        this._parent._setServiceInstance(id, instance);\n      } else {\n        throw new Error('illegalState - setting UNKNOWN service instance');\n      }\n    }\n  }, {\n    key: \"_getServiceInstanceOrDescriptor\",\n    value: function _getServiceInstanceOrDescriptor(id) {\n      var instanceOrDesc = this._services.get(id);\n      if (!instanceOrDesc && this._parent) {\n        return this._parent._getServiceInstanceOrDescriptor(id);\n      } else {\n        return instanceOrDesc;\n      }\n    }\n  }, {\n    key: \"_getOrCreateServiceInstance\",\n    value: function _getOrCreateServiceInstance(id, _trace) {\n      if (this._globalGraph && this._globalGraphImplicitDependency) {\n        this._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(id));\n      }\n      var thing = this._getServiceInstanceOrDescriptor(id);\n      if (thing instanceof SyncDescriptor) {\n        return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n      } else {\n        _trace.branch(id, false);\n        return thing;\n      }\n    }\n  }, {\n    key: \"_safeCreateAndCacheServiceInstance\",\n    value: function _safeCreateAndCacheServiceInstance(id, desc, _trace) {\n      if (this._activeInstantiations.has(id)) {\n        throw new Error(\"illegal state - RECURSIVELY instantiating service '\".concat(id, \"'\"));\n      }\n      this._activeInstantiations.add(id);\n      try {\n        return this._createAndCacheServiceInstance(id, desc, _trace);\n      } finally {\n        this._activeInstantiations[\"delete\"](id);\n      }\n    }\n  }, {\n    key: \"_createAndCacheServiceInstance\",\n    value: function _createAndCacheServiceInstance(id, desc, _trace) {\n      var _a;\n      var graph = new Graph(function (data) {\n        return data.id.toString();\n      });\n      var cycleCount = 0;\n      var stack = [{\n        id: id,\n        desc: desc,\n        _trace: _trace\n      }];\n      while (stack.length) {\n        var item = stack.pop();\n        graph.lookupOrInsertNode(item);\n        // a weak but working heuristic for cycle checks\n        if (cycleCount++ > 1000) {\n          throw new CyclicDependencyError(graph);\n        }\n        // check all dependencies for existence and if they need to be created first\n        var _iterator2 = _createForOfIteratorHelper(_util.getServiceDependencies(item.desc.ctor)),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var dependency = _step2.value;\n            var instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n            if (!instanceOrDesc) {\n              this._throwIfStrict(\"[createInstance] \".concat(id, \" depends on \").concat(dependency.id, \" which is NOT registered.\"), true);\n            }\n            // take note of all service dependencies\n            (_a = this._globalGraph) === null || _a === void 0 ? void 0 : _a.insertEdge(String(item.id), String(dependency.id));\n            if (instanceOrDesc instanceof SyncDescriptor) {\n              var d = {\n                id: dependency.id,\n                desc: instanceOrDesc,\n                _trace: item._trace.branch(dependency.id, true)\n              };\n              graph.insertEdge(item, d);\n              stack.push(d);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      while (true) {\n        var roots = graph.roots();\n        // if there is no more roots but still\n        // nodes in the graph we have a cycle\n        if (roots.length === 0) {\n          if (!graph.isEmpty()) {\n            throw new CyclicDependencyError(graph);\n          }\n          break;\n        }\n        var _iterator3 = _createForOfIteratorHelper(roots),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var data = _step3.value.data;\n            // Repeat the check for this still being a service sync descriptor. That's because\n            // instantiating a dependency might have side-effect and recursively trigger instantiation\n            // so that some dependencies are now fullfilled already.\n            var _instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n            if (_instanceOrDesc instanceof SyncDescriptor) {\n              // create instance and overwrite the service collections\n              var instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n              this._setServiceInstance(data.id, instance);\n            }\n            graph.removeNode(data);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n      return this._getServiceInstanceOrDescriptor(id);\n    }\n  }, {\n    key: \"_createServiceInstanceWithOwner\",\n    value: function _createServiceInstanceWithOwner(id, ctor) {\n      var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var supportsDelayedInstantiation = arguments.length > 3 ? arguments[3] : undefined;\n      var _trace = arguments.length > 4 ? arguments[4] : undefined;\n      if (this._services.get(id) instanceof SyncDescriptor) {\n        return this._createServiceInstance(id, ctor, args, supportsDelayedInstantiation, _trace);\n      } else if (this._parent) {\n        return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n      } else {\n        throw new Error(\"illegalState - creating UNKNOWN service instance \".concat(ctor.name));\n      }\n    }\n  }, {\n    key: \"_createServiceInstance\",\n    value: function _createServiceInstance(id, ctor) {\n      var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var supportsDelayedInstantiation = arguments.length > 3 ? arguments[3] : undefined;\n      var _trace = arguments.length > 4 ? arguments[4] : undefined;\n      if (!supportsDelayedInstantiation) {\n        // eager instantiation\n        return this._createInstance(ctor, args, _trace);\n      } else {\n        var child = new InstantiationService(undefined, this._strict, this, this._enableTracing);\n        child._globalGraphImplicitDependency = String(id);\n        // Return a proxy object that's backed by an idle value. That\n        // strategy is to instantiate services in our idle time or when actually\n        // needed but not when injected into a consumer\n        // return \"empty events\" when the service isn't instantiated yet\n        var earlyListeners = new Map();\n        var idle = new GlobalIdleValue(function () {\n          var result = child._createInstance(ctor, args, _trace);\n          // early listeners that we kept are now being subscribed to\n          // the real service\n          var _iterator4 = _createForOfIteratorHelper(earlyListeners),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _step4$value = _slicedToArray(_step4.value, 2),\n                key = _step4$value[0],\n                values = _step4$value[1];\n              var candidate = result[key];\n              if (typeof candidate === 'function') {\n                var _iterator5 = _createForOfIteratorHelper(values),\n                  _step5;\n                try {\n                  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                    var value = _step5.value;\n                    value.disposable = candidate.apply(result, value.listener);\n                  }\n                } catch (err) {\n                  _iterator5.e(err);\n                } finally {\n                  _iterator5.f();\n                }\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          earlyListeners.clear();\n          return result;\n        });\n        return new Proxy(Object.create(null), {\n          get: function get(target, key) {\n            if (!idle.isInitialized) {\n              // looks like an event\n              if (typeof key === 'string' && (key.startsWith('onDid') || key.startsWith('onWill'))) {\n                var list = earlyListeners.get(key);\n                if (!list) {\n                  list = new LinkedList();\n                  earlyListeners.set(key, list);\n                }\n                var event = function event(callback, thisArg, disposables) {\n                  if (idle.isInitialized) {\n                    return idle.value[key](callback, thisArg, disposables);\n                  } else {\n                    var entry = {\n                      listener: [callback, thisArg, disposables],\n                      disposable: undefined\n                    };\n                    var rm = list.push(entry);\n                    var result = toDisposable(function () {\n                      var _a;\n                      rm();\n                      (_a = entry.disposable) === null || _a === void 0 ? void 0 : _a.dispose();\n                    });\n                    return result;\n                  }\n                };\n                return event;\n              }\n            }\n            // value already exists\n            if (key in target) {\n              return target[key];\n            }\n            // create value\n            var obj = idle.value;\n            var prop = obj[key];\n            if (typeof prop !== 'function') {\n              return prop;\n            }\n            prop = prop.bind(obj);\n            target[key] = prop;\n            return prop;\n          },\n          set: function set(_target, p, value) {\n            idle.value[p] = value;\n            return true;\n          },\n          getPrototypeOf: function getPrototypeOf(_target) {\n            return ctor.prototype;\n          }\n        });\n      }\n    }\n  }, {\n    key: \"_throwIfStrict\",\n    value: function _throwIfStrict(msg, printWarning) {\n      if (printWarning) {\n        console.warn(msg);\n      }\n      if (this._strict) {\n        throw new Error(msg);\n      }\n    }\n  }]);\n}();\nexport var Trace = /*#__PURE__*/function () {\n  function Trace(type, name) {\n    _classCallCheck(this, Trace);\n    this.type = type;\n    this.name = name;\n    this._start = Date.now();\n    this._dep = [];\n  }\n  return _createClass(Trace, [{\n    key: \"branch\",\n    value: function branch(id, first) {\n      var child = new Trace(3 /* TraceType.Branch */, id.toString());\n      this._dep.push([id, first, child]);\n      return child;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var dur = Date.now() - this._start;\n      Trace._totals += dur;\n      var causedCreation = false;\n      function printChild(n, trace) {\n        var res = [];\n        var prefix = new Array(n + 1).join('\\t');\n        var _iterator6 = _createForOfIteratorHelper(trace._dep),\n          _step6;\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var _step6$value = _slicedToArray(_step6.value, 3),\n              id = _step6$value[0],\n              first = _step6$value[1],\n              child = _step6$value[2];\n            if (first && child) {\n              causedCreation = true;\n              res.push(\"\".concat(prefix, \"CREATES -> \").concat(id));\n              var nested = printChild(n + 1, child);\n              if (nested) {\n                res.push(nested);\n              }\n            } else {\n              res.push(\"\".concat(prefix, \"uses -> \").concat(id));\n            }\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n        return res.join('\\n');\n      }\n      var lines = [\"\".concat(this.type === 1 /* TraceType.Creation */ ? 'CREATE' : 'CALL', \" \").concat(this.name), \"\".concat(printChild(1, this)), \"DONE, took \".concat(dur.toFixed(2), \"ms (grand total \").concat(Trace._totals.toFixed(2), \"ms)\")];\n      if (dur > 2 || causedCreation) {\n        Trace.all.add(lines.join('\\n'));\n      }\n    }\n  }], [{\n    key: \"traceInvocation\",\n    value: function traceInvocation(_enableTracing, ctor) {\n      return !_enableTracing ? Trace._None : new Trace(2 /* TraceType.Invocation */, ctor.name || new Error().stack.split('\\n').slice(3, 4).join('\\n'));\n    }\n  }, {\n    key: \"traceCreation\",\n    value: function traceCreation(_enableTracing, ctor) {\n      return !_enableTracing ? Trace._None : new Trace(1 /* TraceType.Creation */, ctor.name);\n    }\n  }]);\n}();\nTrace.all = new Set();\nTrace._None = new ( /*#__PURE__*/function (_Trace) {\n  function _class() {\n    _classCallCheck(this, _class);\n    return _callSuper(this, _class, [0 /* TraceType.None */, null]);\n  }\n  _inherits(_class, _Trace);\n  return _createClass(_class, [{\n    key: \"stop\",\n    value: function stop() {}\n  }, {\n    key: \"branch\",\n    value: function branch() {\n      return this;\n    }\n  }]);\n}(Trace))();\nTrace._totals = 0;\n//#endregion","map":{"version":3,"names":["GlobalIdleValue","illegalState","toDisposable","SyncDescriptor","Graph","IInstantiationService","_util","ServiceCollection","LinkedList","_enableAllTracing","CyclicDependencyError","_Error","graph","_this","_classCallCheck","_a","_callSuper","message","findCycleSlow","concat","toString","_inherits","_createClass","_wrapNativeSuper","Error","InstantiationService","_services","arguments","length","undefined","_strict","_parent","_enableTracing","_activeInstantiations","Set","set","_globalGraph","e","key","value","createChild","services","invokeFunction","fn","_this2","_trace","Trace","traceInvocation","_done","accessor","get","id","result","_getOrCreateServiceInstance","_len","args","Array","_key","apply","stop","createInstance","ctorOrDescriptor","_len2","rest","_key2","traceCreation","ctor","_createInstance","staticArguments","serviceDependencies","getServiceDependencies","sort","a","b","index","serviceArgs","_iterator","_createForOfIteratorHelper","_step","s","n","done","dependency","service","_throwIfStrict","name","push","err","f","firstServiceArgPos","console","trace","delta","slice","Reflect","construct","_setServiceInstance","instance","_getServiceInstanceOrDescriptor","instanceOrDesc","_globalGraphImplicitDependency","insertEdge","String","thing","_safeCreateAndCacheServiceInstance","branch","desc","has","add","_createAndCacheServiceInstance","data","cycleCount","stack","item","pop","lookupOrInsertNode","_iterator2","_step2","d","roots","isEmpty","_iterator3","_step3","_createServiceInstanceWithOwner","supportsDelayedInstantiation","removeNode","_createServiceInstance","child","earlyListeners","Map","idle","_iterator4","_step4","_step4$value","_slicedToArray","values","candidate","_iterator5","_step5","disposable","listener","clear","Proxy","Object","create","target","isInitialized","startsWith","list","event","callback","thisArg","disposables","entry","rm","dispose","obj","prop","bind","_target","p","getPrototypeOf","prototype","msg","printWarning","warn","type","_start","Date","now","_dep","first","dur","_totals","causedCreation","printChild","res","prefix","join","_iterator6","_step6","_step6$value","nested","lines","toFixed","all","_None","split","_Trace","_class"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiationService.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { GlobalIdleValue } from '../../../base/common/async.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport { SyncDescriptor } from './descriptors.js';\nimport { Graph } from './graph.js';\nimport { IInstantiationService, _util } from './instantiation.js';\nimport { ServiceCollection } from './serviceCollection.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\n// TRACING\nconst _enableAllTracing = false;\nclass CyclicDependencyError extends Error {\n    constructor(graph) {\n        var _a;\n        super('cyclic dependency between services');\n        this.message = (_a = graph.findCycleSlow()) !== null && _a !== void 0 ? _a : `UNABLE to detect cycle, dumping graph: \\n${graph.toString()}`;\n    }\n}\nexport class InstantiationService {\n    constructor(_services = new ServiceCollection(), _strict = false, _parent, _enableTracing = _enableAllTracing) {\n        var _a;\n        this._services = _services;\n        this._strict = _strict;\n        this._parent = _parent;\n        this._enableTracing = _enableTracing;\n        this._activeInstantiations = new Set();\n        this._services.set(IInstantiationService, this);\n        this._globalGraph = _enableTracing ? (_a = _parent === null || _parent === void 0 ? void 0 : _parent._globalGraph) !== null && _a !== void 0 ? _a : new Graph(e => e) : undefined;\n    }\n    createChild(services) {\n        return new InstantiationService(services, this._strict, this, this._enableTracing);\n    }\n    invokeFunction(fn, ...args) {\n        const _trace = Trace.traceInvocation(this._enableTracing, fn);\n        let _done = false;\n        try {\n            const accessor = {\n                get: (id) => {\n                    if (_done) {\n                        throw illegalState('service accessor is only valid during the invocation of its target method');\n                    }\n                    const result = this._getOrCreateServiceInstance(id, _trace);\n                    if (!result) {\n                        throw new Error(`[invokeFunction] unknown service '${id}'`);\n                    }\n                    return result;\n                }\n            };\n            return fn(accessor, ...args);\n        }\n        finally {\n            _done = true;\n            _trace.stop();\n        }\n    }\n    createInstance(ctorOrDescriptor, ...rest) {\n        let _trace;\n        let result;\n        if (ctorOrDescriptor instanceof SyncDescriptor) {\n            _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor.ctor);\n            result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n        }\n        else {\n            _trace = Trace.traceCreation(this._enableTracing, ctorOrDescriptor);\n            result = this._createInstance(ctorOrDescriptor, rest, _trace);\n        }\n        _trace.stop();\n        return result;\n    }\n    _createInstance(ctor, args = [], _trace) {\n        // arguments defined by service decorators\n        const serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\n        const serviceArgs = [];\n        for (const dependency of serviceDependencies) {\n            const service = this._getOrCreateServiceInstance(dependency.id, _trace);\n            if (!service) {\n                this._throwIfStrict(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`, false);\n            }\n            serviceArgs.push(service);\n        }\n        const firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\n        // check for argument mismatches, adjust static args if needed\n        if (args.length !== firstServiceArgPos) {\n            console.trace(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\n            const delta = firstServiceArgPos - args.length;\n            if (delta > 0) {\n                args = args.concat(new Array(delta));\n            }\n            else {\n                args = args.slice(0, firstServiceArgPos);\n            }\n        }\n        // now create the instance\n        return Reflect.construct(ctor, args.concat(serviceArgs));\n    }\n    _setServiceInstance(id, instance) {\n        if (this._services.get(id) instanceof SyncDescriptor) {\n            this._services.set(id, instance);\n        }\n        else if (this._parent) {\n            this._parent._setServiceInstance(id, instance);\n        }\n        else {\n            throw new Error('illegalState - setting UNKNOWN service instance');\n        }\n    }\n    _getServiceInstanceOrDescriptor(id) {\n        const instanceOrDesc = this._services.get(id);\n        if (!instanceOrDesc && this._parent) {\n            return this._parent._getServiceInstanceOrDescriptor(id);\n        }\n        else {\n            return instanceOrDesc;\n        }\n    }\n    _getOrCreateServiceInstance(id, _trace) {\n        if (this._globalGraph && this._globalGraphImplicitDependency) {\n            this._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(id));\n        }\n        const thing = this._getServiceInstanceOrDescriptor(id);\n        if (thing instanceof SyncDescriptor) {\n            return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n        }\n        else {\n            _trace.branch(id, false);\n            return thing;\n        }\n    }\n    _safeCreateAndCacheServiceInstance(id, desc, _trace) {\n        if (this._activeInstantiations.has(id)) {\n            throw new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);\n        }\n        this._activeInstantiations.add(id);\n        try {\n            return this._createAndCacheServiceInstance(id, desc, _trace);\n        }\n        finally {\n            this._activeInstantiations.delete(id);\n        }\n    }\n    _createAndCacheServiceInstance(id, desc, _trace) {\n        var _a;\n        const graph = new Graph(data => data.id.toString());\n        let cycleCount = 0;\n        const stack = [{ id, desc, _trace }];\n        while (stack.length) {\n            const item = stack.pop();\n            graph.lookupOrInsertNode(item);\n            // a weak but working heuristic for cycle checks\n            if (cycleCount++ > 1000) {\n                throw new CyclicDependencyError(graph);\n            }\n            // check all dependencies for existence and if they need to be created first\n            for (const dependency of _util.getServiceDependencies(item.desc.ctor)) {\n                const instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n                if (!instanceOrDesc) {\n                    this._throwIfStrict(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`, true);\n                }\n                // take note of all service dependencies\n                (_a = this._globalGraph) === null || _a === void 0 ? void 0 : _a.insertEdge(String(item.id), String(dependency.id));\n                if (instanceOrDesc instanceof SyncDescriptor) {\n                    const d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };\n                    graph.insertEdge(item, d);\n                    stack.push(d);\n                }\n            }\n        }\n        while (true) {\n            const roots = graph.roots();\n            // if there is no more roots but still\n            // nodes in the graph we have a cycle\n            if (roots.length === 0) {\n                if (!graph.isEmpty()) {\n                    throw new CyclicDependencyError(graph);\n                }\n                break;\n            }\n            for (const { data } of roots) {\n                // Repeat the check for this still being a service sync descriptor. That's because\n                // instantiating a dependency might have side-effect and recursively trigger instantiation\n                // so that some dependencies are now fullfilled already.\n                const instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n                if (instanceOrDesc instanceof SyncDescriptor) {\n                    // create instance and overwrite the service collections\n                    const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n                    this._setServiceInstance(data.id, instance);\n                }\n                graph.removeNode(data);\n            }\n        }\n        return this._getServiceInstanceOrDescriptor(id);\n    }\n    _createServiceInstanceWithOwner(id, ctor, args = [], supportsDelayedInstantiation, _trace) {\n        if (this._services.get(id) instanceof SyncDescriptor) {\n            return this._createServiceInstance(id, ctor, args, supportsDelayedInstantiation, _trace);\n        }\n        else if (this._parent) {\n            return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n        }\n        else {\n            throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);\n        }\n    }\n    _createServiceInstance(id, ctor, args = [], supportsDelayedInstantiation, _trace) {\n        if (!supportsDelayedInstantiation) {\n            // eager instantiation\n            return this._createInstance(ctor, args, _trace);\n        }\n        else {\n            const child = new InstantiationService(undefined, this._strict, this, this._enableTracing);\n            child._globalGraphImplicitDependency = String(id);\n            // Return a proxy object that's backed by an idle value. That\n            // strategy is to instantiate services in our idle time or when actually\n            // needed but not when injected into a consumer\n            // return \"empty events\" when the service isn't instantiated yet\n            const earlyListeners = new Map();\n            const idle = new GlobalIdleValue(() => {\n                const result = child._createInstance(ctor, args, _trace);\n                // early listeners that we kept are now being subscribed to\n                // the real service\n                for (const [key, values] of earlyListeners) {\n                    const candidate = result[key];\n                    if (typeof candidate === 'function') {\n                        for (const value of values) {\n                            value.disposable = candidate.apply(result, value.listener);\n                        }\n                    }\n                }\n                earlyListeners.clear();\n                return result;\n            });\n            return new Proxy(Object.create(null), {\n                get(target, key) {\n                    if (!idle.isInitialized) {\n                        // looks like an event\n                        if (typeof key === 'string' && (key.startsWith('onDid') || key.startsWith('onWill'))) {\n                            let list = earlyListeners.get(key);\n                            if (!list) {\n                                list = new LinkedList();\n                                earlyListeners.set(key, list);\n                            }\n                            const event = (callback, thisArg, disposables) => {\n                                if (idle.isInitialized) {\n                                    return idle.value[key](callback, thisArg, disposables);\n                                }\n                                else {\n                                    const entry = { listener: [callback, thisArg, disposables], disposable: undefined };\n                                    const rm = list.push(entry);\n                                    const result = toDisposable(() => {\n                                        var _a;\n                                        rm();\n                                        (_a = entry.disposable) === null || _a === void 0 ? void 0 : _a.dispose();\n                                    });\n                                    return result;\n                                }\n                            };\n                            return event;\n                        }\n                    }\n                    // value already exists\n                    if (key in target) {\n                        return target[key];\n                    }\n                    // create value\n                    const obj = idle.value;\n                    let prop = obj[key];\n                    if (typeof prop !== 'function') {\n                        return prop;\n                    }\n                    prop = prop.bind(obj);\n                    target[key] = prop;\n                    return prop;\n                },\n                set(_target, p, value) {\n                    idle.value[p] = value;\n                    return true;\n                },\n                getPrototypeOf(_target) {\n                    return ctor.prototype;\n                }\n            });\n        }\n    }\n    _throwIfStrict(msg, printWarning) {\n        if (printWarning) {\n            console.warn(msg);\n        }\n        if (this._strict) {\n            throw new Error(msg);\n        }\n    }\n}\nexport class Trace {\n    static traceInvocation(_enableTracing, ctor) {\n        return !_enableTracing ? Trace._None : new Trace(2 /* TraceType.Invocation */, ctor.name || new Error().stack.split('\\n').slice(3, 4).join('\\n'));\n    }\n    static traceCreation(_enableTracing, ctor) {\n        return !_enableTracing ? Trace._None : new Trace(1 /* TraceType.Creation */, ctor.name);\n    }\n    constructor(type, name) {\n        this.type = type;\n        this.name = name;\n        this._start = Date.now();\n        this._dep = [];\n    }\n    branch(id, first) {\n        const child = new Trace(3 /* TraceType.Branch */, id.toString());\n        this._dep.push([id, first, child]);\n        return child;\n    }\n    stop() {\n        const dur = Date.now() - this._start;\n        Trace._totals += dur;\n        let causedCreation = false;\n        function printChild(n, trace) {\n            const res = [];\n            const prefix = new Array(n + 1).join('\\t');\n            for (const [id, first, child] of trace._dep) {\n                if (first && child) {\n                    causedCreation = true;\n                    res.push(`${prefix}CREATES -> ${id}`);\n                    const nested = printChild(n + 1, child);\n                    if (nested) {\n                        res.push(nested);\n                    }\n                }\n                else {\n                    res.push(`${prefix}uses -> ${id}`);\n                }\n            }\n            return res.join('\\n');\n        }\n        const lines = [\n            `${this.type === 1 /* TraceType.Creation */ ? 'CREATE' : 'CALL'} ${this.name}`,\n            `${printChild(1, this)}`,\n            `DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`\n        ];\n        if (dur > 2 || causedCreation) {\n            Trace.all.add(lines.join('\\n'));\n        }\n    }\n}\nTrace.all = new Set();\nTrace._None = new class extends Trace {\n    constructor() { super(0 /* TraceType.None */, null); }\n    stop() { }\n    branch() { return this; }\n};\nTrace._totals = 0;\n//#endregion\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}