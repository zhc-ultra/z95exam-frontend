{"ast":null,"code":"import _callSuper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.object.to-string.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport var WordOperations = /*#__PURE__*/function () {\n  function WordOperations() {\n    _classCallCheck(this, WordOperations);\n  }\n  return _createClass(WordOperations, null, [{\n    key: \"_createWord\",\n    value: function _createWord(lineContent, wordType, nextCharClass, start, end) {\n      // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n      return {\n        start: start,\n        end: end,\n        wordType: wordType,\n        nextCharClass: nextCharClass\n      };\n    }\n  }, {\n    key: \"_createIntlWord\",\n    value: function _createIntlWord(intlWord, nextCharClass) {\n      // console.log('INTL WORD ==> ' + intlWord.index + ' => ' + intlWord.index + intlWord.segment.length + ':::: <<<' + intlWord.segment + '>>>');\n      return {\n        start: intlWord.index,\n        end: intlWord.index + intlWord.segment.length,\n        wordType: 1 /* WordType.Regular */,\n        nextCharClass: nextCharClass\n      };\n    }\n  }, {\n    key: \"_findPreviousWordOnLine\",\n    value: function _findPreviousWordOnLine(wordSeparators, model, position) {\n      var lineContent = model.getLineContent(position.lineNumber);\n      return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n    }\n  }, {\n    key: \"_doFindPreviousWordOnLine\",\n    value: function _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n      var wordType = 0 /* WordType.None */;\n      var previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, position.column - 2);\n      for (var chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n        var chCode = lineContent.charCodeAt(chIndex);\n        var chClass = wordSeparators.get(chCode);\n        if (previousIntlWord && chIndex === previousIntlWord.index) {\n          return this._createIntlWord(previousIntlWord, chClass);\n        }\n        if (chClass === 0 /* WordCharacterClass.Regular */) {\n          if (wordType === 2 /* WordType.Separator */) {\n            return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n          }\n          wordType = 1 /* WordType.Regular */;\n        } else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n          if (wordType === 1 /* WordType.Regular */) {\n            return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n          }\n          wordType = 2 /* WordType.Separator */;\n        } else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n          if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n          }\n        }\n      }\n      if (wordType !== 0 /* WordType.None */) {\n        return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n      }\n      return null;\n    }\n  }, {\n    key: \"_findEndOfWord\",\n    value: function _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n      var nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, startIndex);\n      var len = lineContent.length;\n      for (var chIndex = startIndex; chIndex < len; chIndex++) {\n        var chCode = lineContent.charCodeAt(chIndex);\n        var chClass = wordSeparators.get(chCode);\n        if (nextIntlWord && chIndex === nextIntlWord.index + nextIntlWord.segment.length) {\n          return chIndex;\n        }\n        if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n          return chIndex;\n        }\n        if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n          return chIndex;\n        }\n        if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n          return chIndex;\n        }\n      }\n      return len;\n    }\n  }, {\n    key: \"_findNextWordOnLine\",\n    value: function _findNextWordOnLine(wordSeparators, model, position) {\n      var lineContent = model.getLineContent(position.lineNumber);\n      return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n    }\n  }, {\n    key: \"_doFindNextWordOnLine\",\n    value: function _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n      var wordType = 0 /* WordType.None */;\n      var len = lineContent.length;\n      var nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, position.column - 1);\n      for (var chIndex = position.column - 1; chIndex < len; chIndex++) {\n        var chCode = lineContent.charCodeAt(chIndex);\n        var chClass = wordSeparators.get(chCode);\n        if (nextIntlWord && chIndex === nextIntlWord.index) {\n          return this._createIntlWord(nextIntlWord, chClass);\n        }\n        if (chClass === 0 /* WordCharacterClass.Regular */) {\n          if (wordType === 2 /* WordType.Separator */) {\n            return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n          }\n          wordType = 1 /* WordType.Regular */;\n        } else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n          if (wordType === 1 /* WordType.Regular */) {\n            return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n          }\n          wordType = 2 /* WordType.Separator */;\n        } else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n          if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n          }\n        }\n      }\n      if (wordType !== 0 /* WordType.None */) {\n        return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n      }\n      return null;\n    }\n  }, {\n    key: \"_findStartOfWord\",\n    value: function _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n      var previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, startIndex);\n      for (var chIndex = startIndex; chIndex >= 0; chIndex--) {\n        var chCode = lineContent.charCodeAt(chIndex);\n        var chClass = wordSeparators.get(chCode);\n        if (previousIntlWord && chIndex === previousIntlWord.index) {\n          return chIndex;\n        }\n        if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n          return chIndex + 1;\n        }\n        if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n          return chIndex + 1;\n        }\n        if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n          return chIndex + 1;\n        }\n      }\n      return 0;\n    }\n  }, {\n    key: \"moveWordLeft\",\n    value: function moveWordLeft(wordSeparators, model, position, wordNavigationType) {\n      var lineNumber = position.lineNumber;\n      var column = position.column;\n      if (column === 1) {\n        if (lineNumber > 1) {\n          lineNumber = lineNumber - 1;\n          column = model.getLineMaxColumn(lineNumber);\n        }\n      }\n      var prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n      if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n      }\n      if (wordNavigationType === 1 /* WordNavigationType.WordStartFast */) {\n        if (prevWordOnLine && prevWordOnLine.wordType === 2 /* WordType.Separator */ && prevWordOnLine.end - prevWordOnLine.start === 1 && prevWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n          // Skip over a word made up of one single separator and followed by a regular character\n          prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n        }\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n      }\n      if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n        while (prevWordOnLine && prevWordOnLine.wordType === 2 /* WordType.Separator */) {\n          // Skip over words made up of only separators\n          prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n        }\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n      }\n      // We are stopping at the ending of words\n      if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n        prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n      }\n      return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n    }\n  }, {\n    key: \"_moveWordPartLeft\",\n    value: function _moveWordPartLeft(model, position) {\n      var lineNumber = position.lineNumber;\n      var maxColumn = model.getLineMaxColumn(lineNumber);\n      if (position.column === 1) {\n        return lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position;\n      }\n      var lineContent = model.getLineContent(lineNumber);\n      for (var column = position.column - 1; column > 1; column--) {\n        var left = lineContent.charCodeAt(column - 2);\n        var right = lineContent.charCodeAt(column - 1);\n        if (left === 95 /* CharCode.Underline */ && right !== 95 /* CharCode.Underline */) {\n          // snake_case_variables\n          return new Position(lineNumber, column);\n        }\n        if (left === 45 /* CharCode.Dash */ && right !== 45 /* CharCode.Dash */) {\n          // kebab-case-variables\n          return new Position(lineNumber, column);\n        }\n        if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n          // camelCaseVariables\n          return new Position(lineNumber, column);\n        }\n        if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n          // thisIsACamelCaseWithOneLetterWords\n          if (column + 1 < maxColumn) {\n            var rightRight = lineContent.charCodeAt(column);\n            if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n              return new Position(lineNumber, column);\n            }\n          }\n        }\n      }\n      return new Position(lineNumber, 1);\n    }\n  }, {\n    key: \"moveWordRight\",\n    value: function moveWordRight(wordSeparators, model, position, wordNavigationType) {\n      var lineNumber = position.lineNumber;\n      var column = position.column;\n      var movedDown = false;\n      if (column === model.getLineMaxColumn(lineNumber)) {\n        if (lineNumber < model.getLineCount()) {\n          movedDown = true;\n          lineNumber = lineNumber + 1;\n          column = 1;\n        }\n      }\n      var nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n      if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n        if (nextWordOnLine && nextWordOnLine.wordType === 2 /* WordType.Separator */) {\n          if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n            // Skip over a word made up of one single separator and followed by a regular character\n            nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n          }\n        }\n        if (nextWordOnLine) {\n          column = nextWordOnLine.end + 1;\n        } else {\n          column = model.getLineMaxColumn(lineNumber);\n        }\n      } else if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n        if (movedDown) {\n          // If we move to the next line, pretend that the cursor is right before the first character.\n          // This is needed when the first word starts right at the first character - and in order not to miss it,\n          // we need to start before.\n          column = 0;\n        }\n        while (nextWordOnLine && (nextWordOnLine.wordType === 2 /* WordType.Separator */ || nextWordOnLine.start + 1 <= column)) {\n          // Skip over a word made up of one single separator\n          // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n        }\n        if (nextWordOnLine) {\n          column = nextWordOnLine.start + 1;\n        } else {\n          column = model.getLineMaxColumn(lineNumber);\n        }\n      } else {\n        if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n        }\n        if (nextWordOnLine) {\n          column = nextWordOnLine.start + 1;\n        } else {\n          column = model.getLineMaxColumn(lineNumber);\n        }\n      }\n      return new Position(lineNumber, column);\n    }\n  }, {\n    key: \"_moveWordPartRight\",\n    value: function _moveWordPartRight(model, position) {\n      var lineNumber = position.lineNumber;\n      var maxColumn = model.getLineMaxColumn(lineNumber);\n      if (position.column === maxColumn) {\n        return lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position;\n      }\n      var lineContent = model.getLineContent(lineNumber);\n      for (var column = position.column + 1; column < maxColumn; column++) {\n        var left = lineContent.charCodeAt(column - 2);\n        var right = lineContent.charCodeAt(column - 1);\n        if (left !== 95 /* CharCode.Underline */ && right === 95 /* CharCode.Underline */) {\n          // snake_case_variables\n          return new Position(lineNumber, column);\n        }\n        if (left !== 45 /* CharCode.Dash */ && right === 45 /* CharCode.Dash */) {\n          // kebab-case-variables\n          return new Position(lineNumber, column);\n        }\n        if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n          // camelCaseVariables\n          return new Position(lineNumber, column);\n        }\n        if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n          // thisIsACamelCaseWithOneLetterWords\n          if (column + 1 < maxColumn) {\n            var rightRight = lineContent.charCodeAt(column);\n            if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n              return new Position(lineNumber, column);\n            }\n          }\n        }\n      }\n      return new Position(lineNumber, maxColumn);\n    }\n  }, {\n    key: \"_deleteWordLeftWhitespace\",\n    value: function _deleteWordLeftWhitespace(model, position) {\n      var lineContent = model.getLineContent(position.lineNumber);\n      var startIndex = position.column - 2;\n      var lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n      if (lastNonWhitespace + 1 < startIndex) {\n        return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n      }\n      return null;\n    }\n  }, {\n    key: \"deleteWordLeft\",\n    value: function deleteWordLeft(ctx, wordNavigationType) {\n      var wordSeparators = ctx.wordSeparators;\n      var model = ctx.model;\n      var selection = ctx.selection;\n      var whitespaceHeuristics = ctx.whitespaceHeuristics;\n      if (!selection.isEmpty()) {\n        return selection;\n      }\n      if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n        var _position = ctx.selection.getPosition();\n        return new Range(_position.lineNumber, _position.column - 1, _position.lineNumber, _position.column + 1);\n      }\n      var position = new Position(selection.positionLineNumber, selection.positionColumn);\n      var lineNumber = position.lineNumber;\n      var column = position.column;\n      if (lineNumber === 1 && column === 1) {\n        // Ignore deleting at beginning of file\n        return null;\n      }\n      if (whitespaceHeuristics) {\n        var r = this._deleteWordLeftWhitespace(model, position);\n        if (r) {\n          return r;\n        }\n      }\n      var prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n      if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n        if (prevWordOnLine) {\n          column = prevWordOnLine.start + 1;\n        } else {\n          if (column > 1) {\n            column = 1;\n          } else {\n            lineNumber--;\n            column = model.getLineMaxColumn(lineNumber);\n          }\n        }\n      } else {\n        if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n          prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n        }\n        if (prevWordOnLine) {\n          column = prevWordOnLine.end + 1;\n        } else {\n          if (column > 1) {\n            column = 1;\n          } else {\n            lineNumber--;\n            column = model.getLineMaxColumn(lineNumber);\n          }\n        }\n      }\n      return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n  }, {\n    key: \"deleteInsideWord\",\n    value: function deleteInsideWord(wordSeparators, model, selection) {\n      if (!selection.isEmpty()) {\n        return selection;\n      }\n      var position = new Position(selection.positionLineNumber, selection.positionColumn);\n      var r = this._deleteInsideWordWhitespace(model, position);\n      if (r) {\n        return r;\n      }\n      return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n    }\n  }, {\n    key: \"_charAtIsWhitespace\",\n    value: function _charAtIsWhitespace(str, index) {\n      var charCode = str.charCodeAt(index);\n      return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;\n    }\n  }, {\n    key: \"_deleteInsideWordWhitespace\",\n    value: function _deleteInsideWordWhitespace(model, position) {\n      var lineContent = model.getLineContent(position.lineNumber);\n      var lineContentLength = lineContent.length;\n      if (lineContentLength === 0) {\n        // empty line\n        return null;\n      }\n      var leftIndex = Math.max(position.column - 2, 0);\n      if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n        // touches a non-whitespace character to the left\n        return null;\n      }\n      var rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n      if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n        // touches a non-whitespace character to the right\n        return null;\n      }\n      // walk over whitespace to the left\n      while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n        leftIndex--;\n      }\n      // walk over whitespace to the right\n      while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n        rightIndex++;\n      }\n      return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n    }\n  }, {\n    key: \"_deleteInsideWordDetermineDeleteRange\",\n    value: function _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\n      var _this = this;\n      var lineContent = model.getLineContent(position.lineNumber);\n      var lineLength = lineContent.length;\n      if (lineLength === 0) {\n        // empty line\n        if (position.lineNumber > 1) {\n          return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n        } else {\n          if (position.lineNumber < model.getLineCount()) {\n            return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n          } else {\n            // empty model\n            return new Range(position.lineNumber, 1, position.lineNumber, 1);\n          }\n        }\n      }\n      var touchesWord = function touchesWord(word) {\n        return word.start + 1 <= position.column && position.column <= word.end + 1;\n      };\n      var createRangeWithPosition = function createRangeWithPosition(startColumn, endColumn) {\n        startColumn = Math.min(startColumn, position.column);\n        endColumn = Math.max(endColumn, position.column);\n        return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n      };\n      var deleteWordAndAdjacentWhitespace = function deleteWordAndAdjacentWhitespace(word) {\n        var startColumn = word.start + 1;\n        var endColumn = word.end + 1;\n        var expandedToTheRight = false;\n        while (endColumn - 1 < lineLength && _this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n          expandedToTheRight = true;\n          endColumn++;\n        }\n        if (!expandedToTheRight) {\n          while (startColumn > 1 && _this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n            startColumn--;\n          }\n        }\n        return createRangeWithPosition(startColumn, endColumn);\n      };\n      var prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n      if (prevWordOnLine && touchesWord(prevWordOnLine)) {\n        return deleteWordAndAdjacentWhitespace(prevWordOnLine);\n      }\n      var nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n      if (nextWordOnLine && touchesWord(nextWordOnLine)) {\n        return deleteWordAndAdjacentWhitespace(nextWordOnLine);\n      }\n      if (prevWordOnLine && nextWordOnLine) {\n        return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n      }\n      if (prevWordOnLine) {\n        return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n      }\n      if (nextWordOnLine) {\n        return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n      }\n      return createRangeWithPosition(1, lineLength + 1);\n    }\n  }, {\n    key: \"_deleteWordPartLeft\",\n    value: function _deleteWordPartLeft(model, selection) {\n      if (!selection.isEmpty()) {\n        return selection;\n      }\n      var pos = selection.getPosition();\n      var toPosition = WordOperations._moveWordPartLeft(model, pos);\n      return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n  }, {\n    key: \"_findFirstNonWhitespaceChar\",\n    value: function _findFirstNonWhitespaceChar(str, startIndex) {\n      var len = str.length;\n      for (var chIndex = startIndex; chIndex < len; chIndex++) {\n        var ch = str.charAt(chIndex);\n        if (ch !== ' ' && ch !== '\\t') {\n          return chIndex;\n        }\n      }\n      return len;\n    }\n  }, {\n    key: \"_deleteWordRightWhitespace\",\n    value: function _deleteWordRightWhitespace(model, position) {\n      var lineContent = model.getLineContent(position.lineNumber);\n      var startIndex = position.column - 1;\n      var firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n      if (startIndex + 1 < firstNonWhitespace) {\n        // bingo\n        return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n      }\n      return null;\n    }\n  }, {\n    key: \"deleteWordRight\",\n    value: function deleteWordRight(ctx, wordNavigationType) {\n      var wordSeparators = ctx.wordSeparators;\n      var model = ctx.model;\n      var selection = ctx.selection;\n      var whitespaceHeuristics = ctx.whitespaceHeuristics;\n      if (!selection.isEmpty()) {\n        return selection;\n      }\n      var position = new Position(selection.positionLineNumber, selection.positionColumn);\n      var lineNumber = position.lineNumber;\n      var column = position.column;\n      var lineCount = model.getLineCount();\n      var maxColumn = model.getLineMaxColumn(lineNumber);\n      if (lineNumber === lineCount && column === maxColumn) {\n        // Ignore deleting at end of file\n        return null;\n      }\n      if (whitespaceHeuristics) {\n        var r = this._deleteWordRightWhitespace(model, position);\n        if (r) {\n          return r;\n        }\n      }\n      var nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n      if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n        if (nextWordOnLine) {\n          column = nextWordOnLine.end + 1;\n        } else {\n          if (column < maxColumn || lineNumber === lineCount) {\n            column = maxColumn;\n          } else {\n            lineNumber++;\n            nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n            if (nextWordOnLine) {\n              column = nextWordOnLine.start + 1;\n            } else {\n              column = model.getLineMaxColumn(lineNumber);\n            }\n          }\n        }\n      } else {\n        if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n        }\n        if (nextWordOnLine) {\n          column = nextWordOnLine.start + 1;\n        } else {\n          if (column < maxColumn || lineNumber === lineCount) {\n            column = maxColumn;\n          } else {\n            lineNumber++;\n            nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n            if (nextWordOnLine) {\n              column = nextWordOnLine.start + 1;\n            } else {\n              column = model.getLineMaxColumn(lineNumber);\n            }\n          }\n        }\n      }\n      return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n  }, {\n    key: \"_deleteWordPartRight\",\n    value: function _deleteWordPartRight(model, selection) {\n      if (!selection.isEmpty()) {\n        return selection;\n      }\n      var pos = selection.getPosition();\n      var toPosition = WordOperations._moveWordPartRight(model, pos);\n      return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n  }, {\n    key: \"_createWordAtPosition\",\n    value: function _createWordAtPosition(model, lineNumber, word) {\n      var range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n      return {\n        word: model.getValueInRange(range),\n        startColumn: range.startColumn,\n        endColumn: range.endColumn\n      };\n    }\n  }, {\n    key: \"getWordAtPosition\",\n    value: function getWordAtPosition(model, _wordSeparators, _intlSegmenterLocales, position) {\n      var wordSeparators = getMapForWordSeparators(_wordSeparators, _intlSegmenterLocales);\n      var prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n      if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n        return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n      }\n      var nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n      if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n        return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n      }\n      return null;\n    }\n  }, {\n    key: \"word\",\n    value: function word(config, model, cursor, inSelectionMode, position) {\n      var wordSeparators = getMapForWordSeparators(config.wordSeparators, config.wordSegmenterLocales);\n      var prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n      var nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n      if (!inSelectionMode) {\n        // Entering word selection for the first time\n        var _startColumn;\n        var _endColumn;\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n          // isTouchingPrevWord\n          _startColumn = prevWord.start + 1;\n          _endColumn = prevWord.end + 1;\n        } else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n          // isTouchingNextWord\n          _startColumn = nextWord.start + 1;\n          _endColumn = nextWord.end + 1;\n        } else {\n          if (prevWord) {\n            _startColumn = prevWord.end + 1;\n          } else {\n            _startColumn = 1;\n          }\n          if (nextWord) {\n            _endColumn = nextWord.start + 1;\n          } else {\n            _endColumn = model.getLineMaxColumn(position.lineNumber);\n          }\n        }\n        return new SingleCursorState(new Range(position.lineNumber, _startColumn, position.lineNumber, _endColumn), 1 /* SelectionStartKind.Word */, 0, new Position(position.lineNumber, _endColumn), 0);\n      }\n      var startColumn;\n      var endColumn;\n      if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n        // isInsidePrevWord\n        startColumn = prevWord.start + 1;\n        endColumn = prevWord.end + 1;\n      } else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n        // isInsideNextWord\n        startColumn = nextWord.start + 1;\n        endColumn = nextWord.end + 1;\n      } else {\n        startColumn = position.column;\n        endColumn = position.column;\n      }\n      var lineNumber = position.lineNumber;\n      var column;\n      if (cursor.selectionStart.containsPosition(position)) {\n        column = cursor.selectionStart.endColumn;\n      } else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n        column = startColumn;\n        var possiblePosition = new Position(lineNumber, column);\n        if (cursor.selectionStart.containsPosition(possiblePosition)) {\n          column = cursor.selectionStart.endColumn;\n        }\n      } else {\n        column = endColumn;\n        var _possiblePosition = new Position(lineNumber, column);\n        if (cursor.selectionStart.containsPosition(_possiblePosition)) {\n          column = cursor.selectionStart.startColumn;\n        }\n      }\n      return cursor.move(true, lineNumber, column, 0);\n    }\n  }]);\n}();\nexport var WordPartOperations = /*#__PURE__*/function (_WordOperations) {\n  function WordPartOperations() {\n    _classCallCheck(this, WordPartOperations);\n    return _callSuper(this, WordPartOperations, arguments);\n  }\n  _inherits(WordPartOperations, _WordOperations);\n  return _createClass(WordPartOperations, null, [{\n    key: \"deleteWordPartLeft\",\n    value: function deleteWordPartLeft(ctx) {\n      var candidates = enforceDefined([WordOperations.deleteWordLeft(ctx, 0 /* WordNavigationType.WordStart */), WordOperations.deleteWordLeft(ctx, 2 /* WordNavigationType.WordEnd */), WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)]);\n      candidates.sort(Range.compareRangesUsingEnds);\n      return candidates[2];\n    }\n  }, {\n    key: \"deleteWordPartRight\",\n    value: function deleteWordPartRight(ctx) {\n      var candidates = enforceDefined([WordOperations.deleteWordRight(ctx, 0 /* WordNavigationType.WordStart */), WordOperations.deleteWordRight(ctx, 2 /* WordNavigationType.WordEnd */), WordOperations._deleteWordPartRight(ctx.model, ctx.selection)]);\n      candidates.sort(Range.compareRangesUsingStarts);\n      return candidates[0];\n    }\n  }, {\n    key: \"moveWordPartLeft\",\n    value: function moveWordPartLeft(wordSeparators, model, position) {\n      var candidates = enforceDefined([WordOperations.moveWordLeft(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */), WordOperations.moveWordLeft(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */), WordOperations._moveWordPartLeft(model, position)]);\n      candidates.sort(Position.compare);\n      return candidates[2];\n    }\n  }, {\n    key: \"moveWordPartRight\",\n    value: function moveWordPartRight(wordSeparators, model, position) {\n      var candidates = enforceDefined([WordOperations.moveWordRight(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */), WordOperations.moveWordRight(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */), WordOperations._moveWordPartRight(model, position)]);\n      candidates.sort(Position.compare);\n      return candidates[0];\n    }\n  }]);\n}(WordOperations);\nfunction enforceDefined(arr) {\n  return arr.filter(function (el) {\n    return Boolean(el);\n  });\n}","map":{"version":3,"names":["strings","SingleCursorState","DeleteOperations","getMapForWordSeparators","Position","Range","WordOperations","_classCallCheck","_createClass","key","value","_createWord","lineContent","wordType","nextCharClass","start","end","_createIntlWord","intlWord","index","segment","length","_findPreviousWordOnLine","wordSeparators","model","position","getLineContent","lineNumber","_doFindPreviousWordOnLine","previousIntlWord","findPrevIntlWordBeforeOrAtOffset","column","chIndex","chCode","charCodeAt","chClass","get","_findEndOfWord","startIndex","nextIntlWord","findNextIntlWordAtOrAfterOffset","len","_findNextWordOnLine","_doFindNextWordOnLine","_findStartOfWord","moveWordLeft","wordNavigationType","getLineMaxColumn","prevWordOnLine","_moveWordPartLeft","maxColumn","left","right","isLowerAsciiLetter","isAsciiDigit","isUpperAsciiLetter","rightRight","moveWordRight","movedDown","getLineCount","nextWordOnLine","_moveWordPartRight","_deleteWordLeftWhitespace","lastNonWhitespace","lastNonWhitespaceIndex","deleteWordLeft","ctx","selection","whitespaceHeuristics","isEmpty","isAutoClosingPairDelete","autoClosingDelete","autoClosingBrackets","autoClosingQuotes","autoClosingPairs","autoClosingPairsOpenByEnd","autoClosedCharacters","getPosition","positionLineNumber","positionColumn","r","deleteInsideWord","_deleteInsideWordWhitespace","_deleteInsideWordDetermineDeleteRange","_charAtIsWhitespace","str","charCode","lineContentLength","leftIndex","Math","max","rightIndex","min","_this","lineLength","touchesWord","word","createRangeWithPosition","startColumn","endColumn","deleteWordAndAdjacentWhitespace","expandedToTheRight","_deleteWordPartLeft","pos","toPosition","_findFirstNonWhitespaceChar","ch","charAt","_deleteWordRightWhitespace","firstNonWhitespace","deleteWordRight","lineCount","_deleteWordPartRight","_createWordAtPosition","range","getValueInRange","getWordAtPosition","_wordSeparators","_intlSegmenterLocales","prevWord","nextWord","config","cursor","inSelectionMode","wordSegmenterLocales","selectionStart","containsPosition","isBeforeOrEqual","getStartPosition","possiblePosition","move","WordPartOperations","_WordOperations","_callSuper","arguments","_inherits","deleteWordPartLeft","candidates","enforceDefined","sort","compareRangesUsingEnds","deleteWordPartRight","compareRangesUsingStarts","moveWordPartLeft","compare","moveWordPartRight","arr","filter","el","Boolean"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorWordOperations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class WordOperations {\n    static _createWord(lineContent, wordType, nextCharClass, start, end) {\n        // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n        return { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n    }\n    static _createIntlWord(intlWord, nextCharClass) {\n        // console.log('INTL WORD ==> ' + intlWord.index + ' => ' + intlWord.index + intlWord.segment.length + ':::: <<<' + intlWord.segment + '>>>');\n        return { start: intlWord.index, end: intlWord.index + intlWord.segment.length, wordType: 1 /* WordType.Regular */, nextCharClass: nextCharClass };\n    }\n    static _findPreviousWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        const previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, position.column - 2);\n        for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (previousIntlWord && chIndex === previousIntlWord.index) {\n                return this._createIntlWord(previousIntlWord, chClass);\n            }\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n        }\n        return null;\n    }\n    static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        const nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, startIndex);\n        const len = lineContent.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (nextIntlWord && chIndex === nextIntlWord.index + nextIntlWord.segment.length) {\n                return chIndex;\n            }\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _findNextWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        const len = lineContent.length;\n        const nextIntlWord = wordSeparators.findNextIntlWordAtOrAfterOffset(lineContent, position.column - 1);\n        for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (nextIntlWord && chIndex === nextIntlWord.index) {\n                return this._createIntlWord(nextIntlWord, chClass);\n            }\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n        }\n        return null;\n    }\n    static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        const previousIntlWord = wordSeparators.findPrevIntlWordBeforeOrAtOffset(lineContent, startIndex);\n        for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (previousIntlWord && chIndex === previousIntlWord.index) {\n                return chIndex;\n            }\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex + 1;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex + 1;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex + 1;\n            }\n        }\n        return 0;\n    }\n    static moveWordLeft(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (column === 1) {\n            if (lineNumber > 1) {\n                lineNumber = lineNumber - 1;\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 1 /* WordNavigationType.WordStartFast */) {\n            if (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */\n                && prevWordOnLine.end - prevWordOnLine.start === 1\n                && prevWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                // Skip over a word made up of one single separator and followed by a regular character\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            while (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */) {\n                // Skip over words made up of only separators\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        // We are stopping at the ending of words\n        if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n            prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n        }\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n    }\n    static _moveWordPartLeft(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === 1) {\n            return (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column - 1; column > 1; column--) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left === 95 /* CharCode.Underline */ && right !== 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left === 45 /* CharCode.Dash */ && right !== 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, 1);\n    }\n    static moveWordRight(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        let movedDown = false;\n        if (column === model.getLineMaxColumn(lineNumber)) {\n            if (lineNumber < model.getLineCount()) {\n                movedDown = true;\n                lineNumber = lineNumber + 1;\n                column = 1;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine && nextWordOnLine.wordType === 2 /* WordType.Separator */) {\n                if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                    // Skip over a word made up of one single separator and followed by a regular character\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n                }\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            if (movedDown) {\n                // If we move to the next line, pretend that the cursor is right before the first character.\n                // This is needed when the first word starts right at the first character - and in order not to miss it,\n                // we need to start before.\n                column = 0;\n            }\n            while (nextWordOnLine\n                && (nextWordOnLine.wordType === 2 /* WordType.Separator */\n                    || nextWordOnLine.start + 1 <= column)) {\n                // Skip over a word made up of one single separator\n                // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else {\n            if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    static _moveWordPartRight(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === maxColumn) {\n            return (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column + 1; column < maxColumn; column++) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left !== 95 /* CharCode.Underline */ && right === 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left !== 45 /* CharCode.Dash */ && right === 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, maxColumn);\n    }\n    static _deleteWordLeftWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 2;\n        const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n        if (lastNonWhitespace + 1 < startIndex) {\n            return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n        }\n        return null;\n    }\n    static deleteWordLeft(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n            const position = ctx.selection.getPosition();\n            return new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (lineNumber === 1 && column === 1) {\n            // Ignore deleting at beginning of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordLeftWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            if (prevWordOnLine) {\n                column = prevWordOnLine.start + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        else {\n            if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            if (prevWordOnLine) {\n                column = prevWordOnLine.end + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static deleteInsideWord(wordSeparators, model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        const r = this._deleteInsideWordWhitespace(model, position);\n        if (r) {\n            return r;\n        }\n        return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n    }\n    static _charAtIsWhitespace(str, index) {\n        const charCode = str.charCodeAt(index);\n        return (charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */);\n    }\n    static _deleteInsideWordWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineContentLength = lineContent.length;\n        if (lineContentLength === 0) {\n            // empty line\n            return null;\n        }\n        let leftIndex = Math.max(position.column - 2, 0);\n        if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n            // touches a non-whitespace character to the left\n            return null;\n        }\n        let rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n        if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n            // touches a non-whitespace character to the right\n            return null;\n        }\n        // walk over whitespace to the left\n        while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n            leftIndex--;\n        }\n        // walk over whitespace to the right\n        while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n            rightIndex++;\n        }\n        return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n    }\n    static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineLength = lineContent.length;\n        if (lineLength === 0) {\n            // empty line\n            if (position.lineNumber > 1) {\n                return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n            }\n            else {\n                if (position.lineNumber < model.getLineCount()) {\n                    return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n                }\n                else {\n                    // empty model\n                    return new Range(position.lineNumber, 1, position.lineNumber, 1);\n                }\n            }\n        }\n        const touchesWord = (word) => {\n            return (word.start + 1 <= position.column && position.column <= word.end + 1);\n        };\n        const createRangeWithPosition = (startColumn, endColumn) => {\n            startColumn = Math.min(startColumn, position.column);\n            endColumn = Math.max(endColumn, position.column);\n            return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n        };\n        const deleteWordAndAdjacentWhitespace = (word) => {\n            let startColumn = word.start + 1;\n            let endColumn = word.end + 1;\n            let expandedToTheRight = false;\n            while (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n                expandedToTheRight = true;\n                endColumn++;\n            }\n            if (!expandedToTheRight) {\n                while (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n                    startColumn--;\n                }\n            }\n            return createRangeWithPosition(startColumn, endColumn);\n        };\n        const prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWordOnLine && touchesWord(prevWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(prevWordOnLine);\n        }\n        const nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWordOnLine && touchesWord(nextWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(nextWordOnLine);\n        }\n        if (prevWordOnLine && nextWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n        }\n        if (prevWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n        }\n        if (nextWordOnLine) {\n            return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n        }\n        return createRangeWithPosition(1, lineLength + 1);\n    }\n    static _deleteWordPartLeft(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartLeft(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _findFirstNonWhitespaceChar(str, startIndex) {\n        const len = str.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const ch = str.charAt(chIndex);\n            if (ch !== ' ' && ch !== '\\t') {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _deleteWordRightWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 1;\n        const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n        if (startIndex + 1 < firstNonWhitespace) {\n            // bingo\n            return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n        }\n        return null;\n    }\n    static deleteWordRight(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        const lineCount = model.getLineCount();\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (lineNumber === lineCount && column === maxColumn) {\n            // Ignore deleting at end of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordRightWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        else {\n            if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static _deleteWordPartRight(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartRight(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _createWordAtPosition(model, lineNumber, word) {\n        const range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n        return {\n            word: model.getValueInRange(range),\n            startColumn: range.startColumn,\n            endColumn: range.endColumn\n        };\n    }\n    static getWordAtPosition(model, _wordSeparators, _intlSegmenterLocales, position) {\n        const wordSeparators = getMapForWordSeparators(_wordSeparators, _intlSegmenterLocales);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n        }\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n        }\n        return null;\n    }\n    static word(config, model, cursor, inSelectionMode, position) {\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators, config.wordSegmenterLocales);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (!inSelectionMode) {\n            // Entering word selection for the first time\n            let startColumn;\n            let endColumn;\n            if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n                // isTouchingPrevWord\n                startColumn = prevWord.start + 1;\n                endColumn = prevWord.end + 1;\n            }\n            else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n                // isTouchingNextWord\n                startColumn = nextWord.start + 1;\n                endColumn = nextWord.end + 1;\n            }\n            else {\n                if (prevWord) {\n                    startColumn = prevWord.end + 1;\n                }\n                else {\n                    startColumn = 1;\n                }\n                if (nextWord) {\n                    endColumn = nextWord.start + 1;\n                }\n                else {\n                    endColumn = model.getLineMaxColumn(position.lineNumber);\n                }\n            }\n            return new SingleCursorState(new Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 1 /* SelectionStartKind.Word */, 0, new Position(position.lineNumber, endColumn), 0);\n        }\n        let startColumn;\n        let endColumn;\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n            // isInsidePrevWord\n            startColumn = prevWord.start + 1;\n            endColumn = prevWord.end + 1;\n        }\n        else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n            // isInsideNextWord\n            startColumn = nextWord.start + 1;\n            endColumn = nextWord.end + 1;\n        }\n        else {\n            startColumn = position.column;\n            endColumn = position.column;\n        }\n        const lineNumber = position.lineNumber;\n        let column;\n        if (cursor.selectionStart.containsPosition(position)) {\n            column = cursor.selectionStart.endColumn;\n        }\n        else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n            column = startColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.endColumn;\n            }\n        }\n        else {\n            column = endColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.startColumn;\n            }\n        }\n        return cursor.move(true, lineNumber, column, 0);\n    }\n}\nexport class WordPartOperations extends WordOperations {\n    static deleteWordPartLeft(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordLeft(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordLeft(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingEnds);\n        return candidates[2];\n    }\n    static deleteWordPartRight(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordRight(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordRight(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartRight(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingStarts);\n        return candidates[0];\n    }\n    static moveWordPartLeft(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordLeft(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordLeft(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartLeft(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[2];\n    }\n    static moveWordPartRight(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordRight(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordRight(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartRight(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[0];\n    }\n}\nfunction enforceDefined(arr) {\n    return arr.filter(el => Boolean(el));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}