{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.number.max-safe-integer.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { Range } from './range.js';\nimport { findFirstIdxMonotonousOrArrLen, findLastIdxMonotonous, findLastMonotonous } from '../../../base/common/arraysFind.js';\n/**\n * A range of lines (1-based).\n */\nexport var LineRange = /*#__PURE__*/function () {\n  function LineRange(startLineNumber, endLineNumberExclusive) {\n    _classCallCheck(this, LineRange);\n    if (startLineNumber > endLineNumberExclusive) {\n      throw new BugIndicatingError(\"startLineNumber \".concat(startLineNumber, \" cannot be after endLineNumberExclusive \").concat(endLineNumberExclusive));\n    }\n    this.startLineNumber = startLineNumber;\n    this.endLineNumberExclusive = endLineNumberExclusive;\n  }\n  /**\n   * Indicates if this line range contains the given line number.\n   */\n  return _createClass(LineRange, [{\n    key: \"contains\",\n    value: function contains(lineNumber) {\n      return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range is empty.\n     */\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this.startLineNumber === this.endLineNumberExclusive;\n    }\n    /**\n     * Moves this line range by the given offset of line numbers.\n     */\n  }, {\n    key: \"delta\",\n    value: function delta(offset) {\n      return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n    }\n  }, {\n    key: \"deltaLength\",\n    value: function deltaLength(offset) {\n      return new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n    }\n    /**\n     * The number of lines this line range spans.\n     */\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.endLineNumberExclusive - this.startLineNumber;\n    }\n    /**\n     * Creates a line range that combines this and the given line range.\n     */\n  }, {\n    key: \"join\",\n    value: function join(other) {\n      return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"[\".concat(this.startLineNumber, \",\").concat(this.endLineNumberExclusive, \")\");\n    }\n    /**\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n  }, {\n    key: \"intersect\",\n    value: function intersect(other) {\n      var startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n      var endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n      if (startLineNumber <= endLineNumberExclusive) {\n        return new LineRange(startLineNumber, endLineNumberExclusive);\n      }\n      return undefined;\n    }\n  }, {\n    key: \"intersectsStrict\",\n    value: function intersectsStrict(other) {\n      return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n    }\n  }, {\n    key: \"overlapOrTouch\",\n    value: function overlapOrTouch(other) {\n      return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(b) {\n      return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n    }\n  }, {\n    key: \"toInclusiveRange\",\n    value: function toInclusiveRange() {\n      if (this.isEmpty) {\n        return null;\n      }\n      return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n    }\n  }, {\n    key: \"toExclusiveRange\",\n    value: function toExclusiveRange() {\n      return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n    }\n  }, {\n    key: \"mapToLineArray\",\n    value: function mapToLineArray(f) {\n      var result = [];\n      for (var lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n        result.push(f(lineNumber));\n      }\n      return result;\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      for (var lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n        f(lineNumber);\n      }\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return [this.startLineNumber, this.endLineNumberExclusive];\n    }\n  }, {\n    key: \"includes\",\n    value: function includes(lineNumber) {\n      return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n     * @internal\n     */\n  }, {\n    key: \"toOffsetRange\",\n    value: function toOffsetRange() {\n      return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n    }\n  }], [{\n    key: \"fromRangeInclusive\",\n    value: function fromRangeInclusive(range) {\n      return new LineRange(range.startLineNumber, range.endLineNumber + 1);\n    }\n    /**\n     * @param lineRanges An array of sorted line ranges.\n     */\n  }, {\n    key: \"joinMany\",\n    value: function joinMany(lineRanges) {\n      if (lineRanges.length === 0) {\n        return [];\n      }\n      var result = new LineRangeSet(lineRanges[0].slice());\n      for (var i = 1; i < lineRanges.length; i++) {\n        result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n      }\n      return result.ranges;\n    }\n  }, {\n    key: \"join\",\n    value: function join(lineRanges) {\n      if (lineRanges.length === 0) {\n        throw new BugIndicatingError('lineRanges cannot be empty');\n      }\n      var startLineNumber = lineRanges[0].startLineNumber;\n      var endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\n      for (var i = 1; i < lineRanges.length; i++) {\n        startLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);\n        endLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);\n      }\n      return new LineRange(startLineNumber, endLineNumberExclusive);\n    }\n  }, {\n    key: \"ofLength\",\n    value: function ofLength(startLineNumber, length) {\n      return new LineRange(startLineNumber, startLineNumber + length);\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(lineRange) {\n      return new LineRange(lineRange[0], lineRange[1]);\n    }\n  }]);\n}();\nexport var LineRangeSet = /*#__PURE__*/function () {\n  function LineRangeSet() {\n    var _normalizedRanges = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    _classCallCheck(this, LineRangeSet);\n    this._normalizedRanges = _normalizedRanges;\n  }\n  return _createClass(LineRangeSet, [{\n    key: \"ranges\",\n    get: function get() {\n      return this._normalizedRanges;\n    }\n  }, {\n    key: \"addRange\",\n    value: function addRange(range) {\n      if (range.length === 0) {\n        return;\n      }\n      // Idea: Find joinRange such that:\n      // replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n      // idx of first element that touches range or that is after range\n      var joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, function (r) {\n        return r.endLineNumberExclusive >= range.startLineNumber;\n      });\n      // idx of element after { last element that touches range or that is before range }\n      var joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, function (r) {\n        return r.startLineNumber <= range.endLineNumberExclusive;\n      }) + 1;\n      if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n        // If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n        this._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n      } else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n        // Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n        var joinRange = this._normalizedRanges[joinRangeStartIdx];\n        this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n      } else {\n        // First and last element are different - we need to replace the entire range\n        var _joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n        this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, _joinRange);\n      }\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(lineNumber) {\n      var rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, function (r) {\n        return r.startLineNumber <= lineNumber;\n      });\n      return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n    }\n  }, {\n    key: \"intersects\",\n    value: function intersects(range) {\n      var rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, function (r) {\n        return r.startLineNumber < range.endLineNumberExclusive;\n      });\n      return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\n    }\n  }, {\n    key: \"getUnion\",\n    value: function getUnion(other) {\n      if (this._normalizedRanges.length === 0) {\n        return other;\n      }\n      if (other._normalizedRanges.length === 0) {\n        return this;\n      }\n      var result = [];\n      var i1 = 0;\n      var i2 = 0;\n      var current = null;\n      while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n        var next = null;\n        if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n          var lineRange1 = this._normalizedRanges[i1];\n          var lineRange2 = other._normalizedRanges[i2];\n          if (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n            next = lineRange1;\n            i1++;\n          } else {\n            next = lineRange2;\n            i2++;\n          }\n        } else if (i1 < this._normalizedRanges.length) {\n          next = this._normalizedRanges[i1];\n          i1++;\n        } else {\n          next = other._normalizedRanges[i2];\n          i2++;\n        }\n        if (current === null) {\n          current = next;\n        } else {\n          if (current.endLineNumberExclusive >= next.startLineNumber) {\n            // merge\n            current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n          } else {\n            // push\n            result.push(current);\n            current = next;\n          }\n        }\n      }\n      if (current !== null) {\n        result.push(current);\n      }\n      return new LineRangeSet(result);\n    }\n    /**\n     * Subtracts all ranges in this set from `range` and returns the result.\n     */\n  }, {\n    key: \"subtractFrom\",\n    value: function subtractFrom(range) {\n      // idx of first element that touches range or that is after range\n      var joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, function (r) {\n        return r.endLineNumberExclusive >= range.startLineNumber;\n      });\n      // idx of element after { last element that touches range or that is before range }\n      var joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, function (r) {\n        return r.startLineNumber <= range.endLineNumberExclusive;\n      }) + 1;\n      if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n        return new LineRangeSet([range]);\n      }\n      var result = [];\n      var startLineNumber = range.startLineNumber;\n      for (var i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n        var r = this._normalizedRanges[i];\n        if (r.startLineNumber > startLineNumber) {\n          result.push(new LineRange(startLineNumber, r.startLineNumber));\n        }\n        startLineNumber = r.endLineNumberExclusive;\n      }\n      if (startLineNumber < range.endLineNumberExclusive) {\n        result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n      }\n      return new LineRangeSet(result);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this._normalizedRanges.map(function (r) {\n        return r.toString();\n      }).join(', ');\n    }\n  }, {\n    key: \"getIntersection\",\n    value: function getIntersection(other) {\n      var result = [];\n      var i1 = 0;\n      var i2 = 0;\n      while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n        var r1 = this._normalizedRanges[i1];\n        var r2 = other._normalizedRanges[i2];\n        var i = r1.intersect(r2);\n        if (i && !i.isEmpty) {\n          result.push(i);\n        }\n        if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n          i1++;\n        } else {\n          i2++;\n        }\n      }\n      return new LineRangeSet(result);\n    }\n  }, {\n    key: \"getWithDelta\",\n    value: function getWithDelta(value) {\n      return new LineRangeSet(this._normalizedRanges.map(function (r) {\n        return r.delta(value);\n      }));\n    }\n  }]);\n}();","map":{"version":3,"names":["BugIndicatingError","OffsetRange","Range","findFirstIdxMonotonousOrArrLen","findLastIdxMonotonous","findLastMonotonous","LineRange","startLineNumber","endLineNumberExclusive","_classCallCheck","concat","_createClass","key","value","contains","lineNumber","get","delta","offset","deltaLength","join","other","Math","min","max","toString","intersect","undefined","intersectsStrict","overlapOrTouch","equals","b","toInclusiveRange","isEmpty","Number","MAX_SAFE_INTEGER","toExclusiveRange","mapToLineArray","f","result","push","forEach","serialize","includes","toOffsetRange","fromRangeInclusive","range","endLineNumber","joinMany","lineRanges","length","LineRangeSet","slice","i","getUnion","ranges","ofLength","deserialize","lineRange","_normalizedRanges","arguments","addRange","joinRangeStartIdx","r","joinRangeEndIdxExclusive","splice","joinRange","rangeThatStartsBeforeEnd","intersects","i1","i2","current","next","lineRange1","lineRange2","subtractFrom","map","getIntersection","r1","r2","getWithDelta"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { OffsetRange } from './offsetRange.js';\nimport { Range } from './range.js';\nimport { findFirstIdxMonotonousOrArrLen, findLastIdxMonotonous, findLastMonotonous } from '../../../base/common/arraysFind.js';\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n    static fromRangeInclusive(range) {\n        return new LineRange(range.startLineNumber, range.endLineNumber + 1);\n    }\n    /**\n     * @param lineRanges An array of sorted line ranges.\n     */\n    static joinMany(lineRanges) {\n        if (lineRanges.length === 0) {\n            return [];\n        }\n        let result = new LineRangeSet(lineRanges[0].slice());\n        for (let i = 1; i < lineRanges.length; i++) {\n            result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n        }\n        return result.ranges;\n    }\n    static join(lineRanges) {\n        if (lineRanges.length === 0) {\n            throw new BugIndicatingError('lineRanges cannot be empty');\n        }\n        let startLineNumber = lineRanges[0].startLineNumber;\n        let endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\n        for (let i = 1; i < lineRanges.length; i++) {\n            startLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);\n            endLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);\n        }\n        return new LineRange(startLineNumber, endLineNumberExclusive);\n    }\n    static ofLength(startLineNumber, length) {\n        return new LineRange(startLineNumber, startLineNumber + length);\n    }\n    /**\n     * @internal\n     */\n    static deserialize(lineRange) {\n        return new LineRange(lineRange[0], lineRange[1]);\n    }\n    constructor(startLineNumber, endLineNumberExclusive) {\n        if (startLineNumber > endLineNumberExclusive) {\n            throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n        }\n        this.startLineNumber = startLineNumber;\n        this.endLineNumberExclusive = endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range contains the given line number.\n     */\n    contains(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range is empty.\n     */\n    get isEmpty() {\n        return this.startLineNumber === this.endLineNumberExclusive;\n    }\n    /**\n     * Moves this line range by the given offset of line numbers.\n     */\n    delta(offset) {\n        return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n    }\n    deltaLength(offset) {\n        return new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n    }\n    /**\n     * The number of lines this line range spans.\n     */\n    get length() {\n        return this.endLineNumberExclusive - this.startLineNumber;\n    }\n    /**\n     * Creates a line range that combines this and the given line range.\n     */\n    join(other) {\n        return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\n    }\n    toString() {\n        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n    }\n    /**\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n        const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n        if (startLineNumber <= endLineNumberExclusive) {\n            return new LineRange(startLineNumber, endLineNumberExclusive);\n        }\n        return undefined;\n    }\n    intersectsStrict(other) {\n        return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n    }\n    overlapOrTouch(other) {\n        return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n    }\n    equals(b) {\n        return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n    }\n    toInclusiveRange() {\n        if (this.isEmpty) {\n            return null;\n        }\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n    }\n    toExclusiveRange() {\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n    }\n    mapToLineArray(f) {\n        const result = [];\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            result.push(f(lineNumber));\n        }\n        return result;\n    }\n    forEach(f) {\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            f(lineNumber);\n        }\n    }\n    /**\n     * @internal\n     */\n    serialize() {\n        return [this.startLineNumber, this.endLineNumberExclusive];\n    }\n    includes(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n     * @internal\n     */\n    toOffsetRange() {\n        return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n    }\n}\nexport class LineRangeSet {\n    constructor(\n    /**\n     * Sorted by start line number.\n     * No two line ranges are touching or intersecting.\n     */\n    _normalizedRanges = []) {\n        this._normalizedRanges = _normalizedRanges;\n    }\n    get ranges() {\n        return this._normalizedRanges;\n    }\n    addRange(range) {\n        if (range.length === 0) {\n            return;\n        }\n        // Idea: Find joinRange such that:\n        // replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n        // idx of first element that touches range or that is after range\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        // idx of element after { last element that touches range or that is before range }\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            // If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n            this._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n        }\n        else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n            // Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n            const joinRange = this._normalizedRanges[joinRangeStartIdx];\n            this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n        }\n        else {\n            // First and last element are different - we need to replace the entire range\n            const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n            this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n        }\n    }\n    contains(lineNumber) {\n        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n    }\n    intersects(range) {\n        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\n    }\n    getUnion(other) {\n        if (this._normalizedRanges.length === 0) {\n            return other;\n        }\n        if (other._normalizedRanges.length === 0) {\n            return this;\n        }\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        let current = null;\n        while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n            let next = null;\n            if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n                const lineRange1 = this._normalizedRanges[i1];\n                const lineRange2 = other._normalizedRanges[i2];\n                if (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n                    next = lineRange1;\n                    i1++;\n                }\n                else {\n                    next = lineRange2;\n                    i2++;\n                }\n            }\n            else if (i1 < this._normalizedRanges.length) {\n                next = this._normalizedRanges[i1];\n                i1++;\n            }\n            else {\n                next = other._normalizedRanges[i2];\n                i2++;\n            }\n            if (current === null) {\n                current = next;\n            }\n            else {\n                if (current.endLineNumberExclusive >= next.startLineNumber) {\n                    // merge\n                    current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n                }\n                else {\n                    // push\n                    result.push(current);\n                    current = next;\n                }\n            }\n        }\n        if (current !== null) {\n            result.push(current);\n        }\n        return new LineRangeSet(result);\n    }\n    /**\n     * Subtracts all ranges in this set from `range` and returns the result.\n     */\n    subtractFrom(range) {\n        // idx of first element that touches range or that is after range\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        // idx of element after { last element that touches range or that is before range }\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            return new LineRangeSet([range]);\n        }\n        const result = [];\n        let startLineNumber = range.startLineNumber;\n        for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n            const r = this._normalizedRanges[i];\n            if (r.startLineNumber > startLineNumber) {\n                result.push(new LineRange(startLineNumber, r.startLineNumber));\n            }\n            startLineNumber = r.endLineNumberExclusive;\n        }\n        if (startLineNumber < range.endLineNumberExclusive) {\n            result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n        }\n        return new LineRangeSet(result);\n    }\n    toString() {\n        return this._normalizedRanges.map(r => r.toString()).join(', ');\n    }\n    getIntersection(other) {\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n            const r1 = this._normalizedRanges[i1];\n            const r2 = other._normalizedRanges[i2];\n            const i = r1.intersect(r2);\n            if (i && !i.isEmpty) {\n                result.push(i);\n            }\n            if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n                i1++;\n            }\n            else {\n                i2++;\n            }\n        }\n        return new LineRangeSet(result);\n    }\n    getWithDelta(value) {\n        return new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}