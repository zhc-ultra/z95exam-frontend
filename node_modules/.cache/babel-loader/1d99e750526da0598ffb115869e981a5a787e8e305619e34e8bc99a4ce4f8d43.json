{"ast":null,"code":"import _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.number.max-safe-integer.js\";\nimport \"core-js/modules/es.number.min-safe-integer.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.code-point-at.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.substr.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LRUCache } from './map.js';\nimport { getKoreanAltChars } from './naturalLanguage/korean.js';\nimport * as strings from './strings.js';\n// Combined filters\n/**\n * @returns A filter which combines the provided set\n * of filters with an or. The *first* filters that\n * matches defined the return value of the returned\n * filter.\n */\nexport function or() {\n  for (var _len = arguments.length, filter = new Array(_len), _key = 0; _key < _len; _key++) {\n    filter[_key] = arguments[_key];\n  }\n  return function (word, wordToMatchAgainst) {\n    for (var i = 0, len = filter.length; i < len; i++) {\n      var match = filter[i](word, wordToMatchAgainst);\n      if (match) {\n        return match;\n      }\n    }\n    return null;\n  };\n}\n// Prefix\nexport var matchesStrictPrefix = _matchesPrefix.bind(undefined, false);\nexport var matchesPrefix = _matchesPrefix.bind(undefined, true);\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\n  if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n    return null;\n  }\n  var matches;\n  if (ignoreCase) {\n    matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n  } else {\n    matches = wordToMatchAgainst.indexOf(word) === 0;\n  }\n  if (!matches) {\n    return null;\n  }\n  return word.length > 0 ? [{\n    start: 0,\n    end: word.length\n  }] : [];\n}\n// Contiguous Substring\nexport function matchesContiguousSubString(word, wordToMatchAgainst) {\n  var index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n  if (index === -1) {\n    return null;\n  }\n  return [{\n    start: index,\n    end: index + word.length\n  }];\n}\n// Substring\nexport function matchesSubString(word, wordToMatchAgainst) {\n  return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\n  if (i === word.length) {\n    return [];\n  } else if (j === wordToMatchAgainst.length) {\n    return null;\n  } else {\n    if (word[i] === wordToMatchAgainst[j]) {\n      var result = null;\n      if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n        return join({\n          start: j,\n          end: j + 1\n        }, result);\n      }\n      return null;\n    }\n    return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n  }\n}\n// CamelCase\nfunction isLower(code) {\n  return 97 /* CharCode.a */ <= code && code <= 122 /* CharCode.z */;\n}\nexport function isUpper(code) {\n  return 65 /* CharCode.A */ <= code && code <= 90 /* CharCode.Z */;\n}\nfunction isNumber(code) {\n  return 48 /* CharCode.Digit0 */ <= code && code <= 57 /* CharCode.Digit9 */;\n}\nfunction isWhitespace(code) {\n  return code === 32 /* CharCode.Space */ || code === 9 /* CharCode.Tab */ || code === 10 /* CharCode.LineFeed */ || code === 13 /* CharCode.CarriageReturn */;\n}\nvar wordSeparators = new Set();\n// These are chosen as natural word separators based on writen text.\n// It is a subset of the word separators used by the monaco editor.\n'()[]{}<>`\\'\"-/;:,.?!'.split('').forEach(function (s) {\n  return wordSeparators.add(s.charCodeAt(0));\n});\nfunction isWordSeparator(code) {\n  return isWhitespace(code) || wordSeparators.has(code);\n}\nfunction charactersMatch(codeA, codeB) {\n  return codeA === codeB || isWordSeparator(codeA) && isWordSeparator(codeB);\n}\nvar alternateCharsCache = new Map();\n/**\n * Gets alternative codes to the character code passed in. This comes in the\n * form of an array of character codes, all of which must match _in order_ to\n * successfully match.\n *\n * @param code The character code to check.\n */\nfunction getAlternateCodes(code) {\n  if (alternateCharsCache.has(code)) {\n    return alternateCharsCache.get(code);\n  }\n  // NOTE: This function is written in such a way that it can be extended in\n  // the future, but right now the return type takes into account it's only\n  // supported by a single \"alt codes provider\".\n  // `ArrayLike<ArrayLike<number>>` is a more appropriate type if changed.\n  var result;\n  var codes = getKoreanAltChars(code);\n  if (codes) {\n    result = codes;\n  }\n  alternateCharsCache.set(code, result);\n  return result;\n}\nfunction isAlphanumeric(code) {\n  return isLower(code) || isUpper(code) || isNumber(code);\n}\nfunction join(head, tail) {\n  if (tail.length === 0) {\n    tail = [head];\n  } else if (head.end === tail[0].start) {\n    tail[0].start = head.start;\n  } else {\n    tail.unshift(head);\n  }\n  return tail;\n}\nfunction nextAnchor(camelCaseWord, start) {\n  for (var i = start; i < camelCaseWord.length; i++) {\n    var c = camelCaseWord.charCodeAt(i);\n    if (isUpper(c) || isNumber(c) || i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1))) {\n      return i;\n    }\n  }\n  return camelCaseWord.length;\n}\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\n  if (i === word.length) {\n    return [];\n  } else if (j === camelCaseWord.length) {\n    return null;\n  } else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n    return null;\n  } else {\n    var result = null;\n    var nextUpperIndex = j + 1;\n    result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n    while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n      result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n      nextUpperIndex++;\n    }\n    return result === null ? null : join({\n      start: j,\n      end: j + 1\n    }, result);\n  }\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\nfunction analyzeCamelCaseWord(word) {\n  var upper = 0,\n    lower = 0,\n    alpha = 0,\n    numeric = 0,\n    code = 0;\n  for (var i = 0; i < word.length; i++) {\n    code = word.charCodeAt(i);\n    if (isUpper(code)) {\n      upper++;\n    }\n    if (isLower(code)) {\n      lower++;\n    }\n    if (isAlphanumeric(code)) {\n      alpha++;\n    }\n    if (isNumber(code)) {\n      numeric++;\n    }\n  }\n  var upperPercent = upper / word.length;\n  var lowerPercent = lower / word.length;\n  var alphaPercent = alpha / word.length;\n  var numericPercent = numeric / word.length;\n  return {\n    upperPercent: upperPercent,\n    lowerPercent: lowerPercent,\n    alphaPercent: alphaPercent,\n    numericPercent: numericPercent\n  };\n}\nfunction isUpperCaseWord(analysis) {\n  var upperPercent = analysis.upperPercent,\n    lowerPercent = analysis.lowerPercent;\n  return lowerPercent === 0 && upperPercent > 0.6;\n}\nfunction isCamelCaseWord(analysis) {\n  var upperPercent = analysis.upperPercent,\n    lowerPercent = analysis.lowerPercent,\n    alphaPercent = analysis.alphaPercent,\n    numericPercent = analysis.numericPercent;\n  return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\nfunction isCamelCasePattern(word) {\n  var upper = 0,\n    lower = 0,\n    code = 0,\n    whitespace = 0;\n  for (var i = 0; i < word.length; i++) {\n    code = word.charCodeAt(i);\n    if (isUpper(code)) {\n      upper++;\n    }\n    if (isLower(code)) {\n      lower++;\n    }\n    if (isWhitespace(code)) {\n      whitespace++;\n    }\n  }\n  if ((upper === 0 || lower === 0) && whitespace === 0) {\n    return word.length <= 30;\n  } else {\n    return upper <= 5;\n  }\n}\nexport function matchesCamelCase(word, camelCaseWord) {\n  if (!camelCaseWord) {\n    return null;\n  }\n  camelCaseWord = camelCaseWord.trim();\n  if (camelCaseWord.length === 0) {\n    return null;\n  }\n  if (!isCamelCasePattern(word)) {\n    return null;\n  }\n  // TODO: Consider removing this check\n  if (camelCaseWord.length > 60) {\n    camelCaseWord = camelCaseWord.substring(0, 60);\n  }\n  var analysis = analyzeCamelCaseWord(camelCaseWord);\n  if (!isCamelCaseWord(analysis)) {\n    if (!isUpperCaseWord(analysis)) {\n      return null;\n    }\n    camelCaseWord = camelCaseWord.toLowerCase();\n  }\n  var result = null;\n  var i = 0;\n  word = word.toLowerCase();\n  while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n    i = nextAnchor(camelCaseWord, i + 1);\n  }\n  return result;\n}\n// Matches beginning of words supporting non-ASCII languages\n// If `contiguous` is true then matches word with beginnings of the words in the target. E.g. \"pul\" will match \"Git: Pull\"\n// Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\n// Useful in cases where the target is words (e.g. command labels)\nexport function matchesWords(word, target) {\n  var contiguous = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (!target || target.length === 0) {\n    return null;\n  }\n  var result = null;\n  var targetIndex = 0;\n  word = word.toLowerCase();\n  target = target.toLowerCase();\n  while (targetIndex < target.length) {\n    result = _matchesWords(word, target, 0, targetIndex, contiguous);\n    if (result !== null) {\n      break;\n    }\n    targetIndex = nextWord(target, targetIndex + 1);\n  }\n  return result;\n}\nfunction _matchesWords(word, target, wordIndex, targetIndex, contiguous) {\n  var targetIndexOffset = 0;\n  if (wordIndex === word.length) {\n    return [];\n  } else if (targetIndex === target.length) {\n    return null;\n  } else if (!charactersMatch(word.charCodeAt(wordIndex), target.charCodeAt(targetIndex))) {\n    // Verify alternate characters before exiting\n    var altChars = getAlternateCodes(word.charCodeAt(wordIndex));\n    if (!altChars) {\n      return null;\n    }\n    for (var k = 0; k < altChars.length; k++) {\n      if (!charactersMatch(altChars[k], target.charCodeAt(targetIndex + k))) {\n        return null;\n      }\n    }\n    targetIndexOffset += altChars.length - 1;\n  }\n  var result = null;\n  var nextWordIndex = targetIndex + targetIndexOffset + 1;\n  result = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);\n  if (!contiguous) {\n    while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n      result = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);\n      nextWordIndex++;\n    }\n  }\n  if (!result) {\n    return null;\n  }\n  // If the characters don't exactly match, then they must be word separators (see charactersMatch(...)).\n  // We don't want to include this in the matches but we don't want to throw the target out all together so we return `result`.\n  if (word.charCodeAt(wordIndex) !== target.charCodeAt(targetIndex)) {\n    // Verify alternate characters before exiting\n    var _altChars = getAlternateCodes(word.charCodeAt(wordIndex));\n    if (!_altChars) {\n      return result;\n    }\n    for (var _k = 0; _k < _altChars.length; _k++) {\n      if (_altChars[_k] !== target.charCodeAt(targetIndex + _k)) {\n        return result;\n      }\n    }\n  }\n  return join({\n    start: targetIndex,\n    end: targetIndex + targetIndexOffset + 1\n  }, result);\n}\nfunction nextWord(word, start) {\n  for (var i = start; i < word.length; i++) {\n    if (isWordSeparator(word.charCodeAt(i)) || i > 0 && isWordSeparator(word.charCodeAt(i - 1))) {\n      return i;\n    }\n  }\n  return word.length;\n}\n// Fuzzy\nvar fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nvar fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nvar fuzzyRegExpCache = new LRUCache(10000); // bounded to 10000 elements\nexport function matchesFuzzy(word, wordToMatchAgainst) {\n  var enableSeparateSubstringMatching = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n    return null; // return early for invalid input\n  }\n  // Form RegExp for wildcard matches\n  var regexp = fuzzyRegExpCache.get(word);\n  if (!regexp) {\n    regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n    fuzzyRegExpCache.set(word, regexp);\n  }\n  // RegExp Filter\n  var match = regexp.exec(wordToMatchAgainst);\n  if (match) {\n    return [{\n      start: match.index,\n      end: match.index + match[0].length\n    }];\n  }\n  // Default Filter\n  return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\n/**\n * Match pattern against word in a fuzzy way. As in IntelliSense and faster and more\n * powerful than `matchesFuzzy`\n */\nexport function matchesFuzzy2(pattern, word) {\n  var score = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, {\n    firstMatchCanBeWeak: true,\n    boostFullMatch: true\n  });\n  return score ? createMatches(score) : null;\n}\nexport function anyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos) {\n  var max = Math.min(13, pattern.length);\n  for (; patternPos < max; patternPos++) {\n    var result = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, {\n      firstMatchCanBeWeak: true,\n      boostFullMatch: true\n    });\n    if (result) {\n      return result;\n    }\n  }\n  return [0, wordPos];\n}\n//#region --- fuzzyScore ---\nexport function createMatches(score) {\n  if (typeof score === 'undefined') {\n    return [];\n  }\n  var res = [];\n  var wordPos = score[1];\n  for (var i = score.length - 1; i > 1; i--) {\n    var pos = score[i] + wordPos;\n    var last = res[res.length - 1];\n    if (last && last.end === pos) {\n      last.end = pos + 1;\n    } else {\n      res.push({\n        start: pos,\n        end: pos + 1\n      });\n    }\n  }\n  return res;\n}\nvar _maxLen = 128;\nfunction initTable() {\n  var table = [];\n  var row = [];\n  for (var i = 0; i <= _maxLen; i++) {\n    row[i] = 0;\n  }\n  for (var _i = 0; _i <= _maxLen; _i++) {\n    table.push(row.slice(0));\n  }\n  return table;\n}\nfunction initArr(maxLen) {\n  var row = [];\n  for (var i = 0; i <= maxLen; i++) {\n    row[i] = 0;\n  }\n  return row;\n}\nvar _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position\nvar _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position\nvar _diag = initTable(); // the length of a contiguous diagonal match\nvar _table = initTable();\nvar _arrows = initTable();\nvar _debug = false;\nfunction printTable(table, pattern, patternLen, word, wordLen) {\n  function pad(s, n) {\n    var pad = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ' ';\n    while (s.length < n) {\n      s = pad + s;\n    }\n    return s;\n  }\n  var ret = \" |   |\".concat(word.split('').map(function (c) {\n    return pad(c, 3);\n  }).join('|'), \"\\n\");\n  for (var i = 0; i <= patternLen; i++) {\n    if (i === 0) {\n      ret += ' |';\n    } else {\n      ret += \"\".concat(pattern[i - 1], \"|\");\n    }\n    ret += table[i].slice(0, wordLen + 1).map(function (n) {\n      return pad(n.toString(), 3);\n    }).join('|') + '\\n';\n  }\n  return ret;\n}\nfunction printTables(pattern, patternStart, word, wordStart) {\n  pattern = pattern.substr(patternStart);\n  word = word.substr(wordStart);\n  console.log(printTable(_table, pattern, pattern.length, word, word.length));\n  console.log(printTable(_arrows, pattern, pattern.length, word, word.length));\n  console.log(printTable(_diag, pattern, pattern.length, word, word.length));\n}\nfunction isSeparatorAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n  var code = value.codePointAt(index);\n  switch (code) {\n    case 95 /* CharCode.Underline */:\n    case 45 /* CharCode.Dash */:\n    case 46 /* CharCode.Period */:\n    case 32 /* CharCode.Space */:\n    case 47 /* CharCode.Slash */:\n    case 92 /* CharCode.Backslash */:\n    case 39 /* CharCode.SingleQuote */:\n    case 34 /* CharCode.DoubleQuote */:\n    case 58 /* CharCode.Colon */:\n    case 36 /* CharCode.DollarSign */:\n    case 60 /* CharCode.LessThan */:\n    case 62 /* CharCode.GreaterThan */:\n    case 40 /* CharCode.OpenParen */:\n    case 41 /* CharCode.CloseParen */:\n    case 91 /* CharCode.OpenSquareBracket */:\n    case 93 /* CharCode.CloseSquareBracket */:\n    case 123 /* CharCode.OpenCurlyBrace */:\n    case 125 /* CharCode.CloseCurlyBrace */:\n      return true;\n    case undefined:\n      return false;\n    default:\n      if (strings.isEmojiImprecise(code)) {\n        return true;\n      }\n      return false;\n  }\n}\nfunction isWhitespaceAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n  var code = value.charCodeAt(index);\n  switch (code) {\n    case 32 /* CharCode.Space */:\n    case 9 /* CharCode.Tab */:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isUpperCaseAtPos(pos, word, wordLow) {\n  return word[pos] !== wordLow[pos];\n}\nexport function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen) {\n  var fillMinWordPosArr = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  while (patternPos < patternLen && wordPos < wordLen) {\n    if (patternLow[patternPos] === wordLow[wordPos]) {\n      if (fillMinWordPosArr) {\n        // Remember the min word position for each pattern position\n        _minWordMatchPos[patternPos] = wordPos;\n      }\n      patternPos += 1;\n    }\n    wordPos += 1;\n  }\n  return patternPos === patternLen; // pattern must be exhausted\n}\nexport var FuzzyScore;\n(function (FuzzyScore) {\n  /**\n   * No matches and value `-100`\n   */\n  FuzzyScore.Default = [-100, 0];\n  function isDefault(score) {\n    return !score || score.length === 2 && score[0] === -100 && score[1] === 0;\n  }\n  FuzzyScore.isDefault = isDefault;\n})(FuzzyScore || (FuzzyScore = {}));\nexport var FuzzyScoreOptions = /*#__PURE__*/_createClass(function FuzzyScoreOptions(firstMatchCanBeWeak, boostFullMatch) {\n  _classCallCheck(this, FuzzyScoreOptions);\n  this.firstMatchCanBeWeak = firstMatchCanBeWeak;\n  this.boostFullMatch = boostFullMatch;\n});\nFuzzyScoreOptions[\"default\"] = {\n  boostFullMatch: true,\n  firstMatchCanBeWeak: false\n};\nexport function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart) {\n  var options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : FuzzyScoreOptions[\"default\"];\n  var patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n  var wordLen = word.length > _maxLen ? _maxLen : word.length;\n  if (patternStart >= patternLen || wordStart >= wordLen || patternLen - patternStart > wordLen - wordStart) {\n    return undefined;\n  }\n  // Run a simple check if the characters of pattern occur\n  // (in order) at all in word. If that isn't the case we\n  // stop because no match will be possible\n  if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {\n    return undefined;\n  }\n  // Find the max matching word position for each pattern position\n  // NOTE: the min matching word position was filled in above, in the `isPatternInWord` call\n  _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);\n  var row = 1;\n  var column = 1;\n  var patternPos = patternStart;\n  var wordPos = wordStart;\n  var hasStrongFirstMatch = [false];\n  // There will be a match, fill in tables\n  for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n    // Reduce search space to possible matching word positions and to possible access from next row\n    var minWordMatchPos = _minWordMatchPos[patternPos];\n    var maxWordMatchPos = _maxWordMatchPos[patternPos];\n    var nextMaxWordMatchPos = patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen;\n    for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {\n      var score = Number.MIN_SAFE_INTEGER;\n      var canComeDiag = false;\n      if (wordPos <= maxWordMatchPos) {\n        score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, _diag[row - 1][column - 1] === 0, hasStrongFirstMatch);\n      }\n      var diagScore = 0;\n      if (score !== Number.MAX_SAFE_INTEGER) {\n        canComeDiag = true;\n        diagScore = score + _table[row - 1][column - 1];\n      }\n      var canComeLeft = wordPos > minWordMatchPos;\n      var leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0; // penalty for a gap start\n      var canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\n      var leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0; // penalty for a gap start\n      if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {\n        // always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word\n        _table[row][column] = leftLeftScore;\n        _arrows[row][column] = 3 /* Arrow.LeftLeft */;\n        _diag[row][column] = 0;\n      } else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\n        // always prefer choosing left since that means a match is earlier in the word\n        _table[row][column] = leftScore;\n        _arrows[row][column] = 2 /* Arrow.Left */;\n        _diag[row][column] = 0;\n      } else if (canComeDiag) {\n        _table[row][column] = diagScore;\n        _arrows[row][column] = 1 /* Arrow.Diag */;\n        _diag[row][column] = _diag[row - 1][column - 1] + 1;\n      } else {\n        throw new Error(\"not possible\");\n      }\n    }\n  }\n  if (_debug) {\n    printTables(pattern, patternStart, word, wordStart);\n  }\n  if (!hasStrongFirstMatch[0] && !options.firstMatchCanBeWeak) {\n    return undefined;\n  }\n  row--;\n  column--;\n  var result = [_table[row][column], wordStart];\n  var backwardsDiagLength = 0;\n  var maxMatchColumn = 0;\n  while (row >= 1) {\n    // Find the column where we go diagonally up\n    var diagColumn = column;\n    do {\n      var arrow = _arrows[row][diagColumn];\n      if (arrow === 3 /* Arrow.LeftLeft */) {\n        diagColumn = diagColumn - 2;\n      } else if (arrow === 2 /* Arrow.Left */) {\n        diagColumn = diagColumn - 1;\n      } else {\n        // found the diagonal\n        break;\n      }\n    } while (diagColumn >= 1);\n    // Overturn the \"forwards\" decision if keeping the \"backwards\" diagonal would give a better match\n    if (backwardsDiagLength > 1 // only if we would have a contiguous match of 3 characters\n    && patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] // only if we can do a contiguous match diagonally\n    && !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) // only if the forwards chose diagonal is not an uppercase\n    && backwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the \"forwards\" contiguous match\n    ) {\n      diagColumn = column;\n    }\n    if (diagColumn === column) {\n      // this is a contiguous match\n      backwardsDiagLength++;\n    } else {\n      backwardsDiagLength = 1;\n    }\n    if (!maxMatchColumn) {\n      // remember the last matched column\n      maxMatchColumn = diagColumn;\n    }\n    row--;\n    column = diagColumn - 1;\n    result.push(column);\n  }\n  if (wordLen === patternLen && options.boostFullMatch) {\n    // the word matches the pattern with all characters!\n    // giving the score a total match boost (to come up ahead other words)\n    result[0] += 2;\n  }\n  // Add 1 penalty for each skipped character in the word\n  var skippedCharsCount = maxMatchColumn - patternLen;\n  result[0] -= skippedCharsCount;\n  return result;\n}\nfunction _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {\n  var patternPos = patternLen - 1;\n  var wordPos = wordLen - 1;\n  while (patternPos >= patternStart && wordPos >= wordStart) {\n    if (patternLow[patternPos] === wordLow[wordPos]) {\n      _maxWordMatchPos[patternPos] = wordPos;\n      patternPos--;\n    }\n    wordPos--;\n  }\n}\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {\n  if (patternLow[patternPos] !== wordLow[wordPos]) {\n    return Number.MIN_SAFE_INTEGER;\n  }\n  var score = 1;\n  var isGapLocation = false;\n  if (wordPos === patternPos - patternStart) {\n    // common prefix: `foobar <-> foobaz`\n    //                            ^^^^^\n    score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n  } else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n    // hitting upper-case: `foo <-> forOthers`\n    //                              ^^ ^\n    score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n    isGapLocation = true;\n  } else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n    // hitting a separator: `. <-> foo.bar`\n    //                                ^\n    score = 5;\n  } else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n    // post separator: `foo <-> bar_foo`\n    //                              ^^^\n    score = 5;\n    isGapLocation = true;\n  }\n  if (score > 1 && patternPos === patternStart) {\n    outFirstMatchStrong[0] = true;\n  }\n  if (!isGapLocation) {\n    isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);\n  }\n  //\n  if (patternPos === patternStart) {\n    // first character in pattern\n    if (wordPos > wordStart) {\n      // the first pattern character would match a word character that is not at the word start\n      // so introduce a penalty to account for the gap preceding this match\n      score -= isGapLocation ? 3 : 5;\n    }\n  } else {\n    if (newMatchStart) {\n      // this would be the beginning of a new match (i.e. there would be a gap before this location)\n      score += isGapLocation ? 2 : 0;\n    } else {\n      // this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a preferred gap location\n      score += isGapLocation ? 0 : 1;\n    }\n  }\n  if (wordPos + 1 === wordLen) {\n    // we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word\n    // so pretend there is a gap after the last character in the word to normalize things\n    score -= isGapLocation ? 3 : 5;\n  }\n  return score;\n}\n//#endregion\n//#region --- graceful ---\nexport function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, options) {\n  return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, options);\n}\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, options) {\n  var top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options);\n  if (top && !aggressive) {\n    // when using the original pattern yield a result we`\n    // return it unless we are aggressive and try to find\n    // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n    return top;\n  }\n  if (pattern.length >= 3) {\n    // When the pattern is long enough then try a few (max 7)\n    // permutations of the pattern to find a better match. The\n    // permutations only swap neighbouring characters, e.g\n    // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n    var tries = Math.min(7, pattern.length - 1);\n    for (var movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n      var newPattern = nextTypoPermutation(pattern, movingPatternPos);\n      if (newPattern) {\n        var candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, options);\n        if (candidate) {\n          candidate[0] -= 3; // permutation penalty\n          if (!top || candidate[0] > top[0]) {\n            top = candidate;\n          }\n        }\n      }\n    }\n  }\n  return top;\n}\nfunction nextTypoPermutation(pattern, patternPos) {\n  if (patternPos + 1 >= pattern.length) {\n    return undefined;\n  }\n  var swap1 = pattern[patternPos];\n  var swap2 = pattern[patternPos + 1];\n  if (swap1 === swap2) {\n    return undefined;\n  }\n  return pattern.slice(0, patternPos) + swap2 + swap1 + pattern.slice(patternPos + 2);\n}\n//#endregion","map":{"version":3,"names":["LRUCache","getKoreanAltChars","strings","or","_len","arguments","length","filter","Array","_key","word","wordToMatchAgainst","i","len","match","matchesStrictPrefix","_matchesPrefix","bind","undefined","matchesPrefix","ignoreCase","matches","startsWithIgnoreCase","indexOf","start","end","matchesContiguousSubString","index","toLowerCase","matchesSubString","_matchesSubString","j","result","join","isLower","code","isUpper","isNumber","isWhitespace","wordSeparators","Set","split","forEach","s","add","charCodeAt","isWordSeparator","has","charactersMatch","codeA","codeB","alternateCharsCache","Map","getAlternateCodes","get","codes","set","isAlphanumeric","head","tail","unshift","nextAnchor","camelCaseWord","c","_matchesCamelCase","nextUpperIndex","analyzeCamelCaseWord","upper","lower","alpha","numeric","upperPercent","lowerPercent","alphaPercent","numericPercent","isUpperCaseWord","analysis","isCamelCaseWord","isCamelCasePattern","whitespace","matchesCamelCase","trim","substring","matchesWords","target","contiguous","targetIndex","_matchesWords","nextWord","wordIndex","targetIndexOffset","altChars","k","nextWordIndex","fuzzyContiguousFilter","fuzzySeparateFilter","fuzzyRegExpCache","matchesFuzzy","enableSeparateSubstringMatching","regexp","RegExp","convertSimple2RegExpPattern","exec","matchesFuzzy2","pattern","score","fuzzyScore","firstMatchCanBeWeak","boostFullMatch","createMatches","anyScore","lowPattern","patternPos","lowWord","wordPos","max","Math","min","res","pos","last","push","_maxLen","initTable","table","row","slice","initArr","maxLen","_minWordMatchPos","_maxWordMatchPos","_diag","_table","_arrows","_debug","printTable","patternLen","wordLen","pad","n","ret","concat","map","toString","printTables","patternStart","wordStart","substr","console","log","isSeparatorAtPos","value","codePointAt","isEmojiImprecise","isWhitespaceAtPos","isUpperCaseAtPos","wordLow","isPatternInWord","patternLow","fillMinWordPosArr","FuzzyScore","Default","isDefault","FuzzyScoreOptions","_createClass","_classCallCheck","options","_fillInMaxWordMatchPos","column","hasStrongFirstMatch","minWordMatchPos","maxWordMatchPos","nextMaxWordMatchPos","Number","MIN_SAFE_INTEGER","canComeDiag","_doScore","diagScore","MAX_SAFE_INTEGER","canComeLeft","leftScore","canComeLeftLeft","leftLeftScore","Error","backwardsDiagLength","maxMatchColumn","diagColumn","arrow","skippedCharsCount","newMatchStart","outFirstMatchStrong","isGapLocation","fuzzyScoreGracefulAggressive","fuzzyScoreWithPermutations","aggressive","top","tries","movingPatternPos","newPattern","nextTypoPermutation","candidate","swap1","swap2"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/base/common/filters.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LRUCache } from './map.js';\nimport { getKoreanAltChars } from './naturalLanguage/korean.js';\nimport * as strings from './strings.js';\n// Combined filters\n/**\n * @returns A filter which combines the provided set\n * of filters with an or. The *first* filters that\n * matches defined the return value of the returned\n * filter.\n */\nexport function or(...filter) {\n    return function (word, wordToMatchAgainst) {\n        for (let i = 0, len = filter.length; i < len; i++) {\n            const match = filter[i](word, wordToMatchAgainst);\n            if (match) {\n                return match;\n            }\n        }\n        return null;\n    };\n}\n// Prefix\nexport const matchesStrictPrefix = _matchesPrefix.bind(undefined, false);\nexport const matchesPrefix = _matchesPrefix.bind(undefined, true);\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\n    if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n        return null;\n    }\n    let matches;\n    if (ignoreCase) {\n        matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n    }\n    else {\n        matches = wordToMatchAgainst.indexOf(word) === 0;\n    }\n    if (!matches) {\n        return null;\n    }\n    return word.length > 0 ? [{ start: 0, end: word.length }] : [];\n}\n// Contiguous Substring\nexport function matchesContiguousSubString(word, wordToMatchAgainst) {\n    const index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n    if (index === -1) {\n        return null;\n    }\n    return [{ start: index, end: index + word.length }];\n}\n// Substring\nexport function matchesSubString(word, wordToMatchAgainst) {\n    return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === wordToMatchAgainst.length) {\n        return null;\n    }\n    else {\n        if (word[i] === wordToMatchAgainst[j]) {\n            let result = null;\n            if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n                return join({ start: j, end: j + 1 }, result);\n            }\n            return null;\n        }\n        return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n    }\n}\n// CamelCase\nfunction isLower(code) {\n    return 97 /* CharCode.a */ <= code && code <= 122 /* CharCode.z */;\n}\nexport function isUpper(code) {\n    return 65 /* CharCode.A */ <= code && code <= 90 /* CharCode.Z */;\n}\nfunction isNumber(code) {\n    return 48 /* CharCode.Digit0 */ <= code && code <= 57 /* CharCode.Digit9 */;\n}\nfunction isWhitespace(code) {\n    return (code === 32 /* CharCode.Space */\n        || code === 9 /* CharCode.Tab */\n        || code === 10 /* CharCode.LineFeed */\n        || code === 13 /* CharCode.CarriageReturn */);\n}\nconst wordSeparators = new Set();\n// These are chosen as natural word separators based on writen text.\n// It is a subset of the word separators used by the monaco editor.\n'()[]{}<>`\\'\"-/;:,.?!'\n    .split('')\n    .forEach(s => wordSeparators.add(s.charCodeAt(0)));\nfunction isWordSeparator(code) {\n    return isWhitespace(code) || wordSeparators.has(code);\n}\nfunction charactersMatch(codeA, codeB) {\n    return (codeA === codeB) || (isWordSeparator(codeA) && isWordSeparator(codeB));\n}\nconst alternateCharsCache = new Map();\n/**\n * Gets alternative codes to the character code passed in. This comes in the\n * form of an array of character codes, all of which must match _in order_ to\n * successfully match.\n *\n * @param code The character code to check.\n */\nfunction getAlternateCodes(code) {\n    if (alternateCharsCache.has(code)) {\n        return alternateCharsCache.get(code);\n    }\n    // NOTE: This function is written in such a way that it can be extended in\n    // the future, but right now the return type takes into account it's only\n    // supported by a single \"alt codes provider\".\n    // `ArrayLike<ArrayLike<number>>` is a more appropriate type if changed.\n    let result;\n    const codes = getKoreanAltChars(code);\n    if (codes) {\n        result = codes;\n    }\n    alternateCharsCache.set(code, result);\n    return result;\n}\nfunction isAlphanumeric(code) {\n    return isLower(code) || isUpper(code) || isNumber(code);\n}\nfunction join(head, tail) {\n    if (tail.length === 0) {\n        tail = [head];\n    }\n    else if (head.end === tail[0].start) {\n        tail[0].start = head.start;\n    }\n    else {\n        tail.unshift(head);\n    }\n    return tail;\n}\nfunction nextAnchor(camelCaseWord, start) {\n    for (let i = start; i < camelCaseWord.length; i++) {\n        const c = camelCaseWord.charCodeAt(i);\n        if (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\n            return i;\n        }\n    }\n    return camelCaseWord.length;\n}\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === camelCaseWord.length) {\n        return null;\n    }\n    else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n        return null;\n    }\n    else {\n        let result = null;\n        let nextUpperIndex = j + 1;\n        result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n        while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n            result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n            nextUpperIndex++;\n        }\n        return result === null ? null : join({ start: j, end: j + 1 }, result);\n    }\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\nfunction analyzeCamelCaseWord(word) {\n    let upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\n    for (let i = 0; i < word.length; i++) {\n        code = word.charCodeAt(i);\n        if (isUpper(code)) {\n            upper++;\n        }\n        if (isLower(code)) {\n            lower++;\n        }\n        if (isAlphanumeric(code)) {\n            alpha++;\n        }\n        if (isNumber(code)) {\n            numeric++;\n        }\n    }\n    const upperPercent = upper / word.length;\n    const lowerPercent = lower / word.length;\n    const alphaPercent = alpha / word.length;\n    const numericPercent = numeric / word.length;\n    return { upperPercent, lowerPercent, alphaPercent, numericPercent };\n}\nfunction isUpperCaseWord(analysis) {\n    const { upperPercent, lowerPercent } = analysis;\n    return lowerPercent === 0 && upperPercent > 0.6;\n}\nfunction isCamelCaseWord(analysis) {\n    const { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;\n    return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\nfunction isCamelCasePattern(word) {\n    let upper = 0, lower = 0, code = 0, whitespace = 0;\n    for (let i = 0; i < word.length; i++) {\n        code = word.charCodeAt(i);\n        if (isUpper(code)) {\n            upper++;\n        }\n        if (isLower(code)) {\n            lower++;\n        }\n        if (isWhitespace(code)) {\n            whitespace++;\n        }\n    }\n    if ((upper === 0 || lower === 0) && whitespace === 0) {\n        return word.length <= 30;\n    }\n    else {\n        return upper <= 5;\n    }\n}\nexport function matchesCamelCase(word, camelCaseWord) {\n    if (!camelCaseWord) {\n        return null;\n    }\n    camelCaseWord = camelCaseWord.trim();\n    if (camelCaseWord.length === 0) {\n        return null;\n    }\n    if (!isCamelCasePattern(word)) {\n        return null;\n    }\n    // TODO: Consider removing this check\n    if (camelCaseWord.length > 60) {\n        camelCaseWord = camelCaseWord.substring(0, 60);\n    }\n    const analysis = analyzeCamelCaseWord(camelCaseWord);\n    if (!isCamelCaseWord(analysis)) {\n        if (!isUpperCaseWord(analysis)) {\n            return null;\n        }\n        camelCaseWord = camelCaseWord.toLowerCase();\n    }\n    let result = null;\n    let i = 0;\n    word = word.toLowerCase();\n    while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n        i = nextAnchor(camelCaseWord, i + 1);\n    }\n    return result;\n}\n// Matches beginning of words supporting non-ASCII languages\n// If `contiguous` is true then matches word with beginnings of the words in the target. E.g. \"pul\" will match \"Git: Pull\"\n// Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\n// Useful in cases where the target is words (e.g. command labels)\nexport function matchesWords(word, target, contiguous = false) {\n    if (!target || target.length === 0) {\n        return null;\n    }\n    let result = null;\n    let targetIndex = 0;\n    word = word.toLowerCase();\n    target = target.toLowerCase();\n    while (targetIndex < target.length) {\n        result = _matchesWords(word, target, 0, targetIndex, contiguous);\n        if (result !== null) {\n            break;\n        }\n        targetIndex = nextWord(target, targetIndex + 1);\n    }\n    return result;\n}\nfunction _matchesWords(word, target, wordIndex, targetIndex, contiguous) {\n    let targetIndexOffset = 0;\n    if (wordIndex === word.length) {\n        return [];\n    }\n    else if (targetIndex === target.length) {\n        return null;\n    }\n    else if (!charactersMatch(word.charCodeAt(wordIndex), target.charCodeAt(targetIndex))) {\n        // Verify alternate characters before exiting\n        const altChars = getAlternateCodes(word.charCodeAt(wordIndex));\n        if (!altChars) {\n            return null;\n        }\n        for (let k = 0; k < altChars.length; k++) {\n            if (!charactersMatch(altChars[k], target.charCodeAt(targetIndex + k))) {\n                return null;\n            }\n        }\n        targetIndexOffset += altChars.length - 1;\n    }\n    let result = null;\n    let nextWordIndex = targetIndex + targetIndexOffset + 1;\n    result = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);\n    if (!contiguous) {\n        while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n            result = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);\n            nextWordIndex++;\n        }\n    }\n    if (!result) {\n        return null;\n    }\n    // If the characters don't exactly match, then they must be word separators (see charactersMatch(...)).\n    // We don't want to include this in the matches but we don't want to throw the target out all together so we return `result`.\n    if (word.charCodeAt(wordIndex) !== target.charCodeAt(targetIndex)) {\n        // Verify alternate characters before exiting\n        const altChars = getAlternateCodes(word.charCodeAt(wordIndex));\n        if (!altChars) {\n            return result;\n        }\n        for (let k = 0; k < altChars.length; k++) {\n            if (altChars[k] !== target.charCodeAt(targetIndex + k)) {\n                return result;\n            }\n        }\n    }\n    return join({ start: targetIndex, end: targetIndex + targetIndexOffset + 1 }, result);\n}\nfunction nextWord(word, start) {\n    for (let i = start; i < word.length; i++) {\n        if (isWordSeparator(word.charCodeAt(i)) ||\n            (i > 0 && isWordSeparator(word.charCodeAt(i - 1)))) {\n            return i;\n        }\n    }\n    return word.length;\n}\n// Fuzzy\nconst fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nconst fuzzyRegExpCache = new LRUCache(10000); // bounded to 10000 elements\nexport function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching = false) {\n    if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n        return null; // return early for invalid input\n    }\n    // Form RegExp for wildcard matches\n    let regexp = fuzzyRegExpCache.get(word);\n    if (!regexp) {\n        regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n        fuzzyRegExpCache.set(word, regexp);\n    }\n    // RegExp Filter\n    const match = regexp.exec(wordToMatchAgainst);\n    if (match) {\n        return [{ start: match.index, end: match.index + match[0].length }];\n    }\n    // Default Filter\n    return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\n/**\n * Match pattern against word in a fuzzy way. As in IntelliSense and faster and more\n * powerful than `matchesFuzzy`\n */\nexport function matchesFuzzy2(pattern, word) {\n    const score = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, { firstMatchCanBeWeak: true, boostFullMatch: true });\n    return score ? createMatches(score) : null;\n}\nexport function anyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos) {\n    const max = Math.min(13, pattern.length);\n    for (; patternPos < max; patternPos++) {\n        const result = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, { firstMatchCanBeWeak: true, boostFullMatch: true });\n        if (result) {\n            return result;\n        }\n    }\n    return [0, wordPos];\n}\n//#region --- fuzzyScore ---\nexport function createMatches(score) {\n    if (typeof score === 'undefined') {\n        return [];\n    }\n    const res = [];\n    const wordPos = score[1];\n    for (let i = score.length - 1; i > 1; i--) {\n        const pos = score[i] + wordPos;\n        const last = res[res.length - 1];\n        if (last && last.end === pos) {\n            last.end = pos + 1;\n        }\n        else {\n            res.push({ start: pos, end: pos + 1 });\n        }\n    }\n    return res;\n}\nconst _maxLen = 128;\nfunction initTable() {\n    const table = [];\n    const row = [];\n    for (let i = 0; i <= _maxLen; i++) {\n        row[i] = 0;\n    }\n    for (let i = 0; i <= _maxLen; i++) {\n        table.push(row.slice(0));\n    }\n    return table;\n}\nfunction initArr(maxLen) {\n    const row = [];\n    for (let i = 0; i <= maxLen; i++) {\n        row[i] = 0;\n    }\n    return row;\n}\nconst _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position\nconst _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position\nconst _diag = initTable(); // the length of a contiguous diagonal match\nconst _table = initTable();\nconst _arrows = initTable();\nconst _debug = false;\nfunction printTable(table, pattern, patternLen, word, wordLen) {\n    function pad(s, n, pad = ' ') {\n        while (s.length < n) {\n            s = pad + s;\n        }\n        return s;\n    }\n    let ret = ` |   |${word.split('').map(c => pad(c, 3)).join('|')}\\n`;\n    for (let i = 0; i <= patternLen; i++) {\n        if (i === 0) {\n            ret += ' |';\n        }\n        else {\n            ret += `${pattern[i - 1]}|`;\n        }\n        ret += table[i].slice(0, wordLen + 1).map(n => pad(n.toString(), 3)).join('|') + '\\n';\n    }\n    return ret;\n}\nfunction printTables(pattern, patternStart, word, wordStart) {\n    pattern = pattern.substr(patternStart);\n    word = word.substr(wordStart);\n    console.log(printTable(_table, pattern, pattern.length, word, word.length));\n    console.log(printTable(_arrows, pattern, pattern.length, word, word.length));\n    console.log(printTable(_diag, pattern, pattern.length, word, word.length));\n}\nfunction isSeparatorAtPos(value, index) {\n    if (index < 0 || index >= value.length) {\n        return false;\n    }\n    const code = value.codePointAt(index);\n    switch (code) {\n        case 95 /* CharCode.Underline */:\n        case 45 /* CharCode.Dash */:\n        case 46 /* CharCode.Period */:\n        case 32 /* CharCode.Space */:\n        case 47 /* CharCode.Slash */:\n        case 92 /* CharCode.Backslash */:\n        case 39 /* CharCode.SingleQuote */:\n        case 34 /* CharCode.DoubleQuote */:\n        case 58 /* CharCode.Colon */:\n        case 36 /* CharCode.DollarSign */:\n        case 60 /* CharCode.LessThan */:\n        case 62 /* CharCode.GreaterThan */:\n        case 40 /* CharCode.OpenParen */:\n        case 41 /* CharCode.CloseParen */:\n        case 91 /* CharCode.OpenSquareBracket */:\n        case 93 /* CharCode.CloseSquareBracket */:\n        case 123 /* CharCode.OpenCurlyBrace */:\n        case 125 /* CharCode.CloseCurlyBrace */:\n            return true;\n        case undefined:\n            return false;\n        default:\n            if (strings.isEmojiImprecise(code)) {\n                return true;\n            }\n            return false;\n    }\n}\nfunction isWhitespaceAtPos(value, index) {\n    if (index < 0 || index >= value.length) {\n        return false;\n    }\n    const code = value.charCodeAt(index);\n    switch (code) {\n        case 32 /* CharCode.Space */:\n        case 9 /* CharCode.Tab */:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isUpperCaseAtPos(pos, word, wordLow) {\n    return word[pos] !== wordLow[pos];\n}\nexport function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen, fillMinWordPosArr = false) {\n    while (patternPos < patternLen && wordPos < wordLen) {\n        if (patternLow[patternPos] === wordLow[wordPos]) {\n            if (fillMinWordPosArr) {\n                // Remember the min word position for each pattern position\n                _minWordMatchPos[patternPos] = wordPos;\n            }\n            patternPos += 1;\n        }\n        wordPos += 1;\n    }\n    return patternPos === patternLen; // pattern must be exhausted\n}\nexport var FuzzyScore;\n(function (FuzzyScore) {\n    /**\n     * No matches and value `-100`\n     */\n    FuzzyScore.Default = ([-100, 0]);\n    function isDefault(score) {\n        return !score || (score.length === 2 && score[0] === -100 && score[1] === 0);\n    }\n    FuzzyScore.isDefault = isDefault;\n})(FuzzyScore || (FuzzyScore = {}));\nexport class FuzzyScoreOptions {\n    constructor(firstMatchCanBeWeak, boostFullMatch) {\n        this.firstMatchCanBeWeak = firstMatchCanBeWeak;\n        this.boostFullMatch = boostFullMatch;\n    }\n}\nFuzzyScoreOptions.default = { boostFullMatch: true, firstMatchCanBeWeak: false };\nexport function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, options = FuzzyScoreOptions.default) {\n    const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n    const wordLen = word.length > _maxLen ? _maxLen : word.length;\n    if (patternStart >= patternLen || wordStart >= wordLen || (patternLen - patternStart) > (wordLen - wordStart)) {\n        return undefined;\n    }\n    // Run a simple check if the characters of pattern occur\n    // (in order) at all in word. If that isn't the case we\n    // stop because no match will be possible\n    if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {\n        return undefined;\n    }\n    // Find the max matching word position for each pattern position\n    // NOTE: the min matching word position was filled in above, in the `isPatternInWord` call\n    _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);\n    let row = 1;\n    let column = 1;\n    let patternPos = patternStart;\n    let wordPos = wordStart;\n    const hasStrongFirstMatch = [false];\n    // There will be a match, fill in tables\n    for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n        // Reduce search space to possible matching word positions and to possible access from next row\n        const minWordMatchPos = _minWordMatchPos[patternPos];\n        const maxWordMatchPos = _maxWordMatchPos[patternPos];\n        const nextMaxWordMatchPos = (patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen);\n        for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {\n            let score = Number.MIN_SAFE_INTEGER;\n            let canComeDiag = false;\n            if (wordPos <= maxWordMatchPos) {\n                score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, _diag[row - 1][column - 1] === 0, hasStrongFirstMatch);\n            }\n            let diagScore = 0;\n            if (score !== Number.MAX_SAFE_INTEGER) {\n                canComeDiag = true;\n                diagScore = score + _table[row - 1][column - 1];\n            }\n            const canComeLeft = wordPos > minWordMatchPos;\n            const leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0; // penalty for a gap start\n            const canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\n            const leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0; // penalty for a gap start\n            if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {\n                // always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word\n                _table[row][column] = leftLeftScore;\n                _arrows[row][column] = 3 /* Arrow.LeftLeft */;\n                _diag[row][column] = 0;\n            }\n            else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\n                // always prefer choosing left since that means a match is earlier in the word\n                _table[row][column] = leftScore;\n                _arrows[row][column] = 2 /* Arrow.Left */;\n                _diag[row][column] = 0;\n            }\n            else if (canComeDiag) {\n                _table[row][column] = diagScore;\n                _arrows[row][column] = 1 /* Arrow.Diag */;\n                _diag[row][column] = _diag[row - 1][column - 1] + 1;\n            }\n            else {\n                throw new Error(`not possible`);\n            }\n        }\n    }\n    if (_debug) {\n        printTables(pattern, patternStart, word, wordStart);\n    }\n    if (!hasStrongFirstMatch[0] && !options.firstMatchCanBeWeak) {\n        return undefined;\n    }\n    row--;\n    column--;\n    const result = [_table[row][column], wordStart];\n    let backwardsDiagLength = 0;\n    let maxMatchColumn = 0;\n    while (row >= 1) {\n        // Find the column where we go diagonally up\n        let diagColumn = column;\n        do {\n            const arrow = _arrows[row][diagColumn];\n            if (arrow === 3 /* Arrow.LeftLeft */) {\n                diagColumn = diagColumn - 2;\n            }\n            else if (arrow === 2 /* Arrow.Left */) {\n                diagColumn = diagColumn - 1;\n            }\n            else {\n                // found the diagonal\n                break;\n            }\n        } while (diagColumn >= 1);\n        // Overturn the \"forwards\" decision if keeping the \"backwards\" diagonal would give a better match\n        if (backwardsDiagLength > 1 // only if we would have a contiguous match of 3 characters\n            && patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] // only if we can do a contiguous match diagonally\n            && !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) // only if the forwards chose diagonal is not an uppercase\n            && backwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the \"forwards\" contiguous match\n        ) {\n            diagColumn = column;\n        }\n        if (diagColumn === column) {\n            // this is a contiguous match\n            backwardsDiagLength++;\n        }\n        else {\n            backwardsDiagLength = 1;\n        }\n        if (!maxMatchColumn) {\n            // remember the last matched column\n            maxMatchColumn = diagColumn;\n        }\n        row--;\n        column = diagColumn - 1;\n        result.push(column);\n    }\n    if (wordLen === patternLen && options.boostFullMatch) {\n        // the word matches the pattern with all characters!\n        // giving the score a total match boost (to come up ahead other words)\n        result[0] += 2;\n    }\n    // Add 1 penalty for each skipped character in the word\n    const skippedCharsCount = maxMatchColumn - patternLen;\n    result[0] -= skippedCharsCount;\n    return result;\n}\nfunction _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {\n    let patternPos = patternLen - 1;\n    let wordPos = wordLen - 1;\n    while (patternPos >= patternStart && wordPos >= wordStart) {\n        if (patternLow[patternPos] === wordLow[wordPos]) {\n            _maxWordMatchPos[patternPos] = wordPos;\n            patternPos--;\n        }\n        wordPos--;\n    }\n}\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {\n    if (patternLow[patternPos] !== wordLow[wordPos]) {\n        return Number.MIN_SAFE_INTEGER;\n    }\n    let score = 1;\n    let isGapLocation = false;\n    if (wordPos === (patternPos - patternStart)) {\n        // common prefix: `foobar <-> foobaz`\n        //                            ^^^^^\n        score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n    }\n    else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n        // hitting upper-case: `foo <-> forOthers`\n        //                              ^^ ^\n        score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n        isGapLocation = true;\n    }\n    else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n        // hitting a separator: `. <-> foo.bar`\n        //                                ^\n        score = 5;\n    }\n    else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n        // post separator: `foo <-> bar_foo`\n        //                              ^^^\n        score = 5;\n        isGapLocation = true;\n    }\n    if (score > 1 && patternPos === patternStart) {\n        outFirstMatchStrong[0] = true;\n    }\n    if (!isGapLocation) {\n        isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);\n    }\n    //\n    if (patternPos === patternStart) { // first character in pattern\n        if (wordPos > wordStart) {\n            // the first pattern character would match a word character that is not at the word start\n            // so introduce a penalty to account for the gap preceding this match\n            score -= isGapLocation ? 3 : 5;\n        }\n    }\n    else {\n        if (newMatchStart) {\n            // this would be the beginning of a new match (i.e. there would be a gap before this location)\n            score += isGapLocation ? 2 : 0;\n        }\n        else {\n            // this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a preferred gap location\n            score += isGapLocation ? 0 : 1;\n        }\n    }\n    if (wordPos + 1 === wordLen) {\n        // we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word\n        // so pretend there is a gap after the last character in the word to normalize things\n        score -= isGapLocation ? 3 : 5;\n    }\n    return score;\n}\n//#endregion\n//#region --- graceful ---\nexport function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, options) {\n    return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, options);\n}\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, options) {\n    let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options);\n    if (top && !aggressive) {\n        // when using the original pattern yield a result we`\n        // return it unless we are aggressive and try to find\n        // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n        return top;\n    }\n    if (pattern.length >= 3) {\n        // When the pattern is long enough then try a few (max 7)\n        // permutations of the pattern to find a better match. The\n        // permutations only swap neighbouring characters, e.g\n        // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n        const tries = Math.min(7, pattern.length - 1);\n        for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n            const newPattern = nextTypoPermutation(pattern, movingPatternPos);\n            if (newPattern) {\n                const candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, options);\n                if (candidate) {\n                    candidate[0] -= 3; // permutation penalty\n                    if (!top || candidate[0] > top[0]) {\n                        top = candidate;\n                    }\n                }\n            }\n        }\n    }\n    return top;\n}\nfunction nextTypoPermutation(pattern, patternPos) {\n    if (patternPos + 1 >= pattern.length) {\n        return undefined;\n    }\n    const swap1 = pattern[patternPos];\n    const swap2 = pattern[patternPos + 1];\n    if (swap1 === swap2) {\n        return undefined;\n    }\n    return pattern.slice(0, patternPos)\n        + swap2\n        + swap1\n        + pattern.slice(patternPos + 2);\n}\n//#endregion\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}