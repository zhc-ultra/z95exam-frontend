{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nexport var LineTokens = /*#__PURE__*/function () {\n  function LineTokens(tokens, text, decoder) {\n    _classCallCheck(this, LineTokens);\n    this._lineTokensBrand = undefined;\n    this._tokens = tokens;\n    this._tokensCount = this._tokens.length >>> 1;\n    this._text = text;\n    this._languageIdCodec = decoder;\n  }\n  return _createClass(LineTokens, [{\n    key: \"equals\",\n    value: function equals(other) {\n      if (other instanceof LineTokens) {\n        return this.slicedEquals(other, 0, this._tokensCount);\n      }\n      return false;\n    }\n  }, {\n    key: \"slicedEquals\",\n    value: function slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n      if (this._text !== other._text) {\n        return false;\n      }\n      if (this._tokensCount !== other._tokensCount) {\n        return false;\n      }\n      var from = sliceFromTokenIndex << 1;\n      var to = from + (sliceTokenCount << 1);\n      for (var i = from; i < to; i++) {\n        if (this._tokens[i] !== other._tokens[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"getLineContent\",\n    value: function getLineContent() {\n      return this._text;\n    }\n  }, {\n    key: \"getCount\",\n    value: function getCount() {\n      return this._tokensCount;\n    }\n  }, {\n    key: \"getStartOffset\",\n    value: function getStartOffset(tokenIndex) {\n      if (tokenIndex > 0) {\n        return this._tokens[tokenIndex - 1 << 1];\n      }\n      return 0;\n    }\n  }, {\n    key: \"getMetadata\",\n    value: function getMetadata(tokenIndex) {\n      var metadata = this._tokens[(tokenIndex << 1) + 1];\n      return metadata;\n    }\n  }, {\n    key: \"getLanguageId\",\n    value: function getLanguageId(tokenIndex) {\n      var metadata = this._tokens[(tokenIndex << 1) + 1];\n      var languageId = TokenMetadata.getLanguageId(metadata);\n      return this._languageIdCodec.decodeLanguageId(languageId);\n    }\n  }, {\n    key: \"getStandardTokenType\",\n    value: function getStandardTokenType(tokenIndex) {\n      var metadata = this._tokens[(tokenIndex << 1) + 1];\n      return TokenMetadata.getTokenType(metadata);\n    }\n  }, {\n    key: \"getForeground\",\n    value: function getForeground(tokenIndex) {\n      var metadata = this._tokens[(tokenIndex << 1) + 1];\n      return TokenMetadata.getForeground(metadata);\n    }\n  }, {\n    key: \"getClassName\",\n    value: function getClassName(tokenIndex) {\n      var metadata = this._tokens[(tokenIndex << 1) + 1];\n      return TokenMetadata.getClassNameFromMetadata(metadata);\n    }\n  }, {\n    key: \"getInlineStyle\",\n    value: function getInlineStyle(tokenIndex, colorMap) {\n      var metadata = this._tokens[(tokenIndex << 1) + 1];\n      return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n    }\n  }, {\n    key: \"getPresentation\",\n    value: function getPresentation(tokenIndex) {\n      var metadata = this._tokens[(tokenIndex << 1) + 1];\n      return TokenMetadata.getPresentationFromMetadata(metadata);\n    }\n  }, {\n    key: \"getEndOffset\",\n    value: function getEndOffset(tokenIndex) {\n      return this._tokens[tokenIndex << 1];\n    }\n    /**\n     * Find the token containing offset `offset`.\n     * @param offset The search offset\n     * @return The index of the token containing the offset.\n     */\n  }, {\n    key: \"findTokenIndexAtOffset\",\n    value: function findTokenIndexAtOffset(offset) {\n      return LineTokens.findIndexInTokensArray(this._tokens, offset);\n    }\n  }, {\n    key: \"inflate\",\n    value: function inflate() {\n      return this;\n    }\n  }, {\n    key: \"sliceAndInflate\",\n    value: function sliceAndInflate(startOffset, endOffset, deltaOffset) {\n      return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n    }\n  }, {\n    key: \"withInserted\",\n    value:\n    /**\n     * @pure\n     * @param insertTokens Must be sorted by offset.\n    */\n    function withInserted(insertTokens) {\n      if (insertTokens.length === 0) {\n        return this;\n      }\n      var nextOriginalTokenIdx = 0;\n      var nextInsertTokenIdx = 0;\n      var text = '';\n      var newTokens = new Array();\n      var originalEndOffset = 0;\n      while (true) {\n        var nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n        var nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n        if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n          // original token ends before next insert token\n          text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n          var metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n          newTokens.push(text.length, metadata);\n          nextOriginalTokenIdx++;\n          originalEndOffset = nextOriginalTokenEndOffset;\n        } else if (nextInsertToken) {\n          if (nextInsertToken.offset > originalEndOffset) {\n            // insert token is in the middle of the next token.\n            text += this._text.substring(originalEndOffset, nextInsertToken.offset);\n            var _metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n            newTokens.push(text.length, _metadata);\n            originalEndOffset = nextInsertToken.offset;\n          }\n          text += nextInsertToken.text;\n          newTokens.push(text.length, nextInsertToken.tokenMetadata);\n          nextInsertTokenIdx++;\n        } else {\n          break;\n        }\n      }\n      return new LineTokens(new Uint32Array(newTokens), text, this._languageIdCodec);\n    }\n  }], [{\n    key: \"createEmpty\",\n    value: function createEmpty(lineContent, decoder) {\n      var defaultMetadata = LineTokens.defaultTokenMetadata;\n      var tokens = new Uint32Array(2);\n      tokens[0] = lineContent.length;\n      tokens[1] = defaultMetadata;\n      return new LineTokens(tokens, lineContent, decoder);\n    }\n  }, {\n    key: \"convertToEndOffset\",\n    value: function convertToEndOffset(tokens, lineTextLength) {\n      var tokenCount = tokens.length >>> 1;\n      var lastTokenIndex = tokenCount - 1;\n      for (var tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n        tokens[tokenIndex << 1] = tokens[tokenIndex + 1 << 1];\n      }\n      tokens[lastTokenIndex << 1] = lineTextLength;\n    }\n  }, {\n    key: \"findIndexInTokensArray\",\n    value: function findIndexInTokensArray(tokens, desiredIndex) {\n      if (tokens.length <= 2) {\n        return 0;\n      }\n      var low = 0;\n      var high = (tokens.length >>> 1) - 1;\n      while (low < high) {\n        var mid = low + Math.floor((high - low) / 2);\n        var endOffset = tokens[mid << 1];\n        if (endOffset === desiredIndex) {\n          return mid + 1;\n        } else if (endOffset < desiredIndex) {\n          low = mid + 1;\n        } else if (endOffset > desiredIndex) {\n          high = mid;\n        }\n      }\n      return low;\n    }\n  }]);\n}();\nLineTokens.defaultTokenMetadata = (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */ | 1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */ | 2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */) >>> 0;\nvar SliceLineTokens = /*#__PURE__*/function () {\n  function SliceLineTokens(source, startOffset, endOffset, deltaOffset) {\n    _classCallCheck(this, SliceLineTokens);\n    this._source = source;\n    this._startOffset = startOffset;\n    this._endOffset = endOffset;\n    this._deltaOffset = deltaOffset;\n    this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n    this._tokensCount = 0;\n    for (var i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n      var tokenStartOffset = source.getStartOffset(i);\n      if (tokenStartOffset >= endOffset) {\n        break;\n      }\n      this._tokensCount++;\n    }\n  }\n  return _createClass(SliceLineTokens, [{\n    key: \"getMetadata\",\n    value: function getMetadata(tokenIndex) {\n      return this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n    }\n  }, {\n    key: \"getLanguageId\",\n    value: function getLanguageId(tokenIndex) {\n      return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n    }\n  }, {\n    key: \"getLineContent\",\n    value: function getLineContent() {\n      return this._source.getLineContent().substring(this._startOffset, this._endOffset);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (other instanceof SliceLineTokens) {\n        return this._startOffset === other._startOffset && this._endOffset === other._endOffset && this._deltaOffset === other._deltaOffset && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount);\n      }\n      return false;\n    }\n  }, {\n    key: \"getCount\",\n    value: function getCount() {\n      return this._tokensCount;\n    }\n  }, {\n    key: \"getForeground\",\n    value: function getForeground(tokenIndex) {\n      return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n    }\n  }, {\n    key: \"getEndOffset\",\n    value: function getEndOffset(tokenIndex) {\n      var tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n      return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n    }\n  }, {\n    key: \"getClassName\",\n    value: function getClassName(tokenIndex) {\n      return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n    }\n  }, {\n    key: \"getInlineStyle\",\n    value: function getInlineStyle(tokenIndex, colorMap) {\n      return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n    }\n  }, {\n    key: \"getPresentation\",\n    value: function getPresentation(tokenIndex) {\n      return this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n    }\n  }, {\n    key: \"findTokenIndexAtOffset\",\n    value: function findTokenIndexAtOffset(offset) {\n      return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n    }\n  }]);\n}();","map":{"version":3,"names":["TokenMetadata","LineTokens","tokens","text","decoder","_classCallCheck","_lineTokensBrand","undefined","_tokens","_tokensCount","length","_text","_languageIdCodec","_createClass","key","value","equals","other","slicedEquals","sliceFromTokenIndex","sliceTokenCount","from","to","i","getLineContent","getCount","getStartOffset","tokenIndex","getMetadata","metadata","getLanguageId","languageId","decodeLanguageId","getStandardTokenType","getTokenType","getForeground","getClassName","getClassNameFromMetadata","getInlineStyle","colorMap","getInlineStyleFromMetadata","getPresentation","getPresentationFromMetadata","getEndOffset","findTokenIndexAtOffset","offset","findIndexInTokensArray","inflate","sliceAndInflate","startOffset","endOffset","deltaOffset","SliceLineTokens","withInserted","insertTokens","nextOriginalTokenIdx","nextInsertTokenIdx","newTokens","Array","originalEndOffset","nextOriginalTokenEndOffset","nextInsertToken","substring","push","tokenMetadata","Uint32Array","createEmpty","lineContent","defaultMetadata","defaultTokenMetadata","convertToEndOffset","lineTextLength","tokenCount","lastTokenIndex","desiredIndex","low","high","mid","Math","floor","source","_source","_startOffset","_endOffset","_deltaOffset","_firstTokenIndex","len","tokenStartOffset","tokenEndOffset","min"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nexport class LineTokens {\n    static createEmpty(lineContent, decoder) {\n        const defaultMetadata = LineTokens.defaultTokenMetadata;\n        const tokens = new Uint32Array(2);\n        tokens[0] = lineContent.length;\n        tokens[1] = defaultMetadata;\n        return new LineTokens(tokens, lineContent, decoder);\n    }\n    constructor(tokens, text, decoder) {\n        this._lineTokensBrand = undefined;\n        this._tokens = tokens;\n        this._tokensCount = (this._tokens.length >>> 1);\n        this._text = text;\n        this._languageIdCodec = decoder;\n    }\n    equals(other) {\n        if (other instanceof LineTokens) {\n            return this.slicedEquals(other, 0, this._tokensCount);\n        }\n        return false;\n    }\n    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n        if (this._text !== other._text) {\n            return false;\n        }\n        if (this._tokensCount !== other._tokensCount) {\n            return false;\n        }\n        const from = (sliceFromTokenIndex << 1);\n        const to = from + (sliceTokenCount << 1);\n        for (let i = from; i < to; i++) {\n            if (this._tokens[i] !== other._tokens[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getLineContent() {\n        return this._text;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStartOffset(tokenIndex) {\n        if (tokenIndex > 0) {\n            return this._tokens[(tokenIndex - 1) << 1];\n        }\n        return 0;\n    }\n    getMetadata(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return metadata;\n    }\n    getLanguageId(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        const languageId = TokenMetadata.getLanguageId(metadata);\n        return this._languageIdCodec.decodeLanguageId(languageId);\n    }\n    getStandardTokenType(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getTokenType(metadata);\n    }\n    getForeground(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getForeground(metadata);\n    }\n    getClassName(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getClassNameFromMetadata(metadata);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getPresentationFromMetadata(metadata);\n    }\n    getEndOffset(tokenIndex) {\n        return this._tokens[tokenIndex << 1];\n    }\n    /**\n     * Find the token containing offset `offset`.\n     * @param offset The search offset\n     * @return The index of the token containing the offset.\n     */\n    findTokenIndexAtOffset(offset) {\n        return LineTokens.findIndexInTokensArray(this._tokens, offset);\n    }\n    inflate() {\n        return this;\n    }\n    sliceAndInflate(startOffset, endOffset, deltaOffset) {\n        return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n    }\n    static convertToEndOffset(tokens, lineTextLength) {\n        const tokenCount = (tokens.length >>> 1);\n        const lastTokenIndex = tokenCount - 1;\n        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n        }\n        tokens[lastTokenIndex << 1] = lineTextLength;\n    }\n    static findIndexInTokensArray(tokens, desiredIndex) {\n        if (tokens.length <= 2) {\n            return 0;\n        }\n        let low = 0;\n        let high = (tokens.length >>> 1) - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const endOffset = tokens[(mid << 1)];\n            if (endOffset === desiredIndex) {\n                return mid + 1;\n            }\n            else if (endOffset < desiredIndex) {\n                low = mid + 1;\n            }\n            else if (endOffset > desiredIndex) {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    /**\n     * @pure\n     * @param insertTokens Must be sorted by offset.\n    */\n    withInserted(insertTokens) {\n        if (insertTokens.length === 0) {\n            return this;\n        }\n        let nextOriginalTokenIdx = 0;\n        let nextInsertTokenIdx = 0;\n        let text = '';\n        const newTokens = new Array();\n        let originalEndOffset = 0;\n        while (true) {\n            const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n            const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n            if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n                // original token ends before next insert token\n                text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n                const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                newTokens.push(text.length, metadata);\n                nextOriginalTokenIdx++;\n                originalEndOffset = nextOriginalTokenEndOffset;\n            }\n            else if (nextInsertToken) {\n                if (nextInsertToken.offset > originalEndOffset) {\n                    // insert token is in the middle of the next token.\n                    text += this._text.substring(originalEndOffset, nextInsertToken.offset);\n                    const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                    newTokens.push(text.length, metadata);\n                    originalEndOffset = nextInsertToken.offset;\n                }\n                text += nextInsertToken.text;\n                newTokens.push(text.length, nextInsertToken.tokenMetadata);\n                nextInsertTokenIdx++;\n            }\n            else {\n                break;\n            }\n        }\n        return new LineTokens(new Uint32Array(newTokens), text, this._languageIdCodec);\n    }\n}\nLineTokens.defaultTokenMetadata = ((0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n    | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n    | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\nclass SliceLineTokens {\n    constructor(source, startOffset, endOffset, deltaOffset) {\n        this._source = source;\n        this._startOffset = startOffset;\n        this._endOffset = endOffset;\n        this._deltaOffset = deltaOffset;\n        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n        this._tokensCount = 0;\n        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n            const tokenStartOffset = source.getStartOffset(i);\n            if (tokenStartOffset >= endOffset) {\n                break;\n            }\n            this._tokensCount++;\n        }\n    }\n    getMetadata(tokenIndex) {\n        return this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n    }\n    getLanguageId(tokenIndex) {\n        return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n    }\n    getLineContent() {\n        return this._source.getLineContent().substring(this._startOffset, this._endOffset);\n    }\n    equals(other) {\n        if (other instanceof SliceLineTokens) {\n            return (this._startOffset === other._startOffset\n                && this._endOffset === other._endOffset\n                && this._deltaOffset === other._deltaOffset\n                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\n        }\n        return false;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getForeground(tokenIndex) {\n        return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n    }\n    getEndOffset(tokenIndex) {\n        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n    }\n    getClassName(tokenIndex) {\n        return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        return this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}