{"ast":null,"code":"import _objectSpread from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.starts-with.js\";\nimport \"core-js/modules/es.string.trim.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar markRegex = /\\bMARK:\\s*(.*)$/d;\nvar trimDashesRegex = /^-+|-+$/g;\n/**\n * Find section headers in the model.\n *\n * @param model the text model to search in\n * @param options options to search with\n * @returns an array of section headers\n */\nexport function findSectionHeaders(model, options) {\n  var _a;\n  var headers = [];\n  if (options.findRegionSectionHeaders && ((_a = options.foldingRules) === null || _a === void 0 ? void 0 : _a.markers)) {\n    var regionHeaders = collectRegionHeaders(model, options);\n    headers = headers.concat(regionHeaders);\n  }\n  if (options.findMarkSectionHeaders) {\n    var markHeaders = collectMarkHeaders(model);\n    headers = headers.concat(markHeaders);\n  }\n  return headers;\n}\nfunction collectRegionHeaders(model, options) {\n  var regionHeaders = [];\n  var endLineNumber = model.getLineCount();\n  for (var lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {\n    var lineContent = model.getLineContent(lineNumber);\n    var match = lineContent.match(options.foldingRules.markers.start);\n    if (match) {\n      var range = {\n        startLineNumber: lineNumber,\n        startColumn: match[0].length + 1,\n        endLineNumber: lineNumber,\n        endColumn: lineContent.length + 1\n      };\n      if (range.endColumn > range.startColumn) {\n        var sectionHeader = _objectSpread(_objectSpread({\n          range: range\n        }, getHeaderText(lineContent.substring(match[0].length))), {}, {\n          shouldBeInComments: false\n        });\n        if (sectionHeader.text || sectionHeader.hasSeparatorLine) {\n          regionHeaders.push(sectionHeader);\n        }\n      }\n    }\n  }\n  return regionHeaders;\n}\nfunction collectMarkHeaders(model) {\n  var markHeaders = [];\n  var endLineNumber = model.getLineCount();\n  for (var lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {\n    var lineContent = model.getLineContent(lineNumber);\n    addMarkHeaderIfFound(lineContent, lineNumber, markHeaders);\n  }\n  return markHeaders;\n}\nfunction addMarkHeaderIfFound(lineContent, lineNumber, sectionHeaders) {\n  markRegex.lastIndex = 0;\n  var match = markRegex.exec(lineContent);\n  if (match) {\n    var column = match.indices[1][0] + 1;\n    var endColumn = match.indices[1][1] + 1;\n    var range = {\n      startLineNumber: lineNumber,\n      startColumn: column,\n      endLineNumber: lineNumber,\n      endColumn: endColumn\n    };\n    if (range.endColumn > range.startColumn) {\n      var sectionHeader = _objectSpread(_objectSpread({\n        range: range\n      }, getHeaderText(match[1])), {}, {\n        shouldBeInComments: true\n      });\n      if (sectionHeader.text || sectionHeader.hasSeparatorLine) {\n        sectionHeaders.push(sectionHeader);\n      }\n    }\n  }\n}\nfunction getHeaderText(text) {\n  text = text.trim();\n  var hasSeparatorLine = text.startsWith('-');\n  text = text.replace(trimDashesRegex, '');\n  return {\n    text: text,\n    hasSeparatorLine: hasSeparatorLine\n  };\n}","map":{"version":3,"names":["markRegex","trimDashesRegex","findSectionHeaders","model","options","_a","headers","findRegionSectionHeaders","foldingRules","markers","regionHeaders","collectRegionHeaders","concat","findMarkSectionHeaders","markHeaders","collectMarkHeaders","endLineNumber","getLineCount","lineNumber","lineContent","getLineContent","match","start","range","startLineNumber","startColumn","length","endColumn","sectionHeader","_objectSpread","getHeaderText","substring","shouldBeInComments","text","hasSeparatorLine","push","addMarkHeaderIfFound","sectionHeaders","lastIndex","exec","column","indices","trim","startsWith","replace"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/services/findSectionHeaders.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst markRegex = /\\bMARK:\\s*(.*)$/d;\nconst trimDashesRegex = /^-+|-+$/g;\n/**\n * Find section headers in the model.\n *\n * @param model the text model to search in\n * @param options options to search with\n * @returns an array of section headers\n */\nexport function findSectionHeaders(model, options) {\n    var _a;\n    let headers = [];\n    if (options.findRegionSectionHeaders && ((_a = options.foldingRules) === null || _a === void 0 ? void 0 : _a.markers)) {\n        const regionHeaders = collectRegionHeaders(model, options);\n        headers = headers.concat(regionHeaders);\n    }\n    if (options.findMarkSectionHeaders) {\n        const markHeaders = collectMarkHeaders(model);\n        headers = headers.concat(markHeaders);\n    }\n    return headers;\n}\nfunction collectRegionHeaders(model, options) {\n    const regionHeaders = [];\n    const endLineNumber = model.getLineCount();\n    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {\n        const lineContent = model.getLineContent(lineNumber);\n        const match = lineContent.match(options.foldingRules.markers.start);\n        if (match) {\n            const range = { startLineNumber: lineNumber, startColumn: match[0].length + 1, endLineNumber: lineNumber, endColumn: lineContent.length + 1 };\n            if (range.endColumn > range.startColumn) {\n                const sectionHeader = {\n                    range,\n                    ...getHeaderText(lineContent.substring(match[0].length)),\n                    shouldBeInComments: false\n                };\n                if (sectionHeader.text || sectionHeader.hasSeparatorLine) {\n                    regionHeaders.push(sectionHeader);\n                }\n            }\n        }\n    }\n    return regionHeaders;\n}\nfunction collectMarkHeaders(model) {\n    const markHeaders = [];\n    const endLineNumber = model.getLineCount();\n    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {\n        const lineContent = model.getLineContent(lineNumber);\n        addMarkHeaderIfFound(lineContent, lineNumber, markHeaders);\n    }\n    return markHeaders;\n}\nfunction addMarkHeaderIfFound(lineContent, lineNumber, sectionHeaders) {\n    markRegex.lastIndex = 0;\n    const match = markRegex.exec(lineContent);\n    if (match) {\n        const column = match.indices[1][0] + 1;\n        const endColumn = match.indices[1][1] + 1;\n        const range = { startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: endColumn };\n        if (range.endColumn > range.startColumn) {\n            const sectionHeader = {\n                range,\n                ...getHeaderText(match[1]),\n                shouldBeInComments: true\n            };\n            if (sectionHeader.text || sectionHeader.hasSeparatorLine) {\n                sectionHeaders.push(sectionHeader);\n            }\n        }\n    }\n}\nfunction getHeaderText(text) {\n    text = text.trim();\n    const hasSeparatorLine = text.startsWith('-');\n    text = text.replace(trimDashesRegex, '');\n    return { text, hasSeparatorLine };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}