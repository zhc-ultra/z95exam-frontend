{"ast":null,"code":"import _regeneratorRuntime from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.every.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.object.get-own-property-names.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.ends-with.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.substr.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { isThenable } from './async.js';\nimport { isEqualOrParent } from './extpath.js';\nimport { LRUCache } from './map.js';\nimport { basename, extname, posix, sep } from './path.js';\nimport { isLinux } from './platform.js';\nimport { escapeRegExpCharacters, ltrim } from './strings.js';\nexport var GLOBSTAR = '**';\nexport var GLOB_SPLIT = '/';\nvar PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\nvar NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\nvar ALL_FORWARD_SLASHES = /\\//g;\nfunction starsToRegExp(starCount, isLastPattern) {\n  switch (starCount) {\n    case 0:\n      return '';\n    case 1:\n      return \"\".concat(NO_PATH_REGEX, \"*?\");\n    // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n    default:\n      // Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern\n      //           in which case also matches (Path Sep followed by Path Val)\n      // Group is non capturing because we don't need to capture at all (?:...)\n      // Overall we use non-greedy matching because it could be that we match too much\n      return \"(?:\".concat(PATH_REGEX, \"|\").concat(NO_PATH_REGEX, \"+\").concat(PATH_REGEX).concat(isLastPattern ? \"|\".concat(PATH_REGEX).concat(NO_PATH_REGEX, \"+\") : '', \")*?\");\n  }\n}\nexport function splitGlobAware(pattern, splitChar) {\n  if (!pattern) {\n    return [];\n  }\n  var segments = [];\n  var inBraces = false;\n  var inBrackets = false;\n  var curVal = '';\n  var _iterator = _createForOfIteratorHelper(pattern),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _char = _step.value;\n      switch (_char) {\n        case splitChar:\n          if (!inBraces && !inBrackets) {\n            segments.push(curVal);\n            curVal = '';\n            continue;\n          }\n          break;\n        case '{':\n          inBraces = true;\n          break;\n        case '}':\n          inBraces = false;\n          break;\n        case '[':\n          inBrackets = true;\n          break;\n        case ']':\n          inBrackets = false;\n          break;\n      }\n      curVal += _char;\n    }\n    // Tail\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  if (curVal) {\n    segments.push(curVal);\n  }\n  return segments;\n}\nfunction parseRegExp(pattern) {\n  if (!pattern) {\n    return '';\n  }\n  var regEx = '';\n  // Split up into segments for each slash found\n  var segments = splitGlobAware(pattern, GLOB_SPLIT);\n  // Special case where we only have globstars\n  if (segments.every(function (segment) {\n    return segment === GLOBSTAR;\n  })) {\n    regEx = '.*';\n  }\n  // Build regex over segments\n  else {\n    var previousSegmentWasGlobStar = false;\n    segments.forEach(function (segment, index) {\n      // Treat globstar specially\n      if (segment === GLOBSTAR) {\n        // if we have more than one globstar after another, just ignore it\n        if (previousSegmentWasGlobStar) {\n          return;\n        }\n        regEx += starsToRegExp(2, index === segments.length - 1);\n      }\n      // Anything else, not globstar\n      else {\n        // States\n        var inBraces = false;\n        var braceVal = '';\n        var inBrackets = false;\n        var bracketVal = '';\n        var _iterator2 = _createForOfIteratorHelper(segment),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _char2 = _step2.value;\n            // Support brace expansion\n            if (_char2 !== '}' && inBraces) {\n              braceVal += _char2;\n              continue;\n            }\n            // Support brackets\n            if (inBrackets && (_char2 !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n              var res = void 0;\n              // range operator\n              if (_char2 === '-') {\n                res = _char2;\n              }\n              // negation operator (only valid on first index in bracket)\n              else if ((_char2 === '^' || _char2 === '!') && !bracketVal) {\n                res = '^';\n              }\n              // glob split matching is not allowed within character ranges\n              // see http://man7.org/linux/man-pages/man7/glob.7.html\n              else if (_char2 === GLOB_SPLIT) {\n                res = '';\n              }\n              // anything else gets escaped\n              else {\n                res = escapeRegExpCharacters(_char2);\n              }\n              bracketVal += res;\n              continue;\n            }\n            switch (_char2) {\n              case '{':\n                inBraces = true;\n                continue;\n              case '[':\n                inBrackets = true;\n                continue;\n              case '}':\n                {\n                  var choices = splitGlobAware(braceVal, ',');\n                  // Converts {foo,bar} => [foo|bar]\n                  var braceRegExp = \"(?:\".concat(choices.map(function (choice) {\n                    return parseRegExp(choice);\n                  }).join('|'), \")\");\n                  regEx += braceRegExp;\n                  inBraces = false;\n                  braceVal = '';\n                  break;\n                }\n              case ']':\n                {\n                  regEx += '[' + bracketVal + ']';\n                  inBrackets = false;\n                  bracketVal = '';\n                  break;\n                }\n              case '?':\n                regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n                continue;\n              case '*':\n                regEx += starsToRegExp(1);\n                continue;\n              default:\n                regEx += escapeRegExpCharacters(_char2);\n            }\n          }\n          // Tail: Add the slash we had split on if there is more to\n          // come and the remaining pattern is not a globstar\n          // For example if pattern: some/**/*.js we want the \"/\" after\n          // some to be included in the RegEx to prevent a folder called\n          // \"something\" to match as well.\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        if (index < segments.length - 1 && (\n        // more segments to come after this\n        segments[index + 1] !== GLOBSTAR ||\n        // next segment is not **, or...\n        index + 2 < segments.length // ...next segment is ** but there is more segments after that\n        )) {\n          regEx += PATH_REGEX;\n        }\n      }\n      // update globstar state\n      previousSegmentWasGlobStar = segment === GLOBSTAR;\n    });\n  }\n  return regEx;\n}\n// regexes to check for trivial glob patterns that just check for String#endsWith\nvar T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\nvar T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\nvar T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\nvar T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\nvar T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\nvar T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\nvar CACHE = new LRUCache(10000); // bounded to 10000 elements\nvar FALSE = function FALSE() {\n  return false;\n};\nvar NULL = function NULL() {\n  return null;\n};\nfunction parsePattern(arg1, options) {\n  if (!arg1) {\n    return NULL;\n  }\n  // Handle relative patterns\n  var pattern;\n  if (typeof arg1 !== 'string') {\n    pattern = arg1.pattern;\n  } else {\n    pattern = arg1;\n  }\n  // Whitespace trimming\n  pattern = pattern.trim();\n  // Check cache\n  var patternKey = \"\".concat(pattern, \"_\").concat(!!options.trimForExclusions);\n  var parsedPattern = CACHE.get(patternKey);\n  if (parsedPattern) {\n    return wrapRelativePattern(parsedPattern, arg1);\n  }\n  // Check for Trivials\n  var match;\n  if (T1.test(pattern)) {\n    parsedPattern = trivia1(pattern.substr(4), pattern); // common pattern: **/*.txt just need endsWith check\n  } else if (match = T2.exec(trimForExclusions(pattern, options))) {\n    // common pattern: **/some.txt just need basename check\n    parsedPattern = trivia2(match[1], pattern);\n  } else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) {\n    // repetition of common patterns (see above) {**/*.txt,**/*.png}\n    parsedPattern = trivia3(pattern, options);\n  } else if (match = T4.exec(trimForExclusions(pattern, options))) {\n    // common pattern: **/something/else just need endsWith check\n    parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n  } else if (match = T5.exec(trimForExclusions(pattern, options))) {\n    // common pattern: something/else just need equals check\n    parsedPattern = trivia4and5(match[1], pattern, false);\n  }\n  // Otherwise convert to pattern\n  else {\n    parsedPattern = toRegExp(pattern);\n  }\n  // Cache\n  CACHE.set(patternKey, parsedPattern);\n  return wrapRelativePattern(parsedPattern, arg1);\n}\nfunction wrapRelativePattern(parsedPattern, arg2) {\n  if (typeof arg2 === 'string') {\n    return parsedPattern;\n  }\n  var wrappedPattern = function wrappedPattern(path, basename) {\n    if (!isEqualOrParent(path, arg2.base, !isLinux)) {\n      // skip glob matching if `base` is not a parent of `path`\n      return null;\n    }\n    // Given we have checked `base` being a parent of `path`,\n    // we can now remove the `base` portion of the `path`\n    // and only match on the remaining path components\n    // For that we try to extract the portion of the `path`\n    // that comes after the `base` portion. We have to account\n    // for the fact that `base` might end in a path separator\n    // (https://github.com/microsoft/vscode/issues/162498)\n    return parsedPattern(ltrim(path.substr(arg2.base.length), sep), basename);\n  };\n  // Make sure to preserve associated metadata\n  wrappedPattern.allBasenames = parsedPattern.allBasenames;\n  wrappedPattern.allPaths = parsedPattern.allPaths;\n  wrappedPattern.basenames = parsedPattern.basenames;\n  wrappedPattern.patterns = parsedPattern.patterns;\n  return wrappedPattern;\n}\nfunction trimForExclusions(pattern, options) {\n  return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n// common pattern: **/*.txt just need endsWith check\nfunction trivia1(base, pattern) {\n  return function (path, basename) {\n    return typeof path === 'string' && path.endsWith(base) ? pattern : null;\n  };\n}\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base, pattern) {\n  var slashBase = \"/\".concat(base);\n  var backslashBase = \"\\\\\".concat(base);\n  var parsedPattern = function parsedPattern(path, basename) {\n    if (typeof path !== 'string') {\n      return null;\n    }\n    if (basename) {\n      return basename === base ? pattern : null;\n    }\n    return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;\n  };\n  var basenames = [base];\n  parsedPattern.basenames = basenames;\n  parsedPattern.patterns = [pattern];\n  parsedPattern.allBasenames = basenames;\n  return parsedPattern;\n}\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern, options) {\n  var parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',').map(function (pattern) {\n    return parsePattern(pattern, options);\n  }).filter(function (pattern) {\n    return pattern !== NULL;\n  }), pattern);\n  var patternsLength = parsedPatterns.length;\n  if (!patternsLength) {\n    return NULL;\n  }\n  if (patternsLength === 1) {\n    return parsedPatterns[0];\n  }\n  var parsedPattern = function parsedPattern(path, basename) {\n    for (var i = 0, n = parsedPatterns.length; i < n; i++) {\n      if (parsedPatterns[i](path, basename)) {\n        return pattern;\n      }\n    }\n    return null;\n  };\n  var withBasenames = parsedPatterns.find(function (pattern) {\n    return !!pattern.allBasenames;\n  });\n  if (withBasenames) {\n    parsedPattern.allBasenames = withBasenames.allBasenames;\n  }\n  var allPaths = parsedPatterns.reduce(function (all, current) {\n    return current.allPaths ? all.concat(current.allPaths) : all;\n  }, []);\n  if (allPaths.length) {\n    parsedPattern.allPaths = allPaths;\n  }\n  return parsedPattern;\n}\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\n  var usingPosixSep = sep === posix.sep;\n  var nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n  var nativePathEnd = sep + nativePath;\n  var targetPathEnd = posix.sep + targetPath;\n  var parsedPattern;\n  if (matchPathEnds) {\n    parsedPattern = function parsedPattern(path, basename) {\n      return typeof path === 'string' && (path === nativePath || path.endsWith(nativePathEnd) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;\n    };\n  } else {\n    parsedPattern = function parsedPattern(path, basename) {\n      return typeof path === 'string' && (path === nativePath || !usingPosixSep && path === targetPath) ? pattern : null;\n    };\n  }\n  parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n  return parsedPattern;\n}\nfunction toRegExp(pattern) {\n  try {\n    var regExp = new RegExp(\"^\".concat(parseRegExp(pattern), \"$\"));\n    return function (path) {\n      regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n      return typeof path === 'string' && regExp.test(path) ? pattern : null;\n    };\n  } catch (error) {\n    return NULL;\n  }\n}\nexport function match(arg1, path, hasSibling) {\n  if (!arg1 || typeof path !== 'string') {\n    return false;\n  }\n  return parse(arg1)(path, undefined, hasSibling);\n}\nexport function parse(arg1) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!arg1) {\n    return FALSE;\n  }\n  // Glob with String\n  if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n    var parsedPattern = parsePattern(arg1, options);\n    if (parsedPattern === NULL) {\n      return FALSE;\n    }\n    var resultPattern = function resultPattern(path, basename) {\n      return !!parsedPattern(path, basename);\n    };\n    if (parsedPattern.allBasenames) {\n      resultPattern.allBasenames = parsedPattern.allBasenames;\n    }\n    if (parsedPattern.allPaths) {\n      resultPattern.allPaths = parsedPattern.allPaths;\n    }\n    return resultPattern;\n  }\n  // Glob with Expression\n  return parsedExpression(arg1, options);\n}\nexport function isRelativePattern(obj) {\n  var rp = obj;\n  if (!rp) {\n    return false;\n  }\n  return typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\nfunction parsedExpression(expression, options) {\n  var parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression).map(function (pattern) {\n    return parseExpressionPattern(pattern, expression[pattern], options);\n  }).filter(function (pattern) {\n    return pattern !== NULL;\n  }));\n  var patternsLength = parsedPatterns.length;\n  if (!patternsLength) {\n    return NULL;\n  }\n  if (!parsedPatterns.some(function (parsedPattern) {\n    return !!parsedPattern.requiresSiblings;\n  })) {\n    if (patternsLength === 1) {\n      return parsedPatterns[0];\n    }\n    var _resultExpression = function _resultExpression(path, basename) {\n      var resultPromises = undefined;\n      for (var i = 0, n = parsedPatterns.length; i < n; i++) {\n        var result = parsedPatterns[i](path, basename);\n        if (typeof result === 'string') {\n          return result; // immediately return as soon as the first expression matches\n        }\n        // If the result is a promise, we have to keep it for\n        // later processing and await the result properly.\n        if (isThenable(result)) {\n          if (!resultPromises) {\n            resultPromises = [];\n          }\n          resultPromises.push(result);\n        }\n      }\n      // With result promises, we have to loop over each and\n      // await the result before we can return any result.\n      if (resultPromises) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n          var _iterator3, _step3, resultPromise, _result;\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                _iterator3 = _createForOfIteratorHelper(resultPromises);\n                _context.prev = 1;\n                _iterator3.s();\n              case 3:\n                if ((_step3 = _iterator3.n()).done) {\n                  _context.next = 12;\n                  break;\n                }\n                resultPromise = _step3.value;\n                _context.next = 7;\n                return resultPromise;\n              case 7:\n                _result = _context.sent;\n                if (!(typeof _result === 'string')) {\n                  _context.next = 10;\n                  break;\n                }\n                return _context.abrupt(\"return\", _result);\n              case 10:\n                _context.next = 3;\n                break;\n              case 12:\n                _context.next = 17;\n                break;\n              case 14:\n                _context.prev = 14;\n                _context.t0 = _context[\"catch\"](1);\n                _iterator3.e(_context.t0);\n              case 17:\n                _context.prev = 17;\n                _iterator3.f();\n                return _context.finish(17);\n              case 20:\n                return _context.abrupt(\"return\", null);\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee, null, [[1, 14, 17, 20]]);\n        }))();\n      }\n      return null;\n    };\n    var _withBasenames = parsedPatterns.find(function (pattern) {\n      return !!pattern.allBasenames;\n    });\n    if (_withBasenames) {\n      _resultExpression.allBasenames = _withBasenames.allBasenames;\n    }\n    var _allPaths = parsedPatterns.reduce(function (all, current) {\n      return current.allPaths ? all.concat(current.allPaths) : all;\n    }, []);\n    if (_allPaths.length) {\n      _resultExpression.allPaths = _allPaths;\n    }\n    return _resultExpression;\n  }\n  var resultExpression = function resultExpression(path, base, hasSibling) {\n    var name = undefined;\n    var resultPromises = undefined;\n    for (var i = 0, n = parsedPatterns.length; i < n; i++) {\n      // Pattern matches path\n      var parsedPattern = parsedPatterns[i];\n      if (parsedPattern.requiresSiblings && hasSibling) {\n        if (!base) {\n          base = basename(path);\n        }\n        if (!name) {\n          name = base.substr(0, base.length - extname(path).length);\n        }\n      }\n      var result = parsedPattern(path, base, name, hasSibling);\n      if (typeof result === 'string') {\n        return result; // immediately return as soon as the first expression matches\n      }\n      // If the result is a promise, we have to keep it for\n      // later processing and await the result properly.\n      if (isThenable(result)) {\n        if (!resultPromises) {\n          resultPromises = [];\n        }\n        resultPromises.push(result);\n      }\n    }\n    // With result promises, we have to loop over each and\n    // await the result before we can return any result.\n    if (resultPromises) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _iterator4, _step4, resultPromise, _result2;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _iterator4 = _createForOfIteratorHelper(resultPromises);\n              _context2.prev = 1;\n              _iterator4.s();\n            case 3:\n              if ((_step4 = _iterator4.n()).done) {\n                _context2.next = 12;\n                break;\n              }\n              resultPromise = _step4.value;\n              _context2.next = 7;\n              return resultPromise;\n            case 7:\n              _result2 = _context2.sent;\n              if (!(typeof _result2 === 'string')) {\n                _context2.next = 10;\n                break;\n              }\n              return _context2.abrupt(\"return\", _result2);\n            case 10:\n              _context2.next = 3;\n              break;\n            case 12:\n              _context2.next = 17;\n              break;\n            case 14:\n              _context2.prev = 14;\n              _context2.t0 = _context2[\"catch\"](1);\n              _iterator4.e(_context2.t0);\n            case 17:\n              _context2.prev = 17;\n              _iterator4.f();\n              return _context2.finish(17);\n            case 20:\n              return _context2.abrupt(\"return\", null);\n            case 21:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, null, [[1, 14, 17, 20]]);\n      }))();\n    }\n    return null;\n  };\n  var withBasenames = parsedPatterns.find(function (pattern) {\n    return !!pattern.allBasenames;\n  });\n  if (withBasenames) {\n    resultExpression.allBasenames = withBasenames.allBasenames;\n  }\n  var allPaths = parsedPatterns.reduce(function (all, current) {\n    return current.allPaths ? all.concat(current.allPaths) : all;\n  }, []);\n  if (allPaths.length) {\n    resultExpression.allPaths = allPaths;\n  }\n  return resultExpression;\n}\nfunction parseExpressionPattern(pattern, value, options) {\n  if (value === false) {\n    return NULL; // pattern is disabled\n  }\n  var parsedPattern = parsePattern(pattern, options);\n  if (parsedPattern === NULL) {\n    return NULL;\n  }\n  // Expression Pattern is <boolean>\n  if (typeof value === 'boolean') {\n    return parsedPattern;\n  }\n  // Expression Pattern is <SiblingClause>\n  if (value) {\n    var when = value.when;\n    if (typeof when === 'string') {\n      var result = function result(path, basename, name, hasSibling) {\n        if (!hasSibling || !parsedPattern(path, basename)) {\n          return null;\n        }\n        var clausePattern = when.replace('$(basename)', function () {\n          return name;\n        });\n        var matched = hasSibling(clausePattern);\n        return isThenable(matched) ? matched.then(function (match) {\n          return match ? pattern : null;\n        }) : matched ? pattern : null;\n      };\n      result.requiresSiblings = true;\n      return result;\n    }\n  }\n  // Expression is anything\n  return parsedPattern;\n}\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n  var basenamePatterns = parsedPatterns.filter(function (parsedPattern) {\n    return !!parsedPattern.basenames;\n  });\n  if (basenamePatterns.length < 2) {\n    return parsedPatterns;\n  }\n  var basenames = basenamePatterns.reduce(function (all, current) {\n    var basenames = current.basenames;\n    return basenames ? all.concat(basenames) : all;\n  }, []);\n  var patterns;\n  if (result) {\n    patterns = [];\n    for (var i = 0, n = basenames.length; i < n; i++) {\n      patterns.push(result);\n    }\n  } else {\n    patterns = basenamePatterns.reduce(function (all, current) {\n      var patterns = current.patterns;\n      return patterns ? all.concat(patterns) : all;\n    }, []);\n  }\n  var aggregate = function aggregate(path, basename) {\n    if (typeof path !== 'string') {\n      return null;\n    }\n    if (!basename) {\n      var _i;\n      for (_i = path.length; _i > 0; _i--) {\n        var ch = path.charCodeAt(_i - 1);\n        if (ch === 47 /* CharCode.Slash */ || ch === 92 /* CharCode.Backslash */) {\n          break;\n        }\n      }\n      basename = path.substr(_i);\n    }\n    var index = basenames.indexOf(basename);\n    return index !== -1 ? patterns[index] : null;\n  };\n  aggregate.basenames = basenames;\n  aggregate.patterns = patterns;\n  aggregate.allBasenames = basenames;\n  var aggregatedPatterns = parsedPatterns.filter(function (parsedPattern) {\n    return !parsedPattern.basenames;\n  });\n  aggregatedPatterns.push(aggregate);\n  return aggregatedPatterns;\n}","map":{"version":3,"names":["isThenable","isEqualOrParent","LRUCache","basename","extname","posix","sep","isLinux","escapeRegExpCharacters","ltrim","GLOBSTAR","GLOB_SPLIT","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","isLastPattern","concat","splitGlobAware","pattern","splitChar","segments","inBraces","inBrackets","curVal","_iterator","_createForOfIteratorHelper","_step","s","n","done","char","value","push","err","e","f","parseRegExp","regEx","every","segment","previousSegmentWasGlobStar","forEach","index","length","braceVal","bracketVal","_iterator2","_step2","res","choices","braceRegExp","map","choice","join","T1","T2","T3","T3_2","T4","T5","CACHE","FALSE","NULL","parsePattern","arg1","options","trim","patternKey","trimForExclusions","parsedPattern","get","wrapRelativePattern","match","test","trivia1","substr","exec","trivia2","trivia3","trivia4and5","toRegExp","set","arg2","wrappedPattern","path","base","allBasenames","allPaths","basenames","patterns","endsWith","slashBase","backslashBase","parsedPatterns","aggregateBasenameMatches","slice","split","filter","patternsLength","i","withBasenames","find","reduce","all","current","targetPath","matchPathEnds","usingPosixSep","nativePath","replace","nativePathEnd","targetPathEnd","regExp","RegExp","lastIndex","error","hasSibling","parse","undefined","arguments","isRelativePattern","resultPattern","parsedExpression","obj","rp","expression","Object","getOwnPropertyNames","parseExpressionPattern","some","requiresSiblings","resultExpression","resultPromises","result","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_iterator3","_step3","resultPromise","_result","wrap","_callee$","_context","prev","next","sent","abrupt","t0","finish","stop","name","_callee2","_iterator4","_step4","_result2","_callee2$","_context2","when","clausePattern","matched","then","basenamePatterns","aggregate","ch","charCodeAt","indexOf","aggregatedPatterns"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/base/common/glob.js"],"sourcesContent":["import { isThenable } from './async.js';\nimport { isEqualOrParent } from './extpath.js';\nimport { LRUCache } from './map.js';\nimport { basename, extname, posix, sep } from './path.js';\nimport { isLinux } from './platform.js';\nimport { escapeRegExpCharacters, ltrim } from './strings.js';\nexport const GLOBSTAR = '**';\nexport const GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\nfunction starsToRegExp(starCount, isLastPattern) {\n    switch (starCount) {\n        case 0:\n            return '';\n        case 1:\n            return `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n        default:\n            // Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern\n            //           in which case also matches (Path Sep followed by Path Val)\n            // Group is non capturing because we don't need to capture at all (?:...)\n            // Overall we use non-greedy matching because it could be that we match too much\n            return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n    }\n}\nexport function splitGlobAware(pattern, splitChar) {\n    if (!pattern) {\n        return [];\n    }\n    const segments = [];\n    let inBraces = false;\n    let inBrackets = false;\n    let curVal = '';\n    for (const char of pattern) {\n        switch (char) {\n            case splitChar:\n                if (!inBraces && !inBrackets) {\n                    segments.push(curVal);\n                    curVal = '';\n                    continue;\n                }\n                break;\n            case '{':\n                inBraces = true;\n                break;\n            case '}':\n                inBraces = false;\n                break;\n            case '[':\n                inBrackets = true;\n                break;\n            case ']':\n                inBrackets = false;\n                break;\n        }\n        curVal += char;\n    }\n    // Tail\n    if (curVal) {\n        segments.push(curVal);\n    }\n    return segments;\n}\nfunction parseRegExp(pattern) {\n    if (!pattern) {\n        return '';\n    }\n    let regEx = '';\n    // Split up into segments for each slash found\n    const segments = splitGlobAware(pattern, GLOB_SPLIT);\n    // Special case where we only have globstars\n    if (segments.every(segment => segment === GLOBSTAR)) {\n        regEx = '.*';\n    }\n    // Build regex over segments\n    else {\n        let previousSegmentWasGlobStar = false;\n        segments.forEach((segment, index) => {\n            // Treat globstar specially\n            if (segment === GLOBSTAR) {\n                // if we have more than one globstar after another, just ignore it\n                if (previousSegmentWasGlobStar) {\n                    return;\n                }\n                regEx += starsToRegExp(2, index === segments.length - 1);\n            }\n            // Anything else, not globstar\n            else {\n                // States\n                let inBraces = false;\n                let braceVal = '';\n                let inBrackets = false;\n                let bracketVal = '';\n                for (const char of segment) {\n                    // Support brace expansion\n                    if (char !== '}' && inBraces) {\n                        braceVal += char;\n                        continue;\n                    }\n                    // Support brackets\n                    if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n                        let res;\n                        // range operator\n                        if (char === '-') {\n                            res = char;\n                        }\n                        // negation operator (only valid on first index in bracket)\n                        else if ((char === '^' || char === '!') && !bracketVal) {\n                            res = '^';\n                        }\n                        // glob split matching is not allowed within character ranges\n                        // see http://man7.org/linux/man-pages/man7/glob.7.html\n                        else if (char === GLOB_SPLIT) {\n                            res = '';\n                        }\n                        // anything else gets escaped\n                        else {\n                            res = escapeRegExpCharacters(char);\n                        }\n                        bracketVal += res;\n                        continue;\n                    }\n                    switch (char) {\n                        case '{':\n                            inBraces = true;\n                            continue;\n                        case '[':\n                            inBrackets = true;\n                            continue;\n                        case '}': {\n                            const choices = splitGlobAware(braceVal, ',');\n                            // Converts {foo,bar} => [foo|bar]\n                            const braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;\n                            regEx += braceRegExp;\n                            inBraces = false;\n                            braceVal = '';\n                            break;\n                        }\n                        case ']': {\n                            regEx += ('[' + bracketVal + ']');\n                            inBrackets = false;\n                            bracketVal = '';\n                            break;\n                        }\n                        case '?':\n                            regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n                            continue;\n                        case '*':\n                            regEx += starsToRegExp(1);\n                            continue;\n                        default:\n                            regEx += escapeRegExpCharacters(char);\n                    }\n                }\n                // Tail: Add the slash we had split on if there is more to\n                // come and the remaining pattern is not a globstar\n                // For example if pattern: some/**/*.js we want the \"/\" after\n                // some to be included in the RegEx to prevent a folder called\n                // \"something\" to match as well.\n                if (index < segments.length - 1 && // more segments to come after this\n                    (segments[index + 1] !== GLOBSTAR || // next segment is not **, or...\n                        index + 2 < segments.length // ...next segment is ** but there is more segments after that\n                    )) {\n                    regEx += PATH_REGEX;\n                }\n            }\n            // update globstar state\n            previousSegmentWasGlobStar = (segment === GLOBSTAR);\n        });\n    }\n    return regEx;\n}\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\nconst CACHE = new LRUCache(10000); // bounded to 10000 elements\nconst FALSE = function () {\n    return false;\n};\nconst NULL = function () {\n    return null;\n};\nfunction parsePattern(arg1, options) {\n    if (!arg1) {\n        return NULL;\n    }\n    // Handle relative patterns\n    let pattern;\n    if (typeof arg1 !== 'string') {\n        pattern = arg1.pattern;\n    }\n    else {\n        pattern = arg1;\n    }\n    // Whitespace trimming\n    pattern = pattern.trim();\n    // Check cache\n    const patternKey = `${pattern}_${!!options.trimForExclusions}`;\n    let parsedPattern = CACHE.get(patternKey);\n    if (parsedPattern) {\n        return wrapRelativePattern(parsedPattern, arg1);\n    }\n    // Check for Trivials\n    let match;\n    if (T1.test(pattern)) {\n        parsedPattern = trivia1(pattern.substr(4), pattern); // common pattern: **/*.txt just need endsWith check\n    }\n    else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n        parsedPattern = trivia2(match[1], pattern);\n    }\n    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n        parsedPattern = trivia3(pattern, options);\n    }\n    else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n        parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n    }\n    else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n        parsedPattern = trivia4and5(match[1], pattern, false);\n    }\n    // Otherwise convert to pattern\n    else {\n        parsedPattern = toRegExp(pattern);\n    }\n    // Cache\n    CACHE.set(patternKey, parsedPattern);\n    return wrapRelativePattern(parsedPattern, arg1);\n}\nfunction wrapRelativePattern(parsedPattern, arg2) {\n    if (typeof arg2 === 'string') {\n        return parsedPattern;\n    }\n    const wrappedPattern = function (path, basename) {\n        if (!isEqualOrParent(path, arg2.base, !isLinux)) {\n            // skip glob matching if `base` is not a parent of `path`\n            return null;\n        }\n        // Given we have checked `base` being a parent of `path`,\n        // we can now remove the `base` portion of the `path`\n        // and only match on the remaining path components\n        // For that we try to extract the portion of the `path`\n        // that comes after the `base` portion. We have to account\n        // for the fact that `base` might end in a path separator\n        // (https://github.com/microsoft/vscode/issues/162498)\n        return parsedPattern(ltrim(path.substr(arg2.base.length), sep), basename);\n    };\n    // Make sure to preserve associated metadata\n    wrappedPattern.allBasenames = parsedPattern.allBasenames;\n    wrappedPattern.allPaths = parsedPattern.allPaths;\n    wrappedPattern.basenames = parsedPattern.basenames;\n    wrappedPattern.patterns = parsedPattern.patterns;\n    return wrappedPattern;\n}\nfunction trimForExclusions(pattern, options) {\n    return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n// common pattern: **/*.txt just need endsWith check\nfunction trivia1(base, pattern) {\n    return function (path, basename) {\n        return typeof path === 'string' && path.endsWith(base) ? pattern : null;\n    };\n}\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base, pattern) {\n    const slashBase = `/${base}`;\n    const backslashBase = `\\\\${base}`;\n    const parsedPattern = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (basename) {\n            return basename === base ? pattern : null;\n        }\n        return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;\n    };\n    const basenames = [base];\n    parsedPattern.basenames = basenames;\n    parsedPattern.patterns = [pattern];\n    parsedPattern.allBasenames = basenames;\n    return parsedPattern;\n}\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern, options) {\n    const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1)\n        .split(',')\n        .map(pattern => parsePattern(pattern, options))\n        .filter(pattern => pattern !== NULL), pattern);\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (patternsLength === 1) {\n        return parsedPatterns[0];\n    }\n    const parsedPattern = function (path, basename) {\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            if (parsedPatterns[i](path, basename)) {\n                return pattern;\n            }\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        parsedPattern.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        parsedPattern.allPaths = allPaths;\n    }\n    return parsedPattern;\n}\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\n    const usingPosixSep = sep === posix.sep;\n    const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n    const nativePathEnd = sep + nativePath;\n    const targetPathEnd = posix.sep + targetPath;\n    let parsedPattern;\n    if (matchPathEnds) {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && ((path === nativePath || path.endsWith(nativePathEnd)) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;\n        };\n    }\n    else {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && (path === nativePath || (!usingPosixSep && path === targetPath)) ? pattern : null;\n        };\n    }\n    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n    return parsedPattern;\n}\nfunction toRegExp(pattern) {\n    try {\n        const regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n        return function (path) {\n            regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n            return typeof path === 'string' && regExp.test(path) ? pattern : null;\n        };\n    }\n    catch (error) {\n        return NULL;\n    }\n}\nexport function match(arg1, path, hasSibling) {\n    if (!arg1 || typeof path !== 'string') {\n        return false;\n    }\n    return parse(arg1)(path, undefined, hasSibling);\n}\nexport function parse(arg1, options = {}) {\n    if (!arg1) {\n        return FALSE;\n    }\n    // Glob with String\n    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n        const parsedPattern = parsePattern(arg1, options);\n        if (parsedPattern === NULL) {\n            return FALSE;\n        }\n        const resultPattern = function (path, basename) {\n            return !!parsedPattern(path, basename);\n        };\n        if (parsedPattern.allBasenames) {\n            resultPattern.allBasenames = parsedPattern.allBasenames;\n        }\n        if (parsedPattern.allPaths) {\n            resultPattern.allPaths = parsedPattern.allPaths;\n        }\n        return resultPattern;\n    }\n    // Glob with Expression\n    return parsedExpression(arg1, options);\n}\nexport function isRelativePattern(obj) {\n    const rp = obj;\n    if (!rp) {\n        return false;\n    }\n    return typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\nfunction parsedExpression(expression, options) {\n    const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n        .map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n        .filter(pattern => pattern !== NULL));\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (!parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings)) {\n        if (patternsLength === 1) {\n            return parsedPatterns[0];\n        }\n        const resultExpression = function (path, basename) {\n            let resultPromises = undefined;\n            for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n                const result = parsedPatterns[i](path, basename);\n                if (typeof result === 'string') {\n                    return result; // immediately return as soon as the first expression matches\n                }\n                // If the result is a promise, we have to keep it for\n                // later processing and await the result properly.\n                if (isThenable(result)) {\n                    if (!resultPromises) {\n                        resultPromises = [];\n                    }\n                    resultPromises.push(result);\n                }\n            }\n            // With result promises, we have to loop over each and\n            // await the result before we can return any result.\n            if (resultPromises) {\n                return (async () => {\n                    for (const resultPromise of resultPromises) {\n                        const result = await resultPromise;\n                        if (typeof result === 'string') {\n                            return result;\n                        }\n                    }\n                    return null;\n                })();\n            }\n            return null;\n        };\n        const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n        if (withBasenames) {\n            resultExpression.allBasenames = withBasenames.allBasenames;\n        }\n        const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n        if (allPaths.length) {\n            resultExpression.allPaths = allPaths;\n        }\n        return resultExpression;\n    }\n    const resultExpression = function (path, base, hasSibling) {\n        let name = undefined;\n        let resultPromises = undefined;\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            // Pattern matches path\n            const parsedPattern = parsedPatterns[i];\n            if (parsedPattern.requiresSiblings && hasSibling) {\n                if (!base) {\n                    base = basename(path);\n                }\n                if (!name) {\n                    name = base.substr(0, base.length - extname(path).length);\n                }\n            }\n            const result = parsedPattern(path, base, name, hasSibling);\n            if (typeof result === 'string') {\n                return result; // immediately return as soon as the first expression matches\n            }\n            // If the result is a promise, we have to keep it for\n            // later processing and await the result properly.\n            if (isThenable(result)) {\n                if (!resultPromises) {\n                    resultPromises = [];\n                }\n                resultPromises.push(result);\n            }\n        }\n        // With result promises, we have to loop over each and\n        // await the result before we can return any result.\n        if (resultPromises) {\n            return (async () => {\n                for (const resultPromise of resultPromises) {\n                    const result = await resultPromise;\n                    if (typeof result === 'string') {\n                        return result;\n                    }\n                }\n                return null;\n            })();\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        resultExpression.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        resultExpression.allPaths = allPaths;\n    }\n    return resultExpression;\n}\nfunction parseExpressionPattern(pattern, value, options) {\n    if (value === false) {\n        return NULL; // pattern is disabled\n    }\n    const parsedPattern = parsePattern(pattern, options);\n    if (parsedPattern === NULL) {\n        return NULL;\n    }\n    // Expression Pattern is <boolean>\n    if (typeof value === 'boolean') {\n        return parsedPattern;\n    }\n    // Expression Pattern is <SiblingClause>\n    if (value) {\n        const when = value.when;\n        if (typeof when === 'string') {\n            const result = (path, basename, name, hasSibling) => {\n                if (!hasSibling || !parsedPattern(path, basename)) {\n                    return null;\n                }\n                const clausePattern = when.replace('$(basename)', () => name);\n                const matched = hasSibling(clausePattern);\n                return isThenable(matched) ?\n                    matched.then(match => match ? pattern : null) :\n                    matched ? pattern : null;\n            };\n            result.requiresSiblings = true;\n            return result;\n        }\n    }\n    // Expression is anything\n    return parsedPattern;\n}\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);\n    if (basenamePatterns.length < 2) {\n        return parsedPatterns;\n    }\n    const basenames = basenamePatterns.reduce((all, current) => {\n        const basenames = current.basenames;\n        return basenames ? all.concat(basenames) : all;\n    }, []);\n    let patterns;\n    if (result) {\n        patterns = [];\n        for (let i = 0, n = basenames.length; i < n; i++) {\n            patterns.push(result);\n        }\n    }\n    else {\n        patterns = basenamePatterns.reduce((all, current) => {\n            const patterns = current.patterns;\n            return patterns ? all.concat(patterns) : all;\n        }, []);\n    }\n    const aggregate = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (!basename) {\n            let i;\n            for (i = path.length; i > 0; i--) {\n                const ch = path.charCodeAt(i - 1);\n                if (ch === 47 /* CharCode.Slash */ || ch === 92 /* CharCode.Backslash */) {\n                    break;\n                }\n            }\n            basename = path.substr(i);\n        }\n        const index = basenames.indexOf(basename);\n        return index !== -1 ? patterns[index] : null;\n    };\n    aggregate.basenames = basenames;\n    aggregate.patterns = patterns;\n    aggregate.allBasenames = basenames;\n    const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);\n    aggregatedPatterns.push(aggregate);\n    return aggregatedPatterns;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,UAAU,QAAQ,YAAY;AACvC,SAASC,eAAe,QAAQ,cAAc;AAC9C,SAASC,QAAQ,QAAQ,UAAU;AACnC,SAASC,QAAQ,EAAEC,OAAO,EAAEC,KAAK,EAAEC,GAAG,QAAQ,WAAW;AACzD,SAASC,OAAO,QAAQ,eAAe;AACvC,SAASC,sBAAsB,EAAEC,KAAK,QAAQ,cAAc;AAC5D,OAAO,IAAMC,QAAQ,GAAG,IAAI;AAC5B,OAAO,IAAMC,UAAU,GAAG,GAAG;AAC7B,IAAMC,UAAU,GAAG,SAAS,CAAC,CAAC;AAC9B,IAAMC,aAAa,GAAG,UAAU,CAAC,CAAC;AAClC,IAAMC,mBAAmB,GAAG,KAAK;AACjC,SAASC,aAAaA,CAACC,SAAS,EAAEC,aAAa,EAAE;EAC7C,QAAQD,SAAS;IACb,KAAK,CAAC;MACF,OAAO,EAAE;IACb,KAAK,CAAC;MACF,UAAAE,MAAA,CAAUL,aAAa;IAAM;IACjC;MACI;MACA;MACA;MACA;MACA,aAAAK,MAAA,CAAaN,UAAU,OAAAM,MAAA,CAAIL,aAAa,OAAAK,MAAA,CAAIN,UAAU,EAAAM,MAAA,CAAGD,aAAa,OAAAC,MAAA,CAAON,UAAU,EAAAM,MAAA,CAAGL,aAAa,SAAM,EAAE;EACvH;AACJ;AACA,OAAO,SAASM,cAAcA,CAACC,OAAO,EAAEC,SAAS,EAAE;EAC/C,IAAI,CAACD,OAAO,EAAE;IACV,OAAO,EAAE;EACb;EACA,IAAME,QAAQ,GAAG,EAAE;EACnB,IAAIC,QAAQ,GAAG,KAAK;EACpB,IAAIC,UAAU,GAAG,KAAK;EACtB,IAAIC,MAAM,GAAG,EAAE;EAAC,IAAAC,SAAA,GAAAC,0BAAA,CACGP,OAAO;IAAAQ,KAAA;EAAA;IAA1B,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAA4B;MAAA,IAAjBC,KAAI,GAAAJ,KAAA,CAAAK,KAAA;MACX,QAAQD,KAAI;QACR,KAAKX,SAAS;UACV,IAAI,CAACE,QAAQ,IAAI,CAACC,UAAU,EAAE;YAC1BF,QAAQ,CAACY,IAAI,CAACT,MAAM,CAAC;YACrBA,MAAM,GAAG,EAAE;YACX;UACJ;UACA;QACJ,KAAK,GAAG;UACJF,QAAQ,GAAG,IAAI;UACf;QACJ,KAAK,GAAG;UACJA,QAAQ,GAAG,KAAK;UAChB;QACJ,KAAK,GAAG;UACJC,UAAU,GAAG,IAAI;UACjB;QACJ,KAAK,GAAG;UACJA,UAAU,GAAG,KAAK;UAClB;MACR;MACAC,MAAM,IAAIO,KAAI;IAClB;IACA;EAAA,SAAAG,GAAA;IAAAT,SAAA,CAAAU,CAAA,CAAAD,GAAA;EAAA;IAAAT,SAAA,CAAAW,CAAA;EAAA;EACA,IAAIZ,MAAM,EAAE;IACRH,QAAQ,CAACY,IAAI,CAACT,MAAM,CAAC;EACzB;EACA,OAAOH,QAAQ;AACnB;AACA,SAASgB,WAAWA,CAAClB,OAAO,EAAE;EAC1B,IAAI,CAACA,OAAO,EAAE;IACV,OAAO,EAAE;EACb;EACA,IAAImB,KAAK,GAAG,EAAE;EACd;EACA,IAAMjB,QAAQ,GAAGH,cAAc,CAACC,OAAO,EAAET,UAAU,CAAC;EACpD;EACA,IAAIW,QAAQ,CAACkB,KAAK,CAAC,UAAAC,OAAO;IAAA,OAAIA,OAAO,KAAK/B,QAAQ;EAAA,EAAC,EAAE;IACjD6B,KAAK,GAAG,IAAI;EAChB;EACA;EAAA,KACK;IACD,IAAIG,0BAA0B,GAAG,KAAK;IACtCpB,QAAQ,CAACqB,OAAO,CAAC,UAACF,OAAO,EAAEG,KAAK,EAAK;MACjC;MACA,IAAIH,OAAO,KAAK/B,QAAQ,EAAE;QACtB;QACA,IAAIgC,0BAA0B,EAAE;UAC5B;QACJ;QACAH,KAAK,IAAIxB,aAAa,CAAC,CAAC,EAAE6B,KAAK,KAAKtB,QAAQ,CAACuB,MAAM,GAAG,CAAC,CAAC;MAC5D;MACA;MAAA,KACK;QACD;QACA,IAAItB,QAAQ,GAAG,KAAK;QACpB,IAAIuB,QAAQ,GAAG,EAAE;QACjB,IAAItB,UAAU,GAAG,KAAK;QACtB,IAAIuB,UAAU,GAAG,EAAE;QAAC,IAAAC,UAAA,GAAArB,0BAAA,CACDc,OAAO;UAAAQ,MAAA;QAAA;UAA1B,KAAAD,UAAA,CAAAnB,CAAA,MAAAoB,MAAA,GAAAD,UAAA,CAAAlB,CAAA,IAAAC,IAAA,GAA4B;YAAA,IAAjBC,MAAI,GAAAiB,MAAA,CAAAhB,KAAA;YACX;YACA,IAAID,MAAI,KAAK,GAAG,IAAIT,QAAQ,EAAE;cAC1BuB,QAAQ,IAAId,MAAI;cAChB;YACJ;YACA;YACA,IAAIR,UAAU,KAAKQ,MAAI,KAAK,GAAG,IAAI,CAACe,UAAU,CAAC,CAAC,8EAA8E;cAC1H,IAAIG,GAAG;cACP;cACA,IAAIlB,MAAI,KAAK,GAAG,EAAE;gBACdkB,GAAG,GAAGlB,MAAI;cACd;cACA;cAAA,KACK,IAAI,CAACA,MAAI,KAAK,GAAG,IAAIA,MAAI,KAAK,GAAG,KAAK,CAACe,UAAU,EAAE;gBACpDG,GAAG,GAAG,GAAG;cACb;cACA;cACA;cAAA,KACK,IAAIlB,MAAI,KAAKrB,UAAU,EAAE;gBAC1BuC,GAAG,GAAG,EAAE;cACZ;cACA;cAAA,KACK;gBACDA,GAAG,GAAG1C,sBAAsB,CAACwB,MAAI,CAAC;cACtC;cACAe,UAAU,IAAIG,GAAG;cACjB;YACJ;YACA,QAAQlB,MAAI;cACR,KAAK,GAAG;gBACJT,QAAQ,GAAG,IAAI;gBACf;cACJ,KAAK,GAAG;gBACJC,UAAU,GAAG,IAAI;gBACjB;cACJ,KAAK,GAAG;gBAAE;kBACN,IAAM2B,OAAO,GAAGhC,cAAc,CAAC2B,QAAQ,EAAE,GAAG,CAAC;kBAC7C;kBACA,IAAMM,WAAW,SAAAlC,MAAA,CAASiC,OAAO,CAACE,GAAG,CAAC,UAAAC,MAAM;oBAAA,OAAIhB,WAAW,CAACgB,MAAM,CAAC;kBAAA,EAAC,CAACC,IAAI,CAAC,GAAG,CAAC,MAAG;kBACjFhB,KAAK,IAAIa,WAAW;kBACpB7B,QAAQ,GAAG,KAAK;kBAChBuB,QAAQ,GAAG,EAAE;kBACb;gBACJ;cACA,KAAK,GAAG;gBAAE;kBACNP,KAAK,IAAK,GAAG,GAAGQ,UAAU,GAAG,GAAI;kBACjCvB,UAAU,GAAG,KAAK;kBAClBuB,UAAU,GAAG,EAAE;kBACf;gBACJ;cACA,KAAK,GAAG;gBACJR,KAAK,IAAI1B,aAAa,CAAC,CAAC;gBACxB;cACJ,KAAK,GAAG;gBACJ0B,KAAK,IAAIxB,aAAa,CAAC,CAAC,CAAC;gBACzB;cACJ;gBACIwB,KAAK,IAAI/B,sBAAsB,CAACwB,MAAI,CAAC;YAC7C;UACJ;UACA;UACA;UACA;UACA;UACA;QAAA,SAAAG,GAAA;UAAAa,UAAA,CAAAZ,CAAA,CAAAD,GAAA;QAAA;UAAAa,UAAA,CAAAX,CAAA;QAAA;QACA,IAAIO,KAAK,GAAGtB,QAAQ,CAACuB,MAAM,GAAG,CAAC;QAAI;QAC9BvB,QAAQ,CAACsB,KAAK,GAAG,CAAC,CAAC,KAAKlC,QAAQ;QAAI;QACjCkC,KAAK,GAAG,CAAC,GAAGtB,QAAQ,CAACuB,MAAM,CAAC;QAAA,CAC/B,EAAE;UACHN,KAAK,IAAI3B,UAAU;QACvB;MACJ;MACA;MACA8B,0BAA0B,GAAID,OAAO,KAAK/B,QAAS;IACvD,CAAC,CAAC;EACN;EACA,OAAO6B,KAAK;AAChB;AACA;AACA,IAAMiB,EAAE,GAAG,sBAAsB,CAAC,CAAC;AACnC,IAAMC,EAAE,GAAG,uBAAuB,CAAC,CAAC;AACpC,IAAMC,EAAE,GAAG,kDAAkD,CAAC,CAAC;AAC/D,IAAMC,IAAI,GAAG,oEAAoE,CAAC,CAAC;AACnF,IAAMC,EAAE,GAAG,0BAA0B,CAAC,CAAC;AACvC,IAAMC,EAAE,GAAG,8BAA8B,CAAC,CAAC;AAC3C,IAAMC,KAAK,GAAG,IAAI5D,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;AACnC,IAAM6D,KAAK,GAAG,SAARA,KAAKA,CAAA,EAAe;EACtB,OAAO,KAAK;AAChB,CAAC;AACD,IAAMC,IAAI,GAAG,SAAPA,IAAIA,CAAA,EAAe;EACrB,OAAO,IAAI;AACf,CAAC;AACD,SAASC,YAAYA,CAACC,IAAI,EAAEC,OAAO,EAAE;EACjC,IAAI,CAACD,IAAI,EAAE;IACP,OAAOF,IAAI;EACf;EACA;EACA,IAAI5C,OAAO;EACX,IAAI,OAAO8C,IAAI,KAAK,QAAQ,EAAE;IAC1B9C,OAAO,GAAG8C,IAAI,CAAC9C,OAAO;EAC1B,CAAC,MACI;IACDA,OAAO,GAAG8C,IAAI;EAClB;EACA;EACA9C,OAAO,GAAGA,OAAO,CAACgD,IAAI,CAAC,CAAC;EACxB;EACA,IAAMC,UAAU,MAAAnD,MAAA,CAAME,OAAO,OAAAF,MAAA,CAAI,CAAC,CAACiD,OAAO,CAACG,iBAAiB,CAAE;EAC9D,IAAIC,aAAa,GAAGT,KAAK,CAACU,GAAG,CAACH,UAAU,CAAC;EACzC,IAAIE,aAAa,EAAE;IACf,OAAOE,mBAAmB,CAACF,aAAa,EAAEL,IAAI,CAAC;EACnD;EACA;EACA,IAAIQ,KAAK;EACT,IAAIlB,EAAE,CAACmB,IAAI,CAACvD,OAAO,CAAC,EAAE;IAClBmD,aAAa,GAAGK,OAAO,CAACxD,OAAO,CAACyD,MAAM,CAAC,CAAC,CAAC,EAAEzD,OAAO,CAAC,CAAC,CAAC;EACzD,CAAC,MACI,IAAIsD,KAAK,GAAGjB,EAAE,CAACqB,IAAI,CAACR,iBAAiB,CAAClD,OAAO,EAAE+C,OAAO,CAAC,CAAC,EAAE;IAAE;IAC7DI,aAAa,GAAGQ,OAAO,CAACL,KAAK,CAAC,CAAC,CAAC,EAAEtD,OAAO,CAAC;EAC9C,CAAC,MACI,IAAI,CAAC+C,OAAO,CAACG,iBAAiB,GAAGX,IAAI,GAAGD,EAAE,EAAEiB,IAAI,CAACvD,OAAO,CAAC,EAAE;IAAE;IAC9DmD,aAAa,GAAGS,OAAO,CAAC5D,OAAO,EAAE+C,OAAO,CAAC;EAC7C,CAAC,MACI,IAAIO,KAAK,GAAGd,EAAE,CAACkB,IAAI,CAACR,iBAAiB,CAAClD,OAAO,EAAE+C,OAAO,CAAC,CAAC,EAAE;IAAE;IAC7DI,aAAa,GAAGU,WAAW,CAACP,KAAK,CAAC,CAAC,CAAC,CAACG,MAAM,CAAC,CAAC,CAAC,EAAEzD,OAAO,EAAE,IAAI,CAAC;EAClE,CAAC,MACI,IAAIsD,KAAK,GAAGb,EAAE,CAACiB,IAAI,CAACR,iBAAiB,CAAClD,OAAO,EAAE+C,OAAO,CAAC,CAAC,EAAE;IAAE;IAC7DI,aAAa,GAAGU,WAAW,CAACP,KAAK,CAAC,CAAC,CAAC,EAAEtD,OAAO,EAAE,KAAK,CAAC;EACzD;EACA;EAAA,KACK;IACDmD,aAAa,GAAGW,QAAQ,CAAC9D,OAAO,CAAC;EACrC;EACA;EACA0C,KAAK,CAACqB,GAAG,CAACd,UAAU,EAAEE,aAAa,CAAC;EACpC,OAAOE,mBAAmB,CAACF,aAAa,EAAEL,IAAI,CAAC;AACnD;AACA,SAASO,mBAAmBA,CAACF,aAAa,EAAEa,IAAI,EAAE;EAC9C,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IAC1B,OAAOb,aAAa;EACxB;EACA,IAAMc,cAAc,GAAG,SAAjBA,cAAcA,CAAaC,IAAI,EAAEnF,QAAQ,EAAE;IAC7C,IAAI,CAACF,eAAe,CAACqF,IAAI,EAAEF,IAAI,CAACG,IAAI,EAAE,CAAChF,OAAO,CAAC,EAAE;MAC7C;MACA,OAAO,IAAI;IACf;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,OAAOgE,aAAa,CAAC9D,KAAK,CAAC6E,IAAI,CAACT,MAAM,CAACO,IAAI,CAACG,IAAI,CAAC1C,MAAM,CAAC,EAAEvC,GAAG,CAAC,EAAEH,QAAQ,CAAC;EAC7E,CAAC;EACD;EACAkF,cAAc,CAACG,YAAY,GAAGjB,aAAa,CAACiB,YAAY;EACxDH,cAAc,CAACI,QAAQ,GAAGlB,aAAa,CAACkB,QAAQ;EAChDJ,cAAc,CAACK,SAAS,GAAGnB,aAAa,CAACmB,SAAS;EAClDL,cAAc,CAACM,QAAQ,GAAGpB,aAAa,CAACoB,QAAQ;EAChD,OAAON,cAAc;AACzB;AACA,SAASf,iBAAiBA,CAAClD,OAAO,EAAE+C,OAAO,EAAE;EACzC,OAAOA,OAAO,CAACG,iBAAiB,IAAIlD,OAAO,CAACwE,QAAQ,CAAC,KAAK,CAAC,GAAGxE,OAAO,CAACyD,MAAM,CAAC,CAAC,EAAEzD,OAAO,CAACyB,MAAM,GAAG,CAAC,CAAC,GAAGzB,OAAO,CAAC,CAAC;AACnH;AACA;AACA,SAASwD,OAAOA,CAACW,IAAI,EAAEnE,OAAO,EAAE;EAC5B,OAAO,UAAUkE,IAAI,EAAEnF,QAAQ,EAAE;IAC7B,OAAO,OAAOmF,IAAI,KAAK,QAAQ,IAAIA,IAAI,CAACM,QAAQ,CAACL,IAAI,CAAC,GAAGnE,OAAO,GAAG,IAAI;EAC3E,CAAC;AACL;AACA;AACA,SAAS2D,OAAOA,CAACQ,IAAI,EAAEnE,OAAO,EAAE;EAC5B,IAAMyE,SAAS,OAAA3E,MAAA,CAAOqE,IAAI,CAAE;EAC5B,IAAMO,aAAa,QAAA5E,MAAA,CAAQqE,IAAI,CAAE;EACjC,IAAMhB,aAAa,GAAG,SAAhBA,aAAaA,CAAae,IAAI,EAAEnF,QAAQ,EAAE;IAC5C,IAAI,OAAOmF,IAAI,KAAK,QAAQ,EAAE;MAC1B,OAAO,IAAI;IACf;IACA,IAAInF,QAAQ,EAAE;MACV,OAAOA,QAAQ,KAAKoF,IAAI,GAAGnE,OAAO,GAAG,IAAI;IAC7C;IACA,OAAOkE,IAAI,KAAKC,IAAI,IAAID,IAAI,CAACM,QAAQ,CAACC,SAAS,CAAC,IAAIP,IAAI,CAACM,QAAQ,CAACE,aAAa,CAAC,GAAG1E,OAAO,GAAG,IAAI;EACrG,CAAC;EACD,IAAMsE,SAAS,GAAG,CAACH,IAAI,CAAC;EACxBhB,aAAa,CAACmB,SAAS,GAAGA,SAAS;EACnCnB,aAAa,CAACoB,QAAQ,GAAG,CAACvE,OAAO,CAAC;EAClCmD,aAAa,CAACiB,YAAY,GAAGE,SAAS;EACtC,OAAOnB,aAAa;AACxB;AACA;AACA,SAASS,OAAOA,CAAC5D,OAAO,EAAE+C,OAAO,EAAE;EAC/B,IAAM4B,cAAc,GAAGC,wBAAwB,CAAC5E,OAAO,CAAC6E,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAC/DC,KAAK,CAAC,GAAG,CAAC,CACV7C,GAAG,CAAC,UAAAjC,OAAO;IAAA,OAAI6C,YAAY,CAAC7C,OAAO,EAAE+C,OAAO,CAAC;EAAA,EAAC,CAC9CgC,MAAM,CAAC,UAAA/E,OAAO;IAAA,OAAIA,OAAO,KAAK4C,IAAI;EAAA,EAAC,EAAE5C,OAAO,CAAC;EAClD,IAAMgF,cAAc,GAAGL,cAAc,CAAClD,MAAM;EAC5C,IAAI,CAACuD,cAAc,EAAE;IACjB,OAAOpC,IAAI;EACf;EACA,IAAIoC,cAAc,KAAK,CAAC,EAAE;IACtB,OAAOL,cAAc,CAAC,CAAC,CAAC;EAC5B;EACA,IAAMxB,aAAa,GAAG,SAAhBA,aAAaA,CAAae,IAAI,EAAEnF,QAAQ,EAAE;IAC5C,KAAK,IAAIkG,CAAC,GAAG,CAAC,EAAEvE,CAAC,GAAGiE,cAAc,CAAClD,MAAM,EAAEwD,CAAC,GAAGvE,CAAC,EAAEuE,CAAC,EAAE,EAAE;MACnD,IAAIN,cAAc,CAACM,CAAC,CAAC,CAACf,IAAI,EAAEnF,QAAQ,CAAC,EAAE;QACnC,OAAOiB,OAAO;MAClB;IACJ;IACA,OAAO,IAAI;EACf,CAAC;EACD,IAAMkF,aAAa,GAAGP,cAAc,CAACQ,IAAI,CAAC,UAAAnF,OAAO;IAAA,OAAI,CAAC,CAACA,OAAO,CAACoE,YAAY;EAAA,EAAC;EAC5E,IAAIc,aAAa,EAAE;IACf/B,aAAa,CAACiB,YAAY,GAAGc,aAAa,CAACd,YAAY;EAC3D;EACA,IAAMC,QAAQ,GAAGM,cAAc,CAACS,MAAM,CAAC,UAACC,GAAG,EAAEC,OAAO;IAAA,OAAKA,OAAO,CAACjB,QAAQ,GAAGgB,GAAG,CAACvF,MAAM,CAACwF,OAAO,CAACjB,QAAQ,CAAC,GAAGgB,GAAG;EAAA,GAAE,EAAE,CAAC;EACnH,IAAIhB,QAAQ,CAAC5C,MAAM,EAAE;IACjB0B,aAAa,CAACkB,QAAQ,GAAGA,QAAQ;EACrC;EACA,OAAOlB,aAAa;AACxB;AACA;AACA,SAASU,WAAWA,CAAC0B,UAAU,EAAEvF,OAAO,EAAEwF,aAAa,EAAE;EACrD,IAAMC,aAAa,GAAGvG,GAAG,KAAKD,KAAK,CAACC,GAAG;EACvC,IAAMwG,UAAU,GAAGD,aAAa,GAAGF,UAAU,GAAGA,UAAU,CAACI,OAAO,CAACjG,mBAAmB,EAAER,GAAG,CAAC;EAC5F,IAAM0G,aAAa,GAAG1G,GAAG,GAAGwG,UAAU;EACtC,IAAMG,aAAa,GAAG5G,KAAK,CAACC,GAAG,GAAGqG,UAAU;EAC5C,IAAIpC,aAAa;EACjB,IAAIqC,aAAa,EAAE;IACfrC,aAAa,GAAG,SAAAA,cAAUe,IAAI,EAAEnF,QAAQ,EAAE;MACtC,OAAO,OAAOmF,IAAI,KAAK,QAAQ,KAAMA,IAAI,KAAKwB,UAAU,IAAIxB,IAAI,CAACM,QAAQ,CAACoB,aAAa,CAAC,IAAK,CAACH,aAAa,KAAKvB,IAAI,KAAKqB,UAAU,IAAIrB,IAAI,CAACM,QAAQ,CAACqB,aAAa,CAAC,CAAC,CAAC,GAAG7F,OAAO,GAAG,IAAI;IAC1L,CAAC;EACL,CAAC,MACI;IACDmD,aAAa,GAAG,SAAAA,cAAUe,IAAI,EAAEnF,QAAQ,EAAE;MACtC,OAAO,OAAOmF,IAAI,KAAK,QAAQ,KAAKA,IAAI,KAAKwB,UAAU,IAAK,CAACD,aAAa,IAAIvB,IAAI,KAAKqB,UAAW,CAAC,GAAGvF,OAAO,GAAG,IAAI;IACxH,CAAC;EACL;EACAmD,aAAa,CAACkB,QAAQ,GAAG,CAAC,CAACmB,aAAa,GAAG,IAAI,GAAG,IAAI,IAAID,UAAU,CAAC;EACrE,OAAOpC,aAAa;AACxB;AACA,SAASW,QAAQA,CAAC9D,OAAO,EAAE;EACvB,IAAI;IACA,IAAM8F,MAAM,GAAG,IAAIC,MAAM,KAAAjG,MAAA,CAAKoB,WAAW,CAAClB,OAAO,CAAC,MAAG,CAAC;IACtD,OAAO,UAAUkE,IAAI,EAAE;MACnB4B,MAAM,CAACE,SAAS,GAAG,CAAC,CAAC,CAAC;MACtB,OAAO,OAAO9B,IAAI,KAAK,QAAQ,IAAI4B,MAAM,CAACvC,IAAI,CAACW,IAAI,CAAC,GAAGlE,OAAO,GAAG,IAAI;IACzE,CAAC;EACL,CAAC,CACD,OAAOiG,KAAK,EAAE;IACV,OAAOrD,IAAI;EACf;AACJ;AACA,OAAO,SAASU,KAAKA,CAACR,IAAI,EAAEoB,IAAI,EAAEgC,UAAU,EAAE;EAC1C,IAAI,CAACpD,IAAI,IAAI,OAAOoB,IAAI,KAAK,QAAQ,EAAE;IACnC,OAAO,KAAK;EAChB;EACA,OAAOiC,KAAK,CAACrD,IAAI,CAAC,CAACoB,IAAI,EAAEkC,SAAS,EAAEF,UAAU,CAAC;AACnD;AACA,OAAO,SAASC,KAAKA,CAACrD,IAAI,EAAgB;EAAA,IAAdC,OAAO,GAAAsD,SAAA,CAAA5E,MAAA,QAAA4E,SAAA,QAAAD,SAAA,GAAAC,SAAA,MAAG,CAAC,CAAC;EACpC,IAAI,CAACvD,IAAI,EAAE;IACP,OAAOH,KAAK;EAChB;EACA;EACA,IAAI,OAAOG,IAAI,KAAK,QAAQ,IAAIwD,iBAAiB,CAACxD,IAAI,CAAC,EAAE;IACrD,IAAMK,aAAa,GAAGN,YAAY,CAACC,IAAI,EAAEC,OAAO,CAAC;IACjD,IAAII,aAAa,KAAKP,IAAI,EAAE;MACxB,OAAOD,KAAK;IAChB;IACA,IAAM4D,aAAa,GAAG,SAAhBA,aAAaA,CAAarC,IAAI,EAAEnF,QAAQ,EAAE;MAC5C,OAAO,CAAC,CAACoE,aAAa,CAACe,IAAI,EAAEnF,QAAQ,CAAC;IAC1C,CAAC;IACD,IAAIoE,aAAa,CAACiB,YAAY,EAAE;MAC5BmC,aAAa,CAACnC,YAAY,GAAGjB,aAAa,CAACiB,YAAY;IAC3D;IACA,IAAIjB,aAAa,CAACkB,QAAQ,EAAE;MACxBkC,aAAa,CAAClC,QAAQ,GAAGlB,aAAa,CAACkB,QAAQ;IACnD;IACA,OAAOkC,aAAa;EACxB;EACA;EACA,OAAOC,gBAAgB,CAAC1D,IAAI,EAAEC,OAAO,CAAC;AAC1C;AACA,OAAO,SAASuD,iBAAiBA,CAACG,GAAG,EAAE;EACnC,IAAMC,EAAE,GAAGD,GAAG;EACd,IAAI,CAACC,EAAE,EAAE;IACL,OAAO,KAAK;EAChB;EACA,OAAO,OAAOA,EAAE,CAACvC,IAAI,KAAK,QAAQ,IAAI,OAAOuC,EAAE,CAAC1G,OAAO,KAAK,QAAQ;AACxE;AACA,SAASwG,gBAAgBA,CAACG,UAAU,EAAE5D,OAAO,EAAE;EAC3C,IAAM4B,cAAc,GAAGC,wBAAwB,CAACgC,MAAM,CAACC,mBAAmB,CAACF,UAAU,CAAC,CACjF1E,GAAG,CAAC,UAAAjC,OAAO;IAAA,OAAI8G,sBAAsB,CAAC9G,OAAO,EAAE2G,UAAU,CAAC3G,OAAO,CAAC,EAAE+C,OAAO,CAAC;EAAA,EAAC,CAC7EgC,MAAM,CAAC,UAAA/E,OAAO;IAAA,OAAIA,OAAO,KAAK4C,IAAI;EAAA,EAAC,CAAC;EACzC,IAAMoC,cAAc,GAAGL,cAAc,CAAClD,MAAM;EAC5C,IAAI,CAACuD,cAAc,EAAE;IACjB,OAAOpC,IAAI;EACf;EACA,IAAI,CAAC+B,cAAc,CAACoC,IAAI,CAAC,UAAA5D,aAAa;IAAA,OAAI,CAAC,CAACA,aAAa,CAAC6D,gBAAgB;EAAA,EAAC,EAAE;IACzE,IAAIhC,cAAc,KAAK,CAAC,EAAE;MACtB,OAAOL,cAAc,CAAC,CAAC,CAAC;IAC5B;IACA,IAAMsC,iBAAgB,GAAG,SAAnBA,iBAAgBA,CAAa/C,IAAI,EAAEnF,QAAQ,EAAE;MAC/C,IAAImI,cAAc,GAAGd,SAAS;MAC9B,KAAK,IAAInB,CAAC,GAAG,CAAC,EAAEvE,CAAC,GAAGiE,cAAc,CAAClD,MAAM,EAAEwD,CAAC,GAAGvE,CAAC,EAAEuE,CAAC,EAAE,EAAE;QACnD,IAAMkC,MAAM,GAAGxC,cAAc,CAACM,CAAC,CAAC,CAACf,IAAI,EAAEnF,QAAQ,CAAC;QAChD,IAAI,OAAOoI,MAAM,KAAK,QAAQ,EAAE;UAC5B,OAAOA,MAAM,CAAC,CAAC;QACnB;QACA;QACA;QACA,IAAIvI,UAAU,CAACuI,MAAM,CAAC,EAAE;UACpB,IAAI,CAACD,cAAc,EAAE;YACjBA,cAAc,GAAG,EAAE;UACvB;UACAA,cAAc,CAACpG,IAAI,CAACqG,MAAM,CAAC;QAC/B;MACJ;MACA;MACA;MACA,IAAID,cAAc,EAAE;QAChB,OAAOE,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAC,SAAAC,QAAA;UAAA,IAAAC,UAAA,EAAAC,MAAA,EAAAC,aAAA,EAAAC,OAAA;UAAA,OAAAN,mBAAA,GAAAO,IAAA,UAAAC,SAAAC,QAAA;YAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;cAAA;gBAAAR,UAAA,GAAAjH,0BAAA,CACwB2G,cAAc;gBAAAY,QAAA,CAAAC,IAAA;gBAAAP,UAAA,CAAA/G,CAAA;cAAA;gBAAA,KAAAgH,MAAA,GAAAD,UAAA,CAAA9G,CAAA,IAAAC,IAAA;kBAAAmH,QAAA,CAAAE,IAAA;kBAAA;gBAAA;gBAA/BN,aAAa,GAAAD,MAAA,CAAA5G,KAAA;gBAAAiH,QAAA,CAAAE,IAAA;gBAAA,OACCN,aAAa;cAAA;gBAA5BP,OAAM,GAAAW,QAAA,CAAAG,IAAA;gBAAA,MACR,OAAOd,OAAM,KAAK,QAAQ;kBAAAW,QAAA,CAAAE,IAAA;kBAAA;gBAAA;gBAAA,OAAAF,QAAA,CAAAI,MAAA,WACnBf,OAAM;cAAA;gBAAAW,QAAA,CAAAE,IAAA;gBAAA;cAAA;gBAAAF,QAAA,CAAAE,IAAA;gBAAA;cAAA;gBAAAF,QAAA,CAAAC,IAAA;gBAAAD,QAAA,CAAAK,EAAA,GAAAL,QAAA;gBAAAN,UAAA,CAAAxG,CAAA,CAAA8G,QAAA,CAAAK,EAAA;cAAA;gBAAAL,QAAA,CAAAC,IAAA;gBAAAP,UAAA,CAAAvG,CAAA;gBAAA,OAAA6G,QAAA,CAAAM,MAAA;cAAA;gBAAA,OAAAN,QAAA,CAAAI,MAAA,WAGd,IAAI;cAAA;cAAA;gBAAA,OAAAJ,QAAA,CAAAO,IAAA;YAAA;UAAA,GAAAd,OAAA;QAAA,CACd,GAAE,CAAC;MACR;MACA,OAAO,IAAI;IACf,CAAC;IACD,IAAMrC,cAAa,GAAGP,cAAc,CAACQ,IAAI,CAAC,UAAAnF,OAAO;MAAA,OAAI,CAAC,CAACA,OAAO,CAACoE,YAAY;IAAA,EAAC;IAC5E,IAAIc,cAAa,EAAE;MACf+B,iBAAgB,CAAC7C,YAAY,GAAGc,cAAa,CAACd,YAAY;IAC9D;IACA,IAAMC,SAAQ,GAAGM,cAAc,CAACS,MAAM,CAAC,UAACC,GAAG,EAAEC,OAAO;MAAA,OAAKA,OAAO,CAACjB,QAAQ,GAAGgB,GAAG,CAACvF,MAAM,CAACwF,OAAO,CAACjB,QAAQ,CAAC,GAAGgB,GAAG;IAAA,GAAE,EAAE,CAAC;IACnH,IAAIhB,SAAQ,CAAC5C,MAAM,EAAE;MACjBwF,iBAAgB,CAAC5C,QAAQ,GAAGA,SAAQ;IACxC;IACA,OAAO4C,iBAAgB;EAC3B;EACA,IAAMA,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAa/C,IAAI,EAAEC,IAAI,EAAE+B,UAAU,EAAE;IACvD,IAAIoC,IAAI,GAAGlC,SAAS;IACpB,IAAIc,cAAc,GAAGd,SAAS;IAC9B,KAAK,IAAInB,CAAC,GAAG,CAAC,EAAEvE,CAAC,GAAGiE,cAAc,CAAClD,MAAM,EAAEwD,CAAC,GAAGvE,CAAC,EAAEuE,CAAC,EAAE,EAAE;MACnD;MACA,IAAM9B,aAAa,GAAGwB,cAAc,CAACM,CAAC,CAAC;MACvC,IAAI9B,aAAa,CAAC6D,gBAAgB,IAAId,UAAU,EAAE;QAC9C,IAAI,CAAC/B,IAAI,EAAE;UACPA,IAAI,GAAGpF,QAAQ,CAACmF,IAAI,CAAC;QACzB;QACA,IAAI,CAACoE,IAAI,EAAE;UACPA,IAAI,GAAGnE,IAAI,CAACV,MAAM,CAAC,CAAC,EAAEU,IAAI,CAAC1C,MAAM,GAAGzC,OAAO,CAACkF,IAAI,CAAC,CAACzC,MAAM,CAAC;QAC7D;MACJ;MACA,IAAM0F,MAAM,GAAGhE,aAAa,CAACe,IAAI,EAAEC,IAAI,EAAEmE,IAAI,EAAEpC,UAAU,CAAC;MAC1D,IAAI,OAAOiB,MAAM,KAAK,QAAQ,EAAE;QAC5B,OAAOA,MAAM,CAAC,CAAC;MACnB;MACA;MACA;MACA,IAAIvI,UAAU,CAACuI,MAAM,CAAC,EAAE;QACpB,IAAI,CAACD,cAAc,EAAE;UACjBA,cAAc,GAAG,EAAE;QACvB;QACAA,cAAc,CAACpG,IAAI,CAACqG,MAAM,CAAC;MAC/B;IACJ;IACA;IACA;IACA,IAAID,cAAc,EAAE;MAChB,OAAOE,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAC,SAAAiB,SAAA;QAAA,IAAAC,UAAA,EAAAC,MAAA,EAAAf,aAAA,EAAAgB,QAAA;QAAA,OAAArB,mBAAA,GAAAO,IAAA,UAAAe,UAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAAb,IAAA,GAAAa,SAAA,CAAAZ,IAAA;YAAA;cAAAQ,UAAA,GAAAjI,0BAAA,CACwB2G,cAAc;cAAA0B,SAAA,CAAAb,IAAA;cAAAS,UAAA,CAAA/H,CAAA;YAAA;cAAA,KAAAgI,MAAA,GAAAD,UAAA,CAAA9H,CAAA,IAAAC,IAAA;gBAAAiI,SAAA,CAAAZ,IAAA;gBAAA;cAAA;cAA/BN,aAAa,GAAAe,MAAA,CAAA5H,KAAA;cAAA+H,SAAA,CAAAZ,IAAA;cAAA,OACCN,aAAa;YAAA;cAA5BP,QAAM,GAAAyB,SAAA,CAAAX,IAAA;cAAA,MACR,OAAOd,QAAM,KAAK,QAAQ;gBAAAyB,SAAA,CAAAZ,IAAA;gBAAA;cAAA;cAAA,OAAAY,SAAA,CAAAV,MAAA,WACnBf,QAAM;YAAA;cAAAyB,SAAA,CAAAZ,IAAA;cAAA;YAAA;cAAAY,SAAA,CAAAZ,IAAA;cAAA;YAAA;cAAAY,SAAA,CAAAb,IAAA;cAAAa,SAAA,CAAAT,EAAA,GAAAS,SAAA;cAAAJ,UAAA,CAAAxH,CAAA,CAAA4H,SAAA,CAAAT,EAAA;YAAA;cAAAS,SAAA,CAAAb,IAAA;cAAAS,UAAA,CAAAvH,CAAA;cAAA,OAAA2H,SAAA,CAAAR,MAAA;YAAA;cAAA,OAAAQ,SAAA,CAAAV,MAAA,WAGd,IAAI;YAAA;YAAA;cAAA,OAAAU,SAAA,CAAAP,IAAA;UAAA;QAAA,GAAAE,QAAA;MAAA,CACd,GAAE,CAAC;IACR;IACA,OAAO,IAAI;EACf,CAAC;EACD,IAAMrD,aAAa,GAAGP,cAAc,CAACQ,IAAI,CAAC,UAAAnF,OAAO;IAAA,OAAI,CAAC,CAACA,OAAO,CAACoE,YAAY;EAAA,EAAC;EAC5E,IAAIc,aAAa,EAAE;IACf+B,gBAAgB,CAAC7C,YAAY,GAAGc,aAAa,CAACd,YAAY;EAC9D;EACA,IAAMC,QAAQ,GAAGM,cAAc,CAACS,MAAM,CAAC,UAACC,GAAG,EAAEC,OAAO;IAAA,OAAKA,OAAO,CAACjB,QAAQ,GAAGgB,GAAG,CAACvF,MAAM,CAACwF,OAAO,CAACjB,QAAQ,CAAC,GAAGgB,GAAG;EAAA,GAAE,EAAE,CAAC;EACnH,IAAIhB,QAAQ,CAAC5C,MAAM,EAAE;IACjBwF,gBAAgB,CAAC5C,QAAQ,GAAGA,QAAQ;EACxC;EACA,OAAO4C,gBAAgB;AAC3B;AACA,SAASH,sBAAsBA,CAAC9G,OAAO,EAAEa,KAAK,EAAEkC,OAAO,EAAE;EACrD,IAAIlC,KAAK,KAAK,KAAK,EAAE;IACjB,OAAO+B,IAAI,CAAC,CAAC;EACjB;EACA,IAAMO,aAAa,GAAGN,YAAY,CAAC7C,OAAO,EAAE+C,OAAO,CAAC;EACpD,IAAII,aAAa,KAAKP,IAAI,EAAE;IACxB,OAAOA,IAAI;EACf;EACA;EACA,IAAI,OAAO/B,KAAK,KAAK,SAAS,EAAE;IAC5B,OAAOsC,aAAa;EACxB;EACA;EACA,IAAItC,KAAK,EAAE;IACP,IAAMgI,IAAI,GAAGhI,KAAK,CAACgI,IAAI;IACvB,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;MAC1B,IAAM1B,MAAM,GAAG,SAATA,MAAMA,CAAIjD,IAAI,EAAEnF,QAAQ,EAAEuJ,IAAI,EAAEpC,UAAU,EAAK;QACjD,IAAI,CAACA,UAAU,IAAI,CAAC/C,aAAa,CAACe,IAAI,EAAEnF,QAAQ,CAAC,EAAE;UAC/C,OAAO,IAAI;QACf;QACA,IAAM+J,aAAa,GAAGD,IAAI,CAAClD,OAAO,CAAC,aAAa,EAAE;UAAA,OAAM2C,IAAI;QAAA,EAAC;QAC7D,IAAMS,OAAO,GAAG7C,UAAU,CAAC4C,aAAa,CAAC;QACzC,OAAOlK,UAAU,CAACmK,OAAO,CAAC,GACtBA,OAAO,CAACC,IAAI,CAAC,UAAA1F,KAAK;UAAA,OAAIA,KAAK,GAAGtD,OAAO,GAAG,IAAI;QAAA,EAAC,GAC7C+I,OAAO,GAAG/I,OAAO,GAAG,IAAI;MAChC,CAAC;MACDmH,MAAM,CAACH,gBAAgB,GAAG,IAAI;MAC9B,OAAOG,MAAM;IACjB;EACJ;EACA;EACA,OAAOhE,aAAa;AACxB;AACA,SAASyB,wBAAwBA,CAACD,cAAc,EAAEwC,MAAM,EAAE;EACtD,IAAM8B,gBAAgB,GAAGtE,cAAc,CAACI,MAAM,CAAC,UAAA5B,aAAa;IAAA,OAAI,CAAC,CAACA,aAAa,CAACmB,SAAS;EAAA,EAAC;EAC1F,IAAI2E,gBAAgB,CAACxH,MAAM,GAAG,CAAC,EAAE;IAC7B,OAAOkD,cAAc;EACzB;EACA,IAAML,SAAS,GAAG2E,gBAAgB,CAAC7D,MAAM,CAAC,UAACC,GAAG,EAAEC,OAAO,EAAK;IACxD,IAAMhB,SAAS,GAAGgB,OAAO,CAAChB,SAAS;IACnC,OAAOA,SAAS,GAAGe,GAAG,CAACvF,MAAM,CAACwE,SAAS,CAAC,GAAGe,GAAG;EAClD,CAAC,EAAE,EAAE,CAAC;EACN,IAAId,QAAQ;EACZ,IAAI4C,MAAM,EAAE;IACR5C,QAAQ,GAAG,EAAE;IACb,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEvE,CAAC,GAAG4D,SAAS,CAAC7C,MAAM,EAAEwD,CAAC,GAAGvE,CAAC,EAAEuE,CAAC,EAAE,EAAE;MAC9CV,QAAQ,CAACzD,IAAI,CAACqG,MAAM,CAAC;IACzB;EACJ,CAAC,MACI;IACD5C,QAAQ,GAAG0E,gBAAgB,CAAC7D,MAAM,CAAC,UAACC,GAAG,EAAEC,OAAO,EAAK;MACjD,IAAMf,QAAQ,GAAGe,OAAO,CAACf,QAAQ;MACjC,OAAOA,QAAQ,GAAGc,GAAG,CAACvF,MAAM,CAACyE,QAAQ,CAAC,GAAGc,GAAG;IAChD,CAAC,EAAE,EAAE,CAAC;EACV;EACA,IAAM6D,SAAS,GAAG,SAAZA,SAASA,CAAahF,IAAI,EAAEnF,QAAQ,EAAE;IACxC,IAAI,OAAOmF,IAAI,KAAK,QAAQ,EAAE;MAC1B,OAAO,IAAI;IACf;IACA,IAAI,CAACnF,QAAQ,EAAE;MACX,IAAIkG,EAAC;MACL,KAAKA,EAAC,GAAGf,IAAI,CAACzC,MAAM,EAAEwD,EAAC,GAAG,CAAC,EAAEA,EAAC,EAAE,EAAE;QAC9B,IAAMkE,EAAE,GAAGjF,IAAI,CAACkF,UAAU,CAACnE,EAAC,GAAG,CAAC,CAAC;QACjC,IAAIkE,EAAE,KAAK,EAAE,CAAC,wBAAwBA,EAAE,KAAK,EAAE,CAAC,0BAA0B;UACtE;QACJ;MACJ;MACApK,QAAQ,GAAGmF,IAAI,CAACT,MAAM,CAACwB,EAAC,CAAC;IAC7B;IACA,IAAMzD,KAAK,GAAG8C,SAAS,CAAC+E,OAAO,CAACtK,QAAQ,CAAC;IACzC,OAAOyC,KAAK,KAAK,CAAC,CAAC,GAAG+C,QAAQ,CAAC/C,KAAK,CAAC,GAAG,IAAI;EAChD,CAAC;EACD0H,SAAS,CAAC5E,SAAS,GAAGA,SAAS;EAC/B4E,SAAS,CAAC3E,QAAQ,GAAGA,QAAQ;EAC7B2E,SAAS,CAAC9E,YAAY,GAAGE,SAAS;EAClC,IAAMgF,kBAAkB,GAAG3E,cAAc,CAACI,MAAM,CAAC,UAAA5B,aAAa;IAAA,OAAI,CAACA,aAAa,CAACmB,SAAS;EAAA,EAAC;EAC3FgF,kBAAkB,CAACxI,IAAI,CAACoI,SAAS,CAAC;EAClC,OAAOI,kBAAkB;AAC7B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}