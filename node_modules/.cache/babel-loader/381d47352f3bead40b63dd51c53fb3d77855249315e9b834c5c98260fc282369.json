{"ast":null,"code":"import _typeof from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.number.constructor.js\";\n/**\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('hast').Element} Element\n */\n\n/**\n * @typedef {null | undefined | string | TestFunctionAnything | Array<string | TestFunctionAnything>} Test\n *   Check for an arbitrary element, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if an element passes a test, unaware of TypeScript inferral.\n * @param {Element} element\n *   An element.\n * @param {number | null | undefined} [index]\n *   The element’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The element’s parent.\n * @returns {boolean | void}\n *   Whether this element passes the test.\n */\n\n/**\n * @template {Element} T\n *   Element type.\n * @typedef {T['tagName'] | TestFunctionPredicate<T> | Array<T['tagName'] | TestFunctionPredicate<T>>} PredicateTest\n *   Check for an element that can be inferred by TypeScript.\n */\n\n/**\n * Check if an element passes a certain node test.\n *\n * @template {Element} T\n *   Element type.\n * @callback TestFunctionPredicate\n *   Complex test function for an element that can be inferred by TypeScript.\n * @param {Element} element\n *   An element.\n * @param {number | null | undefined} [index]\n *   The element’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The element’s parent.\n * @returns {element is T}\n *   Whether this element passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is an element, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is an element and passes a test.\n */\n\n/**\n * Check if a node is an element and passes a certain node test\n *\n * @template {Element} T\n *   Element type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific element, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is T}\n *   Whether this is an element and passes a test.\n */\n\n/**\n * Check if `node` is an `Element` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific element.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is an element and passes a test.\n */\nexport var isElement =\n/**\n * @type {(\n *   (() => false) &\n *   (<T extends Element = Element>(node: unknown, test?: PredicateTest<T>, index?: number, parent?: Parent, context?: unknown) => node is T) &\n *   ((node: unknown, test: Test, index?: number, parent?: Parent, context?: unknown) => boolean)\n * )}\n */\n\n/**\n * @param {unknown} [node]\n * @param {Test | undefined} [test]\n * @param {number | null | undefined} [index]\n * @param {Parent | null | undefined} [parent]\n * @param {unknown} [context]\n * @returns {boolean}\n */\n// eslint-disable-next-line max-params\nfunction isElement(node, test, index, parent, context) {\n  var check = convertElement(test);\n  if (index !== undefined && index !== null && (typeof index !== 'number' || index < 0 || index === Number.POSITIVE_INFINITY)) {\n    throw new Error('Expected positive finite index for child node');\n  }\n  if (parent !== undefined && parent !== null && (!parent.type || !parent.children)) {\n    throw new Error('Expected parent node');\n  }\n\n  // @ts-expect-error Looks like a node.\n  if (!node || !node.type || typeof node.type !== 'string') {\n    return false;\n  }\n  if ((parent === undefined || parent === null) !== (index === undefined || index === null)) {\n    throw new Error('Expected both parent and index');\n  }\n  return check.call(context, node, index, parent);\n};\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *  When nullish, checks if `node` is an `Element`.\n *   *  When `string`, works like passing `(element) => element.tagName === test`.\n *   *  When `function` checks if function passed the element is true.\n *   *  When `array`, checks any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport var convertElement =\n/**\n * @type {(\n *   (<T extends Element>(test: T['tagName'] | TestFunctionPredicate<T>) => AssertPredicate<T>) &\n *   ((test?: Test) => AssertAnything)\n * )}\n */\n\n/**\n * @param {Test | null | undefined} [test]\n * @returns {AssertAnything}\n */\nfunction convertElement(test) {\n  if (test === undefined || test === null) {\n    return element;\n  }\n  if (typeof test === 'string') {\n    return tagNameFactory(test);\n  }\n  if (_typeof(test) === 'object') {\n    return anyFactory(test);\n  }\n  if (typeof test === 'function') {\n    return castFactory(test);\n  }\n  throw new Error('Expected function, string, or array as test');\n};\n\n/**\n * Handle multiple tests.\n *\n * @param {Array<string | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  var checks = [];\n  var index = -1;\n  while (++index < tests.length) {\n    checks[index] = convertElement(tests[index]);\n  }\n  return castFactory(any);\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any() {\n    var index = -1;\n    for (var _len = arguments.length, parameters = new Array(_len), _key = 0; _key < _len; _key++) {\n      parameters[_key] = arguments[_key];\n    }\n    while (++index < checks.length) {\n      var _checks$index;\n      if ((_checks$index = checks[index]).call.apply(_checks$index, [this].concat(parameters))) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n/**\n * Turn a string into a test for an element with a certain tag name.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction tagNameFactory(check) {\n  return tagName;\n\n  /**\n   * @param {unknown} node\n   * @returns {boolean}\n   */\n  function tagName(node) {\n    return element(node) && node.tagName === check;\n  }\n}\n\n/**\n * Turn a custom test into a test for an element that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion;\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node) {\n    for (var _len2 = arguments.length, parameters = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      parameters[_key2 - 1] = arguments[_key2];\n    }\n    // @ts-expect-error: fine.\n    return element(node) && Boolean(check.call.apply(check, [this, node].concat(parameters)));\n  }\n}\n\n/**\n * Make sure something is an element.\n *\n * @param {unknown} node\n * @returns {node is Element}\n */\nfunction element(node) {\n  return Boolean(node && _typeof(node) === 'object' &&\n  // @ts-expect-error Looks like a node.\n  node.type === 'element' &&\n  // @ts-expect-error Looks like an element.\n  typeof node.tagName === 'string');\n}","map":{"version":3,"names":["isElement","node","test","index","parent","context","check","convertElement","undefined","Number","POSITIVE_INFINITY","Error","type","children","call","element","tagNameFactory","_typeof","anyFactory","castFactory","tests","checks","length","any","_len","arguments","parameters","Array","_key","_checks$index","apply","concat","tagName","assertion","_len2","_key2","Boolean"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/hast-util-is-element/index.js"],"sourcesContent":["/**\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('hast').Element} Element\n */\n\n/**\n * @typedef {null | undefined | string | TestFunctionAnything | Array<string | TestFunctionAnything>} Test\n *   Check for an arbitrary element, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if an element passes a test, unaware of TypeScript inferral.\n * @param {Element} element\n *   An element.\n * @param {number | null | undefined} [index]\n *   The element’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The element’s parent.\n * @returns {boolean | void}\n *   Whether this element passes the test.\n */\n\n/**\n * @template {Element} T\n *   Element type.\n * @typedef {T['tagName'] | TestFunctionPredicate<T> | Array<T['tagName'] | TestFunctionPredicate<T>>} PredicateTest\n *   Check for an element that can be inferred by TypeScript.\n */\n\n/**\n * Check if an element passes a certain node test.\n *\n * @template {Element} T\n *   Element type.\n * @callback TestFunctionPredicate\n *   Complex test function for an element that can be inferred by TypeScript.\n * @param {Element} element\n *   An element.\n * @param {number | null | undefined} [index]\n *   The element’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The element’s parent.\n * @returns {element is T}\n *   Whether this element passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is an element, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is an element and passes a test.\n */\n\n/**\n * Check if a node is an element and passes a certain node test\n *\n * @template {Element} T\n *   Element type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific element, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is T}\n *   Whether this is an element and passes a test.\n */\n\n/**\n * Check if `node` is an `Element` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific element.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is an element and passes a test.\n */\nexport const isElement =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<T extends Element = Element>(node: unknown, test?: PredicateTest<T>, index?: number, parent?: Parent, context?: unknown) => node is T) &\n   *   ((node: unknown, test: Test, index?: number, parent?: Parent, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test | undefined} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (node, test, index, parent, context) {\n      const check = convertElement(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index for child node')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!parent.type || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      // @ts-expect-error Looks like a node.\n      if (!node || !node.type || typeof node.type !== 'string') {\n        return false\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      return check.call(context, node, index, parent)\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *  When nullish, checks if `node` is an `Element`.\n *   *  When `string`, works like passing `(element) => element.tagName === test`.\n *   *  When `function` checks if function passed the element is true.\n *   *  When `array`, checks any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convertElement =\n  /**\n   * @type {(\n   *   (<T extends Element>(test: T['tagName'] | TestFunctionPredicate<T>) => AssertPredicate<T>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test | null | undefined} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return element\n      }\n\n      if (typeof test === 'string') {\n        return tagNameFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return anyFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or array as test')\n    }\n  )\n\n/**\n * Handle multiple tests.\n *\n * @param {Array<string | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convertElement(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn a string into a test for an element with a certain tag name.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction tagNameFactory(check) {\n  return tagName\n\n  /**\n   * @param {unknown} node\n   * @returns {boolean}\n   */\n  function tagName(node) {\n    return element(node) && node.tagName === check\n  }\n}\n\n/**\n * Turn a custom test into a test for an element that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    // @ts-expect-error: fine.\n    return element(node) && Boolean(check.call(this, node, ...parameters))\n  }\n}\n\n/**\n * Make sure something is an element.\n *\n * @param {unknown} node\n * @returns {node is Element}\n */\nfunction element(node) {\n  return Boolean(\n    node &&\n      typeof node === 'object' &&\n      // @ts-expect-error Looks like a node.\n      node.type === 'element' &&\n      // @ts-expect-error Looks like an element.\n      typeof node.tagName === 'string'\n  )\n}\n"],"mappings":";;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAMA,SAAS;AACpB;AACF;AACA;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACI;AACA,SAlBSA,SAASA,CAkBRC,IAAI,EAAEC,IAAI,EAAEC,KAAK,EAAEC,MAAM,EAAEC,OAAO,EAAE;EAC5C,IAAMC,KAAK,GAAGC,cAAc,CAACL,IAAI,CAAC;EAElC,IACEC,KAAK,KAAKK,SAAS,IACnBL,KAAK,KAAK,IAAI,KACb,OAAOA,KAAK,KAAK,QAAQ,IACxBA,KAAK,GAAG,CAAC,IACTA,KAAK,KAAKM,MAAM,CAACC,iBAAiB,CAAC,EACrC;IACA,MAAM,IAAIC,KAAK,CAAC,+CAA+C,CAAC;EAClE;EAEA,IACEP,MAAM,KAAKI,SAAS,IACpBJ,MAAM,KAAK,IAAI,KACd,CAACA,MAAM,CAACQ,IAAI,IAAI,CAACR,MAAM,CAACS,QAAQ,CAAC,EAClC;IACA,MAAM,IAAIF,KAAK,CAAC,sBAAsB,CAAC;EACzC;;EAEA;EACA,IAAI,CAACV,IAAI,IAAI,CAACA,IAAI,CAACW,IAAI,IAAI,OAAOX,IAAI,CAACW,IAAI,KAAK,QAAQ,EAAE;IACxD,OAAO,KAAK;EACd;EAEA,IACE,CAACR,MAAM,KAAKI,SAAS,IAAIJ,MAAM,KAAK,IAAI,OACvCD,KAAK,KAAKK,SAAS,IAAIL,KAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}