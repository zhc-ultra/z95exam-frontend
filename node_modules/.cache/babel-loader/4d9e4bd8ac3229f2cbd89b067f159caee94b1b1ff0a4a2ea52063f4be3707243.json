{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _callSuper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _get2 from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.typed-array.uint8-clamped-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './minimap.css';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { GlobalPointerMoveMonitor } from '../../../../base/browser/globalPointerMoveMonitor.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { RenderedLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { MINIMAP_GUTTER_WIDTH, EditorLayoutInfoComputer } from '../../../common/config/editorOptions.js';\nimport { Range } from '../../../common/core/range.js';\nimport { RGBA8 } from '../../../common/core/rgba.js';\nimport { MinimapTokensColorTracker } from '../../../common/viewModel/minimapTokensColorTracker.js';\nimport { ViewModelDecoration } from '../../../common/viewModel.js';\nimport { minimapSelection, minimapBackground, minimapForegroundOpacity, editorForeground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { EventType, Gesture } from '../../../../base/browser/touch.js';\nimport { MinimapCharRendererFactory } from './minimapCharRendererFactory.js';\nimport { createSingleCallFunction } from '../../../../base/common/functional.js';\nimport { LRUCache } from '../../../../base/common/map.js';\nimport { DEFAULT_FONT_FAMILY } from '../../../../base/browser/fonts.js';\n/**\n * The orthogonal distance to the slider at which dragging \"resets\". This implements \"snapping\"\n */\nvar POINTER_DRAG_RESET_DISTANCE = 140;\nvar GUTTER_DECORATION_WIDTH = 2;\nvar MinimapOptions = /*#__PURE__*/function () {\n  function MinimapOptions(configuration, theme, tokensColorTracker) {\n    var _this = this;\n    _classCallCheck(this, MinimapOptions);\n    var options = configuration.options;\n    var pixelRatio = options.get(143 /* EditorOption.pixelRatio */);\n    var layoutInfo = options.get(145 /* EditorOption.layoutInfo */);\n    var minimapLayout = layoutInfo.minimap;\n    var fontInfo = options.get(50 /* EditorOption.fontInfo */);\n    var minimapOpts = options.get(73 /* EditorOption.minimap */);\n    this.renderMinimap = minimapLayout.renderMinimap;\n    this.size = minimapOpts.size;\n    this.minimapHeightIsEditorHeight = minimapLayout.minimapHeightIsEditorHeight;\n    this.scrollBeyondLastLine = options.get(105 /* EditorOption.scrollBeyondLastLine */);\n    this.paddingTop = options.get(84 /* EditorOption.padding */).top;\n    this.paddingBottom = options.get(84 /* EditorOption.padding */).bottom;\n    this.showSlider = minimapOpts.showSlider;\n    this.autohide = minimapOpts.autohide;\n    this.pixelRatio = pixelRatio;\n    this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n    this.lineHeight = options.get(67 /* EditorOption.lineHeight */);\n    this.minimapLeft = minimapLayout.minimapLeft;\n    this.minimapWidth = minimapLayout.minimapWidth;\n    this.minimapHeight = layoutInfo.height;\n    this.canvasInnerWidth = minimapLayout.minimapCanvasInnerWidth;\n    this.canvasInnerHeight = minimapLayout.minimapCanvasInnerHeight;\n    this.canvasOuterWidth = minimapLayout.minimapCanvasOuterWidth;\n    this.canvasOuterHeight = minimapLayout.minimapCanvasOuterHeight;\n    this.isSampling = minimapLayout.minimapIsSampling;\n    this.editorHeight = layoutInfo.height;\n    this.fontScale = minimapLayout.minimapScale;\n    this.minimapLineHeight = minimapLayout.minimapLineHeight;\n    this.minimapCharWidth = 1 /* Constants.BASE_CHAR_WIDTH */ * this.fontScale;\n    this.sectionHeaderFontFamily = DEFAULT_FONT_FAMILY;\n    this.sectionHeaderFontSize = minimapOpts.sectionHeaderFontSize * pixelRatio;\n    this.sectionHeaderFontColor = MinimapOptions._getSectionHeaderColor(theme, tokensColorTracker.getColor(1 /* ColorId.DefaultForeground */));\n    this.charRenderer = createSingleCallFunction(function () {\n      return MinimapCharRendererFactory.create(_this.fontScale, fontInfo.fontFamily);\n    });\n    this.defaultBackgroundColor = tokensColorTracker.getColor(2 /* ColorId.DefaultBackground */);\n    this.backgroundColor = MinimapOptions._getMinimapBackground(theme, this.defaultBackgroundColor);\n    this.foregroundAlpha = MinimapOptions._getMinimapForegroundOpacity(theme);\n  }\n  return _createClass(MinimapOptions, [{\n    key: \"equals\",\n    value: function equals(other) {\n      return this.renderMinimap === other.renderMinimap && this.size === other.size && this.minimapHeightIsEditorHeight === other.minimapHeightIsEditorHeight && this.scrollBeyondLastLine === other.scrollBeyondLastLine && this.paddingTop === other.paddingTop && this.paddingBottom === other.paddingBottom && this.showSlider === other.showSlider && this.autohide === other.autohide && this.pixelRatio === other.pixelRatio && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth && this.lineHeight === other.lineHeight && this.minimapLeft === other.minimapLeft && this.minimapWidth === other.minimapWidth && this.minimapHeight === other.minimapHeight && this.canvasInnerWidth === other.canvasInnerWidth && this.canvasInnerHeight === other.canvasInnerHeight && this.canvasOuterWidth === other.canvasOuterWidth && this.canvasOuterHeight === other.canvasOuterHeight && this.isSampling === other.isSampling && this.editorHeight === other.editorHeight && this.fontScale === other.fontScale && this.minimapLineHeight === other.minimapLineHeight && this.minimapCharWidth === other.minimapCharWidth && this.sectionHeaderFontSize === other.sectionHeaderFontSize && this.defaultBackgroundColor && this.defaultBackgroundColor.equals(other.defaultBackgroundColor) && this.backgroundColor && this.backgroundColor.equals(other.backgroundColor) && this.foregroundAlpha === other.foregroundAlpha;\n    }\n  }], [{\n    key: \"_getMinimapBackground\",\n    value: function _getMinimapBackground(theme, defaultBackgroundColor) {\n      var themeColor = theme.getColor(minimapBackground);\n      if (themeColor) {\n        return new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, Math.round(255 * themeColor.rgba.a));\n      }\n      return defaultBackgroundColor;\n    }\n  }, {\n    key: \"_getMinimapForegroundOpacity\",\n    value: function _getMinimapForegroundOpacity(theme) {\n      var themeColor = theme.getColor(minimapForegroundOpacity);\n      if (themeColor) {\n        return RGBA8._clamp(Math.round(255 * themeColor.rgba.a));\n      }\n      return 255;\n    }\n  }, {\n    key: \"_getSectionHeaderColor\",\n    value: function _getSectionHeaderColor(theme, defaultForegroundColor) {\n      var themeColor = theme.getColor(editorForeground);\n      if (themeColor) {\n        return new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, Math.round(255 * themeColor.rgba.a));\n      }\n      return defaultForegroundColor;\n    }\n  }]);\n}();\nvar MinimapLayout = /*#__PURE__*/function () {\n  function MinimapLayout(\n  /**\n   * The given editor scrollTop (input).\n   */\n  scrollTop,\n  /**\n   * The given editor scrollHeight (input).\n   */\n  scrollHeight, sliderNeeded, _computedSliderRatio,\n  /**\n   * slider dom node top (in CSS px)\n   */\n  sliderTop,\n  /**\n   * slider dom node height (in CSS px)\n   */\n  sliderHeight,\n  /**\n   * empty lines to reserve at the top of the minimap.\n   */\n  topPaddingLineCount,\n  /**\n   * minimap render start line number.\n   */\n  startLineNumber,\n  /**\n   * minimap render end line number.\n   */\n  endLineNumber) {\n    _classCallCheck(this, MinimapLayout);\n    this.scrollTop = scrollTop;\n    this.scrollHeight = scrollHeight;\n    this.sliderNeeded = sliderNeeded;\n    this._computedSliderRatio = _computedSliderRatio;\n    this.sliderTop = sliderTop;\n    this.sliderHeight = sliderHeight;\n    this.topPaddingLineCount = topPaddingLineCount;\n    this.startLineNumber = startLineNumber;\n    this.endLineNumber = endLineNumber;\n  }\n  /**\n   * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n   */\n  return _createClass(MinimapLayout, [{\n    key: \"getDesiredScrollTopFromDelta\",\n    value: function getDesiredScrollTopFromDelta(delta) {\n      return Math.round(this.scrollTop + delta / this._computedSliderRatio);\n    }\n  }, {\n    key: \"getDesiredScrollTopFromTouchLocation\",\n    value: function getDesiredScrollTopFromTouchLocation(pageY) {\n      return Math.round((pageY - this.sliderHeight / 2) / this._computedSliderRatio);\n    }\n    /**\n     * Intersect a line range with `this.startLineNumber` and `this.endLineNumber`.\n     */\n  }, {\n    key: \"intersectWithViewport\",\n    value: function intersectWithViewport(range) {\n      var startLineNumber = Math.max(this.startLineNumber, range.startLineNumber);\n      var endLineNumber = Math.min(this.endLineNumber, range.endLineNumber);\n      if (startLineNumber > endLineNumber) {\n        // entirely outside minimap's viewport\n        return null;\n      }\n      return [startLineNumber, endLineNumber];\n    }\n    /**\n     * Get the inner minimap y coordinate for a line number.\n     */\n  }, {\n    key: \"getYForLineNumber\",\n    value: function getYForLineNumber(lineNumber, minimapLineHeight) {\n      return +(lineNumber - this.startLineNumber + this.topPaddingLineCount) * minimapLineHeight;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(options, viewportStartLineNumber, viewportEndLineNumber, viewportStartLineNumberVerticalOffset, viewportHeight, viewportContainsWhitespaceGaps, lineCount, realLineCount, scrollTop, scrollHeight, previousLayout) {\n      var pixelRatio = options.pixelRatio;\n      var minimapLineHeight = options.minimapLineHeight;\n      var minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight);\n      var lineHeight = options.lineHeight;\n      if (options.minimapHeightIsEditorHeight) {\n        var logicalScrollHeight = realLineCount * options.lineHeight + options.paddingTop + options.paddingBottom;\n        if (options.scrollBeyondLastLine) {\n          logicalScrollHeight += Math.max(0, viewportHeight - options.lineHeight - options.paddingBottom);\n        }\n        var _sliderHeight = Math.max(1, Math.floor(viewportHeight * viewportHeight / logicalScrollHeight));\n        var _maxMinimapSliderTop = Math.max(0, options.minimapHeight - _sliderHeight);\n        // The slider can move from 0 to `maxMinimapSliderTop`\n        // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n        var _computedSliderRatio2 = _maxMinimapSliderTop / (scrollHeight - viewportHeight);\n        var _sliderTop = scrollTop * _computedSliderRatio2;\n        var sliderNeeded = _maxMinimapSliderTop > 0;\n        var maxLinesFitting = Math.floor(options.canvasInnerHeight / options.minimapLineHeight);\n        var topPaddingLineCount = Math.floor(options.paddingTop / options.lineHeight);\n        return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, _computedSliderRatio2, _sliderTop, _sliderHeight, topPaddingLineCount, 1, Math.min(lineCount, maxLinesFitting));\n      }\n      // The visible line count in a viewport can change due to a number of reasons:\n      //  a) with the same viewport width, different scroll positions can result in partial lines being visible:\n      //    e.g. for a line height of 20, and a viewport height of 600\n      //          * scrollTop = 0  => visible lines are [1, 30]\n      //          * scrollTop = 10 => visible lines are [1, 31] (with lines 1 and 31 partially visible)\n      //          * scrollTop = 20 => visible lines are [2, 31]\n      //  b) whitespace gaps might make their way in the viewport (which results in a decrease in the visible line count)\n      //  c) we could be in the scroll beyond last line case (which also results in a decrease in the visible line count, down to possibly only one line being visible)\n      // We must first establish a desirable slider height.\n      var sliderHeight;\n      if (viewportContainsWhitespaceGaps && viewportEndLineNumber !== lineCount) {\n        // case b) from above: there are whitespace gaps in the viewport.\n        // In this case, the height of the slider directly reflects the visible line count.\n        var viewportLineCount = viewportEndLineNumber - viewportStartLineNumber + 1;\n        sliderHeight = Math.floor(viewportLineCount * minimapLineHeight / pixelRatio);\n      } else {\n        // The slider has a stable height\n        var expectedViewportLineCount = viewportHeight / lineHeight;\n        sliderHeight = Math.floor(expectedViewportLineCount * minimapLineHeight / pixelRatio);\n      }\n      var extraLinesAtTheTop = Math.floor(options.paddingTop / lineHeight);\n      var extraLinesAtTheBottom = Math.floor(options.paddingBottom / lineHeight);\n      if (options.scrollBeyondLastLine) {\n        var _expectedViewportLineCount = viewportHeight / lineHeight;\n        extraLinesAtTheBottom = Math.max(extraLinesAtTheBottom, _expectedViewportLineCount - 1);\n      }\n      var maxMinimapSliderTop;\n      if (extraLinesAtTheBottom > 0) {\n        var _expectedViewportLineCount2 = viewportHeight / lineHeight;\n        // The minimap slider, when dragged all the way down, will contain the last line at its top\n        maxMinimapSliderTop = (extraLinesAtTheTop + lineCount + extraLinesAtTheBottom - _expectedViewportLineCount2 - 1) * minimapLineHeight / pixelRatio;\n      } else {\n        // The minimap slider, when dragged all the way down, will contain the last line at its bottom\n        maxMinimapSliderTop = Math.max(0, (extraLinesAtTheTop + lineCount) * minimapLineHeight / pixelRatio - sliderHeight);\n      }\n      maxMinimapSliderTop = Math.min(options.minimapHeight - sliderHeight, maxMinimapSliderTop);\n      // The slider can move from 0 to `maxMinimapSliderTop`\n      // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n      var computedSliderRatio = maxMinimapSliderTop / (scrollHeight - viewportHeight);\n      var sliderTop = scrollTop * computedSliderRatio;\n      if (minimapLinesFitting >= extraLinesAtTheTop + lineCount + extraLinesAtTheBottom) {\n        // All lines fit in the minimap\n        var _sliderNeeded = maxMinimapSliderTop > 0;\n        return new MinimapLayout(scrollTop, scrollHeight, _sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, extraLinesAtTheTop, 1, lineCount);\n      } else {\n        var consideringStartLineNumber;\n        if (viewportStartLineNumber > 1) {\n          consideringStartLineNumber = viewportStartLineNumber + extraLinesAtTheTop;\n        } else {\n          consideringStartLineNumber = Math.max(1, scrollTop / lineHeight);\n        }\n        var _topPaddingLineCount;\n        var startLineNumber = Math.max(1, Math.floor(consideringStartLineNumber - sliderTop * pixelRatio / minimapLineHeight));\n        if (startLineNumber < extraLinesAtTheTop) {\n          _topPaddingLineCount = extraLinesAtTheTop - startLineNumber + 1;\n          startLineNumber = 1;\n        } else {\n          _topPaddingLineCount = 0;\n          startLineNumber = Math.max(1, startLineNumber - extraLinesAtTheTop);\n        }\n        // Avoid flickering caused by a partial viewport start line\n        // by being consistent w.r.t. the previous layout decision\n        if (previousLayout && previousLayout.scrollHeight === scrollHeight) {\n          if (previousLayout.scrollTop > scrollTop) {\n            // Scrolling up => never increase `startLineNumber`\n            startLineNumber = Math.min(startLineNumber, previousLayout.startLineNumber);\n            _topPaddingLineCount = Math.max(_topPaddingLineCount, previousLayout.topPaddingLineCount);\n          }\n          if (previousLayout.scrollTop < scrollTop) {\n            // Scrolling down => never decrease `startLineNumber`\n            startLineNumber = Math.max(startLineNumber, previousLayout.startLineNumber);\n            _topPaddingLineCount = Math.min(_topPaddingLineCount, previousLayout.topPaddingLineCount);\n          }\n        }\n        var endLineNumber = Math.min(lineCount, startLineNumber - _topPaddingLineCount + minimapLinesFitting - 1);\n        var partialLine = (scrollTop - viewportStartLineNumberVerticalOffset) / lineHeight;\n        var sliderTopAligned;\n        if (scrollTop >= options.paddingTop) {\n          sliderTopAligned = (viewportStartLineNumber - startLineNumber + _topPaddingLineCount + partialLine) * minimapLineHeight / pixelRatio;\n        } else {\n          sliderTopAligned = scrollTop / options.paddingTop * (_topPaddingLineCount + partialLine) * minimapLineHeight / pixelRatio;\n        }\n        return new MinimapLayout(scrollTop, scrollHeight, true, computedSliderRatio, sliderTopAligned, sliderHeight, _topPaddingLineCount, startLineNumber, endLineNumber);\n      }\n    }\n  }]);\n}();\nvar MinimapLine = /*#__PURE__*/function () {\n  function MinimapLine(dy) {\n    _classCallCheck(this, MinimapLine);\n    this.dy = dy;\n  }\n  return _createClass(MinimapLine, [{\n    key: \"onContentChanged\",\n    value: function onContentChanged() {\n      this.dy = -1;\n    }\n  }, {\n    key: \"onTokensChanged\",\n    value: function onTokensChanged() {\n      this.dy = -1;\n    }\n  }]);\n}();\nMinimapLine.INVALID = new MinimapLine(-1);\nvar RenderData = /*#__PURE__*/function () {\n  function RenderData(renderedLayout, imageData, lines) {\n    _classCallCheck(this, RenderData);\n    this.renderedLayout = renderedLayout;\n    this._imageData = imageData;\n    this._renderedLines = new RenderedLinesCollection(function () {\n      return MinimapLine.INVALID;\n    });\n    this._renderedLines._set(renderedLayout.startLineNumber, lines);\n  }\n  /**\n   * Check if the current RenderData matches accurately the new desired layout and no painting is needed.\n   */\n  return _createClass(RenderData, [{\n    key: \"linesEquals\",\n    value: function linesEquals(layout) {\n      if (!this.scrollEquals(layout)) {\n        return false;\n      }\n      var tmp = this._renderedLines._get();\n      var lines = tmp.lines;\n      for (var i = 0, len = lines.length; i < len; i++) {\n        if (lines[i].dy === -1) {\n          // This line is invalid\n          return false;\n        }\n      }\n      return true;\n    }\n    /**\n     * Check if the current RenderData matches the new layout's scroll position\n     */\n  }, {\n    key: \"scrollEquals\",\n    value: function scrollEquals(layout) {\n      return this.renderedLayout.startLineNumber === layout.startLineNumber && this.renderedLayout.endLineNumber === layout.endLineNumber;\n    }\n  }, {\n    key: \"_get\",\n    value: function _get() {\n      var tmp = this._renderedLines._get();\n      return {\n        imageData: this._imageData,\n        rendLineNumberStart: tmp.rendLineNumberStart,\n        lines: tmp.lines\n      };\n    }\n  }, {\n    key: \"onLinesChanged\",\n    value: function onLinesChanged(changeFromLineNumber, changeCount) {\n      return this._renderedLines.onLinesChanged(changeFromLineNumber, changeCount);\n    }\n  }, {\n    key: \"onLinesDeleted\",\n    value: function onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n      this._renderedLines.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n    }\n  }, {\n    key: \"onLinesInserted\",\n    value: function onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n      this._renderedLines.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n    }\n  }, {\n    key: \"onTokensChanged\",\n    value: function onTokensChanged(ranges) {\n      return this._renderedLines.onTokensChanged(ranges);\n    }\n  }]);\n}();\n/**\n * Some sort of double buffering.\n *\n * Keeps two buffers around that will be rotated for painting.\n * Always gives a buffer that is filled with the background color.\n */\nvar MinimapBuffers = /*#__PURE__*/function () {\n  function MinimapBuffers(ctx, WIDTH, HEIGHT, background) {\n    _classCallCheck(this, MinimapBuffers);\n    this._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);\n    this._buffers = [ctx.createImageData(WIDTH, HEIGHT), ctx.createImageData(WIDTH, HEIGHT)];\n    this._lastUsedBuffer = 0;\n  }\n  return _createClass(MinimapBuffers, [{\n    key: \"getBuffer\",\n    value: function getBuffer() {\n      // rotate buffers\n      this._lastUsedBuffer = 1 - this._lastUsedBuffer;\n      var result = this._buffers[this._lastUsedBuffer];\n      // fill with background color\n      result.data.set(this._backgroundFillData);\n      return result;\n    }\n  }], [{\n    key: \"_createBackgroundFillData\",\n    value: function _createBackgroundFillData(WIDTH, HEIGHT, background) {\n      var backgroundR = background.r;\n      var backgroundG = background.g;\n      var backgroundB = background.b;\n      var backgroundA = background.a;\n      var result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);\n      var offset = 0;\n      for (var i = 0; i < HEIGHT; i++) {\n        for (var j = 0; j < WIDTH; j++) {\n          result[offset] = backgroundR;\n          result[offset + 1] = backgroundG;\n          result[offset + 2] = backgroundB;\n          result[offset + 3] = backgroundA;\n          offset += 4;\n        }\n      }\n      return result;\n    }\n  }]);\n}();\nvar MinimapSamplingState = /*#__PURE__*/function () {\n  function MinimapSamplingState(samplingRatio, minimapLines // a map of 0-based minimap line indexes to 1-based view line numbers\n  ) {\n    _classCallCheck(this, MinimapSamplingState);\n    this.samplingRatio = samplingRatio;\n    this.minimapLines = minimapLines;\n  }\n  return _createClass(MinimapSamplingState, [{\n    key: \"modelLineToMinimapLine\",\n    value: function modelLineToMinimapLine(lineNumber) {\n      return Math.min(this.minimapLines.length, Math.max(1, Math.round(lineNumber / this.samplingRatio)));\n    }\n    /**\n     * Will return null if the model line ranges are not intersecting with a sampled model line.\n     */\n  }, {\n    key: \"modelLineRangeToMinimapLineRange\",\n    value: function modelLineRangeToMinimapLineRange(fromLineNumber, toLineNumber) {\n      var fromLineIndex = this.modelLineToMinimapLine(fromLineNumber) - 1;\n      while (fromLineIndex > 0 && this.minimapLines[fromLineIndex - 1] >= fromLineNumber) {\n        fromLineIndex--;\n      }\n      var toLineIndex = this.modelLineToMinimapLine(toLineNumber) - 1;\n      while (toLineIndex + 1 < this.minimapLines.length && this.minimapLines[toLineIndex + 1] <= toLineNumber) {\n        toLineIndex++;\n      }\n      if (fromLineIndex === toLineIndex) {\n        var sampledLineNumber = this.minimapLines[fromLineIndex];\n        if (sampledLineNumber < fromLineNumber || sampledLineNumber > toLineNumber) {\n          // This line is not part of the sampled lines ==> nothing to do\n          return null;\n        }\n      }\n      return [fromLineIndex + 1, toLineIndex + 1];\n    }\n    /**\n     * Will always return a range, even if it is not intersecting with a sampled model line.\n     */\n  }, {\n    key: \"decorationLineRangeToMinimapLineRange\",\n    value: function decorationLineRangeToMinimapLineRange(startLineNumber, endLineNumber) {\n      var minimapLineStart = this.modelLineToMinimapLine(startLineNumber);\n      var minimapLineEnd = this.modelLineToMinimapLine(endLineNumber);\n      if (startLineNumber !== endLineNumber && minimapLineEnd === minimapLineStart) {\n        if (minimapLineEnd === this.minimapLines.length) {\n          if (minimapLineStart > 1) {\n            minimapLineStart--;\n          }\n        } else {\n          minimapLineEnd++;\n        }\n      }\n      return [minimapLineStart, minimapLineEnd];\n    }\n  }, {\n    key: \"onLinesDeleted\",\n    value: function onLinesDeleted(e) {\n      // have the mapping be sticky\n      var deletedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n      var changeStartIndex = this.minimapLines.length;\n      var changeEndIndex = 0;\n      for (var i = this.minimapLines.length - 1; i >= 0; i--) {\n        if (this.minimapLines[i] < e.fromLineNumber) {\n          break;\n        }\n        if (this.minimapLines[i] <= e.toLineNumber) {\n          // this line got deleted => move to previous available\n          this.minimapLines[i] = Math.max(1, e.fromLineNumber - 1);\n          changeStartIndex = Math.min(changeStartIndex, i);\n          changeEndIndex = Math.max(changeEndIndex, i);\n        } else {\n          this.minimapLines[i] -= deletedLineCount;\n        }\n      }\n      return [changeStartIndex, changeEndIndex];\n    }\n  }, {\n    key: \"onLinesInserted\",\n    value: function onLinesInserted(e) {\n      // have the mapping be sticky\n      var insertedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n      for (var i = this.minimapLines.length - 1; i >= 0; i--) {\n        if (this.minimapLines[i] < e.fromLineNumber) {\n          break;\n        }\n        this.minimapLines[i] += insertedLineCount;\n      }\n    }\n  }], [{\n    key: \"compute\",\n    value: function compute(options, viewLineCount, oldSamplingState) {\n      if (options.renderMinimap === 0 /* RenderMinimap.None */ || !options.isSampling) {\n        return [null, []];\n      }\n      // ratio is intentionally not part of the layout to avoid the layout changing all the time\n      // so we need to recompute it again...\n      var _EditorLayoutInfoComp = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\n          viewLineCount: viewLineCount,\n          scrollBeyondLastLine: options.scrollBeyondLastLine,\n          paddingTop: options.paddingTop,\n          paddingBottom: options.paddingBottom,\n          height: options.editorHeight,\n          lineHeight: options.lineHeight,\n          pixelRatio: options.pixelRatio\n        }),\n        minimapLineCount = _EditorLayoutInfoComp.minimapLineCount;\n      var ratio = viewLineCount / minimapLineCount;\n      var halfRatio = ratio / 2;\n      if (!oldSamplingState || oldSamplingState.minimapLines.length === 0) {\n        var _result = [];\n        _result[0] = 1;\n        if (minimapLineCount > 1) {\n          for (var i = 0, lastIndex = minimapLineCount - 1; i < lastIndex; i++) {\n            _result[i] = Math.round(i * ratio + halfRatio);\n          }\n          _result[minimapLineCount - 1] = viewLineCount;\n        }\n        return [new MinimapSamplingState(ratio, _result), []];\n      }\n      var oldMinimapLines = oldSamplingState.minimapLines;\n      var oldLength = oldMinimapLines.length;\n      var result = [];\n      var oldIndex = 0;\n      var oldDeltaLineCount = 0;\n      var minViewLineNumber = 1;\n      var MAX_EVENT_COUNT = 10; // generate at most 10 events, if there are more than 10 changes, just flush all previous data\n      var events = [];\n      var lastEvent = null;\n      for (var _i = 0; _i < minimapLineCount; _i++) {\n        var fromViewLineNumber = Math.max(minViewLineNumber, Math.round(_i * ratio));\n        var toViewLineNumber = Math.max(fromViewLineNumber, Math.round((_i + 1) * ratio));\n        while (oldIndex < oldLength && oldMinimapLines[oldIndex] < fromViewLineNumber) {\n          if (events.length < MAX_EVENT_COUNT) {\n            var oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n            if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n              lastEvent.deleteToLineNumber++;\n            } else {\n              lastEvent = {\n                type: 'deleted',\n                _oldIndex: oldIndex,\n                deleteFromLineNumber: oldMinimapLineNumber,\n                deleteToLineNumber: oldMinimapLineNumber\n              };\n              events.push(lastEvent);\n            }\n            oldDeltaLineCount--;\n          }\n          oldIndex++;\n        }\n        var selectedViewLineNumber = void 0;\n        if (oldIndex < oldLength && oldMinimapLines[oldIndex] <= toViewLineNumber) {\n          // reuse the old sampled line\n          selectedViewLineNumber = oldMinimapLines[oldIndex];\n          oldIndex++;\n        } else {\n          if (_i === 0) {\n            selectedViewLineNumber = 1;\n          } else if (_i + 1 === minimapLineCount) {\n            selectedViewLineNumber = viewLineCount;\n          } else {\n            selectedViewLineNumber = Math.round(_i * ratio + halfRatio);\n          }\n          if (events.length < MAX_EVENT_COUNT) {\n            var _oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n            if (lastEvent && lastEvent.type === 'inserted' && lastEvent._i === _i - 1) {\n              lastEvent.insertToLineNumber++;\n            } else {\n              lastEvent = {\n                type: 'inserted',\n                _i: _i,\n                insertFromLineNumber: _oldMinimapLineNumber,\n                insertToLineNumber: _oldMinimapLineNumber\n              };\n              events.push(lastEvent);\n            }\n            oldDeltaLineCount++;\n          }\n        }\n        result[_i] = selectedViewLineNumber;\n        minViewLineNumber = selectedViewLineNumber;\n      }\n      if (events.length < MAX_EVENT_COUNT) {\n        while (oldIndex < oldLength) {\n          var _oldMinimapLineNumber2 = oldIndex + 1 + oldDeltaLineCount;\n          if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n            lastEvent.deleteToLineNumber++;\n          } else {\n            lastEvent = {\n              type: 'deleted',\n              _oldIndex: oldIndex,\n              deleteFromLineNumber: _oldMinimapLineNumber2,\n              deleteToLineNumber: _oldMinimapLineNumber2\n            };\n            events.push(lastEvent);\n          }\n          oldDeltaLineCount--;\n          oldIndex++;\n        }\n      } else {\n        // too many events, just give up\n        events = [{\n          type: 'flush'\n        }];\n      }\n      return [new MinimapSamplingState(ratio, result), events];\n    }\n  }]);\n}();\nexport var Minimap = /*#__PURE__*/function (_ViewPart) {\n  function Minimap(context) {\n    var _this2;\n    _classCallCheck(this, Minimap);\n    _this2 = _callSuper(this, Minimap, [context]);\n    _this2._sectionHeaderCache = new LRUCache(10, 1.5);\n    _this2.tokensColorTracker = MinimapTokensColorTracker.getInstance();\n    _this2._selections = [];\n    _this2._minimapSelections = null;\n    _this2.options = new MinimapOptions(_this2._context.configuration, _this2._context.theme, _this2.tokensColorTracker);\n    var _MinimapSamplingState = MinimapSamplingState.compute(_this2.options, _this2._context.viewModel.getLineCount(), null),\n      _MinimapSamplingState2 = _slicedToArray(_MinimapSamplingState, 1),\n      samplingState = _MinimapSamplingState2[0];\n    _this2._samplingState = samplingState;\n    _this2._shouldCheckSampling = false;\n    _this2._actual = new InnerMinimap(context.theme, _this2);\n    return _this2;\n  }\n  _inherits(Minimap, _ViewPart);\n  return _createClass(Minimap, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this._actual.dispose();\n      _get2(_getPrototypeOf(Minimap.prototype), \"dispose\", this).call(this);\n    }\n  }, {\n    key: \"getDomNode\",\n    value: function getDomNode() {\n      return this._actual.getDomNode();\n    }\n  }, {\n    key: \"_onOptionsMaybeChanged\",\n    value: function _onOptionsMaybeChanged() {\n      var opts = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n      if (this.options.equals(opts)) {\n        return false;\n      }\n      this.options = opts;\n      this._recreateLineSampling();\n      this._actual.onDidChangeOptions();\n      return true;\n    }\n    // ---- begin view event handlers\n  }, {\n    key: \"onConfigurationChanged\",\n    value: function onConfigurationChanged(e) {\n      return this._onOptionsMaybeChanged();\n    }\n  }, {\n    key: \"onCursorStateChanged\",\n    value: function onCursorStateChanged(e) {\n      this._selections = e.selections;\n      this._minimapSelections = null;\n      return this._actual.onSelectionChanged();\n    }\n  }, {\n    key: \"onDecorationsChanged\",\n    value: function onDecorationsChanged(e) {\n      if (e.affectsMinimap) {\n        return this._actual.onDecorationsChanged();\n      }\n      return false;\n    }\n  }, {\n    key: \"onFlushed\",\n    value: function onFlushed(e) {\n      if (this._samplingState) {\n        this._shouldCheckSampling = true;\n      }\n      return this._actual.onFlushed();\n    }\n  }, {\n    key: \"onLinesChanged\",\n    value: function onLinesChanged(e) {\n      if (this._samplingState) {\n        var minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.fromLineNumber + e.count - 1);\n        if (minimapLineRange) {\n          return this._actual.onLinesChanged(minimapLineRange[0], minimapLineRange[1] - minimapLineRange[0] + 1);\n        } else {\n          return false;\n        }\n      } else {\n        return this._actual.onLinesChanged(e.fromLineNumber, e.count);\n      }\n    }\n  }, {\n    key: \"onLinesDeleted\",\n    value: function onLinesDeleted(e) {\n      if (this._samplingState) {\n        var _this$_samplingState$ = this._samplingState.onLinesDeleted(e),\n          _this$_samplingState$2 = _slicedToArray(_this$_samplingState$, 2),\n          changeStartIndex = _this$_samplingState$2[0],\n          changeEndIndex = _this$_samplingState$2[1];\n        if (changeStartIndex <= changeEndIndex) {\n          this._actual.onLinesChanged(changeStartIndex + 1, changeEndIndex - changeStartIndex + 1);\n        }\n        this._shouldCheckSampling = true;\n        return true;\n      } else {\n        return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n      }\n    }\n  }, {\n    key: \"onLinesInserted\",\n    value: function onLinesInserted(e) {\n      if (this._samplingState) {\n        this._samplingState.onLinesInserted(e);\n        this._shouldCheckSampling = true;\n        return true;\n      } else {\n        return this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n      }\n    }\n  }, {\n    key: \"onScrollChanged\",\n    value: function onScrollChanged(e) {\n      return this._actual.onScrollChanged();\n    }\n  }, {\n    key: \"onThemeChanged\",\n    value: function onThemeChanged(e) {\n      this._actual.onThemeChanged();\n      this._onOptionsMaybeChanged();\n      return true;\n    }\n  }, {\n    key: \"onTokensChanged\",\n    value: function onTokensChanged(e) {\n      if (this._samplingState) {\n        var ranges = [];\n        var _iterator = _createForOfIteratorHelper(e.ranges),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var range = _step.value;\n            var minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(range.fromLineNumber, range.toLineNumber);\n            if (minimapLineRange) {\n              ranges.push({\n                fromLineNumber: minimapLineRange[0],\n                toLineNumber: minimapLineRange[1]\n              });\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        if (ranges.length) {\n          return this._actual.onTokensChanged(ranges);\n        } else {\n          return false;\n        }\n      } else {\n        return this._actual.onTokensChanged(e.ranges);\n      }\n    }\n  }, {\n    key: \"onTokensColorsChanged\",\n    value: function onTokensColorsChanged(e) {\n      this._onOptionsMaybeChanged();\n      return this._actual.onTokensColorsChanged();\n    }\n  }, {\n    key: \"onZonesChanged\",\n    value: function onZonesChanged(e) {\n      return this._actual.onZonesChanged();\n    }\n    // --- end event handlers\n  }, {\n    key: \"prepareRender\",\n    value: function prepareRender(ctx) {\n      if (this._shouldCheckSampling) {\n        this._shouldCheckSampling = false;\n        this._recreateLineSampling();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(ctx) {\n      var viewportStartLineNumber = ctx.visibleRange.startLineNumber;\n      var viewportEndLineNumber = ctx.visibleRange.endLineNumber;\n      if (this._samplingState) {\n        viewportStartLineNumber = this._samplingState.modelLineToMinimapLine(viewportStartLineNumber);\n        viewportEndLineNumber = this._samplingState.modelLineToMinimapLine(viewportEndLineNumber);\n      }\n      var minimapCtx = {\n        viewportContainsWhitespaceGaps: ctx.viewportData.whitespaceViewportData.length > 0,\n        scrollWidth: ctx.scrollWidth,\n        scrollHeight: ctx.scrollHeight,\n        viewportStartLineNumber: viewportStartLineNumber,\n        viewportEndLineNumber: viewportEndLineNumber,\n        viewportStartLineNumberVerticalOffset: ctx.getVerticalOffsetForLineNumber(viewportStartLineNumber),\n        scrollTop: ctx.scrollTop,\n        scrollLeft: ctx.scrollLeft,\n        viewportWidth: ctx.viewportWidth,\n        viewportHeight: ctx.viewportHeight\n      };\n      this._actual.render(minimapCtx);\n    }\n    //#region IMinimapModel\n  }, {\n    key: \"_recreateLineSampling\",\n    value: function _recreateLineSampling() {\n      this._minimapSelections = null;\n      var wasSampling = Boolean(this._samplingState);\n      var _MinimapSamplingState3 = MinimapSamplingState.compute(this.options, this._context.viewModel.getLineCount(), this._samplingState),\n        _MinimapSamplingState4 = _slicedToArray(_MinimapSamplingState3, 2),\n        samplingState = _MinimapSamplingState4[0],\n        events = _MinimapSamplingState4[1];\n      this._samplingState = samplingState;\n      if (wasSampling && this._samplingState) {\n        // was sampling, is sampling\n        var _iterator2 = _createForOfIteratorHelper(events),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var event = _step2.value;\n            switch (event.type) {\n              case 'deleted':\n                this._actual.onLinesDeleted(event.deleteFromLineNumber, event.deleteToLineNumber);\n                break;\n              case 'inserted':\n                this._actual.onLinesInserted(event.insertFromLineNumber, event.insertToLineNumber);\n                break;\n              case 'flush':\n                this._actual.onFlushed();\n                break;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n  }, {\n    key: \"getLineCount\",\n    value: function getLineCount() {\n      if (this._samplingState) {\n        return this._samplingState.minimapLines.length;\n      }\n      return this._context.viewModel.getLineCount();\n    }\n  }, {\n    key: \"getRealLineCount\",\n    value: function getRealLineCount() {\n      return this._context.viewModel.getLineCount();\n    }\n  }, {\n    key: \"getLineContent\",\n    value: function getLineContent(lineNumber) {\n      if (this._samplingState) {\n        return this._context.viewModel.getLineContent(this._samplingState.minimapLines[lineNumber - 1]);\n      }\n      return this._context.viewModel.getLineContent(lineNumber);\n    }\n  }, {\n    key: \"getLineMaxColumn\",\n    value: function getLineMaxColumn(lineNumber) {\n      if (this._samplingState) {\n        return this._context.viewModel.getLineMaxColumn(this._samplingState.minimapLines[lineNumber - 1]);\n      }\n      return this._context.viewModel.getLineMaxColumn(lineNumber);\n    }\n  }, {\n    key: \"getMinimapLinesRenderingData\",\n    value: function getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n      if (this._samplingState) {\n        var result = [];\n        for (var lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n          if (needed[lineIndex]) {\n            result[lineIndex] = this._context.viewModel.getViewLineData(this._samplingState.minimapLines[startLineNumber + lineIndex - 1]);\n          } else {\n            result[lineIndex] = null;\n          }\n        }\n        return result;\n      }\n      return this._context.viewModel.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed).data;\n    }\n  }, {\n    key: \"getSelections\",\n    value: function getSelections() {\n      if (this._minimapSelections === null) {\n        if (this._samplingState) {\n          this._minimapSelections = [];\n          var _iterator3 = _createForOfIteratorHelper(this._selections),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var selection = _step3.value;\n              var _this$_samplingState$3 = this._samplingState.decorationLineRangeToMinimapLineRange(selection.startLineNumber, selection.endLineNumber),\n                _this$_samplingState$4 = _slicedToArray(_this$_samplingState$3, 2),\n                minimapLineStart = _this$_samplingState$4[0],\n                minimapLineEnd = _this$_samplingState$4[1];\n              this._minimapSelections.push(new Selection(minimapLineStart, selection.startColumn, minimapLineEnd, selection.endColumn));\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        } else {\n          this._minimapSelections = this._selections;\n        }\n      }\n      return this._minimapSelections;\n    }\n  }, {\n    key: \"getMinimapDecorationsInViewport\",\n    value: function getMinimapDecorationsInViewport(startLineNumber, endLineNumber) {\n      var decorations = this._getMinimapDecorationsInViewport(startLineNumber, endLineNumber).filter(function (decoration) {\n        var _a;\n        return !((_a = decoration.options.minimap) === null || _a === void 0 ? void 0 : _a.sectionHeaderStyle);\n      });\n      if (this._samplingState) {\n        var result = [];\n        var _iterator4 = _createForOfIteratorHelper(decorations),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var decoration = _step4.value;\n            if (!decoration.options.minimap) {\n              continue;\n            }\n            var range = decoration.range;\n            var minimapStartLineNumber = this._samplingState.modelLineToMinimapLine(range.startLineNumber);\n            var minimapEndLineNumber = this._samplingState.modelLineToMinimapLine(range.endLineNumber);\n            result.push(new ViewModelDecoration(new Range(minimapStartLineNumber, range.startColumn, minimapEndLineNumber, range.endColumn), decoration.options));\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n        return result;\n      }\n      return decorations;\n    }\n  }, {\n    key: \"getSectionHeaderDecorationsInViewport\",\n    value: function getSectionHeaderDecorationsInViewport(startLineNumber, endLineNumber) {\n      var minimapLineHeight = this.options.minimapLineHeight;\n      var sectionHeaderFontSize = this.options.sectionHeaderFontSize;\n      var headerHeightInMinimapLines = sectionHeaderFontSize / minimapLineHeight;\n      startLineNumber = Math.floor(Math.max(1, startLineNumber - headerHeightInMinimapLines));\n      return this._getMinimapDecorationsInViewport(startLineNumber, endLineNumber).filter(function (decoration) {\n        var _a;\n        return !!((_a = decoration.options.minimap) === null || _a === void 0 ? void 0 : _a.sectionHeaderStyle);\n      });\n    }\n  }, {\n    key: \"_getMinimapDecorationsInViewport\",\n    value: function _getMinimapDecorationsInViewport(startLineNumber, endLineNumber) {\n      var visibleRange;\n      if (this._samplingState) {\n        var modelStartLineNumber = this._samplingState.minimapLines[startLineNumber - 1];\n        var modelEndLineNumber = this._samplingState.minimapLines[endLineNumber - 1];\n        visibleRange = new Range(modelStartLineNumber, 1, modelEndLineNumber, this._context.viewModel.getLineMaxColumn(modelEndLineNumber));\n      } else {\n        visibleRange = new Range(startLineNumber, 1, endLineNumber, this._context.viewModel.getLineMaxColumn(endLineNumber));\n      }\n      return this._context.viewModel.getMinimapDecorationsInRange(visibleRange);\n    }\n  }, {\n    key: \"getSectionHeaderText\",\n    value: function getSectionHeaderText(decoration, fitWidth) {\n      var _a;\n      var headerText = (_a = decoration.options.minimap) === null || _a === void 0 ? void 0 : _a.sectionHeaderText;\n      if (!headerText) {\n        return null;\n      }\n      var cachedText = this._sectionHeaderCache.get(headerText);\n      if (cachedText) {\n        return cachedText;\n      }\n      var fittedText = fitWidth(headerText);\n      this._sectionHeaderCache.set(headerText, fittedText);\n      return fittedText;\n    }\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      return this._context.viewModel.model.getOptions();\n    }\n  }, {\n    key: \"revealLineNumber\",\n    value: function revealLineNumber(lineNumber) {\n      if (this._samplingState) {\n        lineNumber = this._samplingState.minimapLines[lineNumber - 1];\n      }\n      this._context.viewModel.revealRange('mouse', false, new Range(lineNumber, 1, lineNumber, 1), 1 /* viewEvents.VerticalRevealType.Center */, 0 /* ScrollType.Smooth */);\n    }\n  }, {\n    key: \"setScrollTop\",\n    value: function setScrollTop(scrollTop) {\n      this._context.viewModel.viewLayout.setScrollPosition({\n        scrollTop: scrollTop\n      }, 1 /* ScrollType.Immediate */);\n    }\n  }]);\n}(ViewPart);\nvar InnerMinimap = /*#__PURE__*/function (_Disposable) {\n  function InnerMinimap(theme, model) {\n    var _this3;\n    _classCallCheck(this, InnerMinimap);\n    _this3 = _callSuper(this, InnerMinimap);\n    _this3._renderDecorations = false;\n    _this3._gestureInProgress = false;\n    _this3._theme = theme;\n    _this3._model = model;\n    _this3._lastRenderData = null;\n    _this3._buffers = null;\n    _this3._selectionColor = _this3._theme.getColor(minimapSelection);\n    _this3._domNode = createFastDomNode(document.createElement('div'));\n    PartFingerprints.write(_this3._domNode, 9 /* PartFingerprint.Minimap */);\n    _this3._domNode.setClassName(_this3._getMinimapDomNodeClassName());\n    _this3._domNode.setPosition('absolute');\n    _this3._domNode.setAttribute('role', 'presentation');\n    _this3._domNode.setAttribute('aria-hidden', 'true');\n    _this3._shadow = createFastDomNode(document.createElement('div'));\n    _this3._shadow.setClassName('minimap-shadow-hidden');\n    _this3._domNode.appendChild(_this3._shadow);\n    _this3._canvas = createFastDomNode(document.createElement('canvas'));\n    _this3._canvas.setPosition('absolute');\n    _this3._canvas.setLeft(0);\n    _this3._domNode.appendChild(_this3._canvas);\n    _this3._decorationsCanvas = createFastDomNode(document.createElement('canvas'));\n    _this3._decorationsCanvas.setPosition('absolute');\n    _this3._decorationsCanvas.setClassName('minimap-decorations-layer');\n    _this3._decorationsCanvas.setLeft(0);\n    _this3._domNode.appendChild(_this3._decorationsCanvas);\n    _this3._slider = createFastDomNode(document.createElement('div'));\n    _this3._slider.setPosition('absolute');\n    _this3._slider.setClassName('minimap-slider');\n    _this3._slider.setLayerHinting(true);\n    _this3._slider.setContain('strict');\n    _this3._domNode.appendChild(_this3._slider);\n    _this3._sliderHorizontal = createFastDomNode(document.createElement('div'));\n    _this3._sliderHorizontal.setPosition('absolute');\n    _this3._sliderHorizontal.setClassName('minimap-slider-horizontal');\n    _this3._slider.appendChild(_this3._sliderHorizontal);\n    _this3._applyLayout();\n    _this3._pointerDownListener = dom.addStandardDisposableListener(_this3._domNode.domNode, dom.EventType.POINTER_DOWN, function (e) {\n      e.preventDefault();\n      var renderMinimap = _this3._model.options.renderMinimap;\n      if (renderMinimap === 0 /* RenderMinimap.None */) {\n        return;\n      }\n      if (!_this3._lastRenderData) {\n        return;\n      }\n      if (_this3._model.options.size !== 'proportional') {\n        if (e.button === 0 && _this3._lastRenderData) {\n          // pretend the click occurred in the center of the slider\n          var position = dom.getDomNodePagePosition(_this3._slider.domNode);\n          var initialPosY = position.top + position.height / 2;\n          _this3._startSliderDragging(e, initialPosY, _this3._lastRenderData.renderedLayout);\n        }\n        return;\n      }\n      var minimapLineHeight = _this3._model.options.minimapLineHeight;\n      var internalOffsetY = _this3._model.options.canvasInnerHeight / _this3._model.options.canvasOuterHeight * e.offsetY;\n      var lineIndex = Math.floor(internalOffsetY / minimapLineHeight);\n      var lineNumber = lineIndex + _this3._lastRenderData.renderedLayout.startLineNumber - _this3._lastRenderData.renderedLayout.topPaddingLineCount;\n      lineNumber = Math.min(lineNumber, _this3._model.getLineCount());\n      _this3._model.revealLineNumber(lineNumber);\n    });\n    _this3._sliderPointerMoveMonitor = new GlobalPointerMoveMonitor();\n    _this3._sliderPointerDownListener = dom.addStandardDisposableListener(_this3._slider.domNode, dom.EventType.POINTER_DOWN, function (e) {\n      e.preventDefault();\n      e.stopPropagation();\n      if (e.button === 0 && _this3._lastRenderData) {\n        _this3._startSliderDragging(e, e.pageY, _this3._lastRenderData.renderedLayout);\n      }\n    });\n    _this3._gestureDisposable = Gesture.addTarget(_this3._domNode.domNode);\n    _this3._sliderTouchStartListener = dom.addDisposableListener(_this3._domNode.domNode, EventType.Start, function (e) {\n      e.preventDefault();\n      e.stopPropagation();\n      if (_this3._lastRenderData) {\n        _this3._slider.toggleClassName('active', true);\n        _this3._gestureInProgress = true;\n        _this3.scrollDueToTouchEvent(e);\n      }\n    }, {\n      passive: false\n    });\n    _this3._sliderTouchMoveListener = dom.addDisposableListener(_this3._domNode.domNode, EventType.Change, function (e) {\n      e.preventDefault();\n      e.stopPropagation();\n      if (_this3._lastRenderData && _this3._gestureInProgress) {\n        _this3.scrollDueToTouchEvent(e);\n      }\n    }, {\n      passive: false\n    });\n    _this3._sliderTouchEndListener = dom.addStandardDisposableListener(_this3._domNode.domNode, EventType.End, function (e) {\n      e.preventDefault();\n      e.stopPropagation();\n      _this3._gestureInProgress = false;\n      _this3._slider.toggleClassName('active', false);\n    });\n    return _this3;\n  }\n  _inherits(InnerMinimap, _Disposable);\n  return _createClass(InnerMinimap, [{\n    key: \"_startSliderDragging\",\n    value: function _startSliderDragging(e, initialPosY, initialSliderState) {\n      var _this4 = this;\n      if (!e.target || !(e.target instanceof Element)) {\n        return;\n      }\n      var initialPosX = e.pageX;\n      this._slider.toggleClassName('active', true);\n      var handlePointerMove = function handlePointerMove(posy, posx) {\n        var minimapPosition = dom.getDomNodePagePosition(_this4._domNode.domNode);\n        var pointerOrthogonalDelta = Math.min(Math.abs(posx - initialPosX), Math.abs(posx - minimapPosition.left), Math.abs(posx - minimapPosition.left - minimapPosition.width));\n        if (platform.isWindows && pointerOrthogonalDelta > POINTER_DRAG_RESET_DISTANCE) {\n          // The pointer has wondered away from the scrollbar => reset dragging\n          _this4._model.setScrollTop(initialSliderState.scrollTop);\n          return;\n        }\n        var pointerDelta = posy - initialPosY;\n        _this4._model.setScrollTop(initialSliderState.getDesiredScrollTopFromDelta(pointerDelta));\n      };\n      if (e.pageY !== initialPosY) {\n        handlePointerMove(e.pageY, initialPosX);\n      }\n      this._sliderPointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, function (pointerMoveData) {\n        return handlePointerMove(pointerMoveData.pageY, pointerMoveData.pageX);\n      }, function () {\n        _this4._slider.toggleClassName('active', false);\n      });\n    }\n  }, {\n    key: \"scrollDueToTouchEvent\",\n    value: function scrollDueToTouchEvent(touch) {\n      var startY = this._domNode.domNode.getBoundingClientRect().top;\n      var scrollTop = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(touch.pageY - startY);\n      this._model.setScrollTop(scrollTop);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this._pointerDownListener.dispose();\n      this._sliderPointerMoveMonitor.dispose();\n      this._sliderPointerDownListener.dispose();\n      this._gestureDisposable.dispose();\n      this._sliderTouchStartListener.dispose();\n      this._sliderTouchMoveListener.dispose();\n      this._sliderTouchEndListener.dispose();\n      _get2(_getPrototypeOf(InnerMinimap.prototype), \"dispose\", this).call(this);\n    }\n  }, {\n    key: \"_getMinimapDomNodeClassName\",\n    value: function _getMinimapDomNodeClassName() {\n      var class_ = ['minimap'];\n      if (this._model.options.showSlider === 'always') {\n        class_.push('slider-always');\n      } else {\n        class_.push('slider-mouseover');\n      }\n      if (this._model.options.autohide) {\n        class_.push('autohide');\n      }\n      return class_.join(' ');\n    }\n  }, {\n    key: \"getDomNode\",\n    value: function getDomNode() {\n      return this._domNode;\n    }\n  }, {\n    key: \"_applyLayout\",\n    value: function _applyLayout() {\n      this._domNode.setLeft(this._model.options.minimapLeft);\n      this._domNode.setWidth(this._model.options.minimapWidth);\n      this._domNode.setHeight(this._model.options.minimapHeight);\n      this._shadow.setHeight(this._model.options.minimapHeight);\n      this._canvas.setWidth(this._model.options.canvasOuterWidth);\n      this._canvas.setHeight(this._model.options.canvasOuterHeight);\n      this._canvas.domNode.width = this._model.options.canvasInnerWidth;\n      this._canvas.domNode.height = this._model.options.canvasInnerHeight;\n      this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth);\n      this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight);\n      this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth;\n      this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight;\n      this._slider.setWidth(this._model.options.minimapWidth);\n    }\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer() {\n      if (!this._buffers) {\n        if (this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0) {\n          this._buffers = new MinimapBuffers(this._canvas.domNode.getContext('2d'), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor);\n        }\n      }\n      return this._buffers ? this._buffers.getBuffer() : null;\n    }\n    // ---- begin view event handlers\n  }, {\n    key: \"onDidChangeOptions\",\n    value: function onDidChangeOptions() {\n      this._lastRenderData = null;\n      this._buffers = null;\n      this._applyLayout();\n      this._domNode.setClassName(this._getMinimapDomNodeClassName());\n    }\n  }, {\n    key: \"onSelectionChanged\",\n    value: function onSelectionChanged() {\n      this._renderDecorations = true;\n      return true;\n    }\n  }, {\n    key: \"onDecorationsChanged\",\n    value: function onDecorationsChanged() {\n      this._renderDecorations = true;\n      return true;\n    }\n  }, {\n    key: \"onFlushed\",\n    value: function onFlushed() {\n      this._lastRenderData = null;\n      return true;\n    }\n  }, {\n    key: \"onLinesChanged\",\n    value: function onLinesChanged(changeFromLineNumber, changeCount) {\n      if (this._lastRenderData) {\n        return this._lastRenderData.onLinesChanged(changeFromLineNumber, changeCount);\n      }\n      return false;\n    }\n  }, {\n    key: \"onLinesDeleted\",\n    value: function onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n      var _a;\n      (_a = this._lastRenderData) === null || _a === void 0 ? void 0 : _a.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n      return true;\n    }\n  }, {\n    key: \"onLinesInserted\",\n    value: function onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n      var _a;\n      (_a = this._lastRenderData) === null || _a === void 0 ? void 0 : _a.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n      return true;\n    }\n  }, {\n    key: \"onScrollChanged\",\n    value: function onScrollChanged() {\n      this._renderDecorations = true;\n      return true;\n    }\n  }, {\n    key: \"onThemeChanged\",\n    value: function onThemeChanged() {\n      this._selectionColor = this._theme.getColor(minimapSelection);\n      this._renderDecorations = true;\n      return true;\n    }\n  }, {\n    key: \"onTokensChanged\",\n    value: function onTokensChanged(ranges) {\n      if (this._lastRenderData) {\n        return this._lastRenderData.onTokensChanged(ranges);\n      }\n      return false;\n    }\n  }, {\n    key: \"onTokensColorsChanged\",\n    value: function onTokensColorsChanged() {\n      this._lastRenderData = null;\n      this._buffers = null;\n      return true;\n    }\n  }, {\n    key: \"onZonesChanged\",\n    value: function onZonesChanged() {\n      this._lastRenderData = null;\n      return true;\n    }\n    // --- end event handlers\n  }, {\n    key: \"render\",\n    value: function render(renderingCtx) {\n      var renderMinimap = this._model.options.renderMinimap;\n      if (renderMinimap === 0 /* RenderMinimap.None */) {\n        this._shadow.setClassName('minimap-shadow-hidden');\n        this._sliderHorizontal.setWidth(0);\n        this._sliderHorizontal.setHeight(0);\n        return;\n      }\n      if (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth) {\n        this._shadow.setClassName('minimap-shadow-hidden');\n      } else {\n        this._shadow.setClassName('minimap-shadow-visible');\n      }\n      var layout = MinimapLayout.create(this._model.options, renderingCtx.viewportStartLineNumber, renderingCtx.viewportEndLineNumber, renderingCtx.viewportStartLineNumberVerticalOffset, renderingCtx.viewportHeight, renderingCtx.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), renderingCtx.scrollTop, renderingCtx.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);\n      this._slider.setDisplay(layout.sliderNeeded ? 'block' : 'none');\n      this._slider.setTop(layout.sliderTop);\n      this._slider.setHeight(layout.sliderHeight);\n      // Compute horizontal slider coordinates\n      this._sliderHorizontal.setLeft(0);\n      this._sliderHorizontal.setWidth(this._model.options.minimapWidth);\n      this._sliderHorizontal.setTop(0);\n      this._sliderHorizontal.setHeight(layout.sliderHeight);\n      this.renderDecorations(layout);\n      this._lastRenderData = this.renderLines(layout);\n    }\n  }, {\n    key: \"renderDecorations\",\n    value: function renderDecorations(layout) {\n      if (this._renderDecorations) {\n        this._renderDecorations = false;\n        var selections = this._model.getSelections();\n        selections.sort(Range.compareRangesUsingStarts);\n        var decorations = this._model.getMinimapDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\n        decorations.sort(function (a, b) {\n          return (a.options.zIndex || 0) - (b.options.zIndex || 0);\n        });\n        var _this$_model$options = this._model.options,\n          canvasInnerWidth = _this$_model$options.canvasInnerWidth,\n          canvasInnerHeight = _this$_model$options.canvasInnerHeight;\n        var minimapLineHeight = this._model.options.minimapLineHeight;\n        var minimapCharWidth = this._model.options.minimapCharWidth;\n        var tabSize = this._model.getOptions().tabSize;\n        var canvasContext = this._decorationsCanvas.domNode.getContext('2d');\n        canvasContext.clearRect(0, 0, canvasInnerWidth, canvasInnerHeight);\n        // We first need to render line highlights and then render decorations on top of those.\n        // But we need to pick a single color for each line, and use that as a line highlight.\n        // This needs to be the color of the decoration with the highest `zIndex`, but priority\n        // is given to the selection.\n        var highlightedLines = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, false);\n        this._renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, minimapLineHeight);\n        this._renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, minimapLineHeight);\n        var lineOffsetMap = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, null);\n        this._renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, minimapLineHeight, tabSize, minimapCharWidth, canvasInnerWidth);\n        this._renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, minimapLineHeight, tabSize, minimapCharWidth, canvasInnerWidth);\n        this._renderSectionHeaders(layout);\n      }\n    }\n  }, {\n    key: \"_renderSelectionLineHighlights\",\n    value: function _renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, minimapLineHeight) {\n      if (!this._selectionColor || this._selectionColor.isTransparent()) {\n        return;\n      }\n      canvasContext.fillStyle = this._selectionColor.transparent(0.5).toString();\n      var y1 = 0;\n      var y2 = 0;\n      var _iterator5 = _createForOfIteratorHelper(selections),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var selection = _step5.value;\n          var intersection = layout.intersectWithViewport(selection);\n          if (!intersection) {\n            // entirely outside minimap's viewport\n            continue;\n          }\n          var _intersection = _slicedToArray(intersection, 2),\n            startLineNumber = _intersection[0],\n            endLineNumber = _intersection[1];\n          for (var line = startLineNumber; line <= endLineNumber; line++) {\n            highlightedLines.set(line, true);\n          }\n          var yy1 = layout.getYForLineNumber(startLineNumber, minimapLineHeight);\n          var yy2 = layout.getYForLineNumber(endLineNumber, minimapLineHeight);\n          if (y2 >= yy1) {\n            // merge into previous\n            y2 = yy2;\n          } else {\n            if (y2 > y1) {\n              // flush\n              canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n            }\n            y1 = yy1;\n            y2 = yy2;\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      if (y2 > y1) {\n        // flush\n        canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n      }\n    }\n  }, {\n    key: \"_renderDecorationsLineHighlights\",\n    value: function _renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, minimapLineHeight) {\n      var highlightColors = new Map();\n      // Loop backwards to hit first decorations with higher `zIndex`\n      for (var i = decorations.length - 1; i >= 0; i--) {\n        var decoration = decorations[i];\n        var minimapOptions = decoration.options.minimap;\n        if (!minimapOptions || minimapOptions.position !== 1 /* MinimapPosition.Inline */) {\n          continue;\n        }\n        var intersection = layout.intersectWithViewport(decoration.range);\n        if (!intersection) {\n          // entirely outside minimap's viewport\n          continue;\n        }\n        var _intersection2 = _slicedToArray(intersection, 2),\n          startLineNumber = _intersection2[0],\n          endLineNumber = _intersection2[1];\n        var decorationColor = minimapOptions.getColor(this._theme.value);\n        if (!decorationColor || decorationColor.isTransparent()) {\n          continue;\n        }\n        var highlightColor = highlightColors.get(decorationColor.toString());\n        if (!highlightColor) {\n          highlightColor = decorationColor.transparent(0.5).toString();\n          highlightColors.set(decorationColor.toString(), highlightColor);\n        }\n        canvasContext.fillStyle = highlightColor;\n        for (var line = startLineNumber; line <= endLineNumber; line++) {\n          if (highlightedLines.has(line)) {\n            continue;\n          }\n          highlightedLines.set(line, true);\n          var y = layout.getYForLineNumber(startLineNumber, minimapLineHeight);\n          canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y, canvasContext.canvas.width, minimapLineHeight);\n        }\n      }\n    }\n  }, {\n    key: \"_renderSelectionsHighlights\",\n    value: function _renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth) {\n      if (!this._selectionColor || this._selectionColor.isTransparent()) {\n        return;\n      }\n      var _iterator6 = _createForOfIteratorHelper(selections),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var selection = _step6.value;\n          var intersection = layout.intersectWithViewport(selection);\n          if (!intersection) {\n            // entirely outside minimap's viewport\n            continue;\n          }\n          var _intersection3 = _slicedToArray(intersection, 2),\n            startLineNumber = _intersection3[0],\n            endLineNumber = _intersection3[1];\n          for (var line = startLineNumber; line <= endLineNumber; line++) {\n            this.renderDecorationOnLine(canvasContext, lineOffsetMap, selection, this._selectionColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  }, {\n    key: \"_renderDecorationsHighlights\",\n    value: function _renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, minimapLineHeight, tabSize, characterWidth, canvasInnerWidth) {\n      // Loop forwards to hit first decorations with lower `zIndex`\n      var _iterator7 = _createForOfIteratorHelper(decorations),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var decoration = _step7.value;\n          var minimapOptions = decoration.options.minimap;\n          if (!minimapOptions) {\n            continue;\n          }\n          var intersection = layout.intersectWithViewport(decoration.range);\n          if (!intersection) {\n            // entirely outside minimap's viewport\n            continue;\n          }\n          var _intersection4 = _slicedToArray(intersection, 2),\n            startLineNumber = _intersection4[0],\n            endLineNumber = _intersection4[1];\n          var decorationColor = minimapOptions.getColor(this._theme.value);\n          if (!decorationColor || decorationColor.isTransparent()) {\n            continue;\n          }\n          for (var line = startLineNumber; line <= endLineNumber; line++) {\n            switch (minimapOptions.position) {\n              case 1 /* MinimapPosition.Inline */:\n                this.renderDecorationOnLine(canvasContext, lineOffsetMap, decoration.range, decorationColor, layout, line, minimapLineHeight, minimapLineHeight, tabSize, characterWidth, canvasInnerWidth);\n                continue;\n              case 2 /* MinimapPosition.Gutter */:\n                {\n                  var y = layout.getYForLineNumber(line, minimapLineHeight);\n                  var x = 2;\n                  this.renderDecoration(canvasContext, decorationColor, x, y, GUTTER_DECORATION_WIDTH, minimapLineHeight);\n                  continue;\n                }\n            }\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }, {\n    key: \"renderDecorationOnLine\",\n    value: function renderDecorationOnLine(canvasContext, lineOffsetMap, decorationRange, decorationColor, layout, lineNumber, height, minimapLineHeight, tabSize, charWidth, canvasInnerWidth) {\n      var y = layout.getYForLineNumber(lineNumber, minimapLineHeight);\n      // Skip rendering the line if it's vertically outside our viewport\n      if (y + height < 0 || y > this._model.options.canvasInnerHeight) {\n        return;\n      }\n      var startLineNumber = decorationRange.startLineNumber,\n        endLineNumber = decorationRange.endLineNumber;\n      var startColumn = startLineNumber === lineNumber ? decorationRange.startColumn : 1;\n      var endColumn = endLineNumber === lineNumber ? decorationRange.endColumn : this._model.getLineMaxColumn(lineNumber);\n      var x1 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, startColumn, tabSize, charWidth, canvasInnerWidth);\n      var x2 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, endColumn, tabSize, charWidth, canvasInnerWidth);\n      this.renderDecoration(canvasContext, decorationColor, x1, y, x2 - x1, height);\n    }\n  }, {\n    key: \"getXOffsetForPosition\",\n    value: function getXOffsetForPosition(lineOffsetMap, lineNumber, column, tabSize, charWidth, canvasInnerWidth) {\n      if (column === 1) {\n        return MINIMAP_GUTTER_WIDTH;\n      }\n      var minimumXOffset = (column - 1) * charWidth;\n      if (minimumXOffset >= canvasInnerWidth) {\n        // there is no need to look at actual characters,\n        // as this column is certainly after the minimap width\n        return canvasInnerWidth;\n      }\n      // Cache line offset data so that it is only read once per line\n      var lineIndexToXOffset = lineOffsetMap.get(lineNumber);\n      if (!lineIndexToXOffset) {\n        var lineData = this._model.getLineContent(lineNumber);\n        lineIndexToXOffset = [MINIMAP_GUTTER_WIDTH];\n        var prevx = MINIMAP_GUTTER_WIDTH;\n        for (var i = 1; i < lineData.length + 1; i++) {\n          var charCode = lineData.charCodeAt(i - 1);\n          var dx = charCode === 9 /* CharCode.Tab */ ? tabSize * charWidth : strings.isFullWidthCharacter(charCode) ? 2 * charWidth : charWidth;\n          var x = prevx + dx;\n          if (x >= canvasInnerWidth) {\n            // no need to keep on going, as we've hit the canvas width\n            lineIndexToXOffset[i] = canvasInnerWidth;\n            break;\n          }\n          lineIndexToXOffset[i] = x;\n          prevx = x;\n        }\n        lineOffsetMap.set(lineNumber, lineIndexToXOffset);\n      }\n      if (column - 1 < lineIndexToXOffset.length) {\n        return lineIndexToXOffset[column - 1];\n      }\n      // goes over the canvas width\n      return canvasInnerWidth;\n    }\n  }, {\n    key: \"renderDecoration\",\n    value: function renderDecoration(canvasContext, decorationColor, x, y, width, height) {\n      canvasContext.fillStyle = decorationColor && decorationColor.toString() || '';\n      canvasContext.fillRect(x, y, width, height);\n    }\n  }, {\n    key: \"_renderSectionHeaders\",\n    value: function _renderSectionHeaders(layout) {\n      var _a;\n      var minimapLineHeight = this._model.options.minimapLineHeight;\n      var sectionHeaderFontSize = this._model.options.sectionHeaderFontSize;\n      var backgroundFillHeight = sectionHeaderFontSize * 1.5;\n      var canvasInnerWidth = this._model.options.canvasInnerWidth;\n      var backgroundColor = this._model.options.backgroundColor;\n      var backgroundFill = \"rgb(\".concat(backgroundColor.r, \" \").concat(backgroundColor.g, \" \").concat(backgroundColor.b, \" / .7)\");\n      var foregroundColor = this._model.options.sectionHeaderFontColor;\n      var foregroundFill = \"rgb(\".concat(foregroundColor.r, \" \").concat(foregroundColor.g, \" \").concat(foregroundColor.b, \")\");\n      var separatorStroke = foregroundFill;\n      var canvasContext = this._decorationsCanvas.domNode.getContext('2d');\n      canvasContext.font = sectionHeaderFontSize + 'px ' + this._model.options.sectionHeaderFontFamily;\n      canvasContext.strokeStyle = separatorStroke;\n      canvasContext.lineWidth = 0.2;\n      var decorations = this._model.getSectionHeaderDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\n      decorations.sort(function (a, b) {\n        return a.range.startLineNumber - b.range.startLineNumber;\n      });\n      var fitWidth = InnerMinimap._fitSectionHeader.bind(null, canvasContext, canvasInnerWidth - MINIMAP_GUTTER_WIDTH);\n      var _iterator8 = _createForOfIteratorHelper(decorations),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var decoration = _step8.value;\n          var y = layout.getYForLineNumber(decoration.range.startLineNumber, minimapLineHeight) + sectionHeaderFontSize;\n          var backgroundFillY = y - sectionHeaderFontSize;\n          var separatorY = backgroundFillY + 2;\n          var headerText = this._model.getSectionHeaderText(decoration, fitWidth);\n          InnerMinimap._renderSectionLabel(canvasContext, headerText, ((_a = decoration.options.minimap) === null || _a === void 0 ? void 0 : _a.sectionHeaderStyle) === 2 /* MinimapSectionHeaderStyle.Underlined */, backgroundFill, foregroundFill, canvasInnerWidth, backgroundFillY, backgroundFillHeight, y, separatorY);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  }, {\n    key: \"renderLines\",\n    value: function renderLines(layout) {\n      var startLineNumber = layout.startLineNumber;\n      var endLineNumber = layout.endLineNumber;\n      var minimapLineHeight = this._model.options.minimapLineHeight;\n      // Check if nothing changed w.r.t. lines from last frame\n      if (this._lastRenderData && this._lastRenderData.linesEquals(layout)) {\n        var _lastData = this._lastRenderData._get();\n        // Nice!! Nothing changed from last frame\n        return new RenderData(layout, _lastData.imageData, _lastData.lines);\n      }\n      // Oh well!! We need to repaint some lines...\n      var imageData = this._getBuffer();\n      if (!imageData) {\n        // 0 width or 0 height canvas, nothing to do\n        return null;\n      }\n      // Render untouched lines by using last rendered data.\n      var _InnerMinimap$_render = InnerMinimap._renderUntouchedLines(imageData, layout.topPaddingLineCount, startLineNumber, endLineNumber, minimapLineHeight, this._lastRenderData),\n        _InnerMinimap$_render2 = _slicedToArray(_InnerMinimap$_render, 3),\n        _dirtyY1 = _InnerMinimap$_render2[0],\n        _dirtyY2 = _InnerMinimap$_render2[1],\n        needed = _InnerMinimap$_render2[2];\n      // Fetch rendering info from view model for rest of lines that need rendering.\n      var lineInfo = this._model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed);\n      var tabSize = this._model.getOptions().tabSize;\n      var defaultBackground = this._model.options.defaultBackgroundColor;\n      var background = this._model.options.backgroundColor;\n      var foregroundAlpha = this._model.options.foregroundAlpha;\n      var tokensColorTracker = this._model.tokensColorTracker;\n      var useLighterFont = tokensColorTracker.backgroundIsLight();\n      var renderMinimap = this._model.options.renderMinimap;\n      var charRenderer = this._model.options.charRenderer();\n      var fontScale = this._model.options.fontScale;\n      var minimapCharWidth = this._model.options.minimapCharWidth;\n      var baseCharHeight = renderMinimap === 1 /* RenderMinimap.Text */ ? 2 /* Constants.BASE_CHAR_HEIGHT */ : 2 /* Constants.BASE_CHAR_HEIGHT */ + 1;\n      var renderMinimapLineHeight = baseCharHeight * fontScale;\n      var innerLinePadding = minimapLineHeight > renderMinimapLineHeight ? Math.floor((minimapLineHeight - renderMinimapLineHeight) / 2) : 0;\n      // Render the rest of lines\n      var backgroundA = background.a / 255;\n      var renderBackground = new RGBA8(Math.round((background.r - defaultBackground.r) * backgroundA + defaultBackground.r), Math.round((background.g - defaultBackground.g) * backgroundA + defaultBackground.g), Math.round((background.b - defaultBackground.b) * backgroundA + defaultBackground.b), 255);\n      var dy = layout.topPaddingLineCount * minimapLineHeight;\n      var renderedLines = [];\n      for (var lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n        if (needed[lineIndex]) {\n          InnerMinimap._renderLine(imageData, renderBackground, background.a, useLighterFont, renderMinimap, minimapCharWidth, tokensColorTracker, foregroundAlpha, charRenderer, dy, innerLinePadding, tabSize, lineInfo[lineIndex], fontScale, minimapLineHeight);\n        }\n        renderedLines[lineIndex] = new MinimapLine(dy);\n        dy += minimapLineHeight;\n      }\n      var dirtyY1 = _dirtyY1 === -1 ? 0 : _dirtyY1;\n      var dirtyY2 = _dirtyY2 === -1 ? imageData.height : _dirtyY2;\n      var dirtyHeight = dirtyY2 - dirtyY1;\n      // Finally, paint to the canvas\n      var ctx = this._canvas.domNode.getContext('2d');\n      ctx.putImageData(imageData, 0, 0, 0, dirtyY1, imageData.width, dirtyHeight);\n      // Save rendered data for reuse on next frame if possible\n      return new RenderData(layout, imageData, renderedLines);\n    }\n  }], [{\n    key: \"_fitSectionHeader\",\n    value: function _fitSectionHeader(target, maxWidth, headerText) {\n      if (!headerText) {\n        return headerText;\n      }\n      var ellipsis = '…';\n      var width = target.measureText(headerText).width;\n      var ellipsisWidth = target.measureText(ellipsis).width;\n      if (width <= maxWidth || width <= ellipsisWidth) {\n        return headerText;\n      }\n      var len = headerText.length;\n      var averageCharWidth = width / headerText.length;\n      var maxCharCount = Math.floor((maxWidth - ellipsisWidth) / averageCharWidth) - 1;\n      // Find a halfway point that isn't after whitespace\n      var halfCharCount = Math.ceil(maxCharCount / 2);\n      while (halfCharCount > 0 && /\\s/.test(headerText[halfCharCount - 1])) {\n        --halfCharCount;\n      }\n      // Split with ellipsis\n      return headerText.substring(0, halfCharCount) + ellipsis + headerText.substring(len - (maxCharCount - halfCharCount));\n    }\n  }, {\n    key: \"_renderSectionLabel\",\n    value: function _renderSectionLabel(target, headerText, hasSeparatorLine, backgroundFill, foregroundFill, minimapWidth, backgroundFillY, backgroundFillHeight, textY, separatorY) {\n      if (headerText) {\n        target.fillStyle = backgroundFill;\n        target.fillRect(0, backgroundFillY, minimapWidth, backgroundFillHeight);\n        target.fillStyle = foregroundFill;\n        target.fillText(headerText, MINIMAP_GUTTER_WIDTH, textY);\n      }\n      if (hasSeparatorLine) {\n        target.beginPath();\n        target.moveTo(0, separatorY);\n        target.lineTo(minimapWidth, separatorY);\n        target.closePath();\n        target.stroke();\n      }\n    }\n  }, {\n    key: \"_renderUntouchedLines\",\n    value: function _renderUntouchedLines(target, topPaddingLineCount, startLineNumber, endLineNumber, minimapLineHeight, lastRenderData) {\n      var needed = [];\n      if (!lastRenderData) {\n        for (var i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {\n          needed[i] = true;\n        }\n        return [-1, -1, needed];\n      }\n      var _lastData = lastRenderData._get();\n      var lastTargetData = _lastData.imageData.data;\n      var lastStartLineNumber = _lastData.rendLineNumberStart;\n      var lastLines = _lastData.lines;\n      var lastLinesLength = lastLines.length;\n      var WIDTH = target.width;\n      var targetData = target.data;\n      var maxDestPixel = (endLineNumber - startLineNumber + 1) * minimapLineHeight * WIDTH * 4;\n      var dirtyPixel1 = -1; // the pixel offset up to which all the data is equal to the prev frame\n      var dirtyPixel2 = -1; // the pixel offset after which all the data is equal to the prev frame\n      var copySourceStart = -1;\n      var copySourceEnd = -1;\n      var copyDestStart = -1;\n      var copyDestEnd = -1;\n      var dest_dy = topPaddingLineCount * minimapLineHeight;\n      for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n        var lineIndex = lineNumber - startLineNumber;\n        var lastLineIndex = lineNumber - lastStartLineNumber;\n        var source_dy = lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? lastLines[lastLineIndex].dy : -1;\n        if (source_dy === -1) {\n          needed[lineIndex] = true;\n          dest_dy += minimapLineHeight;\n          continue;\n        }\n        var sourceStart = source_dy * WIDTH * 4;\n        var sourceEnd = (source_dy + minimapLineHeight) * WIDTH * 4;\n        var destStart = dest_dy * WIDTH * 4;\n        var destEnd = (dest_dy + minimapLineHeight) * WIDTH * 4;\n        if (copySourceEnd === sourceStart && copyDestEnd === destStart) {\n          // contiguous zone => extend copy request\n          copySourceEnd = sourceEnd;\n          copyDestEnd = destEnd;\n        } else {\n          if (copySourceStart !== -1) {\n            // flush existing copy request\n            targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n            if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n              dirtyPixel1 = copySourceEnd;\n            }\n            if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n              dirtyPixel2 = copySourceStart;\n            }\n          }\n          copySourceStart = sourceStart;\n          copySourceEnd = sourceEnd;\n          copyDestStart = destStart;\n          copyDestEnd = destEnd;\n        }\n        needed[lineIndex] = false;\n        dest_dy += minimapLineHeight;\n      }\n      if (copySourceStart !== -1) {\n        // flush existing copy request\n        targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n        if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n          dirtyPixel1 = copySourceEnd;\n        }\n        if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n          dirtyPixel2 = copySourceStart;\n        }\n      }\n      var dirtyY1 = dirtyPixel1 === -1 ? -1 : dirtyPixel1 / (WIDTH * 4);\n      var dirtyY2 = dirtyPixel2 === -1 ? -1 : dirtyPixel2 / (WIDTH * 4);\n      return [dirtyY1, dirtyY2, needed];\n    }\n  }, {\n    key: \"_renderLine\",\n    value: function _renderLine(target, backgroundColor, backgroundAlpha, useLighterFont, renderMinimap, charWidth, colorTracker, foregroundAlpha, minimapCharRenderer, dy, innerLinePadding, tabSize, lineData, fontScale, minimapLineHeight) {\n      var content = lineData.content;\n      var tokens = lineData.tokens;\n      var maxDx = target.width - charWidth;\n      var force1pxHeight = minimapLineHeight === 1;\n      var dx = MINIMAP_GUTTER_WIDTH;\n      var charIndex = 0;\n      var tabsCharDelta = 0;\n      for (var tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n        var tokenEndIndex = tokens.getEndOffset(tokenIndex);\n        var tokenColorId = tokens.getForeground(tokenIndex);\n        var tokenColor = colorTracker.getColor(tokenColorId);\n        for (; charIndex < tokenEndIndex; charIndex++) {\n          if (dx > maxDx) {\n            // hit edge of minimap\n            return;\n          }\n          var charCode = content.charCodeAt(charIndex);\n          if (charCode === 9 /* CharCode.Tab */) {\n            var insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n            tabsCharDelta += insertSpacesCount - 1;\n            // No need to render anything since tab is invisible\n            dx += insertSpacesCount * charWidth;\n          } else if (charCode === 32 /* CharCode.Space */) {\n            // No need to render anything since space is invisible\n            dx += charWidth;\n          } else {\n            // Render twice for a full width character\n            var count = strings.isFullWidthCharacter(charCode) ? 2 : 1;\n            for (var i = 0; i < count; i++) {\n              if (renderMinimap === 2 /* RenderMinimap.Blocks */) {\n                minimapCharRenderer.blockRenderChar(target, dx, dy + innerLinePadding, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, force1pxHeight);\n              } else {\n                // RenderMinimap.Text\n                minimapCharRenderer.renderChar(target, dx, dy + innerLinePadding, charCode, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, fontScale, useLighterFont, force1pxHeight);\n              }\n              dx += charWidth;\n              if (dx > maxDx) {\n                // hit edge of minimap\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }]);\n}(Disposable);\nvar ContiguousLineMap = /*#__PURE__*/function () {\n  function ContiguousLineMap(startLineNumber, endLineNumber, defaultValue) {\n    _classCallCheck(this, ContiguousLineMap);\n    this._startLineNumber = startLineNumber;\n    this._endLineNumber = endLineNumber;\n    this._defaultValue = defaultValue;\n    this._values = [];\n    for (var i = 0, count = this._endLineNumber - this._startLineNumber + 1; i < count; i++) {\n      this._values[i] = defaultValue;\n    }\n  }\n  return _createClass(ContiguousLineMap, [{\n    key: \"has\",\n    value: function has(lineNumber) {\n      return this.get(lineNumber) !== this._defaultValue;\n    }\n  }, {\n    key: \"set\",\n    value: function set(lineNumber, value) {\n      if (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n        return;\n      }\n      this._values[lineNumber - this._startLineNumber] = value;\n    }\n  }, {\n    key: \"get\",\n    value: function get(lineNumber) {\n      if (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n        return this._defaultValue;\n      }\n      return this._values[lineNumber - this._startLineNumber];\n    }\n  }]);\n}();","map":{"version":3,"names":["dom","createFastDomNode","GlobalPointerMoveMonitor","Disposable","platform","strings","RenderedLinesCollection","PartFingerprints","ViewPart","MINIMAP_GUTTER_WIDTH","EditorLayoutInfoComputer","Range","RGBA8","MinimapTokensColorTracker","ViewModelDecoration","minimapSelection","minimapBackground","minimapForegroundOpacity","editorForeground","Selection","EventType","Gesture","MinimapCharRendererFactory","createSingleCallFunction","LRUCache","DEFAULT_FONT_FAMILY","POINTER_DRAG_RESET_DISTANCE","GUTTER_DECORATION_WIDTH","MinimapOptions","configuration","theme","tokensColorTracker","_this","_classCallCheck","options","pixelRatio","get","layoutInfo","minimapLayout","minimap","fontInfo","minimapOpts","renderMinimap","size","minimapHeightIsEditorHeight","scrollBeyondLastLine","paddingTop","top","paddingBottom","bottom","showSlider","autohide","typicalHalfwidthCharacterWidth","lineHeight","minimapLeft","minimapWidth","minimapHeight","height","canvasInnerWidth","minimapCanvasInnerWidth","canvasInnerHeight","minimapCanvasInnerHeight","canvasOuterWidth","minimapCanvasOuterWidth","canvasOuterHeight","minimapCanvasOuterHeight","isSampling","minimapIsSampling","editorHeight","fontScale","minimapScale","minimapLineHeight","minimapCharWidth","sectionHeaderFontFamily","sectionHeaderFontSize","sectionHeaderFontColor","_getSectionHeaderColor","getColor","charRenderer","create","fontFamily","defaultBackgroundColor","backgroundColor","_getMinimapBackground","foregroundAlpha","_getMinimapForegroundOpacity","_createClass","key","value","equals","other","themeColor","rgba","r","g","b","Math","round","a","_clamp","defaultForegroundColor","MinimapLayout","scrollTop","scrollHeight","sliderNeeded","_computedSliderRatio","sliderTop","sliderHeight","topPaddingLineCount","startLineNumber","endLineNumber","getDesiredScrollTopFromDelta","delta","getDesiredScrollTopFromTouchLocation","pageY","intersectWithViewport","range","max","min","getYForLineNumber","lineNumber","viewportStartLineNumber","viewportEndLineNumber","viewportStartLineNumberVerticalOffset","viewportHeight","viewportContainsWhitespaceGaps","lineCount","realLineCount","previousLayout","minimapLinesFitting","floor","logicalScrollHeight","maxMinimapSliderTop","computedSliderRatio","maxLinesFitting","viewportLineCount","expectedViewportLineCount","extraLinesAtTheTop","extraLinesAtTheBottom","consideringStartLineNumber","partialLine","sliderTopAligned","MinimapLine","dy","onContentChanged","onTokensChanged","INVALID","RenderData","renderedLayout","imageData","lines","_imageData","_renderedLines","_set","linesEquals","layout","scrollEquals","tmp","_get","i","len","length","rendLineNumberStart","onLinesChanged","changeFromLineNumber","changeCount","onLinesDeleted","deleteFromLineNumber","deleteToLineNumber","onLinesInserted","insertFromLineNumber","insertToLineNumber","ranges","MinimapBuffers","ctx","WIDTH","HEIGHT","background","_backgroundFillData","_createBackgroundFillData","_buffers","createImageData","_lastUsedBuffer","getBuffer","result","data","set","backgroundR","backgroundG","backgroundB","backgroundA","Uint8ClampedArray","offset","j","MinimapSamplingState","samplingRatio","minimapLines","modelLineToMinimapLine","modelLineRangeToMinimapLineRange","fromLineNumber","toLineNumber","fromLineIndex","toLineIndex","sampledLineNumber","decorationLineRangeToMinimapLineRange","minimapLineStart","minimapLineEnd","e","deletedLineCount","changeStartIndex","changeEndIndex","insertedLineCount","compute","viewLineCount","oldSamplingState","_EditorLayoutInfoComp","computeContainedMinimapLineCount","minimapLineCount","ratio","halfRatio","lastIndex","oldMinimapLines","oldLength","oldIndex","oldDeltaLineCount","minViewLineNumber","MAX_EVENT_COUNT","events","lastEvent","fromViewLineNumber","toViewLineNumber","oldMinimapLineNumber","type","_oldIndex","push","selectedViewLineNumber","_i","Minimap","_ViewPart","context","_this2","_callSuper","_sectionHeaderCache","getInstance","_selections","_minimapSelections","_context","_MinimapSamplingState","viewModel","getLineCount","_MinimapSamplingState2","_slicedToArray","samplingState","_samplingState","_shouldCheckSampling","_actual","InnerMinimap","_inherits","dispose","_get2","_getPrototypeOf","prototype","call","getDomNode","_onOptionsMaybeChanged","opts","_recreateLineSampling","onDidChangeOptions","onConfigurationChanged","onCursorStateChanged","selections","onSelectionChanged","onDecorationsChanged","affectsMinimap","onFlushed","minimapLineRange","count","_this$_samplingState$","_this$_samplingState$2","onScrollChanged","onThemeChanged","_iterator","_createForOfIteratorHelper","_step","s","n","done","err","f","onTokensColorsChanged","onZonesChanged","prepareRender","render","visibleRange","minimapCtx","viewportData","whitespaceViewportData","scrollWidth","getVerticalOffsetForLineNumber","scrollLeft","viewportWidth","wasSampling","Boolean","_MinimapSamplingState3","_MinimapSamplingState4","_iterator2","_step2","event","getRealLineCount","getLineContent","getLineMaxColumn","getMinimapLinesRenderingData","needed","lineIndex","getViewLineData","getSelections","_iterator3","_step3","selection","_this$_samplingState$3","_this$_samplingState$4","startColumn","endColumn","getMinimapDecorationsInViewport","decorations","_getMinimapDecorationsInViewport","filter","decoration","_a","sectionHeaderStyle","_iterator4","_step4","minimapStartLineNumber","minimapEndLineNumber","getSectionHeaderDecorationsInViewport","headerHeightInMinimapLines","modelStartLineNumber","modelEndLineNumber","getMinimapDecorationsInRange","getSectionHeaderText","fitWidth","headerText","sectionHeaderText","cachedText","fittedText","getOptions","model","revealLineNumber","revealRange","setScrollTop","viewLayout","setScrollPosition","_Disposable","_this3","_renderDecorations","_gestureInProgress","_theme","_model","_lastRenderData","_selectionColor","_domNode","document","createElement","write","setClassName","_getMinimapDomNodeClassName","setPosition","setAttribute","_shadow","appendChild","_canvas","setLeft","_decorationsCanvas","_slider","setLayerHinting","setContain","_sliderHorizontal","_applyLayout","_pointerDownListener","addStandardDisposableListener","domNode","POINTER_DOWN","preventDefault","button","position","getDomNodePagePosition","initialPosY","_startSliderDragging","internalOffsetY","offsetY","_sliderPointerMoveMonitor","_sliderPointerDownListener","stopPropagation","_gestureDisposable","addTarget","_sliderTouchStartListener","addDisposableListener","Start","toggleClassName","scrollDueToTouchEvent","passive","_sliderTouchMoveListener","Change","_sliderTouchEndListener","End","initialSliderState","_this4","target","Element","initialPosX","pageX","handlePointerMove","posy","posx","minimapPosition","pointerOrthogonalDelta","abs","left","width","isWindows","pointerDelta","startMonitoring","pointerId","buttons","pointerMoveData","touch","startY","getBoundingClientRect","class_","join","setWidth","setHeight","_getBuffer","getContext","renderingCtx","setDisplay","setTop","renderDecorations","renderLines","sort","compareRangesUsingStarts","zIndex","_this$_model$options","tabSize","canvasContext","clearRect","highlightedLines","ContiguousLineMap","_renderSelectionLineHighlights","_renderDecorationsLineHighlights","lineOffsetMap","_renderSelectionsHighlights","_renderDecorationsHighlights","_renderSectionHeaders","isTransparent","fillStyle","transparent","toString","y1","y2","_iterator5","_step5","intersection","_intersection","line","yy1","yy2","fillRect","canvas","highlightColors","Map","minimapOptions","_intersection2","decorationColor","highlightColor","has","y","characterWidth","_iterator6","_step6","_intersection3","renderDecorationOnLine","_iterator7","_step7","_intersection4","x","renderDecoration","decorationRange","charWidth","x1","getXOffsetForPosition","x2","column","minimumXOffset","lineIndexToXOffset","lineData","prevx","charCode","charCodeAt","dx","isFullWidthCharacter","backgroundFillHeight","backgroundFill","concat","foregroundColor","foregroundFill","separatorStroke","font","strokeStyle","lineWidth","_fitSectionHeader","bind","_iterator8","_step8","backgroundFillY","separatorY","_renderSectionLabel","_lastData","_InnerMinimap$_render","_renderUntouchedLines","_InnerMinimap$_render2","_dirtyY1","_dirtyY2","lineInfo","defaultBackground","useLighterFont","backgroundIsLight","baseCharHeight","renderMinimapLineHeight","innerLinePadding","renderBackground","renderedLines","_renderLine","dirtyY1","dirtyY2","dirtyHeight","putImageData","maxWidth","ellipsis","measureText","ellipsisWidth","averageCharWidth","maxCharCount","halfCharCount","ceil","test","substring","hasSeparatorLine","textY","fillText","beginPath","moveTo","lineTo","closePath","stroke","lastRenderData","lastTargetData","lastStartLineNumber","lastLines","lastLinesLength","targetData","maxDestPixel","dirtyPixel1","dirtyPixel2","copySourceStart","copySourceEnd","copyDestStart","copyDestEnd","dest_dy","lastLineIndex","source_dy","sourceStart","sourceEnd","destStart","destEnd","subarray","backgroundAlpha","colorTracker","minimapCharRenderer","content","tokens","maxDx","force1pxHeight","charIndex","tabsCharDelta","tokenIndex","tokensLen","getCount","tokenEndIndex","getEndOffset","tokenColorId","getForeground","tokenColor","insertSpacesCount","blockRenderChar","renderChar","defaultValue","_startLineNumber","_endLineNumber","_defaultValue","_values"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimap.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport './minimap.css';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { GlobalPointerMoveMonitor } from '../../../../base/browser/globalPointerMoveMonitor.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { RenderedLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { MINIMAP_GUTTER_WIDTH, EditorLayoutInfoComputer } from '../../../common/config/editorOptions.js';\nimport { Range } from '../../../common/core/range.js';\nimport { RGBA8 } from '../../../common/core/rgba.js';\nimport { MinimapTokensColorTracker } from '../../../common/viewModel/minimapTokensColorTracker.js';\nimport { ViewModelDecoration } from '../../../common/viewModel.js';\nimport { minimapSelection, minimapBackground, minimapForegroundOpacity, editorForeground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { EventType, Gesture } from '../../../../base/browser/touch.js';\nimport { MinimapCharRendererFactory } from './minimapCharRendererFactory.js';\nimport { createSingleCallFunction } from '../../../../base/common/functional.js';\nimport { LRUCache } from '../../../../base/common/map.js';\nimport { DEFAULT_FONT_FAMILY } from '../../../../base/browser/fonts.js';\n/**\n * The orthogonal distance to the slider at which dragging \"resets\". This implements \"snapping\"\n */\nconst POINTER_DRAG_RESET_DISTANCE = 140;\nconst GUTTER_DECORATION_WIDTH = 2;\nclass MinimapOptions {\n    constructor(configuration, theme, tokensColorTracker) {\n        const options = configuration.options;\n        const pixelRatio = options.get(143 /* EditorOption.pixelRatio */);\n        const layoutInfo = options.get(145 /* EditorOption.layoutInfo */);\n        const minimapLayout = layoutInfo.minimap;\n        const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        const minimapOpts = options.get(73 /* EditorOption.minimap */);\n        this.renderMinimap = minimapLayout.renderMinimap;\n        this.size = minimapOpts.size;\n        this.minimapHeightIsEditorHeight = minimapLayout.minimapHeightIsEditorHeight;\n        this.scrollBeyondLastLine = options.get(105 /* EditorOption.scrollBeyondLastLine */);\n        this.paddingTop = options.get(84 /* EditorOption.padding */).top;\n        this.paddingBottom = options.get(84 /* EditorOption.padding */).bottom;\n        this.showSlider = minimapOpts.showSlider;\n        this.autohide = minimapOpts.autohide;\n        this.pixelRatio = pixelRatio;\n        this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        this.lineHeight = options.get(67 /* EditorOption.lineHeight */);\n        this.minimapLeft = minimapLayout.minimapLeft;\n        this.minimapWidth = minimapLayout.minimapWidth;\n        this.minimapHeight = layoutInfo.height;\n        this.canvasInnerWidth = minimapLayout.minimapCanvasInnerWidth;\n        this.canvasInnerHeight = minimapLayout.minimapCanvasInnerHeight;\n        this.canvasOuterWidth = minimapLayout.minimapCanvasOuterWidth;\n        this.canvasOuterHeight = minimapLayout.minimapCanvasOuterHeight;\n        this.isSampling = minimapLayout.minimapIsSampling;\n        this.editorHeight = layoutInfo.height;\n        this.fontScale = minimapLayout.minimapScale;\n        this.minimapLineHeight = minimapLayout.minimapLineHeight;\n        this.minimapCharWidth = 1 /* Constants.BASE_CHAR_WIDTH */ * this.fontScale;\n        this.sectionHeaderFontFamily = DEFAULT_FONT_FAMILY;\n        this.sectionHeaderFontSize = minimapOpts.sectionHeaderFontSize * pixelRatio;\n        this.sectionHeaderFontColor = MinimapOptions._getSectionHeaderColor(theme, tokensColorTracker.getColor(1 /* ColorId.DefaultForeground */));\n        this.charRenderer = createSingleCallFunction(() => MinimapCharRendererFactory.create(this.fontScale, fontInfo.fontFamily));\n        this.defaultBackgroundColor = tokensColorTracker.getColor(2 /* ColorId.DefaultBackground */);\n        this.backgroundColor = MinimapOptions._getMinimapBackground(theme, this.defaultBackgroundColor);\n        this.foregroundAlpha = MinimapOptions._getMinimapForegroundOpacity(theme);\n    }\n    static _getMinimapBackground(theme, defaultBackgroundColor) {\n        const themeColor = theme.getColor(minimapBackground);\n        if (themeColor) {\n            return new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, Math.round(255 * themeColor.rgba.a));\n        }\n        return defaultBackgroundColor;\n    }\n    static _getMinimapForegroundOpacity(theme) {\n        const themeColor = theme.getColor(minimapForegroundOpacity);\n        if (themeColor) {\n            return RGBA8._clamp(Math.round(255 * themeColor.rgba.a));\n        }\n        return 255;\n    }\n    static _getSectionHeaderColor(theme, defaultForegroundColor) {\n        const themeColor = theme.getColor(editorForeground);\n        if (themeColor) {\n            return new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, Math.round(255 * themeColor.rgba.a));\n        }\n        return defaultForegroundColor;\n    }\n    equals(other) {\n        return (this.renderMinimap === other.renderMinimap\n            && this.size === other.size\n            && this.minimapHeightIsEditorHeight === other.minimapHeightIsEditorHeight\n            && this.scrollBeyondLastLine === other.scrollBeyondLastLine\n            && this.paddingTop === other.paddingTop\n            && this.paddingBottom === other.paddingBottom\n            && this.showSlider === other.showSlider\n            && this.autohide === other.autohide\n            && this.pixelRatio === other.pixelRatio\n            && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth\n            && this.lineHeight === other.lineHeight\n            && this.minimapLeft === other.minimapLeft\n            && this.minimapWidth === other.minimapWidth\n            && this.minimapHeight === other.minimapHeight\n            && this.canvasInnerWidth === other.canvasInnerWidth\n            && this.canvasInnerHeight === other.canvasInnerHeight\n            && this.canvasOuterWidth === other.canvasOuterWidth\n            && this.canvasOuterHeight === other.canvasOuterHeight\n            && this.isSampling === other.isSampling\n            && this.editorHeight === other.editorHeight\n            && this.fontScale === other.fontScale\n            && this.minimapLineHeight === other.minimapLineHeight\n            && this.minimapCharWidth === other.minimapCharWidth\n            && this.sectionHeaderFontSize === other.sectionHeaderFontSize\n            && this.defaultBackgroundColor && this.defaultBackgroundColor.equals(other.defaultBackgroundColor)\n            && this.backgroundColor && this.backgroundColor.equals(other.backgroundColor)\n            && this.foregroundAlpha === other.foregroundAlpha);\n    }\n}\nclass MinimapLayout {\n    constructor(\n    /**\n     * The given editor scrollTop (input).\n     */\n    scrollTop, \n    /**\n     * The given editor scrollHeight (input).\n     */\n    scrollHeight, sliderNeeded, _computedSliderRatio, \n    /**\n     * slider dom node top (in CSS px)\n     */\n    sliderTop, \n    /**\n     * slider dom node height (in CSS px)\n     */\n    sliderHeight, \n    /**\n     * empty lines to reserve at the top of the minimap.\n     */\n    topPaddingLineCount, \n    /**\n     * minimap render start line number.\n     */\n    startLineNumber, \n    /**\n     * minimap render end line number.\n     */\n    endLineNumber) {\n        this.scrollTop = scrollTop;\n        this.scrollHeight = scrollHeight;\n        this.sliderNeeded = sliderNeeded;\n        this._computedSliderRatio = _computedSliderRatio;\n        this.sliderTop = sliderTop;\n        this.sliderHeight = sliderHeight;\n        this.topPaddingLineCount = topPaddingLineCount;\n        this.startLineNumber = startLineNumber;\n        this.endLineNumber = endLineNumber;\n    }\n    /**\n     * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n     */\n    getDesiredScrollTopFromDelta(delta) {\n        return Math.round(this.scrollTop + delta / this._computedSliderRatio);\n    }\n    getDesiredScrollTopFromTouchLocation(pageY) {\n        return Math.round((pageY - this.sliderHeight / 2) / this._computedSliderRatio);\n    }\n    /**\n     * Intersect a line range with `this.startLineNumber` and `this.endLineNumber`.\n     */\n    intersectWithViewport(range) {\n        const startLineNumber = Math.max(this.startLineNumber, range.startLineNumber);\n        const endLineNumber = Math.min(this.endLineNumber, range.endLineNumber);\n        if (startLineNumber > endLineNumber) {\n            // entirely outside minimap's viewport\n            return null;\n        }\n        return [startLineNumber, endLineNumber];\n    }\n    /**\n     * Get the inner minimap y coordinate for a line number.\n     */\n    getYForLineNumber(lineNumber, minimapLineHeight) {\n        return +(lineNumber - this.startLineNumber + this.topPaddingLineCount) * minimapLineHeight;\n    }\n    static create(options, viewportStartLineNumber, viewportEndLineNumber, viewportStartLineNumberVerticalOffset, viewportHeight, viewportContainsWhitespaceGaps, lineCount, realLineCount, scrollTop, scrollHeight, previousLayout) {\n        const pixelRatio = options.pixelRatio;\n        const minimapLineHeight = options.minimapLineHeight;\n        const minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight);\n        const lineHeight = options.lineHeight;\n        if (options.minimapHeightIsEditorHeight) {\n            let logicalScrollHeight = (realLineCount * options.lineHeight\n                + options.paddingTop\n                + options.paddingBottom);\n            if (options.scrollBeyondLastLine) {\n                logicalScrollHeight += Math.max(0, viewportHeight - options.lineHeight - options.paddingBottom);\n            }\n            const sliderHeight = Math.max(1, Math.floor(viewportHeight * viewportHeight / logicalScrollHeight));\n            const maxMinimapSliderTop = Math.max(0, options.minimapHeight - sliderHeight);\n            // The slider can move from 0 to `maxMinimapSliderTop`\n            // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n            const computedSliderRatio = (maxMinimapSliderTop) / (scrollHeight - viewportHeight);\n            const sliderTop = (scrollTop * computedSliderRatio);\n            const sliderNeeded = (maxMinimapSliderTop > 0);\n            const maxLinesFitting = Math.floor(options.canvasInnerHeight / options.minimapLineHeight);\n            const topPaddingLineCount = Math.floor(options.paddingTop / options.lineHeight);\n            return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, topPaddingLineCount, 1, Math.min(lineCount, maxLinesFitting));\n        }\n        // The visible line count in a viewport can change due to a number of reasons:\n        //  a) with the same viewport width, different scroll positions can result in partial lines being visible:\n        //    e.g. for a line height of 20, and a viewport height of 600\n        //          * scrollTop = 0  => visible lines are [1, 30]\n        //          * scrollTop = 10 => visible lines are [1, 31] (with lines 1 and 31 partially visible)\n        //          * scrollTop = 20 => visible lines are [2, 31]\n        //  b) whitespace gaps might make their way in the viewport (which results in a decrease in the visible line count)\n        //  c) we could be in the scroll beyond last line case (which also results in a decrease in the visible line count, down to possibly only one line being visible)\n        // We must first establish a desirable slider height.\n        let sliderHeight;\n        if (viewportContainsWhitespaceGaps && viewportEndLineNumber !== lineCount) {\n            // case b) from above: there are whitespace gaps in the viewport.\n            // In this case, the height of the slider directly reflects the visible line count.\n            const viewportLineCount = viewportEndLineNumber - viewportStartLineNumber + 1;\n            sliderHeight = Math.floor(viewportLineCount * minimapLineHeight / pixelRatio);\n        }\n        else {\n            // The slider has a stable height\n            const expectedViewportLineCount = viewportHeight / lineHeight;\n            sliderHeight = Math.floor(expectedViewportLineCount * minimapLineHeight / pixelRatio);\n        }\n        const extraLinesAtTheTop = Math.floor(options.paddingTop / lineHeight);\n        let extraLinesAtTheBottom = Math.floor(options.paddingBottom / lineHeight);\n        if (options.scrollBeyondLastLine) {\n            const expectedViewportLineCount = viewportHeight / lineHeight;\n            extraLinesAtTheBottom = Math.max(extraLinesAtTheBottom, expectedViewportLineCount - 1);\n        }\n        let maxMinimapSliderTop;\n        if (extraLinesAtTheBottom > 0) {\n            const expectedViewportLineCount = viewportHeight / lineHeight;\n            // The minimap slider, when dragged all the way down, will contain the last line at its top\n            maxMinimapSliderTop = (extraLinesAtTheTop + lineCount + extraLinesAtTheBottom - expectedViewportLineCount - 1) * minimapLineHeight / pixelRatio;\n        }\n        else {\n            // The minimap slider, when dragged all the way down, will contain the last line at its bottom\n            maxMinimapSliderTop = Math.max(0, (extraLinesAtTheTop + lineCount) * minimapLineHeight / pixelRatio - sliderHeight);\n        }\n        maxMinimapSliderTop = Math.min(options.minimapHeight - sliderHeight, maxMinimapSliderTop);\n        // The slider can move from 0 to `maxMinimapSliderTop`\n        // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n        const computedSliderRatio = (maxMinimapSliderTop) / (scrollHeight - viewportHeight);\n        const sliderTop = (scrollTop * computedSliderRatio);\n        if (minimapLinesFitting >= extraLinesAtTheTop + lineCount + extraLinesAtTheBottom) {\n            // All lines fit in the minimap\n            const sliderNeeded = (maxMinimapSliderTop > 0);\n            return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, extraLinesAtTheTop, 1, lineCount);\n        }\n        else {\n            let consideringStartLineNumber;\n            if (viewportStartLineNumber > 1) {\n                consideringStartLineNumber = viewportStartLineNumber + extraLinesAtTheTop;\n            }\n            else {\n                consideringStartLineNumber = Math.max(1, scrollTop / lineHeight);\n            }\n            let topPaddingLineCount;\n            let startLineNumber = Math.max(1, Math.floor(consideringStartLineNumber - sliderTop * pixelRatio / minimapLineHeight));\n            if (startLineNumber < extraLinesAtTheTop) {\n                topPaddingLineCount = extraLinesAtTheTop - startLineNumber + 1;\n                startLineNumber = 1;\n            }\n            else {\n                topPaddingLineCount = 0;\n                startLineNumber = Math.max(1, startLineNumber - extraLinesAtTheTop);\n            }\n            // Avoid flickering caused by a partial viewport start line\n            // by being consistent w.r.t. the previous layout decision\n            if (previousLayout && previousLayout.scrollHeight === scrollHeight) {\n                if (previousLayout.scrollTop > scrollTop) {\n                    // Scrolling up => never increase `startLineNumber`\n                    startLineNumber = Math.min(startLineNumber, previousLayout.startLineNumber);\n                    topPaddingLineCount = Math.max(topPaddingLineCount, previousLayout.topPaddingLineCount);\n                }\n                if (previousLayout.scrollTop < scrollTop) {\n                    // Scrolling down => never decrease `startLineNumber`\n                    startLineNumber = Math.max(startLineNumber, previousLayout.startLineNumber);\n                    topPaddingLineCount = Math.min(topPaddingLineCount, previousLayout.topPaddingLineCount);\n                }\n            }\n            const endLineNumber = Math.min(lineCount, startLineNumber - topPaddingLineCount + minimapLinesFitting - 1);\n            const partialLine = (scrollTop - viewportStartLineNumberVerticalOffset) / lineHeight;\n            let sliderTopAligned;\n            if (scrollTop >= options.paddingTop) {\n                sliderTopAligned = (viewportStartLineNumber - startLineNumber + topPaddingLineCount + partialLine) * minimapLineHeight / pixelRatio;\n            }\n            else {\n                sliderTopAligned = (scrollTop / options.paddingTop) * (topPaddingLineCount + partialLine) * minimapLineHeight / pixelRatio;\n            }\n            return new MinimapLayout(scrollTop, scrollHeight, true, computedSliderRatio, sliderTopAligned, sliderHeight, topPaddingLineCount, startLineNumber, endLineNumber);\n        }\n    }\n}\nclass MinimapLine {\n    constructor(dy) {\n        this.dy = dy;\n    }\n    onContentChanged() {\n        this.dy = -1;\n    }\n    onTokensChanged() {\n        this.dy = -1;\n    }\n}\nMinimapLine.INVALID = new MinimapLine(-1);\nclass RenderData {\n    constructor(renderedLayout, imageData, lines) {\n        this.renderedLayout = renderedLayout;\n        this._imageData = imageData;\n        this._renderedLines = new RenderedLinesCollection(() => MinimapLine.INVALID);\n        this._renderedLines._set(renderedLayout.startLineNumber, lines);\n    }\n    /**\n     * Check if the current RenderData matches accurately the new desired layout and no painting is needed.\n     */\n    linesEquals(layout) {\n        if (!this.scrollEquals(layout)) {\n            return false;\n        }\n        const tmp = this._renderedLines._get();\n        const lines = tmp.lines;\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (lines[i].dy === -1) {\n                // This line is invalid\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Check if the current RenderData matches the new layout's scroll position\n     */\n    scrollEquals(layout) {\n        return this.renderedLayout.startLineNumber === layout.startLineNumber\n            && this.renderedLayout.endLineNumber === layout.endLineNumber;\n    }\n    _get() {\n        const tmp = this._renderedLines._get();\n        return {\n            imageData: this._imageData,\n            rendLineNumberStart: tmp.rendLineNumberStart,\n            lines: tmp.lines\n        };\n    }\n    onLinesChanged(changeFromLineNumber, changeCount) {\n        return this._renderedLines.onLinesChanged(changeFromLineNumber, changeCount);\n    }\n    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n        this._renderedLines.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n    }\n    onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n        this._renderedLines.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n    }\n    onTokensChanged(ranges) {\n        return this._renderedLines.onTokensChanged(ranges);\n    }\n}\n/**\n * Some sort of double buffering.\n *\n * Keeps two buffers around that will be rotated for painting.\n * Always gives a buffer that is filled with the background color.\n */\nclass MinimapBuffers {\n    constructor(ctx, WIDTH, HEIGHT, background) {\n        this._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);\n        this._buffers = [\n            ctx.createImageData(WIDTH, HEIGHT),\n            ctx.createImageData(WIDTH, HEIGHT)\n        ];\n        this._lastUsedBuffer = 0;\n    }\n    getBuffer() {\n        // rotate buffers\n        this._lastUsedBuffer = 1 - this._lastUsedBuffer;\n        const result = this._buffers[this._lastUsedBuffer];\n        // fill with background color\n        result.data.set(this._backgroundFillData);\n        return result;\n    }\n    static _createBackgroundFillData(WIDTH, HEIGHT, background) {\n        const backgroundR = background.r;\n        const backgroundG = background.g;\n        const backgroundB = background.b;\n        const backgroundA = background.a;\n        const result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);\n        let offset = 0;\n        for (let i = 0; i < HEIGHT; i++) {\n            for (let j = 0; j < WIDTH; j++) {\n                result[offset] = backgroundR;\n                result[offset + 1] = backgroundG;\n                result[offset + 2] = backgroundB;\n                result[offset + 3] = backgroundA;\n                offset += 4;\n            }\n        }\n        return result;\n    }\n}\nclass MinimapSamplingState {\n    static compute(options, viewLineCount, oldSamplingState) {\n        if (options.renderMinimap === 0 /* RenderMinimap.None */ || !options.isSampling) {\n            return [null, []];\n        }\n        // ratio is intentionally not part of the layout to avoid the layout changing all the time\n        // so we need to recompute it again...\n        const { minimapLineCount } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\n            viewLineCount: viewLineCount,\n            scrollBeyondLastLine: options.scrollBeyondLastLine,\n            paddingTop: options.paddingTop,\n            paddingBottom: options.paddingBottom,\n            height: options.editorHeight,\n            lineHeight: options.lineHeight,\n            pixelRatio: options.pixelRatio\n        });\n        const ratio = viewLineCount / minimapLineCount;\n        const halfRatio = ratio / 2;\n        if (!oldSamplingState || oldSamplingState.minimapLines.length === 0) {\n            const result = [];\n            result[0] = 1;\n            if (minimapLineCount > 1) {\n                for (let i = 0, lastIndex = minimapLineCount - 1; i < lastIndex; i++) {\n                    result[i] = Math.round(i * ratio + halfRatio);\n                }\n                result[minimapLineCount - 1] = viewLineCount;\n            }\n            return [new MinimapSamplingState(ratio, result), []];\n        }\n        const oldMinimapLines = oldSamplingState.minimapLines;\n        const oldLength = oldMinimapLines.length;\n        const result = [];\n        let oldIndex = 0;\n        let oldDeltaLineCount = 0;\n        let minViewLineNumber = 1;\n        const MAX_EVENT_COUNT = 10; // generate at most 10 events, if there are more than 10 changes, just flush all previous data\n        let events = [];\n        let lastEvent = null;\n        for (let i = 0; i < minimapLineCount; i++) {\n            const fromViewLineNumber = Math.max(minViewLineNumber, Math.round(i * ratio));\n            const toViewLineNumber = Math.max(fromViewLineNumber, Math.round((i + 1) * ratio));\n            while (oldIndex < oldLength && oldMinimapLines[oldIndex] < fromViewLineNumber) {\n                if (events.length < MAX_EVENT_COUNT) {\n                    const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n                    if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n                        lastEvent.deleteToLineNumber++;\n                    }\n                    else {\n                        lastEvent = { type: 'deleted', _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber };\n                        events.push(lastEvent);\n                    }\n                    oldDeltaLineCount--;\n                }\n                oldIndex++;\n            }\n            let selectedViewLineNumber;\n            if (oldIndex < oldLength && oldMinimapLines[oldIndex] <= toViewLineNumber) {\n                // reuse the old sampled line\n                selectedViewLineNumber = oldMinimapLines[oldIndex];\n                oldIndex++;\n            }\n            else {\n                if (i === 0) {\n                    selectedViewLineNumber = 1;\n                }\n                else if (i + 1 === minimapLineCount) {\n                    selectedViewLineNumber = viewLineCount;\n                }\n                else {\n                    selectedViewLineNumber = Math.round(i * ratio + halfRatio);\n                }\n                if (events.length < MAX_EVENT_COUNT) {\n                    const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n                    if (lastEvent && lastEvent.type === 'inserted' && lastEvent._i === i - 1) {\n                        lastEvent.insertToLineNumber++;\n                    }\n                    else {\n                        lastEvent = { type: 'inserted', _i: i, insertFromLineNumber: oldMinimapLineNumber, insertToLineNumber: oldMinimapLineNumber };\n                        events.push(lastEvent);\n                    }\n                    oldDeltaLineCount++;\n                }\n            }\n            result[i] = selectedViewLineNumber;\n            minViewLineNumber = selectedViewLineNumber;\n        }\n        if (events.length < MAX_EVENT_COUNT) {\n            while (oldIndex < oldLength) {\n                const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n                if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n                    lastEvent.deleteToLineNumber++;\n                }\n                else {\n                    lastEvent = { type: 'deleted', _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber };\n                    events.push(lastEvent);\n                }\n                oldDeltaLineCount--;\n                oldIndex++;\n            }\n        }\n        else {\n            // too many events, just give up\n            events = [{ type: 'flush' }];\n        }\n        return [new MinimapSamplingState(ratio, result), events];\n    }\n    constructor(samplingRatio, minimapLines // a map of 0-based minimap line indexes to 1-based view line numbers\n    ) {\n        this.samplingRatio = samplingRatio;\n        this.minimapLines = minimapLines;\n    }\n    modelLineToMinimapLine(lineNumber) {\n        return Math.min(this.minimapLines.length, Math.max(1, Math.round(lineNumber / this.samplingRatio)));\n    }\n    /**\n     * Will return null if the model line ranges are not intersecting with a sampled model line.\n     */\n    modelLineRangeToMinimapLineRange(fromLineNumber, toLineNumber) {\n        let fromLineIndex = this.modelLineToMinimapLine(fromLineNumber) - 1;\n        while (fromLineIndex > 0 && this.minimapLines[fromLineIndex - 1] >= fromLineNumber) {\n            fromLineIndex--;\n        }\n        let toLineIndex = this.modelLineToMinimapLine(toLineNumber) - 1;\n        while (toLineIndex + 1 < this.minimapLines.length && this.minimapLines[toLineIndex + 1] <= toLineNumber) {\n            toLineIndex++;\n        }\n        if (fromLineIndex === toLineIndex) {\n            const sampledLineNumber = this.minimapLines[fromLineIndex];\n            if (sampledLineNumber < fromLineNumber || sampledLineNumber > toLineNumber) {\n                // This line is not part of the sampled lines ==> nothing to do\n                return null;\n            }\n        }\n        return [fromLineIndex + 1, toLineIndex + 1];\n    }\n    /**\n     * Will always return a range, even if it is not intersecting with a sampled model line.\n     */\n    decorationLineRangeToMinimapLineRange(startLineNumber, endLineNumber) {\n        let minimapLineStart = this.modelLineToMinimapLine(startLineNumber);\n        let minimapLineEnd = this.modelLineToMinimapLine(endLineNumber);\n        if (startLineNumber !== endLineNumber && minimapLineEnd === minimapLineStart) {\n            if (minimapLineEnd === this.minimapLines.length) {\n                if (minimapLineStart > 1) {\n                    minimapLineStart--;\n                }\n            }\n            else {\n                minimapLineEnd++;\n            }\n        }\n        return [minimapLineStart, minimapLineEnd];\n    }\n    onLinesDeleted(e) {\n        // have the mapping be sticky\n        const deletedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n        let changeStartIndex = this.minimapLines.length;\n        let changeEndIndex = 0;\n        for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n            if (this.minimapLines[i] < e.fromLineNumber) {\n                break;\n            }\n            if (this.minimapLines[i] <= e.toLineNumber) {\n                // this line got deleted => move to previous available\n                this.minimapLines[i] = Math.max(1, e.fromLineNumber - 1);\n                changeStartIndex = Math.min(changeStartIndex, i);\n                changeEndIndex = Math.max(changeEndIndex, i);\n            }\n            else {\n                this.minimapLines[i] -= deletedLineCount;\n            }\n        }\n        return [changeStartIndex, changeEndIndex];\n    }\n    onLinesInserted(e) {\n        // have the mapping be sticky\n        const insertedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n        for (let i = this.minimapLines.length - 1; i >= 0; i--) {\n            if (this.minimapLines[i] < e.fromLineNumber) {\n                break;\n            }\n            this.minimapLines[i] += insertedLineCount;\n        }\n    }\n}\nexport class Minimap extends ViewPart {\n    constructor(context) {\n        super(context);\n        this._sectionHeaderCache = new LRUCache(10, 1.5);\n        this.tokensColorTracker = MinimapTokensColorTracker.getInstance();\n        this._selections = [];\n        this._minimapSelections = null;\n        this.options = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n        const [samplingState,] = MinimapSamplingState.compute(this.options, this._context.viewModel.getLineCount(), null);\n        this._samplingState = samplingState;\n        this._shouldCheckSampling = false;\n        this._actual = new InnerMinimap(context.theme, this);\n    }\n    dispose() {\n        this._actual.dispose();\n        super.dispose();\n    }\n    getDomNode() {\n        return this._actual.getDomNode();\n    }\n    _onOptionsMaybeChanged() {\n        const opts = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n        if (this.options.equals(opts)) {\n            return false;\n        }\n        this.options = opts;\n        this._recreateLineSampling();\n        this._actual.onDidChangeOptions();\n        return true;\n    }\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        return this._onOptionsMaybeChanged();\n    }\n    onCursorStateChanged(e) {\n        this._selections = e.selections;\n        this._minimapSelections = null;\n        return this._actual.onSelectionChanged();\n    }\n    onDecorationsChanged(e) {\n        if (e.affectsMinimap) {\n            return this._actual.onDecorationsChanged();\n        }\n        return false;\n    }\n    onFlushed(e) {\n        if (this._samplingState) {\n            this._shouldCheckSampling = true;\n        }\n        return this._actual.onFlushed();\n    }\n    onLinesChanged(e) {\n        if (this._samplingState) {\n            const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.fromLineNumber + e.count - 1);\n            if (minimapLineRange) {\n                return this._actual.onLinesChanged(minimapLineRange[0], minimapLineRange[1] - minimapLineRange[0] + 1);\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return this._actual.onLinesChanged(e.fromLineNumber, e.count);\n        }\n    }\n    onLinesDeleted(e) {\n        if (this._samplingState) {\n            const [changeStartIndex, changeEndIndex] = this._samplingState.onLinesDeleted(e);\n            if (changeStartIndex <= changeEndIndex) {\n                this._actual.onLinesChanged(changeStartIndex + 1, changeEndIndex - changeStartIndex + 1);\n            }\n            this._shouldCheckSampling = true;\n            return true;\n        }\n        else {\n            return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n        }\n    }\n    onLinesInserted(e) {\n        if (this._samplingState) {\n            this._samplingState.onLinesInserted(e);\n            this._shouldCheckSampling = true;\n            return true;\n        }\n        else {\n            return this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n        }\n    }\n    onScrollChanged(e) {\n        return this._actual.onScrollChanged();\n    }\n    onThemeChanged(e) {\n        this._actual.onThemeChanged();\n        this._onOptionsMaybeChanged();\n        return true;\n    }\n    onTokensChanged(e) {\n        if (this._samplingState) {\n            const ranges = [];\n            for (const range of e.ranges) {\n                const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(range.fromLineNumber, range.toLineNumber);\n                if (minimapLineRange) {\n                    ranges.push({ fromLineNumber: minimapLineRange[0], toLineNumber: minimapLineRange[1] });\n                }\n            }\n            if (ranges.length) {\n                return this._actual.onTokensChanged(ranges);\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return this._actual.onTokensChanged(e.ranges);\n        }\n    }\n    onTokensColorsChanged(e) {\n        this._onOptionsMaybeChanged();\n        return this._actual.onTokensColorsChanged();\n    }\n    onZonesChanged(e) {\n        return this._actual.onZonesChanged();\n    }\n    // --- end event handlers\n    prepareRender(ctx) {\n        if (this._shouldCheckSampling) {\n            this._shouldCheckSampling = false;\n            this._recreateLineSampling();\n        }\n    }\n    render(ctx) {\n        let viewportStartLineNumber = ctx.visibleRange.startLineNumber;\n        let viewportEndLineNumber = ctx.visibleRange.endLineNumber;\n        if (this._samplingState) {\n            viewportStartLineNumber = this._samplingState.modelLineToMinimapLine(viewportStartLineNumber);\n            viewportEndLineNumber = this._samplingState.modelLineToMinimapLine(viewportEndLineNumber);\n        }\n        const minimapCtx = {\n            viewportContainsWhitespaceGaps: (ctx.viewportData.whitespaceViewportData.length > 0),\n            scrollWidth: ctx.scrollWidth,\n            scrollHeight: ctx.scrollHeight,\n            viewportStartLineNumber: viewportStartLineNumber,\n            viewportEndLineNumber: viewportEndLineNumber,\n            viewportStartLineNumberVerticalOffset: ctx.getVerticalOffsetForLineNumber(viewportStartLineNumber),\n            scrollTop: ctx.scrollTop,\n            scrollLeft: ctx.scrollLeft,\n            viewportWidth: ctx.viewportWidth,\n            viewportHeight: ctx.viewportHeight,\n        };\n        this._actual.render(minimapCtx);\n    }\n    //#region IMinimapModel\n    _recreateLineSampling() {\n        this._minimapSelections = null;\n        const wasSampling = Boolean(this._samplingState);\n        const [samplingState, events] = MinimapSamplingState.compute(this.options, this._context.viewModel.getLineCount(), this._samplingState);\n        this._samplingState = samplingState;\n        if (wasSampling && this._samplingState) {\n            // was sampling, is sampling\n            for (const event of events) {\n                switch (event.type) {\n                    case 'deleted':\n                        this._actual.onLinesDeleted(event.deleteFromLineNumber, event.deleteToLineNumber);\n                        break;\n                    case 'inserted':\n                        this._actual.onLinesInserted(event.insertFromLineNumber, event.insertToLineNumber);\n                        break;\n                    case 'flush':\n                        this._actual.onFlushed();\n                        break;\n                }\n            }\n        }\n    }\n    getLineCount() {\n        if (this._samplingState) {\n            return this._samplingState.minimapLines.length;\n        }\n        return this._context.viewModel.getLineCount();\n    }\n    getRealLineCount() {\n        return this._context.viewModel.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        if (this._samplingState) {\n            return this._context.viewModel.getLineContent(this._samplingState.minimapLines[lineNumber - 1]);\n        }\n        return this._context.viewModel.getLineContent(lineNumber);\n    }\n    getLineMaxColumn(lineNumber) {\n        if (this._samplingState) {\n            return this._context.viewModel.getLineMaxColumn(this._samplingState.minimapLines[lineNumber - 1]);\n        }\n        return this._context.viewModel.getLineMaxColumn(lineNumber);\n    }\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n        if (this._samplingState) {\n            const result = [];\n            for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n                if (needed[lineIndex]) {\n                    result[lineIndex] = this._context.viewModel.getViewLineData(this._samplingState.minimapLines[startLineNumber + lineIndex - 1]);\n                }\n                else {\n                    result[lineIndex] = null;\n                }\n            }\n            return result;\n        }\n        return this._context.viewModel.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed).data;\n    }\n    getSelections() {\n        if (this._minimapSelections === null) {\n            if (this._samplingState) {\n                this._minimapSelections = [];\n                for (const selection of this._selections) {\n                    const [minimapLineStart, minimapLineEnd] = this._samplingState.decorationLineRangeToMinimapLineRange(selection.startLineNumber, selection.endLineNumber);\n                    this._minimapSelections.push(new Selection(minimapLineStart, selection.startColumn, minimapLineEnd, selection.endColumn));\n                }\n            }\n            else {\n                this._minimapSelections = this._selections;\n            }\n        }\n        return this._minimapSelections;\n    }\n    getMinimapDecorationsInViewport(startLineNumber, endLineNumber) {\n        const decorations = this._getMinimapDecorationsInViewport(startLineNumber, endLineNumber)\n            .filter(decoration => { var _a; return !((_a = decoration.options.minimap) === null || _a === void 0 ? void 0 : _a.sectionHeaderStyle); });\n        if (this._samplingState) {\n            const result = [];\n            for (const decoration of decorations) {\n                if (!decoration.options.minimap) {\n                    continue;\n                }\n                const range = decoration.range;\n                const minimapStartLineNumber = this._samplingState.modelLineToMinimapLine(range.startLineNumber);\n                const minimapEndLineNumber = this._samplingState.modelLineToMinimapLine(range.endLineNumber);\n                result.push(new ViewModelDecoration(new Range(minimapStartLineNumber, range.startColumn, minimapEndLineNumber, range.endColumn), decoration.options));\n            }\n            return result;\n        }\n        return decorations;\n    }\n    getSectionHeaderDecorationsInViewport(startLineNumber, endLineNumber) {\n        const minimapLineHeight = this.options.minimapLineHeight;\n        const sectionHeaderFontSize = this.options.sectionHeaderFontSize;\n        const headerHeightInMinimapLines = sectionHeaderFontSize / minimapLineHeight;\n        startLineNumber = Math.floor(Math.max(1, startLineNumber - headerHeightInMinimapLines));\n        return this._getMinimapDecorationsInViewport(startLineNumber, endLineNumber)\n            .filter(decoration => { var _a; return !!((_a = decoration.options.minimap) === null || _a === void 0 ? void 0 : _a.sectionHeaderStyle); });\n    }\n    _getMinimapDecorationsInViewport(startLineNumber, endLineNumber) {\n        let visibleRange;\n        if (this._samplingState) {\n            const modelStartLineNumber = this._samplingState.minimapLines[startLineNumber - 1];\n            const modelEndLineNumber = this._samplingState.minimapLines[endLineNumber - 1];\n            visibleRange = new Range(modelStartLineNumber, 1, modelEndLineNumber, this._context.viewModel.getLineMaxColumn(modelEndLineNumber));\n        }\n        else {\n            visibleRange = new Range(startLineNumber, 1, endLineNumber, this._context.viewModel.getLineMaxColumn(endLineNumber));\n        }\n        return this._context.viewModel.getMinimapDecorationsInRange(visibleRange);\n    }\n    getSectionHeaderText(decoration, fitWidth) {\n        var _a;\n        const headerText = (_a = decoration.options.minimap) === null || _a === void 0 ? void 0 : _a.sectionHeaderText;\n        if (!headerText) {\n            return null;\n        }\n        const cachedText = this._sectionHeaderCache.get(headerText);\n        if (cachedText) {\n            return cachedText;\n        }\n        const fittedText = fitWidth(headerText);\n        this._sectionHeaderCache.set(headerText, fittedText);\n        return fittedText;\n    }\n    getOptions() {\n        return this._context.viewModel.model.getOptions();\n    }\n    revealLineNumber(lineNumber) {\n        if (this._samplingState) {\n            lineNumber = this._samplingState.minimapLines[lineNumber - 1];\n        }\n        this._context.viewModel.revealRange('mouse', false, new Range(lineNumber, 1, lineNumber, 1), 1 /* viewEvents.VerticalRevealType.Center */, 0 /* ScrollType.Smooth */);\n    }\n    setScrollTop(scrollTop) {\n        this._context.viewModel.viewLayout.setScrollPosition({\n            scrollTop: scrollTop\n        }, 1 /* ScrollType.Immediate */);\n    }\n}\nclass InnerMinimap extends Disposable {\n    constructor(theme, model) {\n        super();\n        this._renderDecorations = false;\n        this._gestureInProgress = false;\n        this._theme = theme;\n        this._model = model;\n        this._lastRenderData = null;\n        this._buffers = null;\n        this._selectionColor = this._theme.getColor(minimapSelection);\n        this._domNode = createFastDomNode(document.createElement('div'));\n        PartFingerprints.write(this._domNode, 9 /* PartFingerprint.Minimap */);\n        this._domNode.setClassName(this._getMinimapDomNodeClassName());\n        this._domNode.setPosition('absolute');\n        this._domNode.setAttribute('role', 'presentation');\n        this._domNode.setAttribute('aria-hidden', 'true');\n        this._shadow = createFastDomNode(document.createElement('div'));\n        this._shadow.setClassName('minimap-shadow-hidden');\n        this._domNode.appendChild(this._shadow);\n        this._canvas = createFastDomNode(document.createElement('canvas'));\n        this._canvas.setPosition('absolute');\n        this._canvas.setLeft(0);\n        this._domNode.appendChild(this._canvas);\n        this._decorationsCanvas = createFastDomNode(document.createElement('canvas'));\n        this._decorationsCanvas.setPosition('absolute');\n        this._decorationsCanvas.setClassName('minimap-decorations-layer');\n        this._decorationsCanvas.setLeft(0);\n        this._domNode.appendChild(this._decorationsCanvas);\n        this._slider = createFastDomNode(document.createElement('div'));\n        this._slider.setPosition('absolute');\n        this._slider.setClassName('minimap-slider');\n        this._slider.setLayerHinting(true);\n        this._slider.setContain('strict');\n        this._domNode.appendChild(this._slider);\n        this._sliderHorizontal = createFastDomNode(document.createElement('div'));\n        this._sliderHorizontal.setPosition('absolute');\n        this._sliderHorizontal.setClassName('minimap-slider-horizontal');\n        this._slider.appendChild(this._sliderHorizontal);\n        this._applyLayout();\n        this._pointerDownListener = dom.addStandardDisposableListener(this._domNode.domNode, dom.EventType.POINTER_DOWN, (e) => {\n            e.preventDefault();\n            const renderMinimap = this._model.options.renderMinimap;\n            if (renderMinimap === 0 /* RenderMinimap.None */) {\n                return;\n            }\n            if (!this._lastRenderData) {\n                return;\n            }\n            if (this._model.options.size !== 'proportional') {\n                if (e.button === 0 && this._lastRenderData) {\n                    // pretend the click occurred in the center of the slider\n                    const position = dom.getDomNodePagePosition(this._slider.domNode);\n                    const initialPosY = position.top + position.height / 2;\n                    this._startSliderDragging(e, initialPosY, this._lastRenderData.renderedLayout);\n                }\n                return;\n            }\n            const minimapLineHeight = this._model.options.minimapLineHeight;\n            const internalOffsetY = (this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight) * e.offsetY;\n            const lineIndex = Math.floor(internalOffsetY / minimapLineHeight);\n            let lineNumber = lineIndex + this._lastRenderData.renderedLayout.startLineNumber - this._lastRenderData.renderedLayout.topPaddingLineCount;\n            lineNumber = Math.min(lineNumber, this._model.getLineCount());\n            this._model.revealLineNumber(lineNumber);\n        });\n        this._sliderPointerMoveMonitor = new GlobalPointerMoveMonitor();\n        this._sliderPointerDownListener = dom.addStandardDisposableListener(this._slider.domNode, dom.EventType.POINTER_DOWN, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (e.button === 0 && this._lastRenderData) {\n                this._startSliderDragging(e, e.pageY, this._lastRenderData.renderedLayout);\n            }\n        });\n        this._gestureDisposable = Gesture.addTarget(this._domNode.domNode);\n        this._sliderTouchStartListener = dom.addDisposableListener(this._domNode.domNode, EventType.Start, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (this._lastRenderData) {\n                this._slider.toggleClassName('active', true);\n                this._gestureInProgress = true;\n                this.scrollDueToTouchEvent(e);\n            }\n        }, { passive: false });\n        this._sliderTouchMoveListener = dom.addDisposableListener(this._domNode.domNode, EventType.Change, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (this._lastRenderData && this._gestureInProgress) {\n                this.scrollDueToTouchEvent(e);\n            }\n        }, { passive: false });\n        this._sliderTouchEndListener = dom.addStandardDisposableListener(this._domNode.domNode, EventType.End, (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            this._gestureInProgress = false;\n            this._slider.toggleClassName('active', false);\n        });\n    }\n    _startSliderDragging(e, initialPosY, initialSliderState) {\n        if (!e.target || !(e.target instanceof Element)) {\n            return;\n        }\n        const initialPosX = e.pageX;\n        this._slider.toggleClassName('active', true);\n        const handlePointerMove = (posy, posx) => {\n            const minimapPosition = dom.getDomNodePagePosition(this._domNode.domNode);\n            const pointerOrthogonalDelta = Math.min(Math.abs(posx - initialPosX), Math.abs(posx - minimapPosition.left), Math.abs(posx - minimapPosition.left - minimapPosition.width));\n            if (platform.isWindows && pointerOrthogonalDelta > POINTER_DRAG_RESET_DISTANCE) {\n                // The pointer has wondered away from the scrollbar => reset dragging\n                this._model.setScrollTop(initialSliderState.scrollTop);\n                return;\n            }\n            const pointerDelta = posy - initialPosY;\n            this._model.setScrollTop(initialSliderState.getDesiredScrollTopFromDelta(pointerDelta));\n        };\n        if (e.pageY !== initialPosY) {\n            handlePointerMove(e.pageY, initialPosX);\n        }\n        this._sliderPointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, pointerMoveData => handlePointerMove(pointerMoveData.pageY, pointerMoveData.pageX), () => {\n            this._slider.toggleClassName('active', false);\n        });\n    }\n    scrollDueToTouchEvent(touch) {\n        const startY = this._domNode.domNode.getBoundingClientRect().top;\n        const scrollTop = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(touch.pageY - startY);\n        this._model.setScrollTop(scrollTop);\n    }\n    dispose() {\n        this._pointerDownListener.dispose();\n        this._sliderPointerMoveMonitor.dispose();\n        this._sliderPointerDownListener.dispose();\n        this._gestureDisposable.dispose();\n        this._sliderTouchStartListener.dispose();\n        this._sliderTouchMoveListener.dispose();\n        this._sliderTouchEndListener.dispose();\n        super.dispose();\n    }\n    _getMinimapDomNodeClassName() {\n        const class_ = ['minimap'];\n        if (this._model.options.showSlider === 'always') {\n            class_.push('slider-always');\n        }\n        else {\n            class_.push('slider-mouseover');\n        }\n        if (this._model.options.autohide) {\n            class_.push('autohide');\n        }\n        return class_.join(' ');\n    }\n    getDomNode() {\n        return this._domNode;\n    }\n    _applyLayout() {\n        this._domNode.setLeft(this._model.options.minimapLeft);\n        this._domNode.setWidth(this._model.options.minimapWidth);\n        this._domNode.setHeight(this._model.options.minimapHeight);\n        this._shadow.setHeight(this._model.options.minimapHeight);\n        this._canvas.setWidth(this._model.options.canvasOuterWidth);\n        this._canvas.setHeight(this._model.options.canvasOuterHeight);\n        this._canvas.domNode.width = this._model.options.canvasInnerWidth;\n        this._canvas.domNode.height = this._model.options.canvasInnerHeight;\n        this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth);\n        this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight);\n        this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth;\n        this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight;\n        this._slider.setWidth(this._model.options.minimapWidth);\n    }\n    _getBuffer() {\n        if (!this._buffers) {\n            if (this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0) {\n                this._buffers = new MinimapBuffers(this._canvas.domNode.getContext('2d'), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor);\n            }\n        }\n        return this._buffers ? this._buffers.getBuffer() : null;\n    }\n    // ---- begin view event handlers\n    onDidChangeOptions() {\n        this._lastRenderData = null;\n        this._buffers = null;\n        this._applyLayout();\n        this._domNode.setClassName(this._getMinimapDomNodeClassName());\n    }\n    onSelectionChanged() {\n        this._renderDecorations = true;\n        return true;\n    }\n    onDecorationsChanged() {\n        this._renderDecorations = true;\n        return true;\n    }\n    onFlushed() {\n        this._lastRenderData = null;\n        return true;\n    }\n    onLinesChanged(changeFromLineNumber, changeCount) {\n        if (this._lastRenderData) {\n            return this._lastRenderData.onLinesChanged(changeFromLineNumber, changeCount);\n        }\n        return false;\n    }\n    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n        var _a;\n        (_a = this._lastRenderData) === null || _a === void 0 ? void 0 : _a.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n        return true;\n    }\n    onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n        var _a;\n        (_a = this._lastRenderData) === null || _a === void 0 ? void 0 : _a.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n        return true;\n    }\n    onScrollChanged() {\n        this._renderDecorations = true;\n        return true;\n    }\n    onThemeChanged() {\n        this._selectionColor = this._theme.getColor(minimapSelection);\n        this._renderDecorations = true;\n        return true;\n    }\n    onTokensChanged(ranges) {\n        if (this._lastRenderData) {\n            return this._lastRenderData.onTokensChanged(ranges);\n        }\n        return false;\n    }\n    onTokensColorsChanged() {\n        this._lastRenderData = null;\n        this._buffers = null;\n        return true;\n    }\n    onZonesChanged() {\n        this._lastRenderData = null;\n        return true;\n    }\n    // --- end event handlers\n    render(renderingCtx) {\n        const renderMinimap = this._model.options.renderMinimap;\n        if (renderMinimap === 0 /* RenderMinimap.None */) {\n            this._shadow.setClassName('minimap-shadow-hidden');\n            this._sliderHorizontal.setWidth(0);\n            this._sliderHorizontal.setHeight(0);\n            return;\n        }\n        if (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth) {\n            this._shadow.setClassName('minimap-shadow-hidden');\n        }\n        else {\n            this._shadow.setClassName('minimap-shadow-visible');\n        }\n        const layout = MinimapLayout.create(this._model.options, renderingCtx.viewportStartLineNumber, renderingCtx.viewportEndLineNumber, renderingCtx.viewportStartLineNumberVerticalOffset, renderingCtx.viewportHeight, renderingCtx.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), renderingCtx.scrollTop, renderingCtx.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);\n        this._slider.setDisplay(layout.sliderNeeded ? 'block' : 'none');\n        this._slider.setTop(layout.sliderTop);\n        this._slider.setHeight(layout.sliderHeight);\n        // Compute horizontal slider coordinates\n        this._sliderHorizontal.setLeft(0);\n        this._sliderHorizontal.setWidth(this._model.options.minimapWidth);\n        this._sliderHorizontal.setTop(0);\n        this._sliderHorizontal.setHeight(layout.sliderHeight);\n        this.renderDecorations(layout);\n        this._lastRenderData = this.renderLines(layout);\n    }\n    renderDecorations(layout) {\n        if (this._renderDecorations) {\n            this._renderDecorations = false;\n            const selections = this._model.getSelections();\n            selections.sort(Range.compareRangesUsingStarts);\n            const decorations = this._model.getMinimapDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\n            decorations.sort((a, b) => (a.options.zIndex || 0) - (b.options.zIndex || 0));\n            const { canvasInnerWidth, canvasInnerHeight } = this._model.options;\n            const minimapLineHeight = this._model.options.minimapLineHeight;\n            const minimapCharWidth = this._model.options.minimapCharWidth;\n            const tabSize = this._model.getOptions().tabSize;\n            const canvasContext = this._decorationsCanvas.domNode.getContext('2d');\n            canvasContext.clearRect(0, 0, canvasInnerWidth, canvasInnerHeight);\n            // We first need to render line highlights and then render decorations on top of those.\n            // But we need to pick a single color for each line, and use that as a line highlight.\n            // This needs to be the color of the decoration with the highest `zIndex`, but priority\n            // is given to the selection.\n            const highlightedLines = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, false);\n            this._renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, minimapLineHeight);\n            this._renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, minimapLineHeight);\n            const lineOffsetMap = new ContiguousLineMap(layout.startLineNumber, layout.endLineNumber, null);\n            this._renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, minimapLineHeight, tabSize, minimapCharWidth, canvasInnerWidth);\n            this._renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, minimapLineHeight, tabSize, minimapCharWidth, canvasInnerWidth);\n            this._renderSectionHeaders(layout);\n        }\n    }\n    _renderSelectionLineHighlights(canvasContext, selections, highlightedLines, layout, minimapLineHeight) {\n        if (!this._selectionColor || this._selectionColor.isTransparent()) {\n            return;\n        }\n        canvasContext.fillStyle = this._selectionColor.transparent(0.5).toString();\n        let y1 = 0;\n        let y2 = 0;\n        for (const selection of selections) {\n            const intersection = layout.intersectWithViewport(selection);\n            if (!intersection) {\n                // entirely outside minimap's viewport\n                continue;\n            }\n            const [startLineNumber, endLineNumber] = intersection;\n            for (let line = startLineNumber; line <= endLineNumber; line++) {\n                highlightedLines.set(line, true);\n            }\n            const yy1 = layout.getYForLineNumber(startLineNumber, minimapLineHeight);\n            const yy2 = layout.getYForLineNumber(endLineNumber, minimapLineHeight);\n            if (y2 >= yy1) {\n                // merge into previous\n                y2 = yy2;\n            }\n            else {\n                if (y2 > y1) {\n                    // flush\n                    canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n                }\n                y1 = yy1;\n                y2 = yy2;\n            }\n        }\n        if (y2 > y1) {\n            // flush\n            canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y1, canvasContext.canvas.width, y2 - y1);\n        }\n    }\n    _renderDecorationsLineHighlights(canvasContext, decorations, highlightedLines, layout, minimapLineHeight) {\n        const highlightColors = new Map();\n        // Loop backwards to hit first decorations with higher `zIndex`\n        for (let i = decorations.length - 1; i >= 0; i--) {\n            const decoration = decorations[i];\n            const minimapOptions = decoration.options.minimap;\n            if (!minimapOptions || minimapOptions.position !== 1 /* MinimapPosition.Inline */) {\n                continue;\n            }\n            const intersection = layout.intersectWithViewport(decoration.range);\n            if (!intersection) {\n                // entirely outside minimap's viewport\n                continue;\n            }\n            const [startLineNumber, endLineNumber] = intersection;\n            const decorationColor = minimapOptions.getColor(this._theme.value);\n            if (!decorationColor || decorationColor.isTransparent()) {\n                continue;\n            }\n            let highlightColor = highlightColors.get(decorationColor.toString());\n            if (!highlightColor) {\n                highlightColor = decorationColor.transparent(0.5).toString();\n                highlightColors.set(decorationColor.toString(), highlightColor);\n            }\n            canvasContext.fillStyle = highlightColor;\n            for (let line = startLineNumber; line <= endLineNumber; line++) {\n                if (highlightedLines.has(line)) {\n                    continue;\n                }\n                highlightedLines.set(line, true);\n                const y = layout.getYForLineNumber(startLineNumber, minimapLineHeight);\n                canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y, canvasContext.canvas.width, minimapLineHeight);\n            }\n        }\n    }\n    _renderSelectionsHighlights(canvasContext, selections, lineOffsetMap, layout, lineHeight, tabSize, characterWidth, canvasInnerWidth) {\n        if (!this._selectionColor || this._selectionColor.isTransparent()) {\n            return;\n        }\n        for (const selection of selections) {\n            const intersection = layout.intersectWithViewport(selection);\n            if (!intersection) {\n                // entirely outside minimap's viewport\n                continue;\n            }\n            const [startLineNumber, endLineNumber] = intersection;\n            for (let line = startLineNumber; line <= endLineNumber; line++) {\n                this.renderDecorationOnLine(canvasContext, lineOffsetMap, selection, this._selectionColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth, canvasInnerWidth);\n            }\n        }\n    }\n    _renderDecorationsHighlights(canvasContext, decorations, lineOffsetMap, layout, minimapLineHeight, tabSize, characterWidth, canvasInnerWidth) {\n        // Loop forwards to hit first decorations with lower `zIndex`\n        for (const decoration of decorations) {\n            const minimapOptions = decoration.options.minimap;\n            if (!minimapOptions) {\n                continue;\n            }\n            const intersection = layout.intersectWithViewport(decoration.range);\n            if (!intersection) {\n                // entirely outside minimap's viewport\n                continue;\n            }\n            const [startLineNumber, endLineNumber] = intersection;\n            const decorationColor = minimapOptions.getColor(this._theme.value);\n            if (!decorationColor || decorationColor.isTransparent()) {\n                continue;\n            }\n            for (let line = startLineNumber; line <= endLineNumber; line++) {\n                switch (minimapOptions.position) {\n                    case 1 /* MinimapPosition.Inline */:\n                        this.renderDecorationOnLine(canvasContext, lineOffsetMap, decoration.range, decorationColor, layout, line, minimapLineHeight, minimapLineHeight, tabSize, characterWidth, canvasInnerWidth);\n                        continue;\n                    case 2 /* MinimapPosition.Gutter */: {\n                        const y = layout.getYForLineNumber(line, minimapLineHeight);\n                        const x = 2;\n                        this.renderDecoration(canvasContext, decorationColor, x, y, GUTTER_DECORATION_WIDTH, minimapLineHeight);\n                        continue;\n                    }\n                }\n            }\n        }\n    }\n    renderDecorationOnLine(canvasContext, lineOffsetMap, decorationRange, decorationColor, layout, lineNumber, height, minimapLineHeight, tabSize, charWidth, canvasInnerWidth) {\n        const y = layout.getYForLineNumber(lineNumber, minimapLineHeight);\n        // Skip rendering the line if it's vertically outside our viewport\n        if (y + height < 0 || y > this._model.options.canvasInnerHeight) {\n            return;\n        }\n        const { startLineNumber, endLineNumber } = decorationRange;\n        const startColumn = (startLineNumber === lineNumber ? decorationRange.startColumn : 1);\n        const endColumn = (endLineNumber === lineNumber ? decorationRange.endColumn : this._model.getLineMaxColumn(lineNumber));\n        const x1 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, startColumn, tabSize, charWidth, canvasInnerWidth);\n        const x2 = this.getXOffsetForPosition(lineOffsetMap, lineNumber, endColumn, tabSize, charWidth, canvasInnerWidth);\n        this.renderDecoration(canvasContext, decorationColor, x1, y, x2 - x1, height);\n    }\n    getXOffsetForPosition(lineOffsetMap, lineNumber, column, tabSize, charWidth, canvasInnerWidth) {\n        if (column === 1) {\n            return MINIMAP_GUTTER_WIDTH;\n        }\n        const minimumXOffset = (column - 1) * charWidth;\n        if (minimumXOffset >= canvasInnerWidth) {\n            // there is no need to look at actual characters,\n            // as this column is certainly after the minimap width\n            return canvasInnerWidth;\n        }\n        // Cache line offset data so that it is only read once per line\n        let lineIndexToXOffset = lineOffsetMap.get(lineNumber);\n        if (!lineIndexToXOffset) {\n            const lineData = this._model.getLineContent(lineNumber);\n            lineIndexToXOffset = [MINIMAP_GUTTER_WIDTH];\n            let prevx = MINIMAP_GUTTER_WIDTH;\n            for (let i = 1; i < lineData.length + 1; i++) {\n                const charCode = lineData.charCodeAt(i - 1);\n                const dx = charCode === 9 /* CharCode.Tab */\n                    ? tabSize * charWidth\n                    : strings.isFullWidthCharacter(charCode)\n                        ? 2 * charWidth\n                        : charWidth;\n                const x = prevx + dx;\n                if (x >= canvasInnerWidth) {\n                    // no need to keep on going, as we've hit the canvas width\n                    lineIndexToXOffset[i] = canvasInnerWidth;\n                    break;\n                }\n                lineIndexToXOffset[i] = x;\n                prevx = x;\n            }\n            lineOffsetMap.set(lineNumber, lineIndexToXOffset);\n        }\n        if (column - 1 < lineIndexToXOffset.length) {\n            return lineIndexToXOffset[column - 1];\n        }\n        // goes over the canvas width\n        return canvasInnerWidth;\n    }\n    renderDecoration(canvasContext, decorationColor, x, y, width, height) {\n        canvasContext.fillStyle = decorationColor && decorationColor.toString() || '';\n        canvasContext.fillRect(x, y, width, height);\n    }\n    _renderSectionHeaders(layout) {\n        var _a;\n        const minimapLineHeight = this._model.options.minimapLineHeight;\n        const sectionHeaderFontSize = this._model.options.sectionHeaderFontSize;\n        const backgroundFillHeight = sectionHeaderFontSize * 1.5;\n        const { canvasInnerWidth } = this._model.options;\n        const backgroundColor = this._model.options.backgroundColor;\n        const backgroundFill = `rgb(${backgroundColor.r} ${backgroundColor.g} ${backgroundColor.b} / .7)`;\n        const foregroundColor = this._model.options.sectionHeaderFontColor;\n        const foregroundFill = `rgb(${foregroundColor.r} ${foregroundColor.g} ${foregroundColor.b})`;\n        const separatorStroke = foregroundFill;\n        const canvasContext = this._decorationsCanvas.domNode.getContext('2d');\n        canvasContext.font = sectionHeaderFontSize + 'px ' + this._model.options.sectionHeaderFontFamily;\n        canvasContext.strokeStyle = separatorStroke;\n        canvasContext.lineWidth = 0.2;\n        const decorations = this._model.getSectionHeaderDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\n        decorations.sort((a, b) => a.range.startLineNumber - b.range.startLineNumber);\n        const fitWidth = InnerMinimap._fitSectionHeader.bind(null, canvasContext, canvasInnerWidth - MINIMAP_GUTTER_WIDTH);\n        for (const decoration of decorations) {\n            const y = layout.getYForLineNumber(decoration.range.startLineNumber, minimapLineHeight) + sectionHeaderFontSize;\n            const backgroundFillY = y - sectionHeaderFontSize;\n            const separatorY = backgroundFillY + 2;\n            const headerText = this._model.getSectionHeaderText(decoration, fitWidth);\n            InnerMinimap._renderSectionLabel(canvasContext, headerText, ((_a = decoration.options.minimap) === null || _a === void 0 ? void 0 : _a.sectionHeaderStyle) === 2 /* MinimapSectionHeaderStyle.Underlined */, backgroundFill, foregroundFill, canvasInnerWidth, backgroundFillY, backgroundFillHeight, y, separatorY);\n        }\n    }\n    static _fitSectionHeader(target, maxWidth, headerText) {\n        if (!headerText) {\n            return headerText;\n        }\n        const ellipsis = '…';\n        const width = target.measureText(headerText).width;\n        const ellipsisWidth = target.measureText(ellipsis).width;\n        if (width <= maxWidth || width <= ellipsisWidth) {\n            return headerText;\n        }\n        const len = headerText.length;\n        const averageCharWidth = width / headerText.length;\n        const maxCharCount = Math.floor((maxWidth - ellipsisWidth) / averageCharWidth) - 1;\n        // Find a halfway point that isn't after whitespace\n        let halfCharCount = Math.ceil(maxCharCount / 2);\n        while (halfCharCount > 0 && /\\s/.test(headerText[halfCharCount - 1])) {\n            --halfCharCount;\n        }\n        // Split with ellipsis\n        return headerText.substring(0, halfCharCount)\n            + ellipsis + headerText.substring(len - (maxCharCount - halfCharCount));\n    }\n    static _renderSectionLabel(target, headerText, hasSeparatorLine, backgroundFill, foregroundFill, minimapWidth, backgroundFillY, backgroundFillHeight, textY, separatorY) {\n        if (headerText) {\n            target.fillStyle = backgroundFill;\n            target.fillRect(0, backgroundFillY, minimapWidth, backgroundFillHeight);\n            target.fillStyle = foregroundFill;\n            target.fillText(headerText, MINIMAP_GUTTER_WIDTH, textY);\n        }\n        if (hasSeparatorLine) {\n            target.beginPath();\n            target.moveTo(0, separatorY);\n            target.lineTo(minimapWidth, separatorY);\n            target.closePath();\n            target.stroke();\n        }\n    }\n    renderLines(layout) {\n        const startLineNumber = layout.startLineNumber;\n        const endLineNumber = layout.endLineNumber;\n        const minimapLineHeight = this._model.options.minimapLineHeight;\n        // Check if nothing changed w.r.t. lines from last frame\n        if (this._lastRenderData && this._lastRenderData.linesEquals(layout)) {\n            const _lastData = this._lastRenderData._get();\n            // Nice!! Nothing changed from last frame\n            return new RenderData(layout, _lastData.imageData, _lastData.lines);\n        }\n        // Oh well!! We need to repaint some lines...\n        const imageData = this._getBuffer();\n        if (!imageData) {\n            // 0 width or 0 height canvas, nothing to do\n            return null;\n        }\n        // Render untouched lines by using last rendered data.\n        const [_dirtyY1, _dirtyY2, needed] = InnerMinimap._renderUntouchedLines(imageData, layout.topPaddingLineCount, startLineNumber, endLineNumber, minimapLineHeight, this._lastRenderData);\n        // Fetch rendering info from view model for rest of lines that need rendering.\n        const lineInfo = this._model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed);\n        const tabSize = this._model.getOptions().tabSize;\n        const defaultBackground = this._model.options.defaultBackgroundColor;\n        const background = this._model.options.backgroundColor;\n        const foregroundAlpha = this._model.options.foregroundAlpha;\n        const tokensColorTracker = this._model.tokensColorTracker;\n        const useLighterFont = tokensColorTracker.backgroundIsLight();\n        const renderMinimap = this._model.options.renderMinimap;\n        const charRenderer = this._model.options.charRenderer();\n        const fontScale = this._model.options.fontScale;\n        const minimapCharWidth = this._model.options.minimapCharWidth;\n        const baseCharHeight = (renderMinimap === 1 /* RenderMinimap.Text */ ? 2 /* Constants.BASE_CHAR_HEIGHT */ : 2 /* Constants.BASE_CHAR_HEIGHT */ + 1);\n        const renderMinimapLineHeight = baseCharHeight * fontScale;\n        const innerLinePadding = (minimapLineHeight > renderMinimapLineHeight ? Math.floor((minimapLineHeight - renderMinimapLineHeight) / 2) : 0);\n        // Render the rest of lines\n        const backgroundA = background.a / 255;\n        const renderBackground = new RGBA8(Math.round((background.r - defaultBackground.r) * backgroundA + defaultBackground.r), Math.round((background.g - defaultBackground.g) * backgroundA + defaultBackground.g), Math.round((background.b - defaultBackground.b) * backgroundA + defaultBackground.b), 255);\n        let dy = layout.topPaddingLineCount * minimapLineHeight;\n        const renderedLines = [];\n        for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n            if (needed[lineIndex]) {\n                InnerMinimap._renderLine(imageData, renderBackground, background.a, useLighterFont, renderMinimap, minimapCharWidth, tokensColorTracker, foregroundAlpha, charRenderer, dy, innerLinePadding, tabSize, lineInfo[lineIndex], fontScale, minimapLineHeight);\n            }\n            renderedLines[lineIndex] = new MinimapLine(dy);\n            dy += minimapLineHeight;\n        }\n        const dirtyY1 = (_dirtyY1 === -1 ? 0 : _dirtyY1);\n        const dirtyY2 = (_dirtyY2 === -1 ? imageData.height : _dirtyY2);\n        const dirtyHeight = dirtyY2 - dirtyY1;\n        // Finally, paint to the canvas\n        const ctx = this._canvas.domNode.getContext('2d');\n        ctx.putImageData(imageData, 0, 0, 0, dirtyY1, imageData.width, dirtyHeight);\n        // Save rendered data for reuse on next frame if possible\n        return new RenderData(layout, imageData, renderedLines);\n    }\n    static _renderUntouchedLines(target, topPaddingLineCount, startLineNumber, endLineNumber, minimapLineHeight, lastRenderData) {\n        const needed = [];\n        if (!lastRenderData) {\n            for (let i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {\n                needed[i] = true;\n            }\n            return [-1, -1, needed];\n        }\n        const _lastData = lastRenderData._get();\n        const lastTargetData = _lastData.imageData.data;\n        const lastStartLineNumber = _lastData.rendLineNumberStart;\n        const lastLines = _lastData.lines;\n        const lastLinesLength = lastLines.length;\n        const WIDTH = target.width;\n        const targetData = target.data;\n        const maxDestPixel = (endLineNumber - startLineNumber + 1) * minimapLineHeight * WIDTH * 4;\n        let dirtyPixel1 = -1; // the pixel offset up to which all the data is equal to the prev frame\n        let dirtyPixel2 = -1; // the pixel offset after which all the data is equal to the prev frame\n        let copySourceStart = -1;\n        let copySourceEnd = -1;\n        let copyDestStart = -1;\n        let copyDestEnd = -1;\n        let dest_dy = topPaddingLineCount * minimapLineHeight;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineIndex = lineNumber - startLineNumber;\n            const lastLineIndex = lineNumber - lastStartLineNumber;\n            const source_dy = (lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? lastLines[lastLineIndex].dy : -1);\n            if (source_dy === -1) {\n                needed[lineIndex] = true;\n                dest_dy += minimapLineHeight;\n                continue;\n            }\n            const sourceStart = source_dy * WIDTH * 4;\n            const sourceEnd = (source_dy + minimapLineHeight) * WIDTH * 4;\n            const destStart = dest_dy * WIDTH * 4;\n            const destEnd = (dest_dy + minimapLineHeight) * WIDTH * 4;\n            if (copySourceEnd === sourceStart && copyDestEnd === destStart) {\n                // contiguous zone => extend copy request\n                copySourceEnd = sourceEnd;\n                copyDestEnd = destEnd;\n            }\n            else {\n                if (copySourceStart !== -1) {\n                    // flush existing copy request\n                    targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n                    if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n                        dirtyPixel1 = copySourceEnd;\n                    }\n                    if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n                        dirtyPixel2 = copySourceStart;\n                    }\n                }\n                copySourceStart = sourceStart;\n                copySourceEnd = sourceEnd;\n                copyDestStart = destStart;\n                copyDestEnd = destEnd;\n            }\n            needed[lineIndex] = false;\n            dest_dy += minimapLineHeight;\n        }\n        if (copySourceStart !== -1) {\n            // flush existing copy request\n            targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n            if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n                dirtyPixel1 = copySourceEnd;\n            }\n            if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n                dirtyPixel2 = copySourceStart;\n            }\n        }\n        const dirtyY1 = (dirtyPixel1 === -1 ? -1 : dirtyPixel1 / (WIDTH * 4));\n        const dirtyY2 = (dirtyPixel2 === -1 ? -1 : dirtyPixel2 / (WIDTH * 4));\n        return [dirtyY1, dirtyY2, needed];\n    }\n    static _renderLine(target, backgroundColor, backgroundAlpha, useLighterFont, renderMinimap, charWidth, colorTracker, foregroundAlpha, minimapCharRenderer, dy, innerLinePadding, tabSize, lineData, fontScale, minimapLineHeight) {\n        const content = lineData.content;\n        const tokens = lineData.tokens;\n        const maxDx = target.width - charWidth;\n        const force1pxHeight = (minimapLineHeight === 1);\n        let dx = MINIMAP_GUTTER_WIDTH;\n        let charIndex = 0;\n        let tabsCharDelta = 0;\n        for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n            const tokenEndIndex = tokens.getEndOffset(tokenIndex);\n            const tokenColorId = tokens.getForeground(tokenIndex);\n            const tokenColor = colorTracker.getColor(tokenColorId);\n            for (; charIndex < tokenEndIndex; charIndex++) {\n                if (dx > maxDx) {\n                    // hit edge of minimap\n                    return;\n                }\n                const charCode = content.charCodeAt(charIndex);\n                if (charCode === 9 /* CharCode.Tab */) {\n                    const insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                    tabsCharDelta += insertSpacesCount - 1;\n                    // No need to render anything since tab is invisible\n                    dx += insertSpacesCount * charWidth;\n                }\n                else if (charCode === 32 /* CharCode.Space */) {\n                    // No need to render anything since space is invisible\n                    dx += charWidth;\n                }\n                else {\n                    // Render twice for a full width character\n                    const count = strings.isFullWidthCharacter(charCode) ? 2 : 1;\n                    for (let i = 0; i < count; i++) {\n                        if (renderMinimap === 2 /* RenderMinimap.Blocks */) {\n                            minimapCharRenderer.blockRenderChar(target, dx, dy + innerLinePadding, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, force1pxHeight);\n                        }\n                        else { // RenderMinimap.Text\n                            minimapCharRenderer.renderChar(target, dx, dy + innerLinePadding, charCode, tokenColor, foregroundAlpha, backgroundColor, backgroundAlpha, fontScale, useLighterFont, force1pxHeight);\n                        }\n                        dx += charWidth;\n                        if (dx > maxDx) {\n                            // hit edge of minimap\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nclass ContiguousLineMap {\n    constructor(startLineNumber, endLineNumber, defaultValue) {\n        this._startLineNumber = startLineNumber;\n        this._endLineNumber = endLineNumber;\n        this._defaultValue = defaultValue;\n        this._values = [];\n        for (let i = 0, count = this._endLineNumber - this._startLineNumber + 1; i < count; i++) {\n            this._values[i] = defaultValue;\n        }\n    }\n    has(lineNumber) {\n        return (this.get(lineNumber) !== this._defaultValue);\n    }\n    set(lineNumber, value) {\n        if (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n            return;\n        }\n        this._values[lineNumber - this._startLineNumber] = value;\n    }\n    get(lineNumber) {\n        if (lineNumber < this._startLineNumber || lineNumber > this._endLineNumber) {\n            return this._defaultValue;\n        }\n        return this._values[lineNumber - this._startLineNumber];\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}