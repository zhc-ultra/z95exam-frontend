{"ast":null,"code":"import \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\n/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.48.0(0037b13fb5d186fdf1e7df51a9416a2de2b8c670)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\n// src/basic-languages/ruby/ruby.ts\nvar conf = {\n  comments: {\n    lineComment: \"#\",\n    blockComment: [\"=begin\", \"=end\"]\n  },\n  brackets: [[\"(\", \")\"], [\"{\", \"}\"], [\"[\", \"]\"]],\n  autoClosingPairs: [{\n    open: \"{\",\n    close: \"}\"\n  }, {\n    open: \"[\",\n    close: \"]\"\n  }, {\n    open: \"(\",\n    close: \")\"\n  }, {\n    open: '\"',\n    close: '\"'\n  }, {\n    open: \"'\",\n    close: \"'\"\n  }],\n  surroundingPairs: [{\n    open: \"{\",\n    close: \"}\"\n  }, {\n    open: \"[\",\n    close: \"]\"\n  }, {\n    open: \"(\",\n    close: \")\"\n  }, {\n    open: '\"',\n    close: '\"'\n  }, {\n    open: \"'\",\n    close: \"'\"\n  }],\n  indentationRules: {\n    increaseIndentPattern: new RegExp(\"^\\\\s*((begin|class|(private|protected)\\\\s+def|def|else|elsif|ensure|for|if|module|rescue|unless|until|when|while|case)|([^#]*\\\\sdo\\\\b)|([^#]*=\\\\s*(case|if|unless)))\\\\b([^#\\\\{;]|(\\\"|'|/).*\\\\4)*(#.*)?$\"),\n    decreaseIndentPattern: new RegExp(\"^\\\\s*([}\\\\]]([,)]?\\\\s*(#|$)|\\\\.[a-zA-Z_]\\\\w*\\\\b)|(end|rescue|ensure|else|elsif|when)\\\\b)\")\n  }\n};\nvar language = {\n  tokenPostfix: \".ruby\",\n  keywords: [\"__LINE__\", \"__ENCODING__\", \"__FILE__\", \"BEGIN\", \"END\", \"alias\", \"and\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"defined?\", \"do\", \"else\", \"elsif\", \"end\", \"ensure\", \"for\", \"false\", \"if\", \"in\", \"module\", \"next\", \"nil\", \"not\", \"or\", \"redo\", \"rescue\", \"retry\", \"return\", \"self\", \"super\", \"then\", \"true\", \"undef\", \"unless\", \"until\", \"when\", \"while\", \"yield\"],\n  keywordops: [\"::\", \"..\", \"...\", \"?\", \":\", \"=>\"],\n  builtins: [\"require\", \"public\", \"private\", \"include\", \"extend\", \"attr_reader\", \"protected\", \"private_class_method\", \"protected_class_method\", \"new\"],\n  // these are closed by 'end' (if, while and until are handled separately)\n  declarations: [\"module\", \"class\", \"def\", \"case\", \"do\", \"begin\", \"for\", \"if\", \"while\", \"until\", \"unless\"],\n  linedecls: [\"def\", \"case\", \"do\", \"begin\", \"for\", \"if\", \"while\", \"until\", \"unless\"],\n  operators: [\"^\", \"&\", \"|\", \"<=>\", \"==\", \"===\", \"!~\", \"=~\", \">\", \">=\", \"<\", \"<=\", \"<<\", \">>\", \"+\", \"-\", \"*\", \"/\", \"%\", \"**\", \"~\", \"+@\", \"-@\", \"[]\", \"[]=\", \"`\", \"+=\", \"-=\", \"*=\", \"**=\", \"/=\", \"^=\", \"%=\", \"<<=\", \">>=\", \"&=\", \"&&=\", \"||=\", \"|=\"],\n  brackets: [{\n    open: \"(\",\n    close: \")\",\n    token: \"delimiter.parenthesis\"\n  }, {\n    open: \"{\",\n    close: \"}\",\n    token: \"delimiter.curly\"\n  }, {\n    open: \"[\",\n    close: \"]\",\n    token: \"delimiter.square\"\n  }],\n  // we include these common regular expressions\n  symbols: /[=><!~?:&|+\\-*\\/\\^%\\.]+/,\n  // escape sequences\n  escape: /(?:[abefnrstv\\\\\"'\\n\\r]|[0-7]{1,3}|x[0-9A-Fa-f]{1,2}|u[0-9A-Fa-f]{4})/,\n  escapes: /\\\\(?:C\\-(@escape|.)|c(@escape|.)|@escape)/,\n  decpart: /\\d(_?\\d)*/,\n  decimal: /0|@decpart/,\n  delim: /[^a-zA-Z0-9\\s\\n\\r]/,\n  heredelim: /(?:\\w+|'[^']*'|\"[^\"]*\"|`[^`]*`)/,\n  regexpctl: /[(){}\\[\\]\\$\\^|\\-*+?\\.]/,\n  regexpesc: /\\\\(?:[AzZbBdDfnrstvwWn0\\\\\\/]|@regexpctl|c[A-Z]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4})?/,\n  // The main tokenizer for our languages\n  tokenizer: {\n    // Main entry.\n    // root.<decl> where decl is the current opening declaration (like 'class')\n    root: [\n    // identifiers and keywords\n    // most complexity here is due to matching 'end' correctly with declarations.\n    // We distinguish a declaration that comes first on a line, versus declarations further on a line (which are most likey modifiers)\n    [/^(\\s*)([a-z_]\\w*[!?=]?)/, [\"white\", {\n      cases: {\n        \"for|until|while\": {\n          token: \"keyword.$2\",\n          next: \"@dodecl.$2\"\n        },\n        \"@declarations\": {\n          token: \"keyword.$2\",\n          next: \"@root.$2\"\n        },\n        end: {\n          token: \"keyword.$S2\",\n          next: \"@pop\"\n        },\n        \"@keywords\": \"keyword\",\n        \"@builtins\": \"predefined\",\n        \"@default\": \"identifier\"\n      }\n    }]], [/[a-z_]\\w*[!?=]?/, {\n      cases: {\n        \"if|unless|while|until\": {\n          token: \"keyword.$0x\",\n          next: \"@modifier.$0x\"\n        },\n        \"for\": {\n          token: \"keyword.$2\",\n          next: \"@dodecl.$2\"\n        },\n        \"@linedecls\": {\n          token: \"keyword.$0\",\n          next: \"@root.$0\"\n        },\n        end: {\n          token: \"keyword.$S2\",\n          next: \"@pop\"\n        },\n        \"@keywords\": \"keyword\",\n        \"@builtins\": \"predefined\",\n        \"@default\": \"identifier\"\n      }\n    }], [/[A-Z][\\w]*[!?=]?/, \"constructor.identifier\"],\n    // constant\n    [/\\$[\\w]*/, \"global.constant\"],\n    // global\n    [/@[\\w]*/, \"namespace.instance.identifier\"],\n    // instance\n    [/@@@[\\w]*/, \"namespace.class.identifier\"],\n    // class\n    // here document\n    [/<<[-~](@heredelim).*/, {\n      token: \"string.heredoc.delimiter\",\n      next: \"@heredoc.$1\"\n    }], [/[ \\t\\r\\n]+<<(@heredelim).*/, {\n      token: \"string.heredoc.delimiter\",\n      next: \"@heredoc.$1\"\n    }], [/^<<(@heredelim).*/, {\n      token: \"string.heredoc.delimiter\",\n      next: \"@heredoc.$1\"\n    }],\n    // whitespace\n    {\n      include: \"@whitespace\"\n    },\n    // strings\n    [/\"/, {\n      token: \"string.d.delim\",\n      next: '@dstring.d.\"'\n    }], [/'/, {\n      token: \"string.sq.delim\",\n      next: \"@sstring.sq\"\n    }],\n    // % literals. For efficiency, rematch in the 'pstring' state\n    [/%([rsqxwW]|Q?)/, {\n      token: \"@rematch\",\n      next: \"pstring\"\n    }],\n    // commands and symbols\n    [/`/, {\n      token: \"string.x.delim\",\n      next: \"@dstring.x.`\"\n    }], [/:(\\w|[$@])\\w*[!?=]?/, \"string.s\"], [/:\"/, {\n      token: \"string.s.delim\",\n      next: '@dstring.s.\"'\n    }], [/:'/, {\n      token: \"string.s.delim\",\n      next: \"@sstring.s\"\n    }],\n    // regular expressions. Lookahead for a (not escaped) closing forwardslash on the same line\n    [/\\/(?=(\\\\\\/|[^\\/\\n])+\\/)/, {\n      token: \"regexp.delim\",\n      next: \"@regexp\"\n    }],\n    // delimiters and operators\n    [/[{}()\\[\\]]/, \"@brackets\"], [/@symbols/, {\n      cases: {\n        \"@keywordops\": \"keyword\",\n        \"@operators\": \"operator\",\n        \"@default\": \"\"\n      }\n    }], [/[;,]/, \"delimiter\"],\n    // numbers\n    [/0[xX][0-9a-fA-F](_?[0-9a-fA-F])*/, \"number.hex\"], [/0[_oO][0-7](_?[0-7])*/, \"number.octal\"], [/0[bB][01](_?[01])*/, \"number.binary\"], [/0[dD]@decpart/, \"number\"], [/@decimal((\\.@decpart)?([eE][\\-+]?@decpart)?)/, {\n      cases: {\n        $1: \"number.float\",\n        \"@default\": \"number\"\n      }\n    }]],\n    // used to not treat a 'do' as a block opener if it occurs on the same\n    // line as a 'do' statement: 'while|until|for'\n    // dodecl.<decl> where decl is the declarations started, like 'while'\n    dodecl: [[/^/, {\n      token: \"\",\n      switchTo: \"@root.$S2\"\n    }],\n    // get out of do-skipping mode on a new line\n    [/[a-z_]\\w*[!?=]?/, {\n      cases: {\n        end: {\n          token: \"keyword.$S2\",\n          next: \"@pop\"\n        },\n        // end on same line\n        \"do\": {\n          token: \"keyword\",\n          switchTo: \"@root.$S2\"\n        },\n        // do on same line: not an open bracket here\n        \"@linedecls\": {\n          token: \"@rematch\",\n          switchTo: \"@root.$S2\"\n        },\n        // other declaration on same line: rematch\n        \"@keywords\": \"keyword\",\n        \"@builtins\": \"predefined\",\n        \"@default\": \"identifier\"\n      }\n    }], {\n      include: \"@root\"\n    }],\n    // used to prevent potential modifiers ('if|until|while|unless') to match\n    // with 'end' keywords.\n    // modifier.<decl>x where decl is the declaration starter, like 'if'\n    modifier: [[/^/, \"\", \"@pop\"],\n    // it was a modifier: get out of modifier mode on a new line\n    [/[a-z_]\\w*[!?=]?/, {\n      cases: {\n        end: {\n          token: \"keyword.$S2\",\n          next: \"@pop\"\n        },\n        // end on same line\n        \"then|else|elsif|do\": {\n          token: \"keyword\",\n          switchTo: \"@root.$S2\"\n        },\n        // real declaration and not a modifier\n        \"@linedecls\": {\n          token: \"@rematch\",\n          switchTo: \"@root.$S2\"\n        },\n        // other declaration => not a modifier\n        \"@keywords\": \"keyword\",\n        \"@builtins\": \"predefined\",\n        \"@default\": \"identifier\"\n      }\n    }], {\n      include: \"@root\"\n    }],\n    // single quote strings (also used for symbols)\n    // sstring.<kind>  where kind is 'sq' (single quote) or 's' (symbol)\n    sstring: [[/[^\\\\']+/, \"string.$S2\"], [/\\\\\\\\|\\\\'|\\\\$/, \"string.$S2.escape\"], [/\\\\./, \"string.$S2.invalid\"], [/'/, {\n      token: \"string.$S2.delim\",\n      next: \"@pop\"\n    }]],\n    // double quoted \"string\".\n    // dstring.<kind>.<delim> where kind is 'd' (double quoted), 'x' (command), or 's' (symbol)\n    // and delim is the ending delimiter (\" or `)\n    dstring: [[/[^\\\\`\"#]+/, \"string.$S2\"], [/#/, \"string.$S2.escape\", \"@interpolated\"], [/\\\\$/, \"string.$S2.escape\"], [/@escapes/, \"string.$S2.escape\"], [/\\\\./, \"string.$S2.escape.invalid\"], [/[`\"]/, {\n      cases: {\n        \"$#==$S3\": {\n          token: \"string.$S2.delim\",\n          next: \"@pop\"\n        },\n        \"@default\": \"string.$S2\"\n      }\n    }]],\n    // literal documents\n    // heredoc.<close> where close is the closing delimiter\n    heredoc: [[/^(\\s*)(@heredelim)$/, {\n      cases: {\n        \"$2==$S2\": [\"string.heredoc\", {\n          token: \"string.heredoc.delimiter\",\n          next: \"@pop\"\n        }],\n        \"@default\": [\"string.heredoc\", \"string.heredoc\"]\n      }\n    }], [/.*/, \"string.heredoc\"]],\n    // interpolated sequence\n    interpolated: [[/\\$\\w*/, \"global.constant\", \"@pop\"], [/@\\w*/, \"namespace.class.identifier\", \"@pop\"], [/@@@\\w*/, \"namespace.instance.identifier\", \"@pop\"], [/[{]/, {\n      token: \"string.escape.curly\",\n      switchTo: \"@interpolated_compound\"\n    }], [\"\", \"\", \"@pop\"]\n    // just a # is interpreted as a #\n    ],\n    // any code\n    interpolated_compound: [[/[}]/, {\n      token: \"string.escape.curly\",\n      next: \"@pop\"\n    }], {\n      include: \"@root\"\n    }],\n    // %r quoted regexp\n    // pregexp.<open>.<close> where open/close are the open/close delimiter\n    pregexp: [{\n      include: \"@whitespace\"\n    },\n    // turns out that you can quote using regex control characters, aargh!\n    // for example; %r|kgjgaj| is ok (even though | is used for alternation)\n    // so, we need to match those first\n    [/[^\\(\\{\\[\\\\]/, {\n      cases: {\n        \"$#==$S3\": {\n          token: \"regexp.delim\",\n          next: \"@pop\"\n        },\n        \"$#==$S2\": {\n          token: \"regexp.delim\",\n          next: \"@push\"\n        },\n        // nested delimiters are allowed..\n        \"~[)}\\\\]]\": \"@brackets.regexp.escape.control\",\n        \"~@regexpctl\": \"regexp.escape.control\",\n        \"@default\": \"regexp\"\n      }\n    }], {\n      include: \"@regexcontrol\"\n    }],\n    // We match regular expression quite precisely\n    regexp: [{\n      include: \"@regexcontrol\"\n    }, [/[^\\\\\\/]/, \"regexp\"], [\"/[ixmp]*\", {\n      token: \"regexp.delim\"\n    }, \"@pop\"]],\n    regexcontrol: [[/(\\{)(\\d+(?:,\\d*)?)(\\})/, [\"@brackets.regexp.escape.control\", \"regexp.escape.control\", \"@brackets.regexp.escape.control\"]], [/(\\[)(\\^?)/, [\"@brackets.regexp.escape.control\", {\n      token: \"regexp.escape.control\",\n      next: \"@regexrange\"\n    }]], [/(\\()(\\?[:=!])/, [\"@brackets.regexp.escape.control\", \"regexp.escape.control\"]], [/\\(\\?#/, {\n      token: \"regexp.escape.control\",\n      next: \"@regexpcomment\"\n    }], [/[()]/, \"@brackets.regexp.escape.control\"], [/@regexpctl/, \"regexp.escape.control\"], [/\\\\$/, \"regexp.escape\"], [/@regexpesc/, \"regexp.escape\"], [/\\\\\\./, \"regexp.invalid\"], [/#/, \"regexp.escape\", \"@interpolated\"]],\n    regexrange: [[/-/, \"regexp.escape.control\"], [/\\^/, \"regexp.invalid\"], [/\\\\$/, \"regexp.escape\"], [/@regexpesc/, \"regexp.escape\"], [/[^\\]]/, \"regexp\"], [/\\]/, \"@brackets.regexp.escape.control\", \"@pop\"]],\n    regexpcomment: [[/[^)]+/, \"comment\"], [/\\)/, {\n      token: \"regexp.escape.control\",\n      next: \"@pop\"\n    }]],\n    // % quoted strings\n    // A bit repetitive since we need to often special case the kind of ending delimiter\n    pstring: [[/%([qws])\\(/, {\n      token: \"string.$1.delim\",\n      switchTo: \"@qstring.$1.(.)\"\n    }], [/%([qws])\\[/, {\n      token: \"string.$1.delim\",\n      switchTo: \"@qstring.$1.[.]\"\n    }], [/%([qws])\\{/, {\n      token: \"string.$1.delim\",\n      switchTo: \"@qstring.$1.{.}\"\n    }], [/%([qws])</, {\n      token: \"string.$1.delim\",\n      switchTo: \"@qstring.$1.<.>\"\n    }], [/%([qws])(@delim)/, {\n      token: \"string.$1.delim\",\n      switchTo: \"@qstring.$1.$2.$2\"\n    }], [/%r\\(/, {\n      token: \"regexp.delim\",\n      switchTo: \"@pregexp.(.)\"\n    }], [/%r\\[/, {\n      token: \"regexp.delim\",\n      switchTo: \"@pregexp.[.]\"\n    }], [/%r\\{/, {\n      token: \"regexp.delim\",\n      switchTo: \"@pregexp.{.}\"\n    }], [/%r</, {\n      token: \"regexp.delim\",\n      switchTo: \"@pregexp.<.>\"\n    }], [/%r(@delim)/, {\n      token: \"regexp.delim\",\n      switchTo: \"@pregexp.$1.$1\"\n    }], [/%(x|W|Q?)\\(/, {\n      token: \"string.$1.delim\",\n      switchTo: \"@qqstring.$1.(.)\"\n    }], [/%(x|W|Q?)\\[/, {\n      token: \"string.$1.delim\",\n      switchTo: \"@qqstring.$1.[.]\"\n    }], [/%(x|W|Q?)\\{/, {\n      token: \"string.$1.delim\",\n      switchTo: \"@qqstring.$1.{.}\"\n    }], [/%(x|W|Q?)</, {\n      token: \"string.$1.delim\",\n      switchTo: \"@qqstring.$1.<.>\"\n    }], [/%(x|W|Q?)(@delim)/, {\n      token: \"string.$1.delim\",\n      switchTo: \"@qqstring.$1.$2.$2\"\n    }], [/%([rqwsxW]|Q?)./, {\n      token: \"invalid\",\n      next: \"@pop\"\n    }],\n    // recover\n    [/./, {\n      token: \"invalid\",\n      next: \"@pop\"\n    }]\n    // recover\n    ],\n    // non-expanded quoted string.\n    // qstring.<kind>.<open>.<close>\n    //  kind = q|w|s  (single quote, array, symbol)\n    //  open = open delimiter\n    //  close = close delimiter\n    qstring: [[/\\\\$/, \"string.$S2.escape\"], [/\\\\./, \"string.$S2.escape\"], [/./, {\n      cases: {\n        \"$#==$S4\": {\n          token: \"string.$S2.delim\",\n          next: \"@pop\"\n        },\n        \"$#==$S3\": {\n          token: \"string.$S2.delim\",\n          next: \"@push\"\n        },\n        // nested delimiters are allowed..\n        \"@default\": \"string.$S2\"\n      }\n    }]],\n    // expanded quoted string.\n    // qqstring.<kind>.<open>.<close>\n    //  kind = Q|W|x  (double quote, array, command)\n    //  open = open delimiter\n    //  close = close delimiter\n    qqstring: [[/#/, \"string.$S2.escape\", \"@interpolated\"], {\n      include: \"@qstring\"\n    }],\n    // whitespace & comments\n    whitespace: [[/[ \\t\\r\\n]+/, \"\"], [/^\\s*=begin\\b/, \"comment\", \"@comment\"], [/#.*$/, \"comment\"]],\n    comment: [[/[^=]+/, \"comment\"], [/^\\s*=begin\\b/, \"comment.invalid\"],\n    // nested comment\n    [/^\\s*=end\\b.*/, \"comment\", \"@pop\"], [/[=]/, \"comment\"]]\n  }\n};\nexport { conf, language };","map":{"version":3,"names":["conf","comments","lineComment","blockComment","brackets","autoClosingPairs","open","close","surroundingPairs","indentationRules","increaseIndentPattern","RegExp","decreaseIndentPattern","language","tokenPostfix","keywords","keywordops","builtins","declarations","linedecls","operators","token","symbols","escape","escapes","decpart","decimal","delim","heredelim","regexpctl","regexpesc","tokenizer","root","cases","next","end","include","$1","dodecl","switchTo","modifier","sstring","dstring","heredoc","interpolated","interpolated_compound","pregexp","regexp","regexcontrol","regexrange","regexpcomment","pstring","qstring","qqstring","whitespace","comment"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/basic-languages/ruby/ruby.js"],"sourcesContent":["/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.48.0(0037b13fb5d186fdf1e7df51a9416a2de2b8c670)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\n\n// src/basic-languages/ruby/ruby.ts\nvar conf = {\n  comments: {\n    lineComment: \"#\",\n    blockComment: [\"=begin\", \"=end\"]\n  },\n  brackets: [\n    [\"(\", \")\"],\n    [\"{\", \"}\"],\n    [\"[\", \"]\"]\n  ],\n  autoClosingPairs: [\n    { open: \"{\", close: \"}\" },\n    { open: \"[\", close: \"]\" },\n    { open: \"(\", close: \")\" },\n    { open: '\"', close: '\"' },\n    { open: \"'\", close: \"'\" }\n  ],\n  surroundingPairs: [\n    { open: \"{\", close: \"}\" },\n    { open: \"[\", close: \"]\" },\n    { open: \"(\", close: \")\" },\n    { open: '\"', close: '\"' },\n    { open: \"'\", close: \"'\" }\n  ],\n  indentationRules: {\n    increaseIndentPattern: new RegExp(\n      `^\\\\s*((begin|class|(private|protected)\\\\s+def|def|else|elsif|ensure|for|if|module|rescue|unless|until|when|while|case)|([^#]*\\\\sdo\\\\b)|([^#]*=\\\\s*(case|if|unless)))\\\\b([^#\\\\{;]|(\"|'|/).*\\\\4)*(#.*)?$`\n    ),\n    decreaseIndentPattern: new RegExp(\n      \"^\\\\s*([}\\\\]]([,)]?\\\\s*(#|$)|\\\\.[a-zA-Z_]\\\\w*\\\\b)|(end|rescue|ensure|else|elsif|when)\\\\b)\"\n    )\n  }\n};\nvar language = {\n  tokenPostfix: \".ruby\",\n  keywords: [\n    \"__LINE__\",\n    \"__ENCODING__\",\n    \"__FILE__\",\n    \"BEGIN\",\n    \"END\",\n    \"alias\",\n    \"and\",\n    \"begin\",\n    \"break\",\n    \"case\",\n    \"class\",\n    \"def\",\n    \"defined?\",\n    \"do\",\n    \"else\",\n    \"elsif\",\n    \"end\",\n    \"ensure\",\n    \"for\",\n    \"false\",\n    \"if\",\n    \"in\",\n    \"module\",\n    \"next\",\n    \"nil\",\n    \"not\",\n    \"or\",\n    \"redo\",\n    \"rescue\",\n    \"retry\",\n    \"return\",\n    \"self\",\n    \"super\",\n    \"then\",\n    \"true\",\n    \"undef\",\n    \"unless\",\n    \"until\",\n    \"when\",\n    \"while\",\n    \"yield\"\n  ],\n  keywordops: [\"::\", \"..\", \"...\", \"?\", \":\", \"=>\"],\n  builtins: [\n    \"require\",\n    \"public\",\n    \"private\",\n    \"include\",\n    \"extend\",\n    \"attr_reader\",\n    \"protected\",\n    \"private_class_method\",\n    \"protected_class_method\",\n    \"new\"\n  ],\n  // these are closed by 'end' (if, while and until are handled separately)\n  declarations: [\n    \"module\",\n    \"class\",\n    \"def\",\n    \"case\",\n    \"do\",\n    \"begin\",\n    \"for\",\n    \"if\",\n    \"while\",\n    \"until\",\n    \"unless\"\n  ],\n  linedecls: [\"def\", \"case\", \"do\", \"begin\", \"for\", \"if\", \"while\", \"until\", \"unless\"],\n  operators: [\n    \"^\",\n    \"&\",\n    \"|\",\n    \"<=>\",\n    \"==\",\n    \"===\",\n    \"!~\",\n    \"=~\",\n    \">\",\n    \">=\",\n    \"<\",\n    \"<=\",\n    \"<<\",\n    \">>\",\n    \"+\",\n    \"-\",\n    \"*\",\n    \"/\",\n    \"%\",\n    \"**\",\n    \"~\",\n    \"+@\",\n    \"-@\",\n    \"[]\",\n    \"[]=\",\n    \"`\",\n    \"+=\",\n    \"-=\",\n    \"*=\",\n    \"**=\",\n    \"/=\",\n    \"^=\",\n    \"%=\",\n    \"<<=\",\n    \">>=\",\n    \"&=\",\n    \"&&=\",\n    \"||=\",\n    \"|=\"\n  ],\n  brackets: [\n    { open: \"(\", close: \")\", token: \"delimiter.parenthesis\" },\n    { open: \"{\", close: \"}\", token: \"delimiter.curly\" },\n    { open: \"[\", close: \"]\", token: \"delimiter.square\" }\n  ],\n  // we include these common regular expressions\n  symbols: /[=><!~?:&|+\\-*\\/\\^%\\.]+/,\n  // escape sequences\n  escape: /(?:[abefnrstv\\\\\"'\\n\\r]|[0-7]{1,3}|x[0-9A-Fa-f]{1,2}|u[0-9A-Fa-f]{4})/,\n  escapes: /\\\\(?:C\\-(@escape|.)|c(@escape|.)|@escape)/,\n  decpart: /\\d(_?\\d)*/,\n  decimal: /0|@decpart/,\n  delim: /[^a-zA-Z0-9\\s\\n\\r]/,\n  heredelim: /(?:\\w+|'[^']*'|\"[^\"]*\"|`[^`]*`)/,\n  regexpctl: /[(){}\\[\\]\\$\\^|\\-*+?\\.]/,\n  regexpesc: /\\\\(?:[AzZbBdDfnrstvwWn0\\\\\\/]|@regexpctl|c[A-Z]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4})?/,\n  // The main tokenizer for our languages\n  tokenizer: {\n    // Main entry.\n    // root.<decl> where decl is the current opening declaration (like 'class')\n    root: [\n      // identifiers and keywords\n      // most complexity here is due to matching 'end' correctly with declarations.\n      // We distinguish a declaration that comes first on a line, versus declarations further on a line (which are most likey modifiers)\n      [\n        /^(\\s*)([a-z_]\\w*[!?=]?)/,\n        [\n          \"white\",\n          {\n            cases: {\n              \"for|until|while\": {\n                token: \"keyword.$2\",\n                next: \"@dodecl.$2\"\n              },\n              \"@declarations\": {\n                token: \"keyword.$2\",\n                next: \"@root.$2\"\n              },\n              end: { token: \"keyword.$S2\", next: \"@pop\" },\n              \"@keywords\": \"keyword\",\n              \"@builtins\": \"predefined\",\n              \"@default\": \"identifier\"\n            }\n          }\n        ]\n      ],\n      [\n        /[a-z_]\\w*[!?=]?/,\n        {\n          cases: {\n            \"if|unless|while|until\": {\n              token: \"keyword.$0x\",\n              next: \"@modifier.$0x\"\n            },\n            for: { token: \"keyword.$2\", next: \"@dodecl.$2\" },\n            \"@linedecls\": { token: \"keyword.$0\", next: \"@root.$0\" },\n            end: { token: \"keyword.$S2\", next: \"@pop\" },\n            \"@keywords\": \"keyword\",\n            \"@builtins\": \"predefined\",\n            \"@default\": \"identifier\"\n          }\n        }\n      ],\n      [/[A-Z][\\w]*[!?=]?/, \"constructor.identifier\"],\n      // constant\n      [/\\$[\\w]*/, \"global.constant\"],\n      // global\n      [/@[\\w]*/, \"namespace.instance.identifier\"],\n      // instance\n      [/@@@[\\w]*/, \"namespace.class.identifier\"],\n      // class\n      // here document\n      [/<<[-~](@heredelim).*/, { token: \"string.heredoc.delimiter\", next: \"@heredoc.$1\" }],\n      [/[ \\t\\r\\n]+<<(@heredelim).*/, { token: \"string.heredoc.delimiter\", next: \"@heredoc.$1\" }],\n      [/^<<(@heredelim).*/, { token: \"string.heredoc.delimiter\", next: \"@heredoc.$1\" }],\n      // whitespace\n      { include: \"@whitespace\" },\n      // strings\n      [/\"/, { token: \"string.d.delim\", next: '@dstring.d.\"' }],\n      [/'/, { token: \"string.sq.delim\", next: \"@sstring.sq\" }],\n      // % literals. For efficiency, rematch in the 'pstring' state\n      [/%([rsqxwW]|Q?)/, { token: \"@rematch\", next: \"pstring\" }],\n      // commands and symbols\n      [/`/, { token: \"string.x.delim\", next: \"@dstring.x.`\" }],\n      [/:(\\w|[$@])\\w*[!?=]?/, \"string.s\"],\n      [/:\"/, { token: \"string.s.delim\", next: '@dstring.s.\"' }],\n      [/:'/, { token: \"string.s.delim\", next: \"@sstring.s\" }],\n      // regular expressions. Lookahead for a (not escaped) closing forwardslash on the same line\n      [/\\/(?=(\\\\\\/|[^\\/\\n])+\\/)/, { token: \"regexp.delim\", next: \"@regexp\" }],\n      // delimiters and operators\n      [/[{}()\\[\\]]/, \"@brackets\"],\n      [\n        /@symbols/,\n        {\n          cases: {\n            \"@keywordops\": \"keyword\",\n            \"@operators\": \"operator\",\n            \"@default\": \"\"\n          }\n        }\n      ],\n      [/[;,]/, \"delimiter\"],\n      // numbers\n      [/0[xX][0-9a-fA-F](_?[0-9a-fA-F])*/, \"number.hex\"],\n      [/0[_oO][0-7](_?[0-7])*/, \"number.octal\"],\n      [/0[bB][01](_?[01])*/, \"number.binary\"],\n      [/0[dD]@decpart/, \"number\"],\n      [\n        /@decimal((\\.@decpart)?([eE][\\-+]?@decpart)?)/,\n        {\n          cases: {\n            $1: \"number.float\",\n            \"@default\": \"number\"\n          }\n        }\n      ]\n    ],\n    // used to not treat a 'do' as a block opener if it occurs on the same\n    // line as a 'do' statement: 'while|until|for'\n    // dodecl.<decl> where decl is the declarations started, like 'while'\n    dodecl: [\n      [/^/, { token: \"\", switchTo: \"@root.$S2\" }],\n      // get out of do-skipping mode on a new line\n      [\n        /[a-z_]\\w*[!?=]?/,\n        {\n          cases: {\n            end: { token: \"keyword.$S2\", next: \"@pop\" },\n            // end on same line\n            do: { token: \"keyword\", switchTo: \"@root.$S2\" },\n            // do on same line: not an open bracket here\n            \"@linedecls\": {\n              token: \"@rematch\",\n              switchTo: \"@root.$S2\"\n            },\n            // other declaration on same line: rematch\n            \"@keywords\": \"keyword\",\n            \"@builtins\": \"predefined\",\n            \"@default\": \"identifier\"\n          }\n        }\n      ],\n      { include: \"@root\" }\n    ],\n    // used to prevent potential modifiers ('if|until|while|unless') to match\n    // with 'end' keywords.\n    // modifier.<decl>x where decl is the declaration starter, like 'if'\n    modifier: [\n      [/^/, \"\", \"@pop\"],\n      // it was a modifier: get out of modifier mode on a new line\n      [\n        /[a-z_]\\w*[!?=]?/,\n        {\n          cases: {\n            end: { token: \"keyword.$S2\", next: \"@pop\" },\n            // end on same line\n            \"then|else|elsif|do\": {\n              token: \"keyword\",\n              switchTo: \"@root.$S2\"\n            },\n            // real declaration and not a modifier\n            \"@linedecls\": {\n              token: \"@rematch\",\n              switchTo: \"@root.$S2\"\n            },\n            // other declaration => not a modifier\n            \"@keywords\": \"keyword\",\n            \"@builtins\": \"predefined\",\n            \"@default\": \"identifier\"\n          }\n        }\n      ],\n      { include: \"@root\" }\n    ],\n    // single quote strings (also used for symbols)\n    // sstring.<kind>  where kind is 'sq' (single quote) or 's' (symbol)\n    sstring: [\n      [/[^\\\\']+/, \"string.$S2\"],\n      [/\\\\\\\\|\\\\'|\\\\$/, \"string.$S2.escape\"],\n      [/\\\\./, \"string.$S2.invalid\"],\n      [/'/, { token: \"string.$S2.delim\", next: \"@pop\" }]\n    ],\n    // double quoted \"string\".\n    // dstring.<kind>.<delim> where kind is 'd' (double quoted), 'x' (command), or 's' (symbol)\n    // and delim is the ending delimiter (\" or `)\n    dstring: [\n      [/[^\\\\`\"#]+/, \"string.$S2\"],\n      [/#/, \"string.$S2.escape\", \"@interpolated\"],\n      [/\\\\$/, \"string.$S2.escape\"],\n      [/@escapes/, \"string.$S2.escape\"],\n      [/\\\\./, \"string.$S2.escape.invalid\"],\n      [\n        /[`\"]/,\n        {\n          cases: {\n            \"$#==$S3\": { token: \"string.$S2.delim\", next: \"@pop\" },\n            \"@default\": \"string.$S2\"\n          }\n        }\n      ]\n    ],\n    // literal documents\n    // heredoc.<close> where close is the closing delimiter\n    heredoc: [\n      [\n        /^(\\s*)(@heredelim)$/,\n        {\n          cases: {\n            \"$2==$S2\": [\"string.heredoc\", { token: \"string.heredoc.delimiter\", next: \"@pop\" }],\n            \"@default\": [\"string.heredoc\", \"string.heredoc\"]\n          }\n        }\n      ],\n      [/.*/, \"string.heredoc\"]\n    ],\n    // interpolated sequence\n    interpolated: [\n      [/\\$\\w*/, \"global.constant\", \"@pop\"],\n      [/@\\w*/, \"namespace.class.identifier\", \"@pop\"],\n      [/@@@\\w*/, \"namespace.instance.identifier\", \"@pop\"],\n      [\n        /[{]/,\n        {\n          token: \"string.escape.curly\",\n          switchTo: \"@interpolated_compound\"\n        }\n      ],\n      [\"\", \"\", \"@pop\"]\n      // just a # is interpreted as a #\n    ],\n    // any code\n    interpolated_compound: [\n      [/[}]/, { token: \"string.escape.curly\", next: \"@pop\" }],\n      { include: \"@root\" }\n    ],\n    // %r quoted regexp\n    // pregexp.<open>.<close> where open/close are the open/close delimiter\n    pregexp: [\n      { include: \"@whitespace\" },\n      // turns out that you can quote using regex control characters, aargh!\n      // for example; %r|kgjgaj| is ok (even though | is used for alternation)\n      // so, we need to match those first\n      [\n        /[^\\(\\{\\[\\\\]/,\n        {\n          cases: {\n            \"$#==$S3\": { token: \"regexp.delim\", next: \"@pop\" },\n            \"$#==$S2\": { token: \"regexp.delim\", next: \"@push\" },\n            // nested delimiters are allowed..\n            \"~[)}\\\\]]\": \"@brackets.regexp.escape.control\",\n            \"~@regexpctl\": \"regexp.escape.control\",\n            \"@default\": \"regexp\"\n          }\n        }\n      ],\n      { include: \"@regexcontrol\" }\n    ],\n    // We match regular expression quite precisely\n    regexp: [\n      { include: \"@regexcontrol\" },\n      [/[^\\\\\\/]/, \"regexp\"],\n      [\"/[ixmp]*\", { token: \"regexp.delim\" }, \"@pop\"]\n    ],\n    regexcontrol: [\n      [\n        /(\\{)(\\d+(?:,\\d*)?)(\\})/,\n        [\n          \"@brackets.regexp.escape.control\",\n          \"regexp.escape.control\",\n          \"@brackets.regexp.escape.control\"\n        ]\n      ],\n      [\n        /(\\[)(\\^?)/,\n        [\"@brackets.regexp.escape.control\", { token: \"regexp.escape.control\", next: \"@regexrange\" }]\n      ],\n      [/(\\()(\\?[:=!])/, [\"@brackets.regexp.escape.control\", \"regexp.escape.control\"]],\n      [/\\(\\?#/, { token: \"regexp.escape.control\", next: \"@regexpcomment\" }],\n      [/[()]/, \"@brackets.regexp.escape.control\"],\n      [/@regexpctl/, \"regexp.escape.control\"],\n      [/\\\\$/, \"regexp.escape\"],\n      [/@regexpesc/, \"regexp.escape\"],\n      [/\\\\\\./, \"regexp.invalid\"],\n      [/#/, \"regexp.escape\", \"@interpolated\"]\n    ],\n    regexrange: [\n      [/-/, \"regexp.escape.control\"],\n      [/\\^/, \"regexp.invalid\"],\n      [/\\\\$/, \"regexp.escape\"],\n      [/@regexpesc/, \"regexp.escape\"],\n      [/[^\\]]/, \"regexp\"],\n      [/\\]/, \"@brackets.regexp.escape.control\", \"@pop\"]\n    ],\n    regexpcomment: [\n      [/[^)]+/, \"comment\"],\n      [/\\)/, { token: \"regexp.escape.control\", next: \"@pop\" }]\n    ],\n    // % quoted strings\n    // A bit repetitive since we need to often special case the kind of ending delimiter\n    pstring: [\n      [/%([qws])\\(/, { token: \"string.$1.delim\", switchTo: \"@qstring.$1.(.)\" }],\n      [/%([qws])\\[/, { token: \"string.$1.delim\", switchTo: \"@qstring.$1.[.]\" }],\n      [/%([qws])\\{/, { token: \"string.$1.delim\", switchTo: \"@qstring.$1.{.}\" }],\n      [/%([qws])</, { token: \"string.$1.delim\", switchTo: \"@qstring.$1.<.>\" }],\n      [/%([qws])(@delim)/, { token: \"string.$1.delim\", switchTo: \"@qstring.$1.$2.$2\" }],\n      [/%r\\(/, { token: \"regexp.delim\", switchTo: \"@pregexp.(.)\" }],\n      [/%r\\[/, { token: \"regexp.delim\", switchTo: \"@pregexp.[.]\" }],\n      [/%r\\{/, { token: \"regexp.delim\", switchTo: \"@pregexp.{.}\" }],\n      [/%r</, { token: \"regexp.delim\", switchTo: \"@pregexp.<.>\" }],\n      [/%r(@delim)/, { token: \"regexp.delim\", switchTo: \"@pregexp.$1.$1\" }],\n      [/%(x|W|Q?)\\(/, { token: \"string.$1.delim\", switchTo: \"@qqstring.$1.(.)\" }],\n      [/%(x|W|Q?)\\[/, { token: \"string.$1.delim\", switchTo: \"@qqstring.$1.[.]\" }],\n      [/%(x|W|Q?)\\{/, { token: \"string.$1.delim\", switchTo: \"@qqstring.$1.{.}\" }],\n      [/%(x|W|Q?)</, { token: \"string.$1.delim\", switchTo: \"@qqstring.$1.<.>\" }],\n      [/%(x|W|Q?)(@delim)/, { token: \"string.$1.delim\", switchTo: \"@qqstring.$1.$2.$2\" }],\n      [/%([rqwsxW]|Q?)./, { token: \"invalid\", next: \"@pop\" }],\n      // recover\n      [/./, { token: \"invalid\", next: \"@pop\" }]\n      // recover\n    ],\n    // non-expanded quoted string.\n    // qstring.<kind>.<open>.<close>\n    //  kind = q|w|s  (single quote, array, symbol)\n    //  open = open delimiter\n    //  close = close delimiter\n    qstring: [\n      [/\\\\$/, \"string.$S2.escape\"],\n      [/\\\\./, \"string.$S2.escape\"],\n      [\n        /./,\n        {\n          cases: {\n            \"$#==$S4\": { token: \"string.$S2.delim\", next: \"@pop\" },\n            \"$#==$S3\": { token: \"string.$S2.delim\", next: \"@push\" },\n            // nested delimiters are allowed..\n            \"@default\": \"string.$S2\"\n          }\n        }\n      ]\n    ],\n    // expanded quoted string.\n    // qqstring.<kind>.<open>.<close>\n    //  kind = Q|W|x  (double quote, array, command)\n    //  open = open delimiter\n    //  close = close delimiter\n    qqstring: [[/#/, \"string.$S2.escape\", \"@interpolated\"], { include: \"@qstring\" }],\n    // whitespace & comments\n    whitespace: [\n      [/[ \\t\\r\\n]+/, \"\"],\n      [/^\\s*=begin\\b/, \"comment\", \"@comment\"],\n      [/#.*$/, \"comment\"]\n    ],\n    comment: [\n      [/[^=]+/, \"comment\"],\n      [/^\\s*=begin\\b/, \"comment.invalid\"],\n      // nested comment\n      [/^\\s*=end\\b.*/, \"comment\", \"@pop\"],\n      [/[=]/, \"comment\"]\n    ]\n  }\n};\nexport {\n  conf,\n  language\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}