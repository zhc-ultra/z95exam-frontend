{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { ContiguousTokensEditing, EMPTY_LINE_TOKENS, toUint32Array } from './contiguousTokensEditing.js';\nimport { LineTokens } from './lineTokens.js';\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\n/**\n * Represents contiguous tokens in a text model.\n */\nexport var ContiguousTokensStore = /*#__PURE__*/function () {\n  function ContiguousTokensStore(languageIdCodec) {\n    _classCallCheck(this, ContiguousTokensStore);\n    this._lineTokens = [];\n    this._len = 0;\n    this._languageIdCodec = languageIdCodec;\n  }\n  return _createClass(ContiguousTokensStore, [{\n    key: \"flush\",\n    value: function flush() {\n      this._lineTokens = [];\n      this._len = 0;\n    }\n  }, {\n    key: \"hasTokens\",\n    get: function get() {\n      return this._lineTokens.length > 0;\n    }\n  }, {\n    key: \"getTokens\",\n    value: function getTokens(topLevelLanguageId, lineIndex, lineText) {\n      var rawLineTokens = null;\n      if (lineIndex < this._len) {\n        rawLineTokens = this._lineTokens[lineIndex];\n      }\n      if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n        return new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);\n      }\n      var lineTokens = new Uint32Array(2);\n      lineTokens[0] = lineText.length;\n      lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));\n      return new LineTokens(lineTokens, lineText, this._languageIdCodec);\n    }\n  }, {\n    key: \"_ensureLine\",\n    value: function _ensureLine(lineIndex) {\n      while (lineIndex >= this._len) {\n        this._lineTokens[this._len] = null;\n        this._len++;\n      }\n    }\n  }, {\n    key: \"_deleteLines\",\n    value: function _deleteLines(start, deleteCount) {\n      if (deleteCount === 0) {\n        return;\n      }\n      if (start + deleteCount > this._len) {\n        deleteCount = this._len - start;\n      }\n      this._lineTokens.splice(start, deleteCount);\n      this._len -= deleteCount;\n    }\n  }, {\n    key: \"_insertLines\",\n    value: function _insertLines(insertIndex, insertCount) {\n      if (insertCount === 0) {\n        return;\n      }\n      var lineTokens = [];\n      for (var i = 0; i < insertCount; i++) {\n        lineTokens[i] = null;\n      }\n      this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n      this._len += insertCount;\n    }\n  }, {\n    key: \"setTokens\",\n    value: function setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n      var tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);\n      this._ensureLine(lineIndex);\n      var oldTokens = this._lineTokens[lineIndex];\n      this._lineTokens[lineIndex] = tokens;\n      if (checkEquality) {\n        return !ContiguousTokensStore._equals(oldTokens, tokens);\n      }\n      return false;\n    }\n  }, {\n    key: \"acceptEdit\",\n    value:\n    //#region Editing\n    function acceptEdit(range, eolCount, firstLineLength) {\n      this._acceptDeleteRange(range);\n      this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n    }\n  }, {\n    key: \"_acceptDeleteRange\",\n    value: function _acceptDeleteRange(range) {\n      var firstLineIndex = range.startLineNumber - 1;\n      if (firstLineIndex >= this._len) {\n        return;\n      }\n      if (range.startLineNumber === range.endLineNumber) {\n        if (range.startColumn === range.endColumn) {\n          // Nothing to delete\n          return;\n        }\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing[\"delete\"](this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n        return;\n      }\n      this._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n      var lastLineIndex = range.endLineNumber - 1;\n      var lastLineTokens = null;\n      if (lastLineIndex < this._len) {\n        lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n      }\n      // Take remaining text on last line and append it to remaining text on first line\n      this._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);\n      // Delete middle lines\n      this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n  }, {\n    key: \"_acceptInsertText\",\n    value: function _acceptInsertText(position, eolCount, firstLineLength) {\n      if (eolCount === 0 && firstLineLength === 0) {\n        // Nothing to insert\n        return;\n      }\n      var lineIndex = position.lineNumber - 1;\n      if (lineIndex >= this._len) {\n        return;\n      }\n      if (eolCount === 0) {\n        // Inserting text on one line\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n        return;\n      }\n      this._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n      this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n      this._insertLines(position.lineNumber, eolCount);\n    }\n    //#endregion\n  }, {\n    key: \"setMultilineTokens\",\n    value: function setMultilineTokens(tokens, textModel) {\n      if (tokens.length === 0) {\n        return {\n          changes: []\n        };\n      }\n      var ranges = [];\n      for (var i = 0, len = tokens.length; i < len; i++) {\n        var element = tokens[i];\n        var minChangedLineNumber = 0;\n        var maxChangedLineNumber = 0;\n        var hasChange = false;\n        for (var lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {\n          if (hasChange) {\n            this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);\n            maxChangedLineNumber = lineNumber;\n          } else {\n            var lineHasChange = this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);\n            if (lineHasChange) {\n              hasChange = true;\n              minChangedLineNumber = lineNumber;\n              maxChangedLineNumber = lineNumber;\n            }\n          }\n        }\n        if (hasChange) {\n          ranges.push({\n            fromLineNumber: minChangedLineNumber,\n            toLineNumber: maxChangedLineNumber\n          });\n        }\n      }\n      return {\n        changes: ranges\n      };\n    }\n  }], [{\n    key: \"_massageTokens\",\n    value: function _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n      var tokens = _tokens ? toUint32Array(_tokens) : null;\n      if (lineTextLength === 0) {\n        var hasDifferentLanguageId = false;\n        if (tokens && tokens.length > 1) {\n          hasDifferentLanguageId = TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId;\n        }\n        if (!hasDifferentLanguageId) {\n          return EMPTY_LINE_TOKENS;\n        }\n      }\n      if (!tokens || tokens.length === 0) {\n        var _tokens2 = new Uint32Array(2);\n        _tokens2[0] = lineTextLength;\n        _tokens2[1] = getDefaultMetadata(topLevelLanguageId);\n        return _tokens2.buffer;\n      }\n      // Ensure the last token covers the end of the text\n      tokens[tokens.length - 2] = lineTextLength;\n      if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n        // Store directly the ArrayBuffer pointer to save an object\n        return tokens.buffer;\n      }\n      return tokens;\n    }\n  }, {\n    key: \"_equals\",\n    value: function _equals(_a, _b) {\n      if (!_a || !_b) {\n        return !_a && !_b;\n      }\n      var a = toUint32Array(_a);\n      var b = toUint32Array(_b);\n      if (a.length !== b.length) {\n        return false;\n      }\n      for (var i = 0, len = a.length; i < len; i++) {\n        if (a[i] !== b[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }]);\n}();\nfunction getDefaultMetadata(topLevelLanguageId) {\n  return (topLevelLanguageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */ | 0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */ | 0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */ | 1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */ | 2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */\n  // If there is no grammar, we just take a guess and try to match brackets.\n  | 1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */) >>> 0;\n}","map":{"version":3,"names":["arrays","Position","ContiguousTokensEditing","EMPTY_LINE_TOKENS","toUint32Array","LineTokens","TokenMetadata","ContiguousTokensStore","languageIdCodec","_classCallCheck","_lineTokens","_len","_languageIdCodec","_createClass","key","value","flush","get","length","getTokens","topLevelLanguageId","lineIndex","lineText","rawLineTokens","lineTokens","Uint32Array","getDefaultMetadata","encodeLanguageId","_ensureLine","_deleteLines","start","deleteCount","splice","_insertLines","insertIndex","insertCount","i","arrayInsert","setTokens","lineTextLength","_tokens","checkEquality","tokens","_massageTokens","oldTokens","_equals","acceptEdit","range","eolCount","firstLineLength","_acceptDeleteRange","_acceptInsertText","startLineNumber","startColumn","firstLineIndex","endLineNumber","endColumn","deleteEnding","lastLineIndex","lastLineTokens","deleteBeginning","append","position","lineNumber","insert","column","setMultilineTokens","textModel","changes","ranges","len","element","minChangedLineNumber","maxChangedLineNumber","hasChange","getLanguageId","getLineLength","getLineTokens","lineHasChange","push","fromLineNumber","toLineNumber","hasDifferentLanguageId","buffer","byteOffset","byteLength","_a","_b","a","b"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { ContiguousTokensEditing, EMPTY_LINE_TOKENS, toUint32Array } from './contiguousTokensEditing.js';\nimport { LineTokens } from './lineTokens.js';\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\n/**\n * Represents contiguous tokens in a text model.\n */\nexport class ContiguousTokensStore {\n    constructor(languageIdCodec) {\n        this._lineTokens = [];\n        this._len = 0;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._lineTokens = [];\n        this._len = 0;\n    }\n    get hasTokens() {\n        return this._lineTokens.length > 0;\n    }\n    getTokens(topLevelLanguageId, lineIndex, lineText) {\n        let rawLineTokens = null;\n        if (lineIndex < this._len) {\n            rawLineTokens = this._lineTokens[lineIndex];\n        }\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n            return new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);\n        }\n        const lineTokens = new Uint32Array(2);\n        lineTokens[0] = lineText.length;\n        lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));\n        return new LineTokens(lineTokens, lineText, this._languageIdCodec);\n    }\n    static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n        const tokens = _tokens ? toUint32Array(_tokens) : null;\n        if (lineTextLength === 0) {\n            let hasDifferentLanguageId = false;\n            if (tokens && tokens.length > 1) {\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n            }\n            if (!hasDifferentLanguageId) {\n                return EMPTY_LINE_TOKENS;\n            }\n        }\n        if (!tokens || tokens.length === 0) {\n            const tokens = new Uint32Array(2);\n            tokens[0] = lineTextLength;\n            tokens[1] = getDefaultMetadata(topLevelLanguageId);\n            return tokens.buffer;\n        }\n        // Ensure the last token covers the end of the text\n        tokens[tokens.length - 2] = lineTextLength;\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n            // Store directly the ArrayBuffer pointer to save an object\n            return tokens.buffer;\n        }\n        return tokens;\n    }\n    _ensureLine(lineIndex) {\n        while (lineIndex >= this._len) {\n            this._lineTokens[this._len] = null;\n            this._len++;\n        }\n    }\n    _deleteLines(start, deleteCount) {\n        if (deleteCount === 0) {\n            return;\n        }\n        if (start + deleteCount > this._len) {\n            deleteCount = this._len - start;\n        }\n        this._lineTokens.splice(start, deleteCount);\n        this._len -= deleteCount;\n    }\n    _insertLines(insertIndex, insertCount) {\n        if (insertCount === 0) {\n            return;\n        }\n        const lineTokens = [];\n        for (let i = 0; i < insertCount; i++) {\n            lineTokens[i] = null;\n        }\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n        this._len += insertCount;\n    }\n    setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n        const tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);\n        this._ensureLine(lineIndex);\n        const oldTokens = this._lineTokens[lineIndex];\n        this._lineTokens[lineIndex] = tokens;\n        if (checkEquality) {\n            return !ContiguousTokensStore._equals(oldTokens, tokens);\n        }\n        return false;\n    }\n    static _equals(_a, _b) {\n        if (!_a || !_b) {\n            return !_a && !_b;\n        }\n        const a = toUint32Array(_a);\n        const b = toUint32Array(_b);\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //#region Editing\n    acceptEdit(range, eolCount, firstLineLength) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n    }\n    _acceptDeleteRange(range) {\n        const firstLineIndex = range.startLineNumber - 1;\n        if (firstLineIndex >= this._len) {\n            return;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            this._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n            return;\n        }\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n        const lastLineIndex = range.endLineNumber - 1;\n        let lastLineTokens = null;\n        if (lastLineIndex < this._len) {\n            lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);\n        // Delete middle lines\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n    _acceptInsertText(position, eolCount, firstLineLength) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - 1;\n        if (lineIndex >= this._len) {\n            return;\n        }\n        if (eolCount === 0) {\n            // Inserting text on one line\n            this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n            return;\n        }\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n        this._insertLines(position.lineNumber, eolCount);\n    }\n    //#endregion\n    setMultilineTokens(tokens, textModel) {\n        if (tokens.length === 0) {\n            return { changes: [] };\n        }\n        const ranges = [];\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const element = tokens[i];\n            let minChangedLineNumber = 0;\n            let maxChangedLineNumber = 0;\n            let hasChange = false;\n            for (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {\n                if (hasChange) {\n                    this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);\n                    maxChangedLineNumber = lineNumber;\n                }\n                else {\n                    const lineHasChange = this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);\n                    if (lineHasChange) {\n                        hasChange = true;\n                        minChangedLineNumber = lineNumber;\n                        maxChangedLineNumber = lineNumber;\n                    }\n                }\n            }\n            if (hasChange) {\n                ranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber, });\n            }\n        }\n        return { changes: ranges };\n    }\n}\nfunction getDefaultMetadata(topLevelLanguageId) {\n    return ((topLevelLanguageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)\n        // If there is no grammar, we just take a guess and try to match brackets.\n        | (1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */)) >>> 0;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}