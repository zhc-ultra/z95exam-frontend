{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.string.substr.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createTrustedTypesPolicy } from '../../../base/browser/trustedTypes.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { assertIsDefined } from '../../../base/common/types.js';\nimport { applyFontInfo } from '../config/domFontInfo.js';\nimport { StringBuilder } from '../../common/core/stringBuilder.js';\nimport { ModelLineProjectionData } from '../../common/modelLineProjectionData.js';\nimport { LineInjectedText } from '../../common/textModelEvents.js';\nvar ttPolicy = createTrustedTypesPolicy('domLineBreaksComputer', {\n  createHTML: function createHTML(value) {\n    return value;\n  }\n});\nexport var DOMLineBreaksComputerFactory = /*#__PURE__*/function () {\n  function DOMLineBreaksComputerFactory(targetWindow) {\n    _classCallCheck(this, DOMLineBreaksComputerFactory);\n    this.targetWindow = targetWindow;\n  }\n  return _createClass(DOMLineBreaksComputerFactory, [{\n    key: \"createLineBreaksComputer\",\n    value: function createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent, wordBreak) {\n      var _this = this;\n      var requests = [];\n      var injectedTexts = [];\n      return {\n        addRequest: function addRequest(lineText, injectedText, previousLineBreakData) {\n          requests.push(lineText);\n          injectedTexts.push(injectedText);\n        },\n        finalize: function finalize() {\n          return createLineBreaks(assertIsDefined(_this.targetWindow.deref()), requests, fontInfo, tabSize, wrappingColumn, wrappingIndent, wordBreak, injectedTexts);\n        }\n      };\n    }\n  }], [{\n    key: \"create\",\n    value: function create(targetWindow) {\n      return new DOMLineBreaksComputerFactory(new WeakRef(targetWindow));\n    }\n  }]);\n}();\nfunction createLineBreaks(targetWindow, requests, fontInfo, tabSize, firstLineBreakColumn, wrappingIndent, wordBreak, injectedTextsPerLine) {\n  var _a;\n  function createEmptyLineBreakWithPossiblyInjectedText(requestIdx) {\n    var injectedTexts = injectedTextsPerLine[requestIdx];\n    if (injectedTexts) {\n      var lineText = LineInjectedText.applyInjectedText(requests[requestIdx], injectedTexts);\n      var injectionOptions = injectedTexts.map(function (t) {\n        return t.options;\n      });\n      var injectionOffsets = injectedTexts.map(function (text) {\n        return text.column - 1;\n      });\n      // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n      // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n      return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    } else {\n      return null;\n    }\n  }\n  if (firstLineBreakColumn === -1) {\n    var _result = [];\n    for (var i = 0, len = requests.length; i < len; i++) {\n      _result[i] = createEmptyLineBreakWithPossiblyInjectedText(i);\n    }\n    return _result;\n  }\n  var overallWidth = Math.round(firstLineBreakColumn * fontInfo.typicalHalfwidthCharacterWidth);\n  var additionalIndent = wrappingIndent === 3 /* WrappingIndent.DeepIndent */ ? 2 : wrappingIndent === 2 /* WrappingIndent.Indent */ ? 1 : 0;\n  var additionalIndentSize = Math.round(tabSize * additionalIndent);\n  var additionalIndentLength = Math.ceil(fontInfo.spaceWidth * additionalIndentSize);\n  var containerDomNode = document.createElement('div');\n  applyFontInfo(containerDomNode, fontInfo);\n  var sb = new StringBuilder(10000);\n  var firstNonWhitespaceIndices = [];\n  var wrappedTextIndentLengths = [];\n  var renderLineContents = [];\n  var allCharOffsets = [];\n  var allVisibleColumns = [];\n  for (var _i = 0; _i < requests.length; _i++) {\n    var lineContent = LineInjectedText.applyInjectedText(requests[_i], injectedTextsPerLine[_i]);\n    var firstNonWhitespaceIndex = 0;\n    var wrappedTextIndentLength = 0;\n    var width = overallWidth;\n    if (wrappingIndent !== 0 /* WrappingIndent.None */) {\n      firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n      if (firstNonWhitespaceIndex === -1) {\n        // all whitespace line\n        firstNonWhitespaceIndex = 0;\n      } else {\n        // Track existing indent\n        for (var _i2 = 0; _i2 < firstNonWhitespaceIndex; _i2++) {\n          var charWidth = lineContent.charCodeAt(_i2) === 9 /* CharCode.Tab */ ? tabSize - wrappedTextIndentLength % tabSize : 1;\n          wrappedTextIndentLength += charWidth;\n        }\n        var indentWidth = Math.ceil(fontInfo.spaceWidth * wrappedTextIndentLength);\n        // Force sticking to beginning of line if no character would fit except for the indentation\n        if (indentWidth + fontInfo.typicalFullwidthCharacterWidth > overallWidth) {\n          firstNonWhitespaceIndex = 0;\n          wrappedTextIndentLength = 0;\n        } else {\n          width = overallWidth - indentWidth;\n        }\n      }\n    }\n    var renderLineContent = lineContent.substr(firstNonWhitespaceIndex);\n    var tmp = renderLine(renderLineContent, wrappedTextIndentLength, tabSize, width, sb, additionalIndentLength);\n    firstNonWhitespaceIndices[_i] = firstNonWhitespaceIndex;\n    wrappedTextIndentLengths[_i] = wrappedTextIndentLength;\n    renderLineContents[_i] = renderLineContent;\n    allCharOffsets[_i] = tmp[0];\n    allVisibleColumns[_i] = tmp[1];\n  }\n  var html = sb.build();\n  var trustedhtml = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(html)) !== null && _a !== void 0 ? _a : html;\n  containerDomNode.innerHTML = trustedhtml;\n  containerDomNode.style.position = 'absolute';\n  containerDomNode.style.top = '10000';\n  if (wordBreak === 'keepAll') {\n    // word-break: keep-all; overflow-wrap: anywhere\n    containerDomNode.style.wordBreak = 'keep-all';\n    containerDomNode.style.overflowWrap = 'anywhere';\n  } else {\n    // overflow-wrap: break-word\n    containerDomNode.style.wordBreak = 'inherit';\n    containerDomNode.style.overflowWrap = 'break-word';\n  }\n  targetWindow.document.body.appendChild(containerDomNode);\n  var range = document.createRange();\n  var lineDomNodes = Array.prototype.slice.call(containerDomNode.children, 0);\n  var result = [];\n  for (var _i3 = 0; _i3 < requests.length; _i3++) {\n    var lineDomNode = lineDomNodes[_i3];\n    var breakOffsets = readLineBreaks(range, lineDomNode, renderLineContents[_i3], allCharOffsets[_i3]);\n    if (breakOffsets === null) {\n      result[_i3] = createEmptyLineBreakWithPossiblyInjectedText(_i3);\n      continue;\n    }\n    var _firstNonWhitespaceIndex = firstNonWhitespaceIndices[_i3];\n    var _wrappedTextIndentLength = wrappedTextIndentLengths[_i3] + additionalIndentSize;\n    var visibleColumns = allVisibleColumns[_i3];\n    var breakOffsetsVisibleColumn = [];\n    for (var j = 0, _len = breakOffsets.length; j < _len; j++) {\n      breakOffsetsVisibleColumn[j] = visibleColumns[breakOffsets[j]];\n    }\n    if (_firstNonWhitespaceIndex !== 0) {\n      // All break offsets are relative to the renderLineContent, make them absolute again\n      for (var _j = 0, _len2 = breakOffsets.length; _j < _len2; _j++) {\n        breakOffsets[_j] += _firstNonWhitespaceIndex;\n      }\n    }\n    var injectionOptions = void 0;\n    var injectionOffsets = void 0;\n    var curInjectedTexts = injectedTextsPerLine[_i3];\n    if (curInjectedTexts) {\n      injectionOptions = curInjectedTexts.map(function (t) {\n        return t.options;\n      });\n      injectionOffsets = curInjectedTexts.map(function (text) {\n        return text.column - 1;\n      });\n    } else {\n      injectionOptions = null;\n      injectionOffsets = null;\n    }\n    result[_i3] = new ModelLineProjectionData(injectionOffsets, injectionOptions, breakOffsets, breakOffsetsVisibleColumn, _wrappedTextIndentLength);\n  }\n  targetWindow.document.body.removeChild(containerDomNode);\n  return result;\n}\nfunction renderLine(lineContent, initialVisibleColumn, tabSize, width, sb, wrappingIndentLength) {\n  if (wrappingIndentLength !== 0) {\n    var hangingOffset = String(wrappingIndentLength);\n    sb.appendString('<div style=\"text-indent: -');\n    sb.appendString(hangingOffset);\n    sb.appendString('px; padding-left: ');\n    sb.appendString(hangingOffset);\n    sb.appendString('px; box-sizing: border-box; width:');\n  } else {\n    sb.appendString('<div style=\"width:');\n  }\n  sb.appendString(String(width));\n  sb.appendString('px;\">');\n  // if (containsRTL) {\n  // \tsb.appendASCIIString('\" dir=\"ltr');\n  // }\n  var len = lineContent.length;\n  var visibleColumn = initialVisibleColumn;\n  var charOffset = 0;\n  var charOffsets = [];\n  var visibleColumns = [];\n  var nextCharCode = 0 < len ? lineContent.charCodeAt(0) : 0 /* CharCode.Null */;\n  sb.appendString('<span>');\n  for (var charIndex = 0; charIndex < len; charIndex++) {\n    if (charIndex !== 0 && charIndex % 16384 /* Constants.SPAN_MODULO_LIMIT */ === 0) {\n      sb.appendString('</span><span>');\n    }\n    charOffsets[charIndex] = charOffset;\n    visibleColumns[charIndex] = visibleColumn;\n    var charCode = nextCharCode;\n    nextCharCode = charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* CharCode.Null */;\n    var producedCharacters = 1;\n    var charWidth = 1;\n    switch (charCode) {\n      case 9 /* CharCode.Tab */:\n        producedCharacters = tabSize - visibleColumn % tabSize;\n        charWidth = producedCharacters;\n        for (var space = 1; space <= producedCharacters; space++) {\n          if (space < producedCharacters) {\n            sb.appendCharCode(0xA0); // &nbsp;\n          } else {\n            sb.appendASCIICharCode(32 /* CharCode.Space */);\n          }\n        }\n        break;\n      case 32 /* CharCode.Space */:\n        if (nextCharCode === 32 /* CharCode.Space */) {\n          sb.appendCharCode(0xA0); // &nbsp;\n        } else {\n          sb.appendASCIICharCode(32 /* CharCode.Space */);\n        }\n        break;\n      case 60 /* CharCode.LessThan */:\n        sb.appendString('&lt;');\n        break;\n      case 62 /* CharCode.GreaterThan */:\n        sb.appendString('&gt;');\n        break;\n      case 38 /* CharCode.Ampersand */:\n        sb.appendString('&amp;');\n        break;\n      case 0 /* CharCode.Null */:\n        sb.appendString('&#00;');\n        break;\n      case 65279 /* CharCode.UTF8_BOM */:\n      case 8232 /* CharCode.LINE_SEPARATOR */:\n      case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n      case 133 /* CharCode.NEXT_LINE */:\n        sb.appendCharCode(0xFFFD);\n        break;\n      default:\n        if (strings.isFullWidthCharacter(charCode)) {\n          charWidth++;\n        }\n        if (charCode < 32) {\n          sb.appendCharCode(9216 + charCode);\n        } else {\n          sb.appendCharCode(charCode);\n        }\n    }\n    charOffset += producedCharacters;\n    visibleColumn += charWidth;\n  }\n  sb.appendString('</span>');\n  charOffsets[lineContent.length] = charOffset;\n  visibleColumns[lineContent.length] = visibleColumn;\n  sb.appendString('</div>');\n  return [charOffsets, visibleColumns];\n}\nfunction readLineBreaks(range, lineDomNode, lineContent, charOffsets) {\n  if (lineContent.length <= 1) {\n    return null;\n  }\n  var spans = Array.prototype.slice.call(lineDomNode.children, 0);\n  var breakOffsets = [];\n  try {\n    discoverBreaks(range, spans, charOffsets, 0, null, lineContent.length - 1, null, breakOffsets);\n  } catch (err) {\n    console.log(err);\n    return null;\n  }\n  if (breakOffsets.length === 0) {\n    return null;\n  }\n  breakOffsets.push(lineContent.length);\n  return breakOffsets;\n}\nfunction discoverBreaks(range, spans, charOffsets, low, lowRects, high, highRects, result) {\n  if (low === high) {\n    return;\n  }\n  lowRects = lowRects || readClientRect(range, spans, charOffsets[low], charOffsets[low + 1]);\n  highRects = highRects || readClientRect(range, spans, charOffsets[high], charOffsets[high + 1]);\n  if (Math.abs(lowRects[0].top - highRects[0].top) <= 0.1) {\n    // same line\n    return;\n  }\n  // there is at least one line break between these two offsets\n  if (low + 1 === high) {\n    // the two characters are adjacent, so the line break must be exactly between them\n    result.push(high);\n    return;\n  }\n  var mid = low + (high - low) / 2 | 0;\n  var midRects = readClientRect(range, spans, charOffsets[mid], charOffsets[mid + 1]);\n  discoverBreaks(range, spans, charOffsets, low, lowRects, mid, midRects, result);\n  discoverBreaks(range, spans, charOffsets, mid, midRects, high, highRects, result);\n}\nfunction readClientRect(range, spans, startOffset, endOffset) {\n  range.setStart(spans[startOffset / 16384 /* Constants.SPAN_MODULO_LIMIT */ | 0].firstChild, startOffset % 16384 /* Constants.SPAN_MODULO_LIMIT */);\n  range.setEnd(spans[endOffset / 16384 /* Constants.SPAN_MODULO_LIMIT */ | 0].firstChild, endOffset % 16384 /* Constants.SPAN_MODULO_LIMIT */);\n  return range.getClientRects();\n}","map":{"version":3,"names":["createTrustedTypesPolicy","strings","assertIsDefined","applyFontInfo","StringBuilder","ModelLineProjectionData","LineInjectedText","ttPolicy","createHTML","value","DOMLineBreaksComputerFactory","targetWindow","_classCallCheck","_createClass","key","createLineBreaksComputer","fontInfo","tabSize","wrappingColumn","wrappingIndent","wordBreak","_this","requests","injectedTexts","addRequest","lineText","injectedText","previousLineBreakData","push","finalize","createLineBreaks","deref","create","WeakRef","firstLineBreakColumn","injectedTextsPerLine","_a","createEmptyLineBreakWithPossiblyInjectedText","requestIdx","applyInjectedText","injectionOptions","map","t","options","injectionOffsets","text","column","length","result","i","len","overallWidth","Math","round","typicalHalfwidthCharacterWidth","additionalIndent","additionalIndentSize","additionalIndentLength","ceil","spaceWidth","containerDomNode","document","createElement","sb","firstNonWhitespaceIndices","wrappedTextIndentLengths","renderLineContents","allCharOffsets","allVisibleColumns","lineContent","firstNonWhitespaceIndex","wrappedTextIndentLength","width","charWidth","charCodeAt","indentWidth","typicalFullwidthCharacterWidth","renderLineContent","substr","tmp","renderLine","html","build","trustedhtml","innerHTML","style","position","top","overflowWrap","body","appendChild","range","createRange","lineDomNodes","Array","prototype","slice","call","children","lineDomNode","breakOffsets","readLineBreaks","visibleColumns","breakOffsetsVisibleColumn","j","curInjectedTexts","removeChild","initialVisibleColumn","wrappingIndentLength","hangingOffset","String","appendString","visibleColumn","charOffset","charOffsets","nextCharCode","charIndex","charCode","producedCharacters","space","appendCharCode","appendASCIICharCode","isFullWidthCharacter","spans","discoverBreaks","err","console","log","low","lowRects","high","highRects","readClientRect","abs","mid","midRects","startOffset","endOffset","setStart","firstChild","setEnd","getClientRects"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/browser/view/domLineBreaksComputer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createTrustedTypesPolicy } from '../../../base/browser/trustedTypes.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { assertIsDefined } from '../../../base/common/types.js';\nimport { applyFontInfo } from '../config/domFontInfo.js';\nimport { StringBuilder } from '../../common/core/stringBuilder.js';\nimport { ModelLineProjectionData } from '../../common/modelLineProjectionData.js';\nimport { LineInjectedText } from '../../common/textModelEvents.js';\nconst ttPolicy = createTrustedTypesPolicy('domLineBreaksComputer', { createHTML: value => value });\nexport class DOMLineBreaksComputerFactory {\n    static create(targetWindow) {\n        return new DOMLineBreaksComputerFactory(new WeakRef(targetWindow));\n    }\n    constructor(targetWindow) {\n        this.targetWindow = targetWindow;\n    }\n    createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent, wordBreak) {\n        const requests = [];\n        const injectedTexts = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                requests.push(lineText);\n                injectedTexts.push(injectedText);\n            },\n            finalize: () => {\n                return createLineBreaks(assertIsDefined(this.targetWindow.deref()), requests, fontInfo, tabSize, wrappingColumn, wrappingIndent, wordBreak, injectedTexts);\n            }\n        };\n    }\n}\nfunction createLineBreaks(targetWindow, requests, fontInfo, tabSize, firstLineBreakColumn, wrappingIndent, wordBreak, injectedTextsPerLine) {\n    var _a;\n    function createEmptyLineBreakWithPossiblyInjectedText(requestIdx) {\n        const injectedTexts = injectedTextsPerLine[requestIdx];\n        if (injectedTexts) {\n            const lineText = LineInjectedText.applyInjectedText(requests[requestIdx], injectedTexts);\n            const injectionOptions = injectedTexts.map(t => t.options);\n            const injectionOffsets = injectedTexts.map(text => text.column - 1);\n            // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n            // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n            return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n        }\n        else {\n            return null;\n        }\n    }\n    if (firstLineBreakColumn === -1) {\n        const result = [];\n        for (let i = 0, len = requests.length; i < len; i++) {\n            result[i] = createEmptyLineBreakWithPossiblyInjectedText(i);\n        }\n        return result;\n    }\n    const overallWidth = Math.round(firstLineBreakColumn * fontInfo.typicalHalfwidthCharacterWidth);\n    const additionalIndent = (wrappingIndent === 3 /* WrappingIndent.DeepIndent */ ? 2 : wrappingIndent === 2 /* WrappingIndent.Indent */ ? 1 : 0);\n    const additionalIndentSize = Math.round(tabSize * additionalIndent);\n    const additionalIndentLength = Math.ceil(fontInfo.spaceWidth * additionalIndentSize);\n    const containerDomNode = document.createElement('div');\n    applyFontInfo(containerDomNode, fontInfo);\n    const sb = new StringBuilder(10000);\n    const firstNonWhitespaceIndices = [];\n    const wrappedTextIndentLengths = [];\n    const renderLineContents = [];\n    const allCharOffsets = [];\n    const allVisibleColumns = [];\n    for (let i = 0; i < requests.length; i++) {\n        const lineContent = LineInjectedText.applyInjectedText(requests[i], injectedTextsPerLine[i]);\n        let firstNonWhitespaceIndex = 0;\n        let wrappedTextIndentLength = 0;\n        let width = overallWidth;\n        if (wrappingIndent !== 0 /* WrappingIndent.None */) {\n            firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n            if (firstNonWhitespaceIndex === -1) {\n                // all whitespace line\n                firstNonWhitespaceIndex = 0;\n            }\n            else {\n                // Track existing indent\n                for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n                    const charWidth = (lineContent.charCodeAt(i) === 9 /* CharCode.Tab */\n                        ? (tabSize - (wrappedTextIndentLength % tabSize))\n                        : 1);\n                    wrappedTextIndentLength += charWidth;\n                }\n                const indentWidth = Math.ceil(fontInfo.spaceWidth * wrappedTextIndentLength);\n                // Force sticking to beginning of line if no character would fit except for the indentation\n                if (indentWidth + fontInfo.typicalFullwidthCharacterWidth > overallWidth) {\n                    firstNonWhitespaceIndex = 0;\n                    wrappedTextIndentLength = 0;\n                }\n                else {\n                    width = overallWidth - indentWidth;\n                }\n            }\n        }\n        const renderLineContent = lineContent.substr(firstNonWhitespaceIndex);\n        const tmp = renderLine(renderLineContent, wrappedTextIndentLength, tabSize, width, sb, additionalIndentLength);\n        firstNonWhitespaceIndices[i] = firstNonWhitespaceIndex;\n        wrappedTextIndentLengths[i] = wrappedTextIndentLength;\n        renderLineContents[i] = renderLineContent;\n        allCharOffsets[i] = tmp[0];\n        allVisibleColumns[i] = tmp[1];\n    }\n    const html = sb.build();\n    const trustedhtml = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(html)) !== null && _a !== void 0 ? _a : html;\n    containerDomNode.innerHTML = trustedhtml;\n    containerDomNode.style.position = 'absolute';\n    containerDomNode.style.top = '10000';\n    if (wordBreak === 'keepAll') {\n        // word-break: keep-all; overflow-wrap: anywhere\n        containerDomNode.style.wordBreak = 'keep-all';\n        containerDomNode.style.overflowWrap = 'anywhere';\n    }\n    else {\n        // overflow-wrap: break-word\n        containerDomNode.style.wordBreak = 'inherit';\n        containerDomNode.style.overflowWrap = 'break-word';\n    }\n    targetWindow.document.body.appendChild(containerDomNode);\n    const range = document.createRange();\n    const lineDomNodes = Array.prototype.slice.call(containerDomNode.children, 0);\n    const result = [];\n    for (let i = 0; i < requests.length; i++) {\n        const lineDomNode = lineDomNodes[i];\n        const breakOffsets = readLineBreaks(range, lineDomNode, renderLineContents[i], allCharOffsets[i]);\n        if (breakOffsets === null) {\n            result[i] = createEmptyLineBreakWithPossiblyInjectedText(i);\n            continue;\n        }\n        const firstNonWhitespaceIndex = firstNonWhitespaceIndices[i];\n        const wrappedTextIndentLength = wrappedTextIndentLengths[i] + additionalIndentSize;\n        const visibleColumns = allVisibleColumns[i];\n        const breakOffsetsVisibleColumn = [];\n        for (let j = 0, len = breakOffsets.length; j < len; j++) {\n            breakOffsetsVisibleColumn[j] = visibleColumns[breakOffsets[j]];\n        }\n        if (firstNonWhitespaceIndex !== 0) {\n            // All break offsets are relative to the renderLineContent, make them absolute again\n            for (let j = 0, len = breakOffsets.length; j < len; j++) {\n                breakOffsets[j] += firstNonWhitespaceIndex;\n            }\n        }\n        let injectionOptions;\n        let injectionOffsets;\n        const curInjectedTexts = injectedTextsPerLine[i];\n        if (curInjectedTexts) {\n            injectionOptions = curInjectedTexts.map(t => t.options);\n            injectionOffsets = curInjectedTexts.map(text => text.column - 1);\n        }\n        else {\n            injectionOptions = null;\n            injectionOffsets = null;\n        }\n        result[i] = new ModelLineProjectionData(injectionOffsets, injectionOptions, breakOffsets, breakOffsetsVisibleColumn, wrappedTextIndentLength);\n    }\n    targetWindow.document.body.removeChild(containerDomNode);\n    return result;\n}\nfunction renderLine(lineContent, initialVisibleColumn, tabSize, width, sb, wrappingIndentLength) {\n    if (wrappingIndentLength !== 0) {\n        const hangingOffset = String(wrappingIndentLength);\n        sb.appendString('<div style=\"text-indent: -');\n        sb.appendString(hangingOffset);\n        sb.appendString('px; padding-left: ');\n        sb.appendString(hangingOffset);\n        sb.appendString('px; box-sizing: border-box; width:');\n    }\n    else {\n        sb.appendString('<div style=\"width:');\n    }\n    sb.appendString(String(width));\n    sb.appendString('px;\">');\n    // if (containsRTL) {\n    // \tsb.appendASCIIString('\" dir=\"ltr');\n    // }\n    const len = lineContent.length;\n    let visibleColumn = initialVisibleColumn;\n    let charOffset = 0;\n    const charOffsets = [];\n    const visibleColumns = [];\n    let nextCharCode = (0 < len ? lineContent.charCodeAt(0) : 0 /* CharCode.Null */);\n    sb.appendString('<span>');\n    for (let charIndex = 0; charIndex < len; charIndex++) {\n        if (charIndex !== 0 && charIndex % 16384 /* Constants.SPAN_MODULO_LIMIT */ === 0) {\n            sb.appendString('</span><span>');\n        }\n        charOffsets[charIndex] = charOffset;\n        visibleColumns[charIndex] = visibleColumn;\n        const charCode = nextCharCode;\n        nextCharCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* CharCode.Null */);\n        let producedCharacters = 1;\n        let charWidth = 1;\n        switch (charCode) {\n            case 9 /* CharCode.Tab */:\n                producedCharacters = (tabSize - (visibleColumn % tabSize));\n                charWidth = producedCharacters;\n                for (let space = 1; space <= producedCharacters; space++) {\n                    if (space < producedCharacters) {\n                        sb.appendCharCode(0xA0); // &nbsp;\n                    }\n                    else {\n                        sb.appendASCIICharCode(32 /* CharCode.Space */);\n                    }\n                }\n                break;\n            case 32 /* CharCode.Space */:\n                if (nextCharCode === 32 /* CharCode.Space */) {\n                    sb.appendCharCode(0xA0); // &nbsp;\n                }\n                else {\n                    sb.appendASCIICharCode(32 /* CharCode.Space */);\n                }\n                break;\n            case 60 /* CharCode.LessThan */:\n                sb.appendString('&lt;');\n                break;\n            case 62 /* CharCode.GreaterThan */:\n                sb.appendString('&gt;');\n                break;\n            case 38 /* CharCode.Ampersand */:\n                sb.appendString('&amp;');\n                break;\n            case 0 /* CharCode.Null */:\n                sb.appendString('&#00;');\n                break;\n            case 65279 /* CharCode.UTF8_BOM */:\n            case 8232 /* CharCode.LINE_SEPARATOR */:\n            case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n            case 133 /* CharCode.NEXT_LINE */:\n                sb.appendCharCode(0xFFFD);\n                break;\n            default:\n                if (strings.isFullWidthCharacter(charCode)) {\n                    charWidth++;\n                }\n                if (charCode < 32) {\n                    sb.appendCharCode(9216 + charCode);\n                }\n                else {\n                    sb.appendCharCode(charCode);\n                }\n        }\n        charOffset += producedCharacters;\n        visibleColumn += charWidth;\n    }\n    sb.appendString('</span>');\n    charOffsets[lineContent.length] = charOffset;\n    visibleColumns[lineContent.length] = visibleColumn;\n    sb.appendString('</div>');\n    return [charOffsets, visibleColumns];\n}\nfunction readLineBreaks(range, lineDomNode, lineContent, charOffsets) {\n    if (lineContent.length <= 1) {\n        return null;\n    }\n    const spans = Array.prototype.slice.call(lineDomNode.children, 0);\n    const breakOffsets = [];\n    try {\n        discoverBreaks(range, spans, charOffsets, 0, null, lineContent.length - 1, null, breakOffsets);\n    }\n    catch (err) {\n        console.log(err);\n        return null;\n    }\n    if (breakOffsets.length === 0) {\n        return null;\n    }\n    breakOffsets.push(lineContent.length);\n    return breakOffsets;\n}\nfunction discoverBreaks(range, spans, charOffsets, low, lowRects, high, highRects, result) {\n    if (low === high) {\n        return;\n    }\n    lowRects = lowRects || readClientRect(range, spans, charOffsets[low], charOffsets[low + 1]);\n    highRects = highRects || readClientRect(range, spans, charOffsets[high], charOffsets[high + 1]);\n    if (Math.abs(lowRects[0].top - highRects[0].top) <= 0.1) {\n        // same line\n        return;\n    }\n    // there is at least one line break between these two offsets\n    if (low + 1 === high) {\n        // the two characters are adjacent, so the line break must be exactly between them\n        result.push(high);\n        return;\n    }\n    const mid = low + ((high - low) / 2) | 0;\n    const midRects = readClientRect(range, spans, charOffsets[mid], charOffsets[mid + 1]);\n    discoverBreaks(range, spans, charOffsets, low, lowRects, mid, midRects, result);\n    discoverBreaks(range, spans, charOffsets, mid, midRects, high, highRects, result);\n}\nfunction readClientRect(range, spans, startOffset, endOffset) {\n    range.setStart(spans[(startOffset / 16384 /* Constants.SPAN_MODULO_LIMIT */) | 0].firstChild, startOffset % 16384 /* Constants.SPAN_MODULO_LIMIT */);\n    range.setEnd(spans[(endOffset / 16384 /* Constants.SPAN_MODULO_LIMIT */) | 0].firstChild, endOffset % 16384 /* Constants.SPAN_MODULO_LIMIT */);\n    return range.getClientRects();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}