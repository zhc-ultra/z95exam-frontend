{"ast":null,"code":"import _slicedToArray from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.typed-array.int32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { DiffChange } from './diffChange.js';\nimport { stringHash } from '../hash.js';\nexport var StringDiffSequence = /*#__PURE__*/function () {\n  function StringDiffSequence(source) {\n    _classCallCheck(this, StringDiffSequence);\n    this.source = source;\n  }\n  return _createClass(StringDiffSequence, [{\n    key: \"getElements\",\n    value: function getElements() {\n      var source = this.source;\n      var characters = new Int32Array(source.length);\n      for (var i = 0, len = source.length; i < len; i++) {\n        characters[i] = source.charCodeAt(i);\n      }\n      return characters;\n    }\n  }]);\n}();\nexport function stringDiff(original, modified, pretty) {\n  return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;\n}\n//\n// The code below has been ported from a C# implementation in VS\n//\nvar Debug = /*#__PURE__*/function () {\n  function Debug() {\n    _classCallCheck(this, Debug);\n  }\n  return _createClass(Debug, null, [{\n    key: \"Assert\",\n    value: function Assert(condition, message) {\n      if (!condition) {\n        throw new Error(message);\n      }\n    }\n  }]);\n}();\nvar MyArray = /*#__PURE__*/function () {\n  function MyArray() {\n    _classCallCheck(this, MyArray);\n  }\n  return _createClass(MyArray, null, [{\n    key: \"Copy\",\n    value:\n    /**\n     * Copies a range of elements from an Array starting at the specified source index and pastes\n     * them to another Array starting at the specified destination index. The length and the indexes\n     * are specified as 64-bit integers.\n     * sourceArray:\n     *\t\tThe Array that contains the data to copy.\n     * sourceIndex:\n     *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\n     * destinationArray:\n     *\t\tThe Array that receives the data.\n     * destinationIndex:\n     *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\n     * length:\n     *\t\tA 64-bit integer that represents the number of elements to copy.\n     */\n    function Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n      for (var i = 0; i < length; i++) {\n        destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n      }\n    }\n  }, {\n    key: \"Copy2\",\n    value: function Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n      for (var i = 0; i < length; i++) {\n        destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n      }\n    }\n  }]);\n}();\n/**\n * A utility class which helps to create the set of DiffChanges from\n * a difference operation. This class accepts original DiffElements and\n * modified DiffElements that are involved in a particular change. The\n * MarkNextChange() method can be called to mark the separation between\n * distinct changes. At the end, the Changes property can be called to retrieve\n * the constructed changes.\n */\nvar DiffChangeHelper = /*#__PURE__*/function () {\n  /**\n   * Constructs a new DiffChangeHelper for the given DiffSequences.\n   */\n  function DiffChangeHelper() {\n    _classCallCheck(this, DiffChangeHelper);\n    this.m_changes = [];\n    this.m_originalStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n    this.m_modifiedStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n    this.m_originalCount = 0;\n    this.m_modifiedCount = 0;\n  }\n  /**\n   * Marks the beginning of the next change in the set of differences.\n   */\n  return _createClass(DiffChangeHelper, [{\n    key: \"MarkNextChange\",\n    value: function MarkNextChange() {\n      // Only add to the list if there is something to add\n      if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n        // Add the new change to our list\n        this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\n      }\n      // Reset for the next change\n      this.m_originalCount = 0;\n      this.m_modifiedCount = 0;\n      this.m_originalStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n      this.m_modifiedStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n    }\n    /**\n     * Adds the original element at the given position to the elements\n     * affected by the current change. The modified index gives context\n     * to the change position with respect to the original sequence.\n     * @param originalIndex The index of the original element to add.\n     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\n     */\n  }, {\n    key: \"AddOriginalElement\",\n    value: function AddOriginalElement(originalIndex, modifiedIndex) {\n      // The 'true' start index is the smallest of the ones we've seen\n      this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n      this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n      this.m_originalCount++;\n    }\n    /**\n     * Adds the modified element at the given position to the elements\n     * affected by the current change. The original index gives context\n     * to the change position with respect to the modified sequence.\n     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\n     * @param modifiedIndex The index of the modified element to add.\n     */\n  }, {\n    key: \"AddModifiedElement\",\n    value: function AddModifiedElement(originalIndex, modifiedIndex) {\n      // The 'true' start index is the smallest of the ones we've seen\n      this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n      this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n      this.m_modifiedCount++;\n    }\n    /**\n     * Retrieves all of the changes marked by the class.\n     */\n  }, {\n    key: \"getChanges\",\n    value: function getChanges() {\n      if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n        // Finish up on whatever is left\n        this.MarkNextChange();\n      }\n      return this.m_changes;\n    }\n    /**\n     * Retrieves all of the changes marked by the class in the reverse order\n     */\n  }, {\n    key: \"getReverseChanges\",\n    value: function getReverseChanges() {\n      if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n        // Finish up on whatever is left\n        this.MarkNextChange();\n      }\n      this.m_changes.reverse();\n      return this.m_changes;\n    }\n  }]);\n}();\n/**\n * An implementation of the difference algorithm described in\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n */\nexport var LcsDiff = /*#__PURE__*/function () {\n  /**\n   * Constructs the DiffFinder\n   */\n  function LcsDiff(originalSequence, modifiedSequence) {\n    var continueProcessingPredicate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    _classCallCheck(this, LcsDiff);\n    this.ContinueProcessingPredicate = continueProcessingPredicate;\n    this._originalSequence = originalSequence;\n    this._modifiedSequence = modifiedSequence;\n    var _LcsDiff$_getElements = LcsDiff._getElements(originalSequence),\n      _LcsDiff$_getElements2 = _slicedToArray(_LcsDiff$_getElements, 3),\n      originalStringElements = _LcsDiff$_getElements2[0],\n      originalElementsOrHash = _LcsDiff$_getElements2[1],\n      originalHasStrings = _LcsDiff$_getElements2[2];\n    var _LcsDiff$_getElements3 = LcsDiff._getElements(modifiedSequence),\n      _LcsDiff$_getElements4 = _slicedToArray(_LcsDiff$_getElements3, 3),\n      modifiedStringElements = _LcsDiff$_getElements4[0],\n      modifiedElementsOrHash = _LcsDiff$_getElements4[1],\n      modifiedHasStrings = _LcsDiff$_getElements4[2];\n    this._hasStrings = originalHasStrings && modifiedHasStrings;\n    this._originalStringElements = originalStringElements;\n    this._originalElementsOrHash = originalElementsOrHash;\n    this._modifiedStringElements = modifiedStringElements;\n    this._modifiedElementsOrHash = modifiedElementsOrHash;\n    this.m_forwardHistory = [];\n    this.m_reverseHistory = [];\n  }\n  return _createClass(LcsDiff, [{\n    key: \"ElementsAreEqual\",\n    value: function ElementsAreEqual(originalIndex, newIndex) {\n      if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {\n        return false;\n      }\n      return this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true;\n    }\n  }, {\n    key: \"ElementsAreStrictEqual\",\n    value: function ElementsAreStrictEqual(originalIndex, newIndex) {\n      if (!this.ElementsAreEqual(originalIndex, newIndex)) {\n        return false;\n      }\n      var originalElement = LcsDiff._getStrictElement(this._originalSequence, originalIndex);\n      var modifiedElement = LcsDiff._getStrictElement(this._modifiedSequence, newIndex);\n      return originalElement === modifiedElement;\n    }\n  }, {\n    key: \"OriginalElementsAreEqual\",\n    value: function OriginalElementsAreEqual(index1, index2) {\n      if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {\n        return false;\n      }\n      return this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true;\n    }\n  }, {\n    key: \"ModifiedElementsAreEqual\",\n    value: function ModifiedElementsAreEqual(index1, index2) {\n      if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {\n        return false;\n      }\n      return this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true;\n    }\n  }, {\n    key: \"ComputeDiff\",\n    value: function ComputeDiff(pretty) {\n      return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);\n    }\n    /**\n     * Computes the differences between the original and modified input\n     * sequences on the bounded range.\n     * @returns An array of the differences between the two input sequences.\n     */\n  }, {\n    key: \"_ComputeDiff\",\n    value: function _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {\n      var quitEarlyArr = [false];\n      var changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n      if (pretty) {\n        // We have to clean up the computed diff to be more intuitive\n        // but it turns out this cannot be done correctly until the entire set\n        // of diffs have been computed\n        changes = this.PrettifyChanges(changes);\n      }\n      return {\n        quitEarly: quitEarlyArr[0],\n        changes: changes\n      };\n    }\n    /**\n     * Private helper method which computes the differences on the bounded range\n     * recursively.\n     * @returns An array of the differences between the two input sequences.\n     */\n  }, {\n    key: \"ComputeDiffRecursive\",\n    value: function ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\n      quitEarlyArr[0] = false;\n      // Find the start of the differences\n      while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\n        originalStart++;\n        modifiedStart++;\n      }\n      // Find the end of the differences\n      while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n        originalEnd--;\n        modifiedEnd--;\n      }\n      // In the special case where we either have all insertions or all deletions or the sequences are identical\n      if (originalStart > originalEnd || modifiedStart > modifiedEnd) {\n        var changes;\n        if (modifiedStart <= modifiedEnd) {\n          Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n          // All insertions\n          changes = [new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)];\n        } else if (originalStart <= originalEnd) {\n          Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n          // All deletions\n          changes = [new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)];\n        } else {\n          Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n          Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n          // Identical sequences - No differences\n          changes = [];\n        }\n        return changes;\n      }\n      // This problem can be solved using the Divide-And-Conquer technique.\n      var midOriginalArr = [0];\n      var midModifiedArr = [0];\n      var result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n      var midOriginal = midOriginalArr[0];\n      var midModified = midModifiedArr[0];\n      if (result !== null) {\n        // Result is not-null when there was enough memory to compute the changes while\n        // searching for the recursion point\n        return result;\n      } else if (!quitEarlyArr[0]) {\n        // We can break the problem down recursively by finding the changes in the\n        // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\n        // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\n        // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\n        var leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n        var rightChanges = [];\n        if (!quitEarlyArr[0]) {\n          rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n        } else {\n          // We didn't have time to finish the first half, so we don't have time to compute this half.\n          // Consider the entire rest of the sequence different.\n          rightChanges = [new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)];\n        }\n        return this.ConcatenateChanges(leftChanges, rightChanges);\n      }\n      // If we hit here, we quit early, and so can't return anything meaningful\n      return [new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)];\n    }\n  }, {\n    key: \"WALKTRACE\",\n    value: function WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\n      var forwardChanges = null;\n      var reverseChanges = null;\n      // First, walk backward through the forward diagonals history\n      var changeHelper = new DiffChangeHelper();\n      var diagonalMin = diagonalForwardStart;\n      var diagonalMax = diagonalForwardEnd;\n      var diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;\n      var lastOriginalIndex = -1073741824 /* Constants.MIN_SAFE_SMALL_INTEGER */;\n      var historyIndex = this.m_forwardHistory.length - 1;\n      do {\n        // Get the diagonal index from the relative diagonal number\n        var diagonal = diagonalRelative + diagonalForwardBase;\n        // Figure out where we came from\n        if (diagonal === diagonalMin || diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {\n          // Vertical line (the element is an insert)\n          originalIndex = forwardPoints[diagonal + 1];\n          modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n          if (originalIndex < lastOriginalIndex) {\n            changeHelper.MarkNextChange();\n          }\n          lastOriginalIndex = originalIndex;\n          changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n          diagonalRelative = diagonal + 1 - diagonalForwardBase; //Setup for the next iteration\n        } else {\n          // Horizontal line (the element is a deletion)\n          originalIndex = forwardPoints[diagonal - 1] + 1;\n          modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n          if (originalIndex < lastOriginalIndex) {\n            changeHelper.MarkNextChange();\n          }\n          lastOriginalIndex = originalIndex - 1;\n          changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n          diagonalRelative = diagonal - 1 - diagonalForwardBase; //Setup for the next iteration\n        }\n        if (historyIndex >= 0) {\n          forwardPoints = this.m_forwardHistory[historyIndex];\n          diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\n          diagonalMin = 1;\n          diagonalMax = forwardPoints.length - 1;\n        }\n      } while (--historyIndex >= -1);\n      // Ironically, we get the forward changes as the reverse of the\n      // order we added them since we technically added them backwards\n      forwardChanges = changeHelper.getReverseChanges();\n      if (quitEarlyArr[0]) {\n        // TODO: Calculate a partial from the reverse diagonals.\n        //       For now, just assume everything after the midOriginal/midModified point is a diff\n        var originalStartPoint = midOriginalArr[0] + 1;\n        var modifiedStartPoint = midModifiedArr[0] + 1;\n        if (forwardChanges !== null && forwardChanges.length > 0) {\n          var lastForwardChange = forwardChanges[forwardChanges.length - 1];\n          originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n          modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n        }\n        reverseChanges = [new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)];\n      } else {\n        // Now walk backward through the reverse diagonals history\n        changeHelper = new DiffChangeHelper();\n        diagonalMin = diagonalReverseStart;\n        diagonalMax = diagonalReverseEnd;\n        diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;\n        lastOriginalIndex = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n        historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n        do {\n          // Get the diagonal index from the relative diagonal number\n          var _diagonal = diagonalRelative + diagonalReverseBase;\n          // Figure out where we came from\n          if (_diagonal === diagonalMin || _diagonal < diagonalMax && reversePoints[_diagonal - 1] >= reversePoints[_diagonal + 1]) {\n            // Horizontal line (the element is a deletion))\n            originalIndex = reversePoints[_diagonal + 1] - 1;\n            modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n            if (originalIndex > lastOriginalIndex) {\n              changeHelper.MarkNextChange();\n            }\n            lastOriginalIndex = originalIndex + 1;\n            changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n            diagonalRelative = _diagonal + 1 - diagonalReverseBase; //Setup for the next iteration\n          } else {\n            // Vertical line (the element is an insertion)\n            originalIndex = reversePoints[_diagonal - 1];\n            modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n            if (originalIndex > lastOriginalIndex) {\n              changeHelper.MarkNextChange();\n            }\n            lastOriginalIndex = originalIndex;\n            changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n            diagonalRelative = _diagonal - 1 - diagonalReverseBase; //Setup for the next iteration\n          }\n          if (historyIndex >= 0) {\n            reversePoints = this.m_reverseHistory[historyIndex];\n            diagonalReverseBase = reversePoints[0]; //We stored this in the first spot\n            diagonalMin = 1;\n            diagonalMax = reversePoints.length - 1;\n          }\n        } while (--historyIndex >= -1);\n        // There are cases where the reverse history will find diffs that\n        // are correct, but not intuitive, so we need shift them.\n        reverseChanges = changeHelper.getChanges();\n      }\n      return this.ConcatenateChanges(forwardChanges, reverseChanges);\n    }\n    /**\n     * Given the range to compute the diff on, this method finds the point:\n     * (midOriginal, midModified)\n     * that exists in the middle of the LCS of the two sequences and\n     * is the point at which the LCS problem may be broken down recursively.\n     * This method will try to keep the LCS trace in memory. If the LCS recursion\n     * point is calculated and the full trace is available in memory, then this method\n     * will return the change list.\n     * @param originalStart The start bound of the original sequence range\n     * @param originalEnd The end bound of the original sequence range\n     * @param modifiedStart The start bound of the modified sequence range\n     * @param modifiedEnd The end bound of the modified sequence range\n     * @param midOriginal The middle point of the original sequence range\n     * @param midModified The middle point of the modified sequence range\n     * @returns The diff changes, if available, otherwise null\n     */\n  }, {\n    key: \"ComputeRecursionPoint\",\n    value: function ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\n      var originalIndex = 0,\n        modifiedIndex = 0;\n      var diagonalForwardStart = 0,\n        diagonalForwardEnd = 0;\n      var diagonalReverseStart = 0,\n        diagonalReverseEnd = 0;\n      // To traverse the edit graph and produce the proper LCS, our actual\n      // start position is just outside the given boundary\n      originalStart--;\n      modifiedStart--;\n      // We set these up to make the compiler happy, but they will\n      // be replaced before we return with the actual recursion point\n      midOriginalArr[0] = 0;\n      midModifiedArr[0] = 0;\n      // Clear out the history\n      this.m_forwardHistory = [];\n      this.m_reverseHistory = [];\n      // Each cell in the two arrays corresponds to a diagonal in the edit graph.\n      // The integer value in the cell represents the originalIndex of the furthest\n      // reaching point found so far that ends in that diagonal.\n      // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\n      var maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart);\n      var numDiagonals = maxDifferences + 1;\n      var forwardPoints = new Int32Array(numDiagonals);\n      var reversePoints = new Int32Array(numDiagonals);\n      // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\n      // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\n      var diagonalForwardBase = modifiedEnd - modifiedStart;\n      var diagonalReverseBase = originalEnd - originalStart;\n      // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n      //    diagonal number (relative to diagonalForwardBase)\n      // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n      //    diagonal number (relative to diagonalReverseBase)\n      var diagonalForwardOffset = originalStart - modifiedStart;\n      var diagonalReverseOffset = originalEnd - modifiedEnd;\n      // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\n      //   relative to the start diagonal with diagonal numbers relative to the end diagonal.\n      // The Even/Oddn-ness of this delta is important for determining when we should check for overlap\n      var delta = diagonalReverseBase - diagonalForwardBase;\n      var deltaIsEven = delta % 2 === 0;\n      // Here we set up the start and end points as the furthest points found so far\n      // in both the forward and reverse directions, respectively\n      forwardPoints[diagonalForwardBase] = originalStart;\n      reversePoints[diagonalReverseBase] = originalEnd;\n      // Remember if we quit early, and thus need to do a best-effort result instead of a real result.\n      quitEarlyArr[0] = false;\n      // A couple of points:\n      // --With this method, we iterate on the number of differences between the two sequences.\n      //   The more differences there actually are, the longer this will take.\n      // --Also, as the number of differences increases, we have to search on diagonals further\n      //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\n      // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\n      //   is even and odd diagonals only when numDifferences is odd.\n      for (var numDifferences = 1; numDifferences <= maxDifferences / 2 + 1; numDifferences++) {\n        var furthestOriginalIndex = 0;\n        var furthestModifiedIndex = 0;\n        // Run the algorithm in the forward direction\n        diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n        diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n        for (var diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\n          // STEP 1: We extend the furthest reaching point in the present diagonal\n          // by looking at the diagonals above and below and picking the one whose point\n          // is further away from the start point (originalStart, modifiedStart)\n          if (diagonal === diagonalForwardStart || diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {\n            originalIndex = forwardPoints[diagonal + 1];\n          } else {\n            originalIndex = forwardPoints[diagonal - 1] + 1;\n          }\n          modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\n          // Save the current originalIndex so we can test for false overlap in step 3\n          var tempOriginalIndex = originalIndex;\n          // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n          // so long as the elements are equal.\n          while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n            originalIndex++;\n            modifiedIndex++;\n          }\n          forwardPoints[diagonal] = originalIndex;\n          if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\n            furthestOriginalIndex = originalIndex;\n            furthestModifiedIndex = modifiedIndex;\n          }\n          // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\n          // and diagonal is in the range of reverse diagonals computed for numDifferences-1\n          // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\n          // then check for overlap.\n          if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= numDifferences - 1) {\n            if (originalIndex >= reversePoints[diagonal]) {\n              midOriginalArr[0] = originalIndex;\n              midModifiedArr[0] = modifiedIndex;\n              if (tempOriginalIndex <= reversePoints[diagonal] && 1447 /* LocalConstants.MaxDifferencesHistory */ > 0 && numDifferences <= 1447 /* LocalConstants.MaxDifferencesHistory */ + 1) {\n                // BINGO! We overlapped, and we have the full trace in memory!\n                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n              } else {\n                // Either false overlap, or we didn't have enough memory for the full trace\n                // Just return the recursion point\n                return null;\n              }\n            }\n          }\n        }\n        // Check to see if we should be quitting early, before moving on to the next iteration.\n        var matchLengthOfLongest = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n        if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {\n          // We can't finish, so skip ahead to generating a result from what we have.\n          quitEarlyArr[0] = true;\n          // Use the furthest distance we got in the forward direction.\n          midOriginalArr[0] = furthestOriginalIndex;\n          midModifiedArr[0] = furthestModifiedIndex;\n          if (matchLengthOfLongest > 0 && 1447 /* LocalConstants.MaxDifferencesHistory */ > 0 && numDifferences <= 1447 /* LocalConstants.MaxDifferencesHistory */ + 1) {\n            // Enough of the history is in memory to walk it backwards\n            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n          } else {\n            // We didn't actually remember enough of the history.\n            //Since we are quitting the diff early, we need to shift back the originalStart and modified start\n            //back into the boundary limits since we decremented their value above beyond the boundary limit.\n            originalStart++;\n            modifiedStart++;\n            return [new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)];\n          }\n        }\n        // Run the algorithm in the reverse direction\n        diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n        diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n        for (var _diagonal2 = diagonalReverseStart; _diagonal2 <= diagonalReverseEnd; _diagonal2 += 2) {\n          // STEP 1: We extend the furthest reaching point in the present diagonal\n          // by looking at the diagonals above and below and picking the one whose point\n          // is further away from the start point (originalEnd, modifiedEnd)\n          if (_diagonal2 === diagonalReverseStart || _diagonal2 < diagonalReverseEnd && reversePoints[_diagonal2 - 1] >= reversePoints[_diagonal2 + 1]) {\n            originalIndex = reversePoints[_diagonal2 + 1] - 1;\n          } else {\n            originalIndex = reversePoints[_diagonal2 - 1];\n          }\n          modifiedIndex = originalIndex - (_diagonal2 - diagonalReverseBase) - diagonalReverseOffset;\n          // Save the current originalIndex so we can test for false overlap\n          var _tempOriginalIndex = originalIndex;\n          // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n          // as long as the elements are equal.\n          while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n            originalIndex--;\n            modifiedIndex--;\n          }\n          reversePoints[_diagonal2] = originalIndex;\n          // STEP 4: If delta is even (overlap first happens on reverse when delta is even)\n          // and diagonal is in the range of forward diagonals computed for numDifferences\n          // then check for overlap.\n          if (deltaIsEven && Math.abs(_diagonal2 - diagonalForwardBase) <= numDifferences) {\n            if (originalIndex <= forwardPoints[_diagonal2]) {\n              midOriginalArr[0] = originalIndex;\n              midModifiedArr[0] = modifiedIndex;\n              if (_tempOriginalIndex >= forwardPoints[_diagonal2] && 1447 /* LocalConstants.MaxDifferencesHistory */ > 0 && numDifferences <= 1447 /* LocalConstants.MaxDifferencesHistory */ + 1) {\n                // BINGO! We overlapped, and we have the full trace in memory!\n                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n              } else {\n                // Either false overlap, or we didn't have enough memory for the full trace\n                // Just return the recursion point\n                return null;\n              }\n            }\n          }\n        }\n        // Save current vectors to history before the next iteration\n        if (numDifferences <= 1447 /* LocalConstants.MaxDifferencesHistory */) {\n          // We are allocating space for one extra int, which we fill with\n          // the index of the diagonal base index\n          var temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);\n          temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n          MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n          this.m_forwardHistory.push(temp);\n          temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);\n          temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n          MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n          this.m_reverseHistory.push(temp);\n        }\n      }\n      // If we got here, then we have the full trace in history. We just have to convert it to a change list\n      // NOTE: This part is a bit messy\n      return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n    }\n    /**\n     * Shifts the given changes to provide a more intuitive diff.\n     * While the first element in a diff matches the first element after the diff,\n     * we shift the diff down.\n     *\n     * @param changes The list of changes to shift\n     * @returns The shifted changes\n     */\n  }, {\n    key: \"PrettifyChanges\",\n    value: function PrettifyChanges(changes) {\n      // Shift all the changes down first\n      for (var i = 0; i < changes.length; i++) {\n        var change = changes[i];\n        var originalStop = i < changes.length - 1 ? changes[i + 1].originalStart : this._originalElementsOrHash.length;\n        var modifiedStop = i < changes.length - 1 ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;\n        var checkOriginal = change.originalLength > 0;\n        var checkModified = change.modifiedLength > 0;\n        while (change.originalStart + change.originalLength < originalStop && change.modifiedStart + change.modifiedLength < modifiedStop && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\n          var startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);\n          var endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);\n          if (endStrictEqual && !startStrictEqual) {\n            // moving the change down would create an equal change, but the elements are not strict equal\n            break;\n          }\n          change.originalStart++;\n          change.modifiedStart++;\n        }\n        var mergedChangeArr = [null];\n        if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\n          changes[i] = mergedChangeArr[0];\n          changes.splice(i + 1, 1);\n          i--;\n          continue;\n        }\n      }\n      // Shift changes back up until we hit empty or whitespace-only lines\n      for (var _i = changes.length - 1; _i >= 0; _i--) {\n        var _change = changes[_i];\n        var _originalStop = 0;\n        var _modifiedStop = 0;\n        if (_i > 0) {\n          var prevChange = changes[_i - 1];\n          _originalStop = prevChange.originalStart + prevChange.originalLength;\n          _modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\n        }\n        var _checkOriginal = _change.originalLength > 0;\n        var _checkModified = _change.modifiedLength > 0;\n        var bestDelta = 0;\n        var bestScore = this._boundaryScore(_change.originalStart, _change.originalLength, _change.modifiedStart, _change.modifiedLength);\n        for (var delta = 1;; delta++) {\n          var originalStart = _change.originalStart - delta;\n          var modifiedStart = _change.modifiedStart - delta;\n          if (originalStart < _originalStop || modifiedStart < _modifiedStop) {\n            break;\n          }\n          if (_checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + _change.originalLength)) {\n            break;\n          }\n          if (_checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + _change.modifiedLength)) {\n            break;\n          }\n          var touchingPreviousChange = originalStart === _originalStop && modifiedStart === _modifiedStop;\n          var score = (touchingPreviousChange ? 5 : 0) + this._boundaryScore(originalStart, _change.originalLength, modifiedStart, _change.modifiedLength);\n          if (score > bestScore) {\n            bestScore = score;\n            bestDelta = delta;\n          }\n        }\n        _change.originalStart -= bestDelta;\n        _change.modifiedStart -= bestDelta;\n        var _mergedChangeArr = [null];\n        if (_i > 0 && this.ChangesOverlap(changes[_i - 1], changes[_i], _mergedChangeArr)) {\n          changes[_i - 1] = _mergedChangeArr[0];\n          changes.splice(_i, 1);\n          _i++;\n          continue;\n        }\n      }\n      // There could be multiple longest common substrings.\n      // Give preference to the ones containing longer lines\n      if (this._hasStrings) {\n        for (var _i2 = 1, len = changes.length; _i2 < len; _i2++) {\n          var aChange = changes[_i2 - 1];\n          var bChange = changes[_i2];\n          var matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;\n          var aOriginalStart = aChange.originalStart;\n          var bOriginalEnd = bChange.originalStart + bChange.originalLength;\n          var abOriginalLength = bOriginalEnd - aOriginalStart;\n          var aModifiedStart = aChange.modifiedStart;\n          var bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;\n          var abModifiedLength = bModifiedEnd - aModifiedStart;\n          // Avoid wasting a lot of time with these searches\n          if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {\n            var t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);\n            if (t) {\n              var _t = _slicedToArray(t, 2),\n                originalMatchStart = _t[0],\n                modifiedMatchStart = _t[1];\n              if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {\n                // switch to another sequence that has a better score\n                aChange.originalLength = originalMatchStart - aChange.originalStart;\n                aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;\n                bChange.originalStart = originalMatchStart + matchedLength;\n                bChange.modifiedStart = modifiedMatchStart + matchedLength;\n                bChange.originalLength = bOriginalEnd - bChange.originalStart;\n                bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;\n              }\n            }\n          }\n        }\n      }\n      return changes;\n    }\n  }, {\n    key: \"_findBetterContiguousSequence\",\n    value: function _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {\n      if (originalLength < desiredLength || modifiedLength < desiredLength) {\n        return null;\n      }\n      var originalMax = originalStart + originalLength - desiredLength + 1;\n      var modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;\n      var bestScore = 0;\n      var bestOriginalStart = 0;\n      var bestModifiedStart = 0;\n      for (var i = originalStart; i < originalMax; i++) {\n        for (var j = modifiedStart; j < modifiedMax; j++) {\n          var score = this._contiguousSequenceScore(i, j, desiredLength);\n          if (score > 0 && score > bestScore) {\n            bestScore = score;\n            bestOriginalStart = i;\n            bestModifiedStart = j;\n          }\n        }\n      }\n      if (bestScore > 0) {\n        return [bestOriginalStart, bestModifiedStart];\n      }\n      return null;\n    }\n  }, {\n    key: \"_contiguousSequenceScore\",\n    value: function _contiguousSequenceScore(originalStart, modifiedStart, length) {\n      var score = 0;\n      for (var l = 0; l < length; l++) {\n        if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {\n          return 0;\n        }\n        score += this._originalStringElements[originalStart + l].length;\n      }\n      return score;\n    }\n  }, {\n    key: \"_OriginalIsBoundary\",\n    value: function _OriginalIsBoundary(index) {\n      if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {\n        return true;\n      }\n      return this._hasStrings && /^\\s*$/.test(this._originalStringElements[index]);\n    }\n  }, {\n    key: \"_OriginalRegionIsBoundary\",\n    value: function _OriginalRegionIsBoundary(originalStart, originalLength) {\n      if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\n        return true;\n      }\n      if (originalLength > 0) {\n        var originalEnd = originalStart + originalLength;\n        if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"_ModifiedIsBoundary\",\n    value: function _ModifiedIsBoundary(index) {\n      if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {\n        return true;\n      }\n      return this._hasStrings && /^\\s*$/.test(this._modifiedStringElements[index]);\n    }\n  }, {\n    key: \"_ModifiedRegionIsBoundary\",\n    value: function _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {\n      if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\n        return true;\n      }\n      if (modifiedLength > 0) {\n        var modifiedEnd = modifiedStart + modifiedLength;\n        if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"_boundaryScore\",\n    value: function _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {\n      var originalScore = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;\n      var modifiedScore = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;\n      return originalScore + modifiedScore;\n    }\n    /**\n     * Concatenates the two input DiffChange lists and returns the resulting\n     * list.\n     * @param The left changes\n     * @param The right changes\n     * @returns The concatenated list\n     */\n  }, {\n    key: \"ConcatenateChanges\",\n    value: function ConcatenateChanges(left, right) {\n      var mergedChangeArr = [];\n      if (left.length === 0 || right.length === 0) {\n        return right.length > 0 ? right : left;\n      } else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n        // Since we break the problem down recursively, it is possible that we\n        // might recurse in the middle of a change thereby splitting it into\n        // two changes. Here in the combining stage, we detect and fuse those\n        // changes back together\n        var result = new Array(left.length + right.length - 1);\n        MyArray.Copy(left, 0, result, 0, left.length - 1);\n        result[left.length - 1] = mergedChangeArr[0];\n        MyArray.Copy(right, 1, result, left.length, right.length - 1);\n        return result;\n      } else {\n        var _result = new Array(left.length + right.length);\n        MyArray.Copy(left, 0, _result, 0, left.length);\n        MyArray.Copy(right, 0, _result, left.length, right.length);\n        return _result;\n      }\n    }\n    /**\n     * Returns true if the two changes overlap and can be merged into a single\n     * change\n     * @param left The left change\n     * @param right The right change\n     * @param mergedChange The merged change if the two overlap, null otherwise\n     * @returns True if the two changes overlap\n     */\n  }, {\n    key: \"ChangesOverlap\",\n    value: function ChangesOverlap(left, right, mergedChangeArr) {\n      Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\n      Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\n      if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n        var originalStart = left.originalStart;\n        var originalLength = left.originalLength;\n        var modifiedStart = left.modifiedStart;\n        var modifiedLength = left.modifiedLength;\n        if (left.originalStart + left.originalLength >= right.originalStart) {\n          originalLength = right.originalStart + right.originalLength - left.originalStart;\n        }\n        if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n          modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n        }\n        mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\n        return true;\n      } else {\n        mergedChangeArr[0] = null;\n        return false;\n      }\n    }\n    /**\n     * Helper method used to clip a diagonal index to the range of valid\n     * diagonals. This also decides whether or not the diagonal index,\n     * if it exceeds the boundary, should be clipped to the boundary or clipped\n     * one inside the boundary depending on the Even/Odd status of the boundary\n     * and numDifferences.\n     * @param diagonal The index of the diagonal to clip.\n     * @param numDifferences The current number of differences being iterated upon.\n     * @param diagonalBaseIndex The base reference diagonal.\n     * @param numDiagonals The total number of diagonals.\n     * @returns The clipped diagonal index.\n     */\n  }, {\n    key: \"ClipDiagonalBound\",\n    value: function ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\n      if (diagonal >= 0 && diagonal < numDiagonals) {\n        // Nothing to clip, its in range\n        return diagonal;\n      }\n      // diagonalsBelow: The number of diagonals below the reference diagonal\n      // diagonalsAbove: The number of diagonals above the reference diagonal\n      var diagonalsBelow = diagonalBaseIndex;\n      var diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n      var diffEven = numDifferences % 2 === 0;\n      if (diagonal < 0) {\n        var lowerBoundEven = diagonalsBelow % 2 === 0;\n        return diffEven === lowerBoundEven ? 0 : 1;\n      } else {\n        var upperBoundEven = diagonalsAbove % 2 === 0;\n        return diffEven === upperBoundEven ? numDiagonals - 1 : numDiagonals - 2;\n      }\n    }\n  }], [{\n    key: \"_isStringArray\",\n    value: function _isStringArray(arr) {\n      return arr.length > 0 && typeof arr[0] === 'string';\n    }\n  }, {\n    key: \"_getElements\",\n    value: function _getElements(sequence) {\n      var elements = sequence.getElements();\n      if (LcsDiff._isStringArray(elements)) {\n        var hashes = new Int32Array(elements.length);\n        for (var i = 0, len = elements.length; i < len; i++) {\n          hashes[i] = stringHash(elements[i], 0);\n        }\n        return [elements, hashes, true];\n      }\n      if (elements instanceof Int32Array) {\n        return [[], elements, false];\n      }\n      return [[], new Int32Array(elements), false];\n    }\n  }, {\n    key: \"_getStrictElement\",\n    value: function _getStrictElement(sequence, index) {\n      if (typeof sequence.getStrictElement === 'function') {\n        return sequence.getStrictElement(index);\n      }\n      return null;\n    }\n  }]);\n}();","map":{"version":3,"names":["DiffChange","stringHash","StringDiffSequence","source","_classCallCheck","_createClass","key","value","getElements","characters","Int32Array","length","i","len","charCodeAt","stringDiff","original","modified","pretty","LcsDiff","ComputeDiff","changes","Debug","Assert","condition","message","Error","MyArray","Copy","sourceArray","sourceIndex","destinationArray","destinationIndex","Copy2","DiffChangeHelper","m_changes","m_originalStart","m_modifiedStart","m_originalCount","m_modifiedCount","MarkNextChange","push","AddOriginalElement","originalIndex","modifiedIndex","Math","min","AddModifiedElement","getChanges","getReverseChanges","reverse","originalSequence","modifiedSequence","continueProcessingPredicate","arguments","undefined","ContinueProcessingPredicate","_originalSequence","_modifiedSequence","_LcsDiff$_getElements","_getElements","_LcsDiff$_getElements2","_slicedToArray","originalStringElements","originalElementsOrHash","originalHasStrings","_LcsDiff$_getElements3","_LcsDiff$_getElements4","modifiedStringElements","modifiedElementsOrHash","modifiedHasStrings","_hasStrings","_originalStringElements","_originalElementsOrHash","_modifiedStringElements","_modifiedElementsOrHash","m_forwardHistory","m_reverseHistory","ElementsAreEqual","newIndex","ElementsAreStrictEqual","originalElement","_getStrictElement","modifiedElement","OriginalElementsAreEqual","index1","index2","ModifiedElementsAreEqual","_ComputeDiff","originalStart","originalEnd","modifiedStart","modifiedEnd","quitEarlyArr","ComputeDiffRecursive","PrettifyChanges","quitEarly","midOriginalArr","midModifiedArr","result","ComputeRecursionPoint","midOriginal","midModified","leftChanges","rightChanges","ConcatenateChanges","WALKTRACE","diagonalForwardBase","diagonalForwardStart","diagonalForwardEnd","diagonalForwardOffset","diagonalReverseBase","diagonalReverseStart","diagonalReverseEnd","diagonalReverseOffset","forwardPoints","reversePoints","deltaIsEven","forwardChanges","reverseChanges","changeHelper","diagonalMin","diagonalMax","diagonalRelative","lastOriginalIndex","historyIndex","diagonal","originalStartPoint","modifiedStartPoint","lastForwardChange","max","getOriginalEnd","getModifiedEnd","maxDifferences","numDiagonals","delta","numDifferences","furthestOriginalIndex","furthestModifiedIndex","ClipDiagonalBound","tempOriginalIndex","abs","matchLengthOfLongest","temp","change","originalStop","modifiedStop","checkOriginal","originalLength","checkModified","modifiedLength","startStrictEqual","endStrictEqual","mergedChangeArr","ChangesOverlap","splice","prevChange","bestDelta","bestScore","_boundaryScore","touchingPreviousChange","score","aChange","bChange","matchedLength","aOriginalStart","bOriginalEnd","abOriginalLength","aModifiedStart","bModifiedEnd","abModifiedLength","t","_findBetterContiguousSequence","_t","originalMatchStart","modifiedMatchStart","desiredLength","originalMax","modifiedMax","bestOriginalStart","bestModifiedStart","j","_contiguousSequenceScore","l","_OriginalIsBoundary","index","test","_OriginalRegionIsBoundary","_ModifiedIsBoundary","_ModifiedRegionIsBoundary","originalScore","modifiedScore","left","right","Array","diagonalBaseIndex","diagonalsBelow","diagonalsAbove","diffEven","lowerBoundEven","upperBoundEven","_isStringArray","arr","sequence","elements","hashes","getStrictElement"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/base/common/diff/diff.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { DiffChange } from './diffChange.js';\nimport { stringHash } from '../hash.js';\nexport class StringDiffSequence {\n    constructor(source) {\n        this.source = source;\n    }\n    getElements() {\n        const source = this.source;\n        const characters = new Int32Array(source.length);\n        for (let i = 0, len = source.length; i < len; i++) {\n            characters[i] = source.charCodeAt(i);\n        }\n        return characters;\n    }\n}\nexport function stringDiff(original, modified, pretty) {\n    return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;\n}\n//\n// The code below has been ported from a C# implementation in VS\n//\nclass Debug {\n    static Assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n}\nclass MyArray {\n    /**\n     * Copies a range of elements from an Array starting at the specified source index and pastes\n     * them to another Array starting at the specified destination index. The length and the indexes\n     * are specified as 64-bit integers.\n     * sourceArray:\n     *\t\tThe Array that contains the data to copy.\n     * sourceIndex:\n     *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\n     * destinationArray:\n     *\t\tThe Array that receives the data.\n     * destinationIndex:\n     *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\n     * length:\n     *\t\tA 64-bit integer that represents the number of elements to copy.\n     */\n    static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n        for (let i = 0; i < length; i++) {\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n        }\n    }\n    static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n        for (let i = 0; i < length; i++) {\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n        }\n    }\n}\n/**\n * A utility class which helps to create the set of DiffChanges from\n * a difference operation. This class accepts original DiffElements and\n * modified DiffElements that are involved in a particular change. The\n * MarkNextChange() method can be called to mark the separation between\n * distinct changes. At the end, the Changes property can be called to retrieve\n * the constructed changes.\n */\nclass DiffChangeHelper {\n    /**\n     * Constructs a new DiffChangeHelper for the given DiffSequences.\n     */\n    constructor() {\n        this.m_changes = [];\n        this.m_originalStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n        this.m_modifiedStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n        this.m_originalCount = 0;\n        this.m_modifiedCount = 0;\n    }\n    /**\n     * Marks the beginning of the next change in the set of differences.\n     */\n    MarkNextChange() {\n        // Only add to the list if there is something to add\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Add the new change to our list\n            this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\n        }\n        // Reset for the next change\n        this.m_originalCount = 0;\n        this.m_modifiedCount = 0;\n        this.m_originalStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n        this.m_modifiedStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n    }\n    /**\n     * Adds the original element at the given position to the elements\n     * affected by the current change. The modified index gives context\n     * to the change position with respect to the original sequence.\n     * @param originalIndex The index of the original element to add.\n     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\n     */\n    AddOriginalElement(originalIndex, modifiedIndex) {\n        // The 'true' start index is the smallest of the ones we've seen\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n        this.m_originalCount++;\n    }\n    /**\n     * Adds the modified element at the given position to the elements\n     * affected by the current change. The original index gives context\n     * to the change position with respect to the modified sequence.\n     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\n     * @param modifiedIndex The index of the modified element to add.\n     */\n    AddModifiedElement(originalIndex, modifiedIndex) {\n        // The 'true' start index is the smallest of the ones we've seen\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n        this.m_modifiedCount++;\n    }\n    /**\n     * Retrieves all of the changes marked by the class.\n     */\n    getChanges() {\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Finish up on whatever is left\n            this.MarkNextChange();\n        }\n        return this.m_changes;\n    }\n    /**\n     * Retrieves all of the changes marked by the class in the reverse order\n     */\n    getReverseChanges() {\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Finish up on whatever is left\n            this.MarkNextChange();\n        }\n        this.m_changes.reverse();\n        return this.m_changes;\n    }\n}\n/**\n * An implementation of the difference algorithm described in\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n */\nexport class LcsDiff {\n    /**\n     * Constructs the DiffFinder\n     */\n    constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {\n        this.ContinueProcessingPredicate = continueProcessingPredicate;\n        this._originalSequence = originalSequence;\n        this._modifiedSequence = modifiedSequence;\n        const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);\n        const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);\n        this._hasStrings = (originalHasStrings && modifiedHasStrings);\n        this._originalStringElements = originalStringElements;\n        this._originalElementsOrHash = originalElementsOrHash;\n        this._modifiedStringElements = modifiedStringElements;\n        this._modifiedElementsOrHash = modifiedElementsOrHash;\n        this.m_forwardHistory = [];\n        this.m_reverseHistory = [];\n    }\n    static _isStringArray(arr) {\n        return (arr.length > 0 && typeof arr[0] === 'string');\n    }\n    static _getElements(sequence) {\n        const elements = sequence.getElements();\n        if (LcsDiff._isStringArray(elements)) {\n            const hashes = new Int32Array(elements.length);\n            for (let i = 0, len = elements.length; i < len; i++) {\n                hashes[i] = stringHash(elements[i], 0);\n            }\n            return [elements, hashes, true];\n        }\n        if (elements instanceof Int32Array) {\n            return [[], elements, false];\n        }\n        return [[], new Int32Array(elements), false];\n    }\n    ElementsAreEqual(originalIndex, newIndex) {\n        if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {\n            return false;\n        }\n        return (this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true);\n    }\n    ElementsAreStrictEqual(originalIndex, newIndex) {\n        if (!this.ElementsAreEqual(originalIndex, newIndex)) {\n            return false;\n        }\n        const originalElement = LcsDiff._getStrictElement(this._originalSequence, originalIndex);\n        const modifiedElement = LcsDiff._getStrictElement(this._modifiedSequence, newIndex);\n        return (originalElement === modifiedElement);\n    }\n    static _getStrictElement(sequence, index) {\n        if (typeof sequence.getStrictElement === 'function') {\n            return sequence.getStrictElement(index);\n        }\n        return null;\n    }\n    OriginalElementsAreEqual(index1, index2) {\n        if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {\n            return false;\n        }\n        return (this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true);\n    }\n    ModifiedElementsAreEqual(index1, index2) {\n        if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {\n            return false;\n        }\n        return (this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true);\n    }\n    ComputeDiff(pretty) {\n        return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);\n    }\n    /**\n     * Computes the differences between the original and modified input\n     * sequences on the bounded range.\n     * @returns An array of the differences between the two input sequences.\n     */\n    _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {\n        const quitEarlyArr = [false];\n        let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n        if (pretty) {\n            // We have to clean up the computed diff to be more intuitive\n            // but it turns out this cannot be done correctly until the entire set\n            // of diffs have been computed\n            changes = this.PrettifyChanges(changes);\n        }\n        return {\n            quitEarly: quitEarlyArr[0],\n            changes: changes\n        };\n    }\n    /**\n     * Private helper method which computes the differences on the bounded range\n     * recursively.\n     * @returns An array of the differences between the two input sequences.\n     */\n    ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\n        quitEarlyArr[0] = false;\n        // Find the start of the differences\n        while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\n            originalStart++;\n            modifiedStart++;\n        }\n        // Find the end of the differences\n        while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n            originalEnd--;\n            modifiedEnd--;\n        }\n        // In the special case where we either have all insertions or all deletions or the sequences are identical\n        if (originalStart > originalEnd || modifiedStart > modifiedEnd) {\n            let changes;\n            if (modifiedStart <= modifiedEnd) {\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n                // All insertions\n                changes = [\n                    new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\n                ];\n            }\n            else if (originalStart <= originalEnd) {\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n                // All deletions\n                changes = [\n                    new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\n                ];\n            }\n            else {\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n                // Identical sequences - No differences\n                changes = [];\n            }\n            return changes;\n        }\n        // This problem can be solved using the Divide-And-Conquer technique.\n        const midOriginalArr = [0];\n        const midModifiedArr = [0];\n        const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n        const midOriginal = midOriginalArr[0];\n        const midModified = midModifiedArr[0];\n        if (result !== null) {\n            // Result is not-null when there was enough memory to compute the changes while\n            // searching for the recursion point\n            return result;\n        }\n        else if (!quitEarlyArr[0]) {\n            // We can break the problem down recursively by finding the changes in the\n            // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\n            // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\n            // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\n            const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n            let rightChanges = [];\n            if (!quitEarlyArr[0]) {\n                rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n            }\n            else {\n                // We didn't have time to finish the first half, so we don't have time to compute this half.\n                // Consider the entire rest of the sequence different.\n                rightChanges = [\n                    new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\n                ];\n            }\n            return this.ConcatenateChanges(leftChanges, rightChanges);\n        }\n        // If we hit here, we quit early, and so can't return anything meaningful\n        return [\n            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n        ];\n    }\n    WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\n        let forwardChanges = null;\n        let reverseChanges = null;\n        // First, walk backward through the forward diagonals history\n        let changeHelper = new DiffChangeHelper();\n        let diagonalMin = diagonalForwardStart;\n        let diagonalMax = diagonalForwardEnd;\n        let diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\n        let lastOriginalIndex = -1073741824 /* Constants.MIN_SAFE_SMALL_INTEGER */;\n        let historyIndex = this.m_forwardHistory.length - 1;\n        do {\n            // Get the diagonal index from the relative diagonal number\n            const diagonal = diagonalRelative + diagonalForwardBase;\n            // Figure out where we came from\n            if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n                // Vertical line (the element is an insert)\n                originalIndex = forwardPoints[diagonal + 1];\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n                if (originalIndex < lastOriginalIndex) {\n                    changeHelper.MarkNextChange();\n                }\n                lastOriginalIndex = originalIndex;\n                changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n                diagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration\n            }\n            else {\n                // Horizontal line (the element is a deletion)\n                originalIndex = forwardPoints[diagonal - 1] + 1;\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n                if (originalIndex < lastOriginalIndex) {\n                    changeHelper.MarkNextChange();\n                }\n                lastOriginalIndex = originalIndex - 1;\n                changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n                diagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration\n            }\n            if (historyIndex >= 0) {\n                forwardPoints = this.m_forwardHistory[historyIndex];\n                diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\n                diagonalMin = 1;\n                diagonalMax = forwardPoints.length - 1;\n            }\n        } while (--historyIndex >= -1);\n        // Ironically, we get the forward changes as the reverse of the\n        // order we added them since we technically added them backwards\n        forwardChanges = changeHelper.getReverseChanges();\n        if (quitEarlyArr[0]) {\n            // TODO: Calculate a partial from the reverse diagonals.\n            //       For now, just assume everything after the midOriginal/midModified point is a diff\n            let originalStartPoint = midOriginalArr[0] + 1;\n            let modifiedStartPoint = midModifiedArr[0] + 1;\n            if (forwardChanges !== null && forwardChanges.length > 0) {\n                const lastForwardChange = forwardChanges[forwardChanges.length - 1];\n                originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n                modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n            }\n            reverseChanges = [\n                new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\n            ];\n        }\n        else {\n            // Now walk backward through the reverse diagonals history\n            changeHelper = new DiffChangeHelper();\n            diagonalMin = diagonalReverseStart;\n            diagonalMax = diagonalReverseEnd;\n            diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\n            lastOriginalIndex = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n            historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n            do {\n                // Get the diagonal index from the relative diagonal number\n                const diagonal = diagonalRelative + diagonalReverseBase;\n                // Figure out where we came from\n                if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n                    // Horizontal line (the element is a deletion))\n                    originalIndex = reversePoints[diagonal + 1] - 1;\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n                    if (originalIndex > lastOriginalIndex) {\n                        changeHelper.MarkNextChange();\n                    }\n                    lastOriginalIndex = originalIndex + 1;\n                    changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n                    diagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration\n                }\n                else {\n                    // Vertical line (the element is an insertion)\n                    originalIndex = reversePoints[diagonal - 1];\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n                    if (originalIndex > lastOriginalIndex) {\n                        changeHelper.MarkNextChange();\n                    }\n                    lastOriginalIndex = originalIndex;\n                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n                    diagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration\n                }\n                if (historyIndex >= 0) {\n                    reversePoints = this.m_reverseHistory[historyIndex];\n                    diagonalReverseBase = reversePoints[0]; //We stored this in the first spot\n                    diagonalMin = 1;\n                    diagonalMax = reversePoints.length - 1;\n                }\n            } while (--historyIndex >= -1);\n            // There are cases where the reverse history will find diffs that\n            // are correct, but not intuitive, so we need shift them.\n            reverseChanges = changeHelper.getChanges();\n        }\n        return this.ConcatenateChanges(forwardChanges, reverseChanges);\n    }\n    /**\n     * Given the range to compute the diff on, this method finds the point:\n     * (midOriginal, midModified)\n     * that exists in the middle of the LCS of the two sequences and\n     * is the point at which the LCS problem may be broken down recursively.\n     * This method will try to keep the LCS trace in memory. If the LCS recursion\n     * point is calculated and the full trace is available in memory, then this method\n     * will return the change list.\n     * @param originalStart The start bound of the original sequence range\n     * @param originalEnd The end bound of the original sequence range\n     * @param modifiedStart The start bound of the modified sequence range\n     * @param modifiedEnd The end bound of the modified sequence range\n     * @param midOriginal The middle point of the original sequence range\n     * @param midModified The middle point of the modified sequence range\n     * @returns The diff changes, if available, otherwise null\n     */\n    ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\n        let originalIndex = 0, modifiedIndex = 0;\n        let diagonalForwardStart = 0, diagonalForwardEnd = 0;\n        let diagonalReverseStart = 0, diagonalReverseEnd = 0;\n        // To traverse the edit graph and produce the proper LCS, our actual\n        // start position is just outside the given boundary\n        originalStart--;\n        modifiedStart--;\n        // We set these up to make the compiler happy, but they will\n        // be replaced before we return with the actual recursion point\n        midOriginalArr[0] = 0;\n        midModifiedArr[0] = 0;\n        // Clear out the history\n        this.m_forwardHistory = [];\n        this.m_reverseHistory = [];\n        // Each cell in the two arrays corresponds to a diagonal in the edit graph.\n        // The integer value in the cell represents the originalIndex of the furthest\n        // reaching point found so far that ends in that diagonal.\n        // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\n        const maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\n        const numDiagonals = maxDifferences + 1;\n        const forwardPoints = new Int32Array(numDiagonals);\n        const reversePoints = new Int32Array(numDiagonals);\n        // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\n        // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\n        const diagonalForwardBase = (modifiedEnd - modifiedStart);\n        const diagonalReverseBase = (originalEnd - originalStart);\n        // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n        //    diagonal number (relative to diagonalForwardBase)\n        // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n        //    diagonal number (relative to diagonalReverseBase)\n        const diagonalForwardOffset = (originalStart - modifiedStart);\n        const diagonalReverseOffset = (originalEnd - modifiedEnd);\n        // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\n        //   relative to the start diagonal with diagonal numbers relative to the end diagonal.\n        // The Even/Oddn-ness of this delta is important for determining when we should check for overlap\n        const delta = diagonalReverseBase - diagonalForwardBase;\n        const deltaIsEven = (delta % 2 === 0);\n        // Here we set up the start and end points as the furthest points found so far\n        // in both the forward and reverse directions, respectively\n        forwardPoints[diagonalForwardBase] = originalStart;\n        reversePoints[diagonalReverseBase] = originalEnd;\n        // Remember if we quit early, and thus need to do a best-effort result instead of a real result.\n        quitEarlyArr[0] = false;\n        // A couple of points:\n        // --With this method, we iterate on the number of differences between the two sequences.\n        //   The more differences there actually are, the longer this will take.\n        // --Also, as the number of differences increases, we have to search on diagonals further\n        //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\n        // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\n        //   is even and odd diagonals only when numDifferences is odd.\n        for (let numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\n            let furthestOriginalIndex = 0;\n            let furthestModifiedIndex = 0;\n            // Run the algorithm in the forward direction\n            diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n            diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n            for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\n                // STEP 1: We extend the furthest reaching point in the present diagonal\n                // by looking at the diagonals above and below and picking the one whose point\n                // is further away from the start point (originalStart, modifiedStart)\n                if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n                    originalIndex = forwardPoints[diagonal + 1];\n                }\n                else {\n                    originalIndex = forwardPoints[diagonal - 1] + 1;\n                }\n                modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\n                // Save the current originalIndex so we can test for false overlap in step 3\n                const tempOriginalIndex = originalIndex;\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n                // so long as the elements are equal.\n                while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n                    originalIndex++;\n                    modifiedIndex++;\n                }\n                forwardPoints[diagonal] = originalIndex;\n                if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\n                    furthestOriginalIndex = originalIndex;\n                    furthestModifiedIndex = modifiedIndex;\n                }\n                // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\n                // and diagonal is in the range of reverse diagonals computed for numDifferences-1\n                // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\n                // then check for overlap.\n                if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\n                    if (originalIndex >= reversePoints[diagonal]) {\n                        midOriginalArr[0] = originalIndex;\n                        midModifiedArr[0] = modifiedIndex;\n                        if (tempOriginalIndex <= reversePoints[diagonal] && 1447 /* LocalConstants.MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* LocalConstants.MaxDifferencesHistory */ + 1)) {\n                            // BINGO! We overlapped, and we have the full trace in memory!\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                        }\n                        else {\n                            // Either false overlap, or we didn't have enough memory for the full trace\n                            // Just return the recursion point\n                            return null;\n                        }\n                    }\n                }\n            }\n            // Check to see if we should be quitting early, before moving on to the next iteration.\n            const matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {\n                // We can't finish, so skip ahead to generating a result from what we have.\n                quitEarlyArr[0] = true;\n                // Use the furthest distance we got in the forward direction.\n                midOriginalArr[0] = furthestOriginalIndex;\n                midModifiedArr[0] = furthestModifiedIndex;\n                if (matchLengthOfLongest > 0 && 1447 /* LocalConstants.MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* LocalConstants.MaxDifferencesHistory */ + 1)) {\n                    // Enough of the history is in memory to walk it backwards\n                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                }\n                else {\n                    // We didn't actually remember enough of the history.\n                    //Since we are quitting the diff early, we need to shift back the originalStart and modified start\n                    //back into the boundary limits since we decremented their value above beyond the boundary limit.\n                    originalStart++;\n                    modifiedStart++;\n                    return [\n                        new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n                    ];\n                }\n            }\n            // Run the algorithm in the reverse direction\n            diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n            diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n            for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\n                // STEP 1: We extend the furthest reaching point in the present diagonal\n                // by looking at the diagonals above and below and picking the one whose point\n                // is further away from the start point (originalEnd, modifiedEnd)\n                if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n                    originalIndex = reversePoints[diagonal + 1] - 1;\n                }\n                else {\n                    originalIndex = reversePoints[diagonal - 1];\n                }\n                modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\n                // Save the current originalIndex so we can test for false overlap\n                const tempOriginalIndex = originalIndex;\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n                // as long as the elements are equal.\n                while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n                    originalIndex--;\n                    modifiedIndex--;\n                }\n                reversePoints[diagonal] = originalIndex;\n                // STEP 4: If delta is even (overlap first happens on reverse when delta is even)\n                // and diagonal is in the range of forward diagonals computed for numDifferences\n                // then check for overlap.\n                if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\n                    if (originalIndex <= forwardPoints[diagonal]) {\n                        midOriginalArr[0] = originalIndex;\n                        midModifiedArr[0] = modifiedIndex;\n                        if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 /* LocalConstants.MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* LocalConstants.MaxDifferencesHistory */ + 1)) {\n                            // BINGO! We overlapped, and we have the full trace in memory!\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                        }\n                        else {\n                            // Either false overlap, or we didn't have enough memory for the full trace\n                            // Just return the recursion point\n                            return null;\n                        }\n                    }\n                }\n            }\n            // Save current vectors to history before the next iteration\n            if (numDifferences <= 1447 /* LocalConstants.MaxDifferencesHistory */) {\n                // We are allocating space for one extra int, which we fill with\n                // the index of the diagonal base index\n                let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);\n                temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n                MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n                this.m_forwardHistory.push(temp);\n                temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);\n                temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n                MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n                this.m_reverseHistory.push(temp);\n            }\n        }\n        // If we got here, then we have the full trace in history. We just have to convert it to a change list\n        // NOTE: This part is a bit messy\n        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n    }\n    /**\n     * Shifts the given changes to provide a more intuitive diff.\n     * While the first element in a diff matches the first element after the diff,\n     * we shift the diff down.\n     *\n     * @param changes The list of changes to shift\n     * @returns The shifted changes\n     */\n    PrettifyChanges(changes) {\n        // Shift all the changes down first\n        for (let i = 0; i < changes.length; i++) {\n            const change = changes[i];\n            const originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this._originalElementsOrHash.length;\n            const modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;\n            const checkOriginal = change.originalLength > 0;\n            const checkModified = change.modifiedLength > 0;\n            while (change.originalStart + change.originalLength < originalStop\n                && change.modifiedStart + change.modifiedLength < modifiedStop\n                && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength))\n                && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\n                const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);\n                const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);\n                if (endStrictEqual && !startStrictEqual) {\n                    // moving the change down would create an equal change, but the elements are not strict equal\n                    break;\n                }\n                change.originalStart++;\n                change.modifiedStart++;\n            }\n            const mergedChangeArr = [null];\n            if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\n                changes[i] = mergedChangeArr[0];\n                changes.splice(i + 1, 1);\n                i--;\n                continue;\n            }\n        }\n        // Shift changes back up until we hit empty or whitespace-only lines\n        for (let i = changes.length - 1; i >= 0; i--) {\n            const change = changes[i];\n            let originalStop = 0;\n            let modifiedStop = 0;\n            if (i > 0) {\n                const prevChange = changes[i - 1];\n                originalStop = prevChange.originalStart + prevChange.originalLength;\n                modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\n            }\n            const checkOriginal = change.originalLength > 0;\n            const checkModified = change.modifiedLength > 0;\n            let bestDelta = 0;\n            let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\n            for (let delta = 1;; delta++) {\n                const originalStart = change.originalStart - delta;\n                const modifiedStart = change.modifiedStart - delta;\n                if (originalStart < originalStop || modifiedStart < modifiedStop) {\n                    break;\n                }\n                if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\n                    break;\n                }\n                if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\n                    break;\n                }\n                const touchingPreviousChange = (originalStart === originalStop && modifiedStart === modifiedStop);\n                const score = ((touchingPreviousChange ? 5 : 0)\n                    + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength));\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestDelta = delta;\n                }\n            }\n            change.originalStart -= bestDelta;\n            change.modifiedStart -= bestDelta;\n            const mergedChangeArr = [null];\n            if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {\n                changes[i - 1] = mergedChangeArr[0];\n                changes.splice(i, 1);\n                i++;\n                continue;\n            }\n        }\n        // There could be multiple longest common substrings.\n        // Give preference to the ones containing longer lines\n        if (this._hasStrings) {\n            for (let i = 1, len = changes.length; i < len; i++) {\n                const aChange = changes[i - 1];\n                const bChange = changes[i];\n                const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;\n                const aOriginalStart = aChange.originalStart;\n                const bOriginalEnd = bChange.originalStart + bChange.originalLength;\n                const abOriginalLength = bOriginalEnd - aOriginalStart;\n                const aModifiedStart = aChange.modifiedStart;\n                const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;\n                const abModifiedLength = bModifiedEnd - aModifiedStart;\n                // Avoid wasting a lot of time with these searches\n                if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {\n                    const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);\n                    if (t) {\n                        const [originalMatchStart, modifiedMatchStart] = t;\n                        if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {\n                            // switch to another sequence that has a better score\n                            aChange.originalLength = originalMatchStart - aChange.originalStart;\n                            aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;\n                            bChange.originalStart = originalMatchStart + matchedLength;\n                            bChange.modifiedStart = modifiedMatchStart + matchedLength;\n                            bChange.originalLength = bOriginalEnd - bChange.originalStart;\n                            bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;\n                        }\n                    }\n                }\n            }\n        }\n        return changes;\n    }\n    _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {\n        if (originalLength < desiredLength || modifiedLength < desiredLength) {\n            return null;\n        }\n        const originalMax = originalStart + originalLength - desiredLength + 1;\n        const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;\n        let bestScore = 0;\n        let bestOriginalStart = 0;\n        let bestModifiedStart = 0;\n        for (let i = originalStart; i < originalMax; i++) {\n            for (let j = modifiedStart; j < modifiedMax; j++) {\n                const score = this._contiguousSequenceScore(i, j, desiredLength);\n                if (score > 0 && score > bestScore) {\n                    bestScore = score;\n                    bestOriginalStart = i;\n                    bestModifiedStart = j;\n                }\n            }\n        }\n        if (bestScore > 0) {\n            return [bestOriginalStart, bestModifiedStart];\n        }\n        return null;\n    }\n    _contiguousSequenceScore(originalStart, modifiedStart, length) {\n        let score = 0;\n        for (let l = 0; l < length; l++) {\n            if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {\n                return 0;\n            }\n            score += this._originalStringElements[originalStart + l].length;\n        }\n        return score;\n    }\n    _OriginalIsBoundary(index) {\n        if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {\n            return true;\n        }\n        return (this._hasStrings && /^\\s*$/.test(this._originalStringElements[index]));\n    }\n    _OriginalRegionIsBoundary(originalStart, originalLength) {\n        if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\n            return true;\n        }\n        if (originalLength > 0) {\n            const originalEnd = originalStart + originalLength;\n            if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _ModifiedIsBoundary(index) {\n        if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {\n            return true;\n        }\n        return (this._hasStrings && /^\\s*$/.test(this._modifiedStringElements[index]));\n    }\n    _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {\n        if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\n            return true;\n        }\n        if (modifiedLength > 0) {\n            const modifiedEnd = modifiedStart + modifiedLength;\n            if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {\n        const originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);\n        const modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);\n        return (originalScore + modifiedScore);\n    }\n    /**\n     * Concatenates the two input DiffChange lists and returns the resulting\n     * list.\n     * @param The left changes\n     * @param The right changes\n     * @returns The concatenated list\n     */\n    ConcatenateChanges(left, right) {\n        const mergedChangeArr = [];\n        if (left.length === 0 || right.length === 0) {\n            return (right.length > 0) ? right : left;\n        }\n        else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n            // Since we break the problem down recursively, it is possible that we\n            // might recurse in the middle of a change thereby splitting it into\n            // two changes. Here in the combining stage, we detect and fuse those\n            // changes back together\n            const result = new Array(left.length + right.length - 1);\n            MyArray.Copy(left, 0, result, 0, left.length - 1);\n            result[left.length - 1] = mergedChangeArr[0];\n            MyArray.Copy(right, 1, result, left.length, right.length - 1);\n            return result;\n        }\n        else {\n            const result = new Array(left.length + right.length);\n            MyArray.Copy(left, 0, result, 0, left.length);\n            MyArray.Copy(right, 0, result, left.length, right.length);\n            return result;\n        }\n    }\n    /**\n     * Returns true if the two changes overlap and can be merged into a single\n     * change\n     * @param left The left change\n     * @param right The right change\n     * @param mergedChange The merged change if the two overlap, null otherwise\n     * @returns True if the two changes overlap\n     */\n    ChangesOverlap(left, right, mergedChangeArr) {\n        Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\n        Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\n        if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n            const originalStart = left.originalStart;\n            let originalLength = left.originalLength;\n            const modifiedStart = left.modifiedStart;\n            let modifiedLength = left.modifiedLength;\n            if (left.originalStart + left.originalLength >= right.originalStart) {\n                originalLength = right.originalStart + right.originalLength - left.originalStart;\n            }\n            if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n                modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n            }\n            mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\n            return true;\n        }\n        else {\n            mergedChangeArr[0] = null;\n            return false;\n        }\n    }\n    /**\n     * Helper method used to clip a diagonal index to the range of valid\n     * diagonals. This also decides whether or not the diagonal index,\n     * if it exceeds the boundary, should be clipped to the boundary or clipped\n     * one inside the boundary depending on the Even/Odd status of the boundary\n     * and numDifferences.\n     * @param diagonal The index of the diagonal to clip.\n     * @param numDifferences The current number of differences being iterated upon.\n     * @param diagonalBaseIndex The base reference diagonal.\n     * @param numDiagonals The total number of diagonals.\n     * @returns The clipped diagonal index.\n     */\n    ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\n        if (diagonal >= 0 && diagonal < numDiagonals) {\n            // Nothing to clip, its in range\n            return diagonal;\n        }\n        // diagonalsBelow: The number of diagonals below the reference diagonal\n        // diagonalsAbove: The number of diagonals above the reference diagonal\n        const diagonalsBelow = diagonalBaseIndex;\n        const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n        const diffEven = (numDifferences % 2 === 0);\n        if (diagonal < 0) {\n            const lowerBoundEven = (diagonalsBelow % 2 === 0);\n            return (diffEven === lowerBoundEven) ? 0 : 1;\n        }\n        else {\n            const upperBoundEven = (diagonalsAbove % 2 === 0);\n            return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}