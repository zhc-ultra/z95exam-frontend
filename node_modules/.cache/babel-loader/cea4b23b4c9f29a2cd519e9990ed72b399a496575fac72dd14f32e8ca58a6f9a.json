{"ast":null,"code":"import _defineProperty from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.string.trim-end.js\";\nimport \"core-js/modules/es.string.trim-start.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLastIdxMonotonous, findLastMonotonous, findFirstMonotonous } from '../../../../base/common/arraysFind.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { isSpace } from './utils.js';\nexport var LinesSliceCharSequence = /*#__PURE__*/function () {\n  function LinesSliceCharSequence(lines, lineRange, considerWhitespaceChanges) {\n    _classCallCheck(this, LinesSliceCharSequence);\n    // This slice has to have lineRange.length many \\n! (otherwise diffing against an empty slice will be problematic)\n    // (Unless it covers the entire document, in that case the other slice also has to cover the entire document ands it's okay)\n    this.lines = lines;\n    this.considerWhitespaceChanges = considerWhitespaceChanges;\n    this.elements = [];\n    this.firstCharOffsetByLine = [];\n    // To account for trimming\n    this.additionalOffsetByLine = [];\n    // If the slice covers the end, but does not start at the beginning, we include just the \\n of the previous line.\n    var trimFirstLineFully = false;\n    if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {\n      lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);\n      trimFirstLineFully = true;\n    }\n    this.lineRange = lineRange;\n    this.firstCharOffsetByLine[0] = 0;\n    for (var i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {\n      var line = lines[i];\n      var offset = 0;\n      if (trimFirstLineFully) {\n        offset = line.length;\n        line = '';\n        trimFirstLineFully = false;\n      } else if (!considerWhitespaceChanges) {\n        var trimmedStartLine = line.trimStart();\n        offset = line.length - trimmedStartLine.length;\n        line = trimmedStartLine.trimEnd();\n      }\n      this.additionalOffsetByLine.push(offset);\n      for (var _i = 0; _i < line.length; _i++) {\n        this.elements.push(line.charCodeAt(_i));\n      }\n      // Don't add an \\n that does not exist in the document.\n      if (i < lines.length - 1) {\n        this.elements.push('\\n'.charCodeAt(0));\n        this.firstCharOffsetByLine[i - this.lineRange.start + 1] = this.elements.length;\n      }\n    }\n    // To account for the last line\n    this.additionalOffsetByLine.push(0);\n  }\n  return _createClass(LinesSliceCharSequence, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"Slice: \\\"\".concat(this.text, \"\\\"\");\n    }\n  }, {\n    key: \"text\",\n    get: function get() {\n      return this.getText(new OffsetRange(0, this.length));\n    }\n  }, {\n    key: \"getText\",\n    value: function getText(range) {\n      return this.elements.slice(range.start, range.endExclusive).map(function (e) {\n        return String.fromCharCode(e);\n      }).join('');\n    }\n  }, {\n    key: \"getElement\",\n    value: function getElement(offset) {\n      return this.elements[offset];\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.elements.length;\n    }\n  }, {\n    key: \"getBoundaryScore\",\n    value: function getBoundaryScore(length) {\n      //   a   b   c   ,           d   e   f\n      // 11  0   0   12  15  6   13  0   0   11\n      var prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n      var nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n      if (prevCategory === 7 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 8 /* CharBoundaryCategory.LineBreakLF */) {\n        // don't break between \\r and \\n\n        return 0;\n      }\n      if (prevCategory === 8 /* CharBoundaryCategory.LineBreakLF */) {\n        // prefer the linebreak before the change\n        return 150;\n      }\n      var score = 0;\n      if (prevCategory !== nextCategory) {\n        score += 10;\n        if (prevCategory === 0 /* CharBoundaryCategory.WordLower */ && nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\n          score += 1;\n        }\n      }\n      score += getCategoryBoundaryScore(prevCategory);\n      score += getCategoryBoundaryScore(nextCategory);\n      return score;\n    }\n  }, {\n    key: \"translateOffset\",\n    value: function translateOffset(offset) {\n      // find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n      if (this.lineRange.isEmpty) {\n        return new Position(this.lineRange.start + 1, 1);\n      }\n      var i = findLastIdxMonotonous(this.firstCharOffsetByLine, function (value) {\n        return value <= offset;\n      });\n      return new Position(this.lineRange.start + i + 1, offset - this.firstCharOffsetByLine[i] + this.additionalOffsetByLine[i] + 1);\n    }\n  }, {\n    key: \"translateRange\",\n    value: function translateRange(range) {\n      return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n    }\n    /**\n     * Finds the word that contains the character at the given offset\n     */\n  }, {\n    key: \"findWordContaining\",\n    value: function findWordContaining(offset) {\n      if (offset < 0 || offset >= this.elements.length) {\n        return undefined;\n      }\n      if (!isWordChar(this.elements[offset])) {\n        return undefined;\n      }\n      // find start\n      var start = offset;\n      while (start > 0 && isWordChar(this.elements[start - 1])) {\n        start--;\n      }\n      // find end\n      var end = offset;\n      while (end < this.elements.length && isWordChar(this.elements[end])) {\n        end++;\n      }\n      return new OffsetRange(start, end);\n    }\n  }, {\n    key: \"countLinesIn\",\n    value: function countLinesIn(range) {\n      return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n    }\n  }, {\n    key: \"isStronglyEqual\",\n    value: function isStronglyEqual(offset1, offset2) {\n      return this.elements[offset1] === this.elements[offset2];\n    }\n  }, {\n    key: \"extendToFullLines\",\n    value: function extendToFullLines(range) {\n      var _a, _b;\n      var start = (_a = findLastMonotonous(this.firstCharOffsetByLine, function (x) {\n        return x <= range.start;\n      })) !== null && _a !== void 0 ? _a : 0;\n      var end = (_b = findFirstMonotonous(this.firstCharOffsetByLine, function (x) {\n        return range.endExclusive <= x;\n      })) !== null && _b !== void 0 ? _b : this.elements.length;\n      return new OffsetRange(start, end);\n    }\n  }]);\n}();\nfunction isWordChar(charCode) {\n  return charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */ || charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */ || charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */;\n}\nvar score = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, 0 /* CharBoundaryCategory.WordLower */, 0), 1 /* CharBoundaryCategory.WordUpper */, 0), 2 /* CharBoundaryCategory.WordNumber */, 0), 3 /* CharBoundaryCategory.End */, 10), 4 /* CharBoundaryCategory.Other */, 2), 5 /* CharBoundaryCategory.Separator */, 30), 6 /* CharBoundaryCategory.Space */, 3), 7 /* CharBoundaryCategory.LineBreakCR */, 10), 8 /* CharBoundaryCategory.LineBreakLF */, 10);\nfunction getCategoryBoundaryScore(category) {\n  return score[category];\n}\nfunction getCategory(charCode) {\n  if (charCode === 10 /* CharCode.LineFeed */) {\n    return 8 /* CharBoundaryCategory.LineBreakLF */;\n  } else if (charCode === 13 /* CharCode.CarriageReturn */) {\n    return 7 /* CharBoundaryCategory.LineBreakCR */;\n  } else if (isSpace(charCode)) {\n    return 6 /* CharBoundaryCategory.Space */;\n  } else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\n    return 0 /* CharBoundaryCategory.WordLower */;\n  } else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\n    return 1 /* CharBoundaryCategory.WordUpper */;\n  } else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\n    return 2 /* CharBoundaryCategory.WordNumber */;\n  } else if (charCode === -1) {\n    return 3 /* CharBoundaryCategory.End */;\n  } else if (charCode === 44 /* CharCode.Comma */ || charCode === 59 /* CharCode.Semicolon */) {\n    return 5 /* CharBoundaryCategory.Separator */;\n  } else {\n    return 4 /* CharBoundaryCategory.Other */;\n  }\n}","map":{"version":3,"names":["findLastIdxMonotonous","findLastMonotonous","findFirstMonotonous","OffsetRange","Position","Range","isSpace","LinesSliceCharSequence","lines","lineRange","considerWhitespaceChanges","_classCallCheck","elements","firstCharOffsetByLine","additionalOffsetByLine","trimFirstLineFully","start","endExclusive","length","i","line","offset","trimmedStartLine","trimStart","trimEnd","push","charCodeAt","_createClass","key","value","toString","concat","text","get","getText","range","slice","map","e","String","fromCharCode","join","getElement","getBoundaryScore","prevCategory","getCategory","nextCategory","score","getCategoryBoundaryScore","translateOffset","isEmpty","translateRange","fromPositions","findWordContaining","undefined","isWordChar","end","countLinesIn","lineNumber","isStronglyEqual","offset1","offset2","extendToFullLines","_a","_b","x","charCode","_defineProperty","category"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLastIdxMonotonous, findLastMonotonous, findFirstMonotonous } from '../../../../base/common/arraysFind.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { isSpace } from './utils.js';\nexport class LinesSliceCharSequence {\n    constructor(lines, lineRange, considerWhitespaceChanges) {\n        // This slice has to have lineRange.length many \\n! (otherwise diffing against an empty slice will be problematic)\n        // (Unless it covers the entire document, in that case the other slice also has to cover the entire document ands it's okay)\n        this.lines = lines;\n        this.considerWhitespaceChanges = considerWhitespaceChanges;\n        this.elements = [];\n        this.firstCharOffsetByLine = [];\n        // To account for trimming\n        this.additionalOffsetByLine = [];\n        // If the slice covers the end, but does not start at the beginning, we include just the \\n of the previous line.\n        let trimFirstLineFully = false;\n        if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {\n            lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);\n            trimFirstLineFully = true;\n        }\n        this.lineRange = lineRange;\n        this.firstCharOffsetByLine[0] = 0;\n        for (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {\n            let line = lines[i];\n            let offset = 0;\n            if (trimFirstLineFully) {\n                offset = line.length;\n                line = '';\n                trimFirstLineFully = false;\n            }\n            else if (!considerWhitespaceChanges) {\n                const trimmedStartLine = line.trimStart();\n                offset = line.length - trimmedStartLine.length;\n                line = trimmedStartLine.trimEnd();\n            }\n            this.additionalOffsetByLine.push(offset);\n            for (let i = 0; i < line.length; i++) {\n                this.elements.push(line.charCodeAt(i));\n            }\n            // Don't add an \\n that does not exist in the document.\n            if (i < lines.length - 1) {\n                this.elements.push('\\n'.charCodeAt(0));\n                this.firstCharOffsetByLine[i - this.lineRange.start + 1] = this.elements.length;\n            }\n        }\n        // To account for the last line\n        this.additionalOffsetByLine.push(0);\n    }\n    toString() {\n        return `Slice: \"${this.text}\"`;\n    }\n    get text() {\n        return this.getText(new OffsetRange(0, this.length));\n    }\n    getText(range) {\n        return this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n    }\n    getElement(offset) {\n        return this.elements[offset];\n    }\n    get length() {\n        return this.elements.length;\n    }\n    getBoundaryScore(length) {\n        //   a   b   c   ,           d   e   f\n        // 11  0   0   12  15  6   13  0   0   11\n        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n        if (prevCategory === 7 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 8 /* CharBoundaryCategory.LineBreakLF */) {\n            // don't break between \\r and \\n\n            return 0;\n        }\n        if (prevCategory === 8 /* CharBoundaryCategory.LineBreakLF */) {\n            // prefer the linebreak before the change\n            return 150;\n        }\n        let score = 0;\n        if (prevCategory !== nextCategory) {\n            score += 10;\n            if (prevCategory === 0 /* CharBoundaryCategory.WordLower */ && nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\n                score += 1;\n            }\n        }\n        score += getCategoryBoundaryScore(prevCategory);\n        score += getCategoryBoundaryScore(nextCategory);\n        return score;\n    }\n    translateOffset(offset) {\n        // find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n        if (this.lineRange.isEmpty) {\n            return new Position(this.lineRange.start + 1, 1);\n        }\n        const i = findLastIdxMonotonous(this.firstCharOffsetByLine, (value) => value <= offset);\n        return new Position(this.lineRange.start + i + 1, offset - this.firstCharOffsetByLine[i] + this.additionalOffsetByLine[i] + 1);\n    }\n    translateRange(range) {\n        return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n    }\n    /**\n     * Finds the word that contains the character at the given offset\n     */\n    findWordContaining(offset) {\n        if (offset < 0 || offset >= this.elements.length) {\n            return undefined;\n        }\n        if (!isWordChar(this.elements[offset])) {\n            return undefined;\n        }\n        // find start\n        let start = offset;\n        while (start > 0 && isWordChar(this.elements[start - 1])) {\n            start--;\n        }\n        // find end\n        let end = offset;\n        while (end < this.elements.length && isWordChar(this.elements[end])) {\n            end++;\n        }\n        return new OffsetRange(start, end);\n    }\n    countLinesIn(range) {\n        return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n    }\n    isStronglyEqual(offset1, offset2) {\n        return this.elements[offset1] === this.elements[offset2];\n    }\n    extendToFullLines(range) {\n        var _a, _b;\n        const start = (_a = findLastMonotonous(this.firstCharOffsetByLine, x => x <= range.start)) !== null && _a !== void 0 ? _a : 0;\n        const end = (_b = findFirstMonotonous(this.firstCharOffsetByLine, x => range.endExclusive <= x)) !== null && _b !== void 0 ? _b : this.elements.length;\n        return new OffsetRange(start, end);\n    }\n}\nfunction isWordChar(charCode) {\n    return charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */\n        || charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */\n        || charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */;\n}\nconst score = {\n    [0 /* CharBoundaryCategory.WordLower */]: 0,\n    [1 /* CharBoundaryCategory.WordUpper */]: 0,\n    [2 /* CharBoundaryCategory.WordNumber */]: 0,\n    [3 /* CharBoundaryCategory.End */]: 10,\n    [4 /* CharBoundaryCategory.Other */]: 2,\n    [5 /* CharBoundaryCategory.Separator */]: 30,\n    [6 /* CharBoundaryCategory.Space */]: 3,\n    [7 /* CharBoundaryCategory.LineBreakCR */]: 10,\n    [8 /* CharBoundaryCategory.LineBreakLF */]: 10,\n};\nfunction getCategoryBoundaryScore(category) {\n    return score[category];\n}\nfunction getCategory(charCode) {\n    if (charCode === 10 /* CharCode.LineFeed */) {\n        return 8 /* CharBoundaryCategory.LineBreakLF */;\n    }\n    else if (charCode === 13 /* CharCode.CarriageReturn */) {\n        return 7 /* CharBoundaryCategory.LineBreakCR */;\n    }\n    else if (isSpace(charCode)) {\n        return 6 /* CharBoundaryCategory.Space */;\n    }\n    else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\n        return 0 /* CharBoundaryCategory.WordLower */;\n    }\n    else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\n        return 1 /* CharBoundaryCategory.WordUpper */;\n    }\n    else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\n        return 2 /* CharBoundaryCategory.WordNumber */;\n    }\n    else if (charCode === -1) {\n        return 3 /* CharBoundaryCategory.End */;\n    }\n    else if (charCode === 44 /* CharCode.Comma */ || charCode === 59 /* CharCode.Semicolon */) {\n        return 5 /* CharBoundaryCategory.Separator */;\n    }\n    else {\n        return 4 /* CharBoundaryCategory.Other */;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}