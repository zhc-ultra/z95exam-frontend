{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar emptyArr = [];\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nexport var SmallImmutableSet = /*#__PURE__*/function () {\n  function SmallImmutableSet(items, additionalItems) {\n    _classCallCheck(this, SmallImmutableSet);\n    this.items = items;\n    this.additionalItems = additionalItems;\n  }\n  return _createClass(SmallImmutableSet, [{\n    key: \"add\",\n    value: function add(value, keyProvider) {\n      var key = keyProvider.getKey(value);\n      var idx = key >> 5; // divided by 32\n      if (idx === 0) {\n        // fast path\n        var newItem = 1 << key | this.items;\n        if (newItem === this.items) {\n          return this;\n        }\n        return SmallImmutableSet.create(newItem, this.additionalItems);\n      }\n      idx--;\n      var newItems = this.additionalItems.slice(0);\n      while (newItems.length < idx) {\n        newItems.push(0);\n      }\n      newItems[idx] |= 1 << (key & 31);\n      return SmallImmutableSet.create(this.items, newItems);\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      var merged = this.items | other.items;\n      if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n        // fast path\n        if (merged === this.items) {\n          return this;\n        }\n        if (merged === other.items) {\n          return other;\n        }\n        return SmallImmutableSet.create(merged, emptyArr);\n      }\n      // This can be optimized, but it's not a common case\n      var newItems = [];\n      for (var i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n        var item1 = this.additionalItems[i] || 0;\n        var item2 = other.additionalItems[i] || 0;\n        newItems.push(item1 | item2);\n      }\n      return SmallImmutableSet.create(merged, newItems);\n    }\n  }, {\n    key: \"intersects\",\n    value: function intersects(other) {\n      if ((this.items & other.items) !== 0) {\n        return true;\n      }\n      for (var i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n        if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(items, additionalItems) {\n      if (items <= 128 && additionalItems.length === 0) {\n        // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n        var cached = SmallImmutableSet.cache[items];\n        if (!cached) {\n          cached = new SmallImmutableSet(items, additionalItems);\n          SmallImmutableSet.cache[items] = cached;\n        }\n        return cached;\n      }\n      return new SmallImmutableSet(items, additionalItems);\n    }\n  }, {\n    key: \"getEmpty\",\n    value: function getEmpty() {\n      return this.empty;\n    }\n  }]);\n}();\nSmallImmutableSet.cache = new Array(129);\nSmallImmutableSet.empty = SmallImmutableSet.create(0, emptyArr);\nexport var identityKeyProvider = {\n  getKey: function getKey(value) {\n    return value;\n  }\n};\n/**\n * Assigns values a unique incrementing key.\n*/\nexport var DenseKeyProvider = /*#__PURE__*/function () {\n  function DenseKeyProvider() {\n    _classCallCheck(this, DenseKeyProvider);\n    this.items = new Map();\n  }\n  return _createClass(DenseKeyProvider, [{\n    key: \"getKey\",\n    value: function getKey(value) {\n      var existing = this.items.get(value);\n      if (existing === undefined) {\n        existing = this.items.size;\n        this.items.set(value, existing);\n      }\n      return existing;\n    }\n  }]);\n}();","map":{"version":3,"names":["emptyArr","SmallImmutableSet","items","additionalItems","_classCallCheck","_createClass","key","value","add","keyProvider","getKey","idx","newItem","create","newItems","slice","length","push","merge","other","merged","i","Math","max","item1","item2","intersects","min","cached","cache","getEmpty","empty","Array","identityKeyProvider","DenseKeyProvider","Map","existing","get","undefined","size","set"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst emptyArr = [];\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nexport class SmallImmutableSet {\n    static create(items, additionalItems) {\n        if (items <= 128 && additionalItems.length === 0) {\n            // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n            let cached = SmallImmutableSet.cache[items];\n            if (!cached) {\n                cached = new SmallImmutableSet(items, additionalItems);\n                SmallImmutableSet.cache[items] = cached;\n            }\n            return cached;\n        }\n        return new SmallImmutableSet(items, additionalItems);\n    }\n    static getEmpty() {\n        return this.empty;\n    }\n    constructor(items, additionalItems) {\n        this.items = items;\n        this.additionalItems = additionalItems;\n    }\n    add(value, keyProvider) {\n        const key = keyProvider.getKey(value);\n        let idx = key >> 5; // divided by 32\n        if (idx === 0) {\n            // fast path\n            const newItem = (1 << key) | this.items;\n            if (newItem === this.items) {\n                return this;\n            }\n            return SmallImmutableSet.create(newItem, this.additionalItems);\n        }\n        idx--;\n        const newItems = this.additionalItems.slice(0);\n        while (newItems.length < idx) {\n            newItems.push(0);\n        }\n        newItems[idx] |= 1 << (key & 31);\n        return SmallImmutableSet.create(this.items, newItems);\n    }\n    merge(other) {\n        const merged = this.items | other.items;\n        if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n            // fast path\n            if (merged === this.items) {\n                return this;\n            }\n            if (merged === other.items) {\n                return other;\n            }\n            return SmallImmutableSet.create(merged, emptyArr);\n        }\n        // This can be optimized, but it's not a common case\n        const newItems = [];\n        for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n            const item1 = this.additionalItems[i] || 0;\n            const item2 = other.additionalItems[i] || 0;\n            newItems.push(item1 | item2);\n        }\n        return SmallImmutableSet.create(merged, newItems);\n    }\n    intersects(other) {\n        if ((this.items & other.items) !== 0) {\n            return true;\n        }\n        for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n            if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nSmallImmutableSet.cache = new Array(129);\nSmallImmutableSet.empty = SmallImmutableSet.create(0, emptyArr);\nexport const identityKeyProvider = {\n    getKey(value) {\n        return value;\n    }\n};\n/**\n * Assigns values a unique incrementing key.\n*/\nexport class DenseKeyProvider {\n    constructor() {\n        this.items = new Map();\n    }\n    getKey(value) {\n        let existing = this.items.get(value);\n        if (existing === undefined) {\n            existing = this.items.size;\n            this.items.set(value, existing);\n        }\n        return existing;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}