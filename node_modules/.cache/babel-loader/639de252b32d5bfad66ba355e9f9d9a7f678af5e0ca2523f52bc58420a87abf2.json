{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.sort.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { FloatHorizontalRange } from '../../view/renderingContext.js';\nexport var RangeUtil = /*#__PURE__*/function () {\n  function RangeUtil() {\n    _classCallCheck(this, RangeUtil);\n  }\n  return _createClass(RangeUtil, null, [{\n    key: \"_createRange\",\n    value: function _createRange() {\n      if (!this._handyReadyRange) {\n        this._handyReadyRange = document.createRange();\n      }\n      return this._handyReadyRange;\n    }\n  }, {\n    key: \"_detachRange\",\n    value: function _detachRange(range, endNode) {\n      // Move range out of the span node, IE doesn't like having many ranges in\n      // the same spot and will act badly for lines containing dashes ('-')\n      range.selectNodeContents(endNode);\n    }\n  }, {\n    key: \"_readClientRects\",\n    value: function _readClientRects(startElement, startOffset, endElement, endOffset, endNode) {\n      var range = this._createRange();\n      try {\n        range.setStart(startElement, startOffset);\n        range.setEnd(endElement, endOffset);\n        return range.getClientRects();\n      } catch (e) {\n        // This is life ...\n        return null;\n      } finally {\n        this._detachRange(range, endNode);\n      }\n    }\n  }, {\n    key: \"_mergeAdjacentRanges\",\n    value: function _mergeAdjacentRanges(ranges) {\n      if (ranges.length === 1) {\n        // There is nothing to merge\n        return ranges;\n      }\n      ranges.sort(FloatHorizontalRange.compare);\n      var result = [];\n      var resultLen = 0;\n      var prev = ranges[0];\n      for (var i = 1, len = ranges.length; i < len; i++) {\n        var range = ranges[i];\n        if (prev.left + prev.width + 0.9 /* account for browser's rounding errors*/ >= range.left) {\n          prev.width = Math.max(prev.width, range.left + range.width - prev.left);\n        } else {\n          result[resultLen++] = prev;\n          prev = range;\n        }\n      }\n      result[resultLen++] = prev;\n      return result;\n    }\n  }, {\n    key: \"_createHorizontalRangesFromClientRects\",\n    value: function _createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft, clientRectScale) {\n      if (!clientRects || clientRects.length === 0) {\n        return null;\n      }\n      // We go through FloatHorizontalRange because it has been observed in bi-di text\n      // that the clientRects are not coming in sorted from the browser\n      var result = [];\n      for (var i = 0, len = clientRects.length; i < len; i++) {\n        var clientRect = clientRects[i];\n        result[i] = new FloatHorizontalRange(Math.max(0, (clientRect.left - clientRectDeltaLeft) / clientRectScale), clientRect.width / clientRectScale);\n      }\n      return this._mergeAdjacentRanges(result);\n    }\n  }, {\n    key: \"readHorizontalRanges\",\n    value: function readHorizontalRanges(domNode, startChildIndex, startOffset, endChildIndex, endOffset, context) {\n      // Panic check\n      var min = 0;\n      var max = domNode.children.length - 1;\n      if (min > max) {\n        return null;\n      }\n      startChildIndex = Math.min(max, Math.max(min, startChildIndex));\n      endChildIndex = Math.min(max, Math.max(min, endChildIndex));\n      if (startChildIndex === endChildIndex && startOffset === endOffset && startOffset === 0 && !domNode.children[startChildIndex].firstChild) {\n        // We must find the position at the beginning of a <span>\n        // To cover cases of empty <span>s, avoid using a range and use the <span>'s bounding box\n        var _clientRects = domNode.children[startChildIndex].getClientRects();\n        context.markDidDomLayout();\n        return this._createHorizontalRangesFromClientRects(_clientRects, context.clientRectDeltaLeft, context.clientRectScale);\n      }\n      // If crossing over to a span only to select offset 0, then use the previous span's maximum offset\n      // Chrome is buggy and doesn't handle 0 offsets well sometimes.\n      if (startChildIndex !== endChildIndex) {\n        if (endChildIndex > 0 && endOffset === 0) {\n          endChildIndex--;\n          endOffset = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n        }\n      }\n      var startElement = domNode.children[startChildIndex].firstChild;\n      var endElement = domNode.children[endChildIndex].firstChild;\n      if (!startElement || !endElement) {\n        // When having an empty <span> (without any text content), try to move to the previous <span>\n        if (!startElement && startOffset === 0 && startChildIndex > 0) {\n          startElement = domNode.children[startChildIndex - 1].firstChild;\n          startOffset = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n        }\n        if (!endElement && endOffset === 0 && endChildIndex > 0) {\n          endElement = domNode.children[endChildIndex - 1].firstChild;\n          endOffset = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n        }\n      }\n      if (!startElement || !endElement) {\n        return null;\n      }\n      startOffset = Math.min(startElement.textContent.length, Math.max(0, startOffset));\n      endOffset = Math.min(endElement.textContent.length, Math.max(0, endOffset));\n      var clientRects = this._readClientRects(startElement, startOffset, endElement, endOffset, context.endNode);\n      context.markDidDomLayout();\n      return this._createHorizontalRangesFromClientRects(clientRects, context.clientRectDeltaLeft, context.clientRectScale);\n    }\n  }]);\n}();","map":{"version":3,"names":["FloatHorizontalRange","RangeUtil","_classCallCheck","_createClass","key","value","_createRange","_handyReadyRange","document","createRange","_detachRange","range","endNode","selectNodeContents","_readClientRects","startElement","startOffset","endElement","endOffset","setStart","setEnd","getClientRects","e","_mergeAdjacentRanges","ranges","length","sort","compare","result","resultLen","prev","i","len","left","width","Math","max","_createHorizontalRangesFromClientRects","clientRects","clientRectDeltaLeft","clientRectScale","clientRect","readHorizontalRanges","domNode","startChildIndex","endChildIndex","context","min","children","firstChild","markDidDomLayout","textContent"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lines/rangeUtil.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { FloatHorizontalRange } from '../../view/renderingContext.js';\nexport class RangeUtil {\n    static _createRange() {\n        if (!this._handyReadyRange) {\n            this._handyReadyRange = document.createRange();\n        }\n        return this._handyReadyRange;\n    }\n    static _detachRange(range, endNode) {\n        // Move range out of the span node, IE doesn't like having many ranges in\n        // the same spot and will act badly for lines containing dashes ('-')\n        range.selectNodeContents(endNode);\n    }\n    static _readClientRects(startElement, startOffset, endElement, endOffset, endNode) {\n        const range = this._createRange();\n        try {\n            range.setStart(startElement, startOffset);\n            range.setEnd(endElement, endOffset);\n            return range.getClientRects();\n        }\n        catch (e) {\n            // This is life ...\n            return null;\n        }\n        finally {\n            this._detachRange(range, endNode);\n        }\n    }\n    static _mergeAdjacentRanges(ranges) {\n        if (ranges.length === 1) {\n            // There is nothing to merge\n            return ranges;\n        }\n        ranges.sort(FloatHorizontalRange.compare);\n        const result = [];\n        let resultLen = 0;\n        let prev = ranges[0];\n        for (let i = 1, len = ranges.length; i < len; i++) {\n            const range = ranges[i];\n            if (prev.left + prev.width + 0.9 /* account for browser's rounding errors*/ >= range.left) {\n                prev.width = Math.max(prev.width, range.left + range.width - prev.left);\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = range;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft, clientRectScale) {\n        if (!clientRects || clientRects.length === 0) {\n            return null;\n        }\n        // We go through FloatHorizontalRange because it has been observed in bi-di text\n        // that the clientRects are not coming in sorted from the browser\n        const result = [];\n        for (let i = 0, len = clientRects.length; i < len; i++) {\n            const clientRect = clientRects[i];\n            result[i] = new FloatHorizontalRange(Math.max(0, (clientRect.left - clientRectDeltaLeft) / clientRectScale), clientRect.width / clientRectScale);\n        }\n        return this._mergeAdjacentRanges(result);\n    }\n    static readHorizontalRanges(domNode, startChildIndex, startOffset, endChildIndex, endOffset, context) {\n        // Panic check\n        const min = 0;\n        const max = domNode.children.length - 1;\n        if (min > max) {\n            return null;\n        }\n        startChildIndex = Math.min(max, Math.max(min, startChildIndex));\n        endChildIndex = Math.min(max, Math.max(min, endChildIndex));\n        if (startChildIndex === endChildIndex && startOffset === endOffset && startOffset === 0 && !domNode.children[startChildIndex].firstChild) {\n            // We must find the position at the beginning of a <span>\n            // To cover cases of empty <span>s, avoid using a range and use the <span>'s bounding box\n            const clientRects = domNode.children[startChildIndex].getClientRects();\n            context.markDidDomLayout();\n            return this._createHorizontalRangesFromClientRects(clientRects, context.clientRectDeltaLeft, context.clientRectScale);\n        }\n        // If crossing over to a span only to select offset 0, then use the previous span's maximum offset\n        // Chrome is buggy and doesn't handle 0 offsets well sometimes.\n        if (startChildIndex !== endChildIndex) {\n            if (endChildIndex > 0 && endOffset === 0) {\n                endChildIndex--;\n                endOffset = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n            }\n        }\n        let startElement = domNode.children[startChildIndex].firstChild;\n        let endElement = domNode.children[endChildIndex].firstChild;\n        if (!startElement || !endElement) {\n            // When having an empty <span> (without any text content), try to move to the previous <span>\n            if (!startElement && startOffset === 0 && startChildIndex > 0) {\n                startElement = domNode.children[startChildIndex - 1].firstChild;\n                startOffset = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n            }\n            if (!endElement && endOffset === 0 && endChildIndex > 0) {\n                endElement = domNode.children[endChildIndex - 1].firstChild;\n                endOffset = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n            }\n        }\n        if (!startElement || !endElement) {\n            return null;\n        }\n        startOffset = Math.min(startElement.textContent.length, Math.max(0, startOffset));\n        endOffset = Math.min(endElement.textContent.length, Math.max(0, endOffset));\n        const clientRects = this._readClientRects(startElement, startOffset, endElement, endOffset, context.endNode);\n        context.markDidDomLayout();\n        return this._createHorizontalRangesFromClientRects(clientRects, context.clientRectDeltaLeft, context.clientRectScale);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}