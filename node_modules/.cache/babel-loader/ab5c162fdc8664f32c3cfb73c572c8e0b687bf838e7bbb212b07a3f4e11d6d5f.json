{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { InvalidBracketAstNode, ListAstNode, PairAstNode, TextAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n  var parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n  return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\nvar Parser = /*#__PURE__*/function () {\n  function Parser(tokenizer, edits, oldNode, createImmutableLists) {\n    _classCallCheck(this, Parser);\n    this.tokenizer = tokenizer;\n    this.createImmutableLists = createImmutableLists;\n    this._itemsConstructed = 0;\n    this._itemsFromCache = 0;\n    if (oldNode && createImmutableLists) {\n      throw new Error('Not supported');\n    }\n    this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n    this.positionMapper = new BeforeEditPositionMapper(edits);\n  }\n  return _createClass(Parser, [{\n    key: \"parseDocument\",\n    value: function parseDocument() {\n      this._itemsConstructed = 0;\n      this._itemsFromCache = 0;\n      var result = this.parseList(SmallImmutableSet.getEmpty(), 0);\n      if (!result) {\n        result = ListAstNode.getEmpty();\n      }\n      return result;\n    }\n  }, {\n    key: \"parseList\",\n    value: function parseList(openedBracketIds, level) {\n      var items = [];\n      while (true) {\n        var child = this.tryReadChildFromCache(openedBracketIds);\n        if (!child) {\n          var token = this.tokenizer.peek();\n          if (!token || token.kind === 2 /* TokenKind.ClosingBracket */ && token.bracketIds.intersects(openedBracketIds)) {\n            break;\n          }\n          child = this.parseChild(openedBracketIds, level + 1);\n        }\n        if (child.kind === 4 /* AstNodeKind.List */ && child.childrenLength === 0) {\n          continue;\n        }\n        items.push(child);\n      }\n      // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n      var result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n      return result;\n    }\n  }, {\n    key: \"tryReadChildFromCache\",\n    value: function tryReadChildFromCache(openedBracketIds) {\n      if (this.oldNodeReader) {\n        var maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n        if (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n          var cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), function (curNode) {\n            // The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n            // If there is no edit anymore, we can re-use the node in any case.\n            if (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n              // Either the node contains edited text or touches edited text.\n              // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n              return false;\n            }\n            var canBeReused = curNode.canBeReused(openedBracketIds);\n            return canBeReused;\n          });\n          if (cachedNode) {\n            this._itemsFromCache++;\n            this.tokenizer.skip(cachedNode.length);\n            return cachedNode;\n          }\n        }\n      }\n      return undefined;\n    }\n  }, {\n    key: \"parseChild\",\n    value: function parseChild(openedBracketIds, level) {\n      this._itemsConstructed++;\n      var token = this.tokenizer.read();\n      switch (token.kind) {\n        case 2 /* TokenKind.ClosingBracket */:\n          return new InvalidBracketAstNode(token.bracketIds, token.length);\n        case 0 /* TokenKind.Text */:\n          return token.astNode;\n        case 1 /* TokenKind.OpeningBracket */:\n          {\n            if (level > 300) {\n              // To prevent stack overflows\n              return new TextAstNode(token.length);\n            }\n            var set = openedBracketIds.merge(token.bracketIds);\n            var child = this.parseList(set, level + 1);\n            var nextToken = this.tokenizer.peek();\n            if (nextToken && nextToken.kind === 2 /* TokenKind.ClosingBracket */ && (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n              this.tokenizer.read();\n              return PairAstNode.create(token.astNode, child, nextToken.astNode);\n            } else {\n              return PairAstNode.create(token.astNode, child, null);\n            }\n          }\n        default:\n          throw new Error('unexpected');\n      }\n    }\n  }]);\n}();","map":{"version":3,"names":["InvalidBracketAstNode","ListAstNode","PairAstNode","TextAstNode","BeforeEditPositionMapper","SmallImmutableSet","lengthIsZero","lengthLessThan","concat23Trees","concat23TreesOfSameHeight","NodeReader","parseDocument","tokenizer","edits","oldNode","createImmutableLists","parser","Parser","_classCallCheck","_itemsConstructed","_itemsFromCache","Error","oldNodeReader","undefined","positionMapper","_createClass","key","value","result","parseList","getEmpty","openedBracketIds","level","items","child","tryReadChildFromCache","token","peek","kind","bracketIds","intersects","parseChild","childrenLength","push","maxCacheableLength","getDistanceToNextChange","offset","cachedNode","readLongestNodeAt","getOffsetBeforeChange","curNode","length","canBeReused","skip","read","astNode","set","merge","nextToken","bracketId","create"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { InvalidBracketAstNode, ListAstNode, PairAstNode, TextAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n    const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n    return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n    constructor(tokenizer, edits, oldNode, createImmutableLists) {\n        this.tokenizer = tokenizer;\n        this.createImmutableLists = createImmutableLists;\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        if (oldNode && createImmutableLists) {\n            throw new Error('Not supported');\n        }\n        this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n        this.positionMapper = new BeforeEditPositionMapper(edits);\n    }\n    parseDocument() {\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        let result = this.parseList(SmallImmutableSet.getEmpty(), 0);\n        if (!result) {\n            result = ListAstNode.getEmpty();\n        }\n        return result;\n    }\n    parseList(openedBracketIds, level) {\n        const items = [];\n        while (true) {\n            let child = this.tryReadChildFromCache(openedBracketIds);\n            if (!child) {\n                const token = this.tokenizer.peek();\n                if (!token ||\n                    (token.kind === 2 /* TokenKind.ClosingBracket */ &&\n                        token.bracketIds.intersects(openedBracketIds))) {\n                    break;\n                }\n                child = this.parseChild(openedBracketIds, level + 1);\n            }\n            if (child.kind === 4 /* AstNodeKind.List */ && child.childrenLength === 0) {\n                continue;\n            }\n            items.push(child);\n        }\n        // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n        const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n        return result;\n    }\n    tryReadChildFromCache(openedBracketIds) {\n        if (this.oldNodeReader) {\n            const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n            if (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n                const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n                    // The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n                    // If there is no edit anymore, we can re-use the node in any case.\n                    if (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n                        // Either the node contains edited text or touches edited text.\n                        // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n                        return false;\n                    }\n                    const canBeReused = curNode.canBeReused(openedBracketIds);\n                    return canBeReused;\n                });\n                if (cachedNode) {\n                    this._itemsFromCache++;\n                    this.tokenizer.skip(cachedNode.length);\n                    return cachedNode;\n                }\n            }\n        }\n        return undefined;\n    }\n    parseChild(openedBracketIds, level) {\n        this._itemsConstructed++;\n        const token = this.tokenizer.read();\n        switch (token.kind) {\n            case 2 /* TokenKind.ClosingBracket */:\n                return new InvalidBracketAstNode(token.bracketIds, token.length);\n            case 0 /* TokenKind.Text */:\n                return token.astNode;\n            case 1 /* TokenKind.OpeningBracket */: {\n                if (level > 300) {\n                    // To prevent stack overflows\n                    return new TextAstNode(token.length);\n                }\n                const set = openedBracketIds.merge(token.bracketIds);\n                const child = this.parseList(set, level + 1);\n                const nextToken = this.tokenizer.peek();\n                if (nextToken &&\n                    nextToken.kind === 2 /* TokenKind.ClosingBracket */ &&\n                    (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n                    this.tokenizer.read();\n                    return PairAstNode.create(token.astNode, child, nextToken.astNode);\n                }\n                else {\n                    return PairAstNode.create(token.astNode, child, null);\n                }\n            }\n            default:\n                throw new Error('unexpected');\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}