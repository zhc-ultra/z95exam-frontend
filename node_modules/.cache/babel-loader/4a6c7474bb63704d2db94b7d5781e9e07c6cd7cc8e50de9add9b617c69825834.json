{"ast":null,"code":"import _toConsumableArray from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.object.freeze.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.ends-with.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.starts-with.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport { createMatches as createFuzzyMatches, fuzzyScore } from './filters.js';\nimport { sep } from './path.js';\nimport { isWindows } from './platform.js';\nimport { stripWildcards } from './strings.js';\nvar NO_SCORE2 = [undefined, []];\nexport function scoreFuzzy2(target, query) {\n  var patternStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var wordStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  // Score: multiple inputs\n  var preparedQuery = query;\n  if (preparedQuery.values && preparedQuery.values.length > 1) {\n    return doScoreFuzzy2Multiple(target, preparedQuery.values, patternStart, wordStart);\n  }\n  // Score: single input\n  return doScoreFuzzy2Single(target, query, patternStart, wordStart);\n}\nfunction doScoreFuzzy2Multiple(target, query, patternStart, wordStart) {\n  var totalScore = 0;\n  var totalMatches = [];\n  var _iterator = _createForOfIteratorHelper(query),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var queryPiece = _step.value;\n      var _doScoreFuzzy2Single = doScoreFuzzy2Single(target, queryPiece, patternStart, wordStart),\n        _doScoreFuzzy2Single2 = _slicedToArray(_doScoreFuzzy2Single, 2),\n        score = _doScoreFuzzy2Single2[0],\n        matches = _doScoreFuzzy2Single2[1];\n      if (typeof score !== 'number') {\n        // if a single query value does not match, return with\n        // no score entirely, we require all queries to match\n        return NO_SCORE2;\n      }\n      totalScore += score;\n      totalMatches.push.apply(totalMatches, _toConsumableArray(matches));\n    }\n    // if we have a score, ensure that the positions are\n    // sorted in ascending order and distinct\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return [totalScore, normalizeMatches(totalMatches)];\n}\nfunction doScoreFuzzy2Single(target, query, patternStart, wordStart) {\n  var score = fuzzyScore(query.original, query.originalLowercase, patternStart, target, target.toLowerCase(), wordStart, {\n    firstMatchCanBeWeak: true,\n    boostFullMatch: true\n  });\n  if (!score) {\n    return NO_SCORE2;\n  }\n  return [score[0], createFuzzyMatches(score)];\n}\nvar NO_ITEM_SCORE = Object.freeze({\n  score: 0\n});\nfunction normalizeMatches(matches) {\n  // sort matches by start to be able to normalize\n  var sortedMatches = matches.sort(function (matchA, matchB) {\n    return matchA.start - matchB.start;\n  });\n  // merge matches that overlap\n  var normalizedMatches = [];\n  var currentMatch = undefined;\n  var _iterator2 = _createForOfIteratorHelper(sortedMatches),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var match = _step2.value;\n      // if we have no current match or the matches\n      // do not overlap, we take it as is and remember\n      // it for future merging\n      if (!currentMatch || !matchOverlaps(currentMatch, match)) {\n        currentMatch = match;\n        normalizedMatches.push(match);\n      }\n      // otherwise we merge the matches\n      else {\n        currentMatch.start = Math.min(currentMatch.start, match.start);\n        currentMatch.end = Math.max(currentMatch.end, match.end);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return normalizedMatches;\n}\nfunction matchOverlaps(matchA, matchB) {\n  if (matchA.end < matchB.start) {\n    return false; // A ends before B starts\n  }\n  if (matchB.end < matchA.start) {\n    return false; // B ends before A starts\n  }\n  return true;\n}\n/*\n * If a query is wrapped in quotes, the user does not want to\n * use fuzzy search for this query.\n */\nfunction queryExpectsExactMatch(query) {\n  return query.startsWith('\"') && query.endsWith('\"');\n}\n/**\n * Helper function to prepare a search value for scoring by removing unwanted characters\n * and allowing to score on multiple pieces separated by whitespace character.\n */\nvar MULTIPLE_QUERY_VALUES_SEPARATOR = ' ';\nexport function prepareQuery(original) {\n  if (typeof original !== 'string') {\n    original = '';\n  }\n  var originalLowercase = original.toLowerCase();\n  var _normalizeQuery = normalizeQuery(original),\n    pathNormalized = _normalizeQuery.pathNormalized,\n    normalized = _normalizeQuery.normalized,\n    normalizedLowercase = _normalizeQuery.normalizedLowercase;\n  var containsPathSeparator = pathNormalized.indexOf(sep) >= 0;\n  var expectExactMatch = queryExpectsExactMatch(original);\n  var values = undefined;\n  var originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);\n  if (originalSplit.length > 1) {\n    var _iterator3 = _createForOfIteratorHelper(originalSplit),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var originalPiece = _step3.value;\n        var expectExactMatchPiece = queryExpectsExactMatch(originalPiece);\n        var _normalizeQuery2 = normalizeQuery(originalPiece),\n          pathNormalizedPiece = _normalizeQuery2.pathNormalized,\n          normalizedPiece = _normalizeQuery2.normalized,\n          normalizedLowercasePiece = _normalizeQuery2.normalizedLowercase;\n        if (normalizedPiece) {\n          if (!values) {\n            values = [];\n          }\n          values.push({\n            original: originalPiece,\n            originalLowercase: originalPiece.toLowerCase(),\n            pathNormalized: pathNormalizedPiece,\n            normalized: normalizedPiece,\n            normalizedLowercase: normalizedLowercasePiece,\n            expectContiguousMatch: expectExactMatchPiece\n          });\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n  return {\n    original: original,\n    originalLowercase: originalLowercase,\n    pathNormalized: pathNormalized,\n    normalized: normalized,\n    normalizedLowercase: normalizedLowercase,\n    values: values,\n    containsPathSeparator: containsPathSeparator,\n    expectContiguousMatch: expectExactMatch\n  };\n}\nfunction normalizeQuery(original) {\n  var pathNormalized;\n  if (isWindows) {\n    pathNormalized = original.replace(/\\//g, sep); // Help Windows users to search for paths when using slash\n  } else {\n    pathNormalized = original.replace(/\\\\/g, sep); // Help macOS/Linux users to search for paths when using backslash\n  }\n  // we remove quotes here because quotes are used for exact match search\n  var normalized = stripWildcards(pathNormalized).replace(/\\s|\"/g, '');\n  return {\n    pathNormalized: pathNormalized,\n    normalized: normalized,\n    normalizedLowercase: normalized.toLowerCase()\n  };\n}\nexport function pieceToQuery(arg1) {\n  if (Array.isArray(arg1)) {\n    return prepareQuery(arg1.map(function (piece) {\n      return piece.original;\n    }).join(MULTIPLE_QUERY_VALUES_SEPARATOR));\n  }\n  return prepareQuery(arg1.original);\n}\n//#endregion","map":{"version":3,"names":["createMatches","createFuzzyMatches","fuzzyScore","sep","isWindows","stripWildcards","NO_SCORE2","undefined","scoreFuzzy2","target","query","patternStart","arguments","length","wordStart","preparedQuery","values","doScoreFuzzy2Multiple","doScoreFuzzy2Single","totalScore","totalMatches","_iterator","_createForOfIteratorHelper","_step","s","n","done","queryPiece","value","_doScoreFuzzy2Single","_doScoreFuzzy2Single2","_slicedToArray","score","matches","push","apply","_toConsumableArray","err","e","f","normalizeMatches","original","originalLowercase","toLowerCase","firstMatchCanBeWeak","boostFullMatch","NO_ITEM_SCORE","Object","freeze","sortedMatches","sort","matchA","matchB","start","normalizedMatches","currentMatch","_iterator2","_step2","match","matchOverlaps","Math","min","end","max","queryExpectsExactMatch","startsWith","endsWith","MULTIPLE_QUERY_VALUES_SEPARATOR","prepareQuery","_normalizeQuery","normalizeQuery","pathNormalized","normalized","normalizedLowercase","containsPathSeparator","indexOf","expectExactMatch","originalSplit","split","_iterator3","_step3","originalPiece","expectExactMatchPiece","_normalizeQuery2","pathNormalizedPiece","normalizedPiece","normalizedLowercasePiece","expectContiguousMatch","replace","pieceToQuery","arg1","Array","isArray","map","piece","join"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/base/common/fuzzyScorer.js"],"sourcesContent":["import { createMatches as createFuzzyMatches, fuzzyScore } from './filters.js';\nimport { sep } from './path.js';\nimport { isWindows } from './platform.js';\nimport { stripWildcards } from './strings.js';\nconst NO_SCORE2 = [undefined, []];\nexport function scoreFuzzy2(target, query, patternStart = 0, wordStart = 0) {\n    // Score: multiple inputs\n    const preparedQuery = query;\n    if (preparedQuery.values && preparedQuery.values.length > 1) {\n        return doScoreFuzzy2Multiple(target, preparedQuery.values, patternStart, wordStart);\n    }\n    // Score: single input\n    return doScoreFuzzy2Single(target, query, patternStart, wordStart);\n}\nfunction doScoreFuzzy2Multiple(target, query, patternStart, wordStart) {\n    let totalScore = 0;\n    const totalMatches = [];\n    for (const queryPiece of query) {\n        const [score, matches] = doScoreFuzzy2Single(target, queryPiece, patternStart, wordStart);\n        if (typeof score !== 'number') {\n            // if a single query value does not match, return with\n            // no score entirely, we require all queries to match\n            return NO_SCORE2;\n        }\n        totalScore += score;\n        totalMatches.push(...matches);\n    }\n    // if we have a score, ensure that the positions are\n    // sorted in ascending order and distinct\n    return [totalScore, normalizeMatches(totalMatches)];\n}\nfunction doScoreFuzzy2Single(target, query, patternStart, wordStart) {\n    const score = fuzzyScore(query.original, query.originalLowercase, patternStart, target, target.toLowerCase(), wordStart, { firstMatchCanBeWeak: true, boostFullMatch: true });\n    if (!score) {\n        return NO_SCORE2;\n    }\n    return [score[0], createFuzzyMatches(score)];\n}\nconst NO_ITEM_SCORE = Object.freeze({ score: 0 });\nfunction normalizeMatches(matches) {\n    // sort matches by start to be able to normalize\n    const sortedMatches = matches.sort((matchA, matchB) => {\n        return matchA.start - matchB.start;\n    });\n    // merge matches that overlap\n    const normalizedMatches = [];\n    let currentMatch = undefined;\n    for (const match of sortedMatches) {\n        // if we have no current match or the matches\n        // do not overlap, we take it as is and remember\n        // it for future merging\n        if (!currentMatch || !matchOverlaps(currentMatch, match)) {\n            currentMatch = match;\n            normalizedMatches.push(match);\n        }\n        // otherwise we merge the matches\n        else {\n            currentMatch.start = Math.min(currentMatch.start, match.start);\n            currentMatch.end = Math.max(currentMatch.end, match.end);\n        }\n    }\n    return normalizedMatches;\n}\nfunction matchOverlaps(matchA, matchB) {\n    if (matchA.end < matchB.start) {\n        return false; // A ends before B starts\n    }\n    if (matchB.end < matchA.start) {\n        return false; // B ends before A starts\n    }\n    return true;\n}\n/*\n * If a query is wrapped in quotes, the user does not want to\n * use fuzzy search for this query.\n */\nfunction queryExpectsExactMatch(query) {\n    return query.startsWith('\"') && query.endsWith('\"');\n}\n/**\n * Helper function to prepare a search value for scoring by removing unwanted characters\n * and allowing to score on multiple pieces separated by whitespace character.\n */\nconst MULTIPLE_QUERY_VALUES_SEPARATOR = ' ';\nexport function prepareQuery(original) {\n    if (typeof original !== 'string') {\n        original = '';\n    }\n    const originalLowercase = original.toLowerCase();\n    const { pathNormalized, normalized, normalizedLowercase } = normalizeQuery(original);\n    const containsPathSeparator = pathNormalized.indexOf(sep) >= 0;\n    const expectExactMatch = queryExpectsExactMatch(original);\n    let values = undefined;\n    const originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);\n    if (originalSplit.length > 1) {\n        for (const originalPiece of originalSplit) {\n            const expectExactMatchPiece = queryExpectsExactMatch(originalPiece);\n            const { pathNormalized: pathNormalizedPiece, normalized: normalizedPiece, normalizedLowercase: normalizedLowercasePiece } = normalizeQuery(originalPiece);\n            if (normalizedPiece) {\n                if (!values) {\n                    values = [];\n                }\n                values.push({\n                    original: originalPiece,\n                    originalLowercase: originalPiece.toLowerCase(),\n                    pathNormalized: pathNormalizedPiece,\n                    normalized: normalizedPiece,\n                    normalizedLowercase: normalizedLowercasePiece,\n                    expectContiguousMatch: expectExactMatchPiece\n                });\n            }\n        }\n    }\n    return { original, originalLowercase, pathNormalized, normalized, normalizedLowercase, values, containsPathSeparator, expectContiguousMatch: expectExactMatch };\n}\nfunction normalizeQuery(original) {\n    let pathNormalized;\n    if (isWindows) {\n        pathNormalized = original.replace(/\\//g, sep); // Help Windows users to search for paths when using slash\n    }\n    else {\n        pathNormalized = original.replace(/\\\\/g, sep); // Help macOS/Linux users to search for paths when using backslash\n    }\n    // we remove quotes here because quotes are used for exact match search\n    const normalized = stripWildcards(pathNormalized).replace(/\\s|\"/g, '');\n    return {\n        pathNormalized,\n        normalized,\n        normalizedLowercase: normalized.toLowerCase()\n    };\n}\nexport function pieceToQuery(arg1) {\n    if (Array.isArray(arg1)) {\n        return prepareQuery(arg1.map(piece => piece.original).join(MULTIPLE_QUERY_VALUES_SEPARATOR));\n    }\n    return prepareQuery(arg1.original);\n}\n//#endregion\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}