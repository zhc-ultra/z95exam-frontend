{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.concat.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertNever } from '../../base/common/assert.js';\nimport { Position } from './core/position.js';\nimport { InjectedTextCursorStops } from './model.js';\n/**\n * *input*:\n * ```\n * xxxxxxxxxxxxxxxxxxxxxxxxxxx\n * ```\n *\n * -> Applying injections `[i...i]`, *inputWithInjections*:\n * ```\n * xxxxxx[iiiiiiiiii]xxxxxxxxxxxxxxxxx[ii]xxxx\n * ```\n *\n * -> breaking at offsets `|` in `xxxxxx[iiiiiii|iii]xxxxxxxxxxx|xxxxxx[ii]xxxx|`:\n * ```\n * xxxxxx[iiiiiii\n * iii]xxxxxxxxxxx\n * xxxxxx[ii]xxxx\n * ```\n *\n * -> applying wrappedTextIndentLength, *output*:\n * ```\n * xxxxxx[iiiiiii\n *    iii]xxxxxxxxxxx\n *    xxxxxx[ii]xxxx\n * ```\n */\nexport var ModelLineProjectionData = /*#__PURE__*/function () {\n  function ModelLineProjectionData(injectionOffsets,\n  /**\n   * `injectionOptions.length` must equal `injectionOffsets.length`\n   */\n  injectionOptions,\n  /**\n   * Refers to offsets after applying injections to the source.\n   * The last break offset indicates the length of the source after applying injections.\n   */\n  breakOffsets,\n  /**\n   * Refers to offsets after applying injections\n   */\n  breakOffsetsVisibleColumn, wrappedTextIndentLength) {\n    _classCallCheck(this, ModelLineProjectionData);\n    this.injectionOffsets = injectionOffsets;\n    this.injectionOptions = injectionOptions;\n    this.breakOffsets = breakOffsets;\n    this.breakOffsetsVisibleColumn = breakOffsetsVisibleColumn;\n    this.wrappedTextIndentLength = wrappedTextIndentLength;\n  }\n  return _createClass(ModelLineProjectionData, [{\n    key: \"getOutputLineCount\",\n    value: function getOutputLineCount() {\n      return this.breakOffsets.length;\n    }\n  }, {\n    key: \"getMinOutputOffset\",\n    value: function getMinOutputOffset(outputLineIndex) {\n      if (outputLineIndex > 0) {\n        return this.wrappedTextIndentLength;\n      }\n      return 0;\n    }\n  }, {\n    key: \"getLineLength\",\n    value: function getLineLength(outputLineIndex) {\n      // These offsets refer to model text with injected text.\n      var startOffset = outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0;\n      var endOffset = this.breakOffsets[outputLineIndex];\n      var lineLength = endOffset - startOffset;\n      if (outputLineIndex > 0) {\n        lineLength += this.wrappedTextIndentLength;\n      }\n      return lineLength;\n    }\n  }, {\n    key: \"getMaxOutputOffset\",\n    value: function getMaxOutputOffset(outputLineIndex) {\n      return this.getLineLength(outputLineIndex);\n    }\n  }, {\n    key: \"translateToInputOffset\",\n    value: function translateToInputOffset(outputLineIndex, outputOffset) {\n      if (outputLineIndex > 0) {\n        outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n      }\n      var offsetInInputWithInjection = outputLineIndex === 0 ? outputOffset : this.breakOffsets[outputLineIndex - 1] + outputOffset;\n      var offsetInInput = offsetInInputWithInjection;\n      if (this.injectionOffsets !== null) {\n        for (var i = 0; i < this.injectionOffsets.length; i++) {\n          if (offsetInInput > this.injectionOffsets[i]) {\n            if (offsetInInput < this.injectionOffsets[i] + this.injectionOptions[i].content.length) {\n              // `inputOffset` is within injected text\n              offsetInInput = this.injectionOffsets[i];\n            } else {\n              offsetInInput -= this.injectionOptions[i].content.length;\n            }\n          } else {\n            break;\n          }\n        }\n      }\n      return offsetInInput;\n    }\n  }, {\n    key: \"translateToOutputPosition\",\n    value: function translateToOutputPosition(inputOffset) {\n      var affinity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n      var inputOffsetInInputWithInjection = inputOffset;\n      if (this.injectionOffsets !== null) {\n        for (var i = 0; i < this.injectionOffsets.length; i++) {\n          if (inputOffset < this.injectionOffsets[i]) {\n            break;\n          }\n          if (affinity !== 1 /* PositionAffinity.Right */ && inputOffset === this.injectionOffsets[i]) {\n            break;\n          }\n          inputOffsetInInputWithInjection += this.injectionOptions[i].content.length;\n        }\n      }\n      return this.offsetInInputWithInjectionsToOutputPosition(inputOffsetInInputWithInjection, affinity);\n    }\n  }, {\n    key: \"offsetInInputWithInjectionsToOutputPosition\",\n    value: function offsetInInputWithInjectionsToOutputPosition(offsetInInputWithInjections) {\n      var affinity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n      var low = 0;\n      var high = this.breakOffsets.length - 1;\n      var mid = 0;\n      var midStart = 0;\n      while (low <= high) {\n        mid = low + (high - low) / 2 | 0;\n        var midStop = this.breakOffsets[mid];\n        midStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;\n        if (affinity === 0 /* PositionAffinity.Left */) {\n          if (offsetInInputWithInjections <= midStart) {\n            high = mid - 1;\n          } else if (offsetInInputWithInjections > midStop) {\n            low = mid + 1;\n          } else {\n            break;\n          }\n        } else {\n          if (offsetInInputWithInjections < midStart) {\n            high = mid - 1;\n          } else if (offsetInInputWithInjections >= midStop) {\n            low = mid + 1;\n          } else {\n            break;\n          }\n        }\n      }\n      var outputOffset = offsetInInputWithInjections - midStart;\n      if (mid > 0) {\n        outputOffset += this.wrappedTextIndentLength;\n      }\n      return new OutputPosition(mid, outputOffset);\n    }\n  }, {\n    key: \"normalizeOutputPosition\",\n    value: function normalizeOutputPosition(outputLineIndex, outputOffset, affinity) {\n      if (this.injectionOffsets !== null) {\n        var offsetInInputWithInjections = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n        var normalizedOffsetInUnwrappedLine = this.normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity);\n        if (normalizedOffsetInUnwrappedLine !== offsetInInputWithInjections) {\n          // injected text caused a change\n          return this.offsetInInputWithInjectionsToOutputPosition(normalizedOffsetInUnwrappedLine, affinity);\n        }\n      }\n      if (affinity === 0 /* PositionAffinity.Left */) {\n        if (outputLineIndex > 0 && outputOffset === this.getMinOutputOffset(outputLineIndex)) {\n          return new OutputPosition(outputLineIndex - 1, this.getMaxOutputOffset(outputLineIndex - 1));\n        }\n      } else if (affinity === 1 /* PositionAffinity.Right */) {\n        var maxOutputLineIndex = this.getOutputLineCount() - 1;\n        if (outputLineIndex < maxOutputLineIndex && outputOffset === this.getMaxOutputOffset(outputLineIndex)) {\n          return new OutputPosition(outputLineIndex + 1, this.getMinOutputOffset(outputLineIndex + 1));\n        }\n      }\n      return new OutputPosition(outputLineIndex, outputOffset);\n    }\n  }, {\n    key: \"outputPositionToOffsetInInputWithInjections\",\n    value: function outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset) {\n      if (outputLineIndex > 0) {\n        outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n      }\n      var result = (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) + outputOffset;\n      return result;\n    }\n  }, {\n    key: \"normalizeOffsetInInputWithInjectionsAroundInjections\",\n    value: function normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity) {\n      var injectedText = this.getInjectedTextAtOffset(offsetInInputWithInjections);\n      if (!injectedText) {\n        return offsetInInputWithInjections;\n      }\n      if (affinity === 2 /* PositionAffinity.None */) {\n        if (offsetInInputWithInjections === injectedText.offsetInInputWithInjections + injectedText.length && hasRightCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n          return injectedText.offsetInInputWithInjections + injectedText.length;\n        } else {\n          var result = injectedText.offsetInInputWithInjections;\n          if (hasLeftCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n            return result;\n          }\n          var index = injectedText.injectedTextIndex - 1;\n          while (index >= 0 && this.injectionOffsets[index] === this.injectionOffsets[injectedText.injectedTextIndex]) {\n            if (hasRightCursorStop(this.injectionOptions[index].cursorStops)) {\n              break;\n            }\n            result -= this.injectionOptions[index].content.length;\n            if (hasLeftCursorStop(this.injectionOptions[index].cursorStops)) {\n              break;\n            }\n            index--;\n          }\n          return result;\n        }\n      } else if (affinity === 1 /* PositionAffinity.Right */ || affinity === 4 /* PositionAffinity.RightOfInjectedText */) {\n        var _result = injectedText.offsetInInputWithInjections + injectedText.length;\n        var _index = injectedText.injectedTextIndex;\n        // traverse all injected text that touch each other\n        while (_index + 1 < this.injectionOffsets.length && this.injectionOffsets[_index + 1] === this.injectionOffsets[_index]) {\n          _result += this.injectionOptions[_index + 1].content.length;\n          _index++;\n        }\n        return _result;\n      } else if (affinity === 0 /* PositionAffinity.Left */ || affinity === 3 /* PositionAffinity.LeftOfInjectedText */) {\n        // affinity is left\n        var _result2 = injectedText.offsetInInputWithInjections;\n        var _index2 = injectedText.injectedTextIndex;\n        // traverse all injected text that touch each other\n        while (_index2 - 1 >= 0 && this.injectionOffsets[_index2 - 1] === this.injectionOffsets[_index2]) {\n          _result2 -= this.injectionOptions[_index2 - 1].content.length;\n          _index2--;\n        }\n        return _result2;\n      }\n      assertNever(affinity);\n    }\n  }, {\n    key: \"getInjectedText\",\n    value: function getInjectedText(outputLineIndex, outputOffset) {\n      var offset = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n      var injectedText = this.getInjectedTextAtOffset(offset);\n      if (!injectedText) {\n        return null;\n      }\n      return {\n        options: this.injectionOptions[injectedText.injectedTextIndex]\n      };\n    }\n  }, {\n    key: \"getInjectedTextAtOffset\",\n    value: function getInjectedTextAtOffset(offsetInInputWithInjections) {\n      var injectionOffsets = this.injectionOffsets;\n      var injectionOptions = this.injectionOptions;\n      if (injectionOffsets !== null) {\n        var totalInjectedTextLengthBefore = 0;\n        for (var i = 0; i < injectionOffsets.length; i++) {\n          var length = injectionOptions[i].content.length;\n          var injectedTextStartOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore;\n          var injectedTextEndOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n          if (injectedTextStartOffsetInInputWithInjections > offsetInInputWithInjections) {\n            // Injected text starts later.\n            break; // All later injected texts have an even larger offset.\n          }\n          if (offsetInInputWithInjections <= injectedTextEndOffsetInInputWithInjections) {\n            // Injected text ends after or with the given position (but also starts with or before it).\n            return {\n              injectedTextIndex: i,\n              offsetInInputWithInjections: injectedTextStartOffsetInInputWithInjections,\n              length: length\n            };\n          }\n          totalInjectedTextLengthBefore += length;\n        }\n      }\n      return undefined;\n    }\n  }]);\n}();\nfunction hasRightCursorStop(cursorStop) {\n  if (cursorStop === null || cursorStop === undefined) {\n    return true;\n  }\n  return cursorStop === InjectedTextCursorStops.Right || cursorStop === InjectedTextCursorStops.Both;\n}\nfunction hasLeftCursorStop(cursorStop) {\n  if (cursorStop === null || cursorStop === undefined) {\n    return true;\n  }\n  return cursorStop === InjectedTextCursorStops.Left || cursorStop === InjectedTextCursorStops.Both;\n}\nexport var InjectedText = /*#__PURE__*/_createClass(function InjectedText(options) {\n  _classCallCheck(this, InjectedText);\n  this.options = options;\n});\nexport var OutputPosition = /*#__PURE__*/function () {\n  function OutputPosition(outputLineIndex, outputOffset) {\n    _classCallCheck(this, OutputPosition);\n    this.outputLineIndex = outputLineIndex;\n    this.outputOffset = outputOffset;\n  }\n  return _createClass(OutputPosition, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.outputLineIndex, \":\").concat(this.outputOffset);\n    }\n  }, {\n    key: \"toPosition\",\n    value: function toPosition(baseLineNumber) {\n      return new Position(baseLineNumber + this.outputLineIndex, this.outputOffset + 1);\n    }\n  }]);\n}();","map":{"version":3,"names":["assertNever","Position","InjectedTextCursorStops","ModelLineProjectionData","injectionOffsets","injectionOptions","breakOffsets","breakOffsetsVisibleColumn","wrappedTextIndentLength","_classCallCheck","_createClass","key","value","getOutputLineCount","length","getMinOutputOffset","outputLineIndex","getLineLength","startOffset","endOffset","lineLength","getMaxOutputOffset","translateToInputOffset","outputOffset","Math","max","offsetInInputWithInjection","offsetInInput","i","content","translateToOutputPosition","inputOffset","affinity","arguments","undefined","inputOffsetInInputWithInjection","offsetInInputWithInjectionsToOutputPosition","offsetInInputWithInjections","low","high","mid","midStart","midStop","OutputPosition","normalizeOutputPosition","outputPositionToOffsetInInputWithInjections","normalizedOffsetInUnwrappedLine","normalizeOffsetInInputWithInjectionsAroundInjections","maxOutputLineIndex","result","injectedText","getInjectedTextAtOffset","hasRightCursorStop","injectedTextIndex","cursorStops","hasLeftCursorStop","index","getInjectedText","offset","options","totalInjectedTextLengthBefore","injectedTextStartOffsetInInputWithInjections","injectedTextEndOffsetInInputWithInjections","cursorStop","Right","Both","Left","InjectedText","toString","concat","toPosition","baseLineNumber"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/modelLineProjectionData.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertNever } from '../../base/common/assert.js';\nimport { Position } from './core/position.js';\nimport { InjectedTextCursorStops } from './model.js';\n/**\n * *input*:\n * ```\n * xxxxxxxxxxxxxxxxxxxxxxxxxxx\n * ```\n *\n * -> Applying injections `[i...i]`, *inputWithInjections*:\n * ```\n * xxxxxx[iiiiiiiiii]xxxxxxxxxxxxxxxxx[ii]xxxx\n * ```\n *\n * -> breaking at offsets `|` in `xxxxxx[iiiiiii|iii]xxxxxxxxxxx|xxxxxx[ii]xxxx|`:\n * ```\n * xxxxxx[iiiiiii\n * iii]xxxxxxxxxxx\n * xxxxxx[ii]xxxx\n * ```\n *\n * -> applying wrappedTextIndentLength, *output*:\n * ```\n * xxxxxx[iiiiiii\n *    iii]xxxxxxxxxxx\n *    xxxxxx[ii]xxxx\n * ```\n */\nexport class ModelLineProjectionData {\n    constructor(injectionOffsets, \n    /**\n     * `injectionOptions.length` must equal `injectionOffsets.length`\n     */\n    injectionOptions, \n    /**\n     * Refers to offsets after applying injections to the source.\n     * The last break offset indicates the length of the source after applying injections.\n     */\n    breakOffsets, \n    /**\n     * Refers to offsets after applying injections\n     */\n    breakOffsetsVisibleColumn, wrappedTextIndentLength) {\n        this.injectionOffsets = injectionOffsets;\n        this.injectionOptions = injectionOptions;\n        this.breakOffsets = breakOffsets;\n        this.breakOffsetsVisibleColumn = breakOffsetsVisibleColumn;\n        this.wrappedTextIndentLength = wrappedTextIndentLength;\n    }\n    getOutputLineCount() {\n        return this.breakOffsets.length;\n    }\n    getMinOutputOffset(outputLineIndex) {\n        if (outputLineIndex > 0) {\n            return this.wrappedTextIndentLength;\n        }\n        return 0;\n    }\n    getLineLength(outputLineIndex) {\n        // These offsets refer to model text with injected text.\n        const startOffset = outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffset = this.breakOffsets[outputLineIndex];\n        let lineLength = endOffset - startOffset;\n        if (outputLineIndex > 0) {\n            lineLength += this.wrappedTextIndentLength;\n        }\n        return lineLength;\n    }\n    getMaxOutputOffset(outputLineIndex) {\n        return this.getLineLength(outputLineIndex);\n    }\n    translateToInputOffset(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const offsetInInputWithInjection = outputLineIndex === 0 ? outputOffset : this.breakOffsets[outputLineIndex - 1] + outputOffset;\n        let offsetInInput = offsetInInputWithInjection;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (offsetInInput > this.injectionOffsets[i]) {\n                    if (offsetInInput < this.injectionOffsets[i] + this.injectionOptions[i].content.length) {\n                        // `inputOffset` is within injected text\n                        offsetInInput = this.injectionOffsets[i];\n                    }\n                    else {\n                        offsetInInput -= this.injectionOptions[i].content.length;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return offsetInInput;\n    }\n    translateToOutputPosition(inputOffset, affinity = 2 /* PositionAffinity.None */) {\n        let inputOffsetInInputWithInjection = inputOffset;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (inputOffset < this.injectionOffsets[i]) {\n                    break;\n                }\n                if (affinity !== 1 /* PositionAffinity.Right */ && inputOffset === this.injectionOffsets[i]) {\n                    break;\n                }\n                inputOffsetInInputWithInjection += this.injectionOptions[i].content.length;\n            }\n        }\n        return this.offsetInInputWithInjectionsToOutputPosition(inputOffsetInInputWithInjection, affinity);\n    }\n    offsetInInputWithInjectionsToOutputPosition(offsetInInputWithInjections, affinity = 2 /* PositionAffinity.None */) {\n        let low = 0;\n        let high = this.breakOffsets.length - 1;\n        let mid = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            const midStop = this.breakOffsets[mid];\n            midStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;\n            if (affinity === 0 /* PositionAffinity.Left */) {\n                if (offsetInInputWithInjections <= midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections > midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                if (offsetInInputWithInjections < midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections >= midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        let outputOffset = offsetInInputWithInjections - midStart;\n        if (mid > 0) {\n            outputOffset += this.wrappedTextIndentLength;\n        }\n        return new OutputPosition(mid, outputOffset);\n    }\n    normalizeOutputPosition(outputLineIndex, outputOffset, affinity) {\n        if (this.injectionOffsets !== null) {\n            const offsetInInputWithInjections = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n            const normalizedOffsetInUnwrappedLine = this.normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity);\n            if (normalizedOffsetInUnwrappedLine !== offsetInInputWithInjections) {\n                // injected text caused a change\n                return this.offsetInInputWithInjectionsToOutputPosition(normalizedOffsetInUnwrappedLine, affinity);\n            }\n        }\n        if (affinity === 0 /* PositionAffinity.Left */) {\n            if (outputLineIndex > 0 && outputOffset === this.getMinOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex - 1, this.getMaxOutputOffset(outputLineIndex - 1));\n            }\n        }\n        else if (affinity === 1 /* PositionAffinity.Right */) {\n            const maxOutputLineIndex = this.getOutputLineCount() - 1;\n            if (outputLineIndex < maxOutputLineIndex && outputOffset === this.getMaxOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex + 1, this.getMinOutputOffset(outputLineIndex + 1));\n            }\n        }\n        return new OutputPosition(outputLineIndex, outputOffset);\n    }\n    outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const result = (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) + outputOffset;\n        return result;\n    }\n    normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity) {\n        const injectedText = this.getInjectedTextAtOffset(offsetInInputWithInjections);\n        if (!injectedText) {\n            return offsetInInputWithInjections;\n        }\n        if (affinity === 2 /* PositionAffinity.None */) {\n            if (offsetInInputWithInjections === injectedText.offsetInInputWithInjections + injectedText.length\n                && hasRightCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                return injectedText.offsetInInputWithInjections + injectedText.length;\n            }\n            else {\n                let result = injectedText.offsetInInputWithInjections;\n                if (hasLeftCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                    return result;\n                }\n                let index = injectedText.injectedTextIndex - 1;\n                while (index >= 0 && this.injectionOffsets[index] === this.injectionOffsets[injectedText.injectedTextIndex]) {\n                    if (hasRightCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    result -= this.injectionOptions[index].content.length;\n                    if (hasLeftCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    index--;\n                }\n                return result;\n            }\n        }\n        else if (affinity === 1 /* PositionAffinity.Right */ || affinity === 4 /* PositionAffinity.RightOfInjectedText */) {\n            let result = injectedText.offsetInInputWithInjections + injectedText.length;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index + 1 < this.injectionOffsets.length && this.injectionOffsets[index + 1] === this.injectionOffsets[index]) {\n                result += this.injectionOptions[index + 1].content.length;\n                index++;\n            }\n            return result;\n        }\n        else if (affinity === 0 /* PositionAffinity.Left */ || affinity === 3 /* PositionAffinity.LeftOfInjectedText */) {\n            // affinity is left\n            let result = injectedText.offsetInInputWithInjections;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index - 1 >= 0 && this.injectionOffsets[index - 1] === this.injectionOffsets[index]) {\n                result -= this.injectionOptions[index - 1].content.length;\n                index--;\n            }\n            return result;\n        }\n        assertNever(affinity);\n    }\n    getInjectedText(outputLineIndex, outputOffset) {\n        const offset = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n        const injectedText = this.getInjectedTextAtOffset(offset);\n        if (!injectedText) {\n            return null;\n        }\n        return {\n            options: this.injectionOptions[injectedText.injectedTextIndex]\n        };\n    }\n    getInjectedTextAtOffset(offsetInInputWithInjections) {\n        const injectionOffsets = this.injectionOffsets;\n        const injectionOptions = this.injectionOptions;\n        if (injectionOffsets !== null) {\n            let totalInjectedTextLengthBefore = 0;\n            for (let i = 0; i < injectionOffsets.length; i++) {\n                const length = injectionOptions[i].content.length;\n                const injectedTextStartOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore;\n                const injectedTextEndOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n                if (injectedTextStartOffsetInInputWithInjections > offsetInInputWithInjections) {\n                    // Injected text starts later.\n                    break; // All later injected texts have an even larger offset.\n                }\n                if (offsetInInputWithInjections <= injectedTextEndOffsetInInputWithInjections) {\n                    // Injected text ends after or with the given position (but also starts with or before it).\n                    return {\n                        injectedTextIndex: i,\n                        offsetInInputWithInjections: injectedTextStartOffsetInInputWithInjections,\n                        length\n                    };\n                }\n                totalInjectedTextLengthBefore += length;\n            }\n        }\n        return undefined;\n    }\n}\nfunction hasRightCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Right || cursorStop === InjectedTextCursorStops.Both;\n}\nfunction hasLeftCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Left || cursorStop === InjectedTextCursorStops.Both;\n}\nexport class InjectedText {\n    constructor(options) {\n        this.options = options;\n    }\n}\nexport class OutputPosition {\n    constructor(outputLineIndex, outputOffset) {\n        this.outputLineIndex = outputLineIndex;\n        this.outputOffset = outputOffset;\n    }\n    toString() {\n        return `${this.outputLineIndex}:${this.outputOffset}`;\n    }\n    toPosition(baseLineNumber) {\n        return new Position(baseLineNumber + this.outputLineIndex, this.outputOffset + 1);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}