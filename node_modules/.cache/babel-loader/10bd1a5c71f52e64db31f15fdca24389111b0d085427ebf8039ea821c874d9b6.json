{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _get from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.last-index-of.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.string.substr.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorState, EditOperationResult } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { CompositionOutcome, TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewEvents.js';\nimport { dispose as _dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModelEventDispatcher.js';\nexport var CursorsController = /*#__PURE__*/function (_Disposable) {\n  function CursorsController(model, viewModel, coordinatesConverter, cursorConfig) {\n    var _this;\n    _classCallCheck(this, CursorsController);\n    _this = _callSuper(this, CursorsController);\n    _this._model = model;\n    _this._knownModelVersionId = _this._model.getVersionId();\n    _this._viewModel = viewModel;\n    _this._coordinatesConverter = coordinatesConverter;\n    _this.context = new CursorContext(_this._model, _this._viewModel, _this._coordinatesConverter, cursorConfig);\n    _this._cursors = new CursorCollection(_this.context);\n    _this._hasFocus = false;\n    _this._isHandling = false;\n    _this._compositionState = null;\n    _this._columnSelectData = null;\n    _this._autoClosedActions = [];\n    _this._prevEditOperationType = 0 /* EditOperationType.Other */;\n    return _this;\n  }\n  _inherits(CursorsController, _Disposable);\n  return _createClass(CursorsController, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this._cursors.dispose();\n      this._autoClosedActions = _dispose(this._autoClosedActions);\n      _get(_getPrototypeOf(CursorsController.prototype), \"dispose\", this).call(this);\n    }\n  }, {\n    key: \"updateConfiguration\",\n    value: function updateConfiguration(cursorConfig) {\n      this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n      this._cursors.updateContext(this.context);\n    }\n  }, {\n    key: \"onLineMappingChanged\",\n    value: function onLineMappingChanged(eventsCollector) {\n      if (this._knownModelVersionId !== this._model.getVersionId()) {\n        // There are model change events that I didn't yet receive.\n        //\n        // This can happen when editing the model, and the view model receives the change events first,\n        // and the view model emits line mapping changed events, all before the cursor gets a chance to\n        // recover from markers.\n        //\n        // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n        return;\n      }\n      // Ensure valid state\n      this.setStates(eventsCollector, 'viewModel', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n    }\n  }, {\n    key: \"setHasFocus\",\n    value: function setHasFocus(hasFocus) {\n      this._hasFocus = hasFocus;\n    }\n  }, {\n    key: \"_validateAutoClosedActions\",\n    value: function _validateAutoClosedActions() {\n      if (this._autoClosedActions.length > 0) {\n        var selections = this._cursors.getSelections();\n        for (var i = 0; i < this._autoClosedActions.length; i++) {\n          var autoClosedAction = this._autoClosedActions[i];\n          if (!autoClosedAction.isValid(selections)) {\n            autoClosedAction.dispose();\n            this._autoClosedActions.splice(i, 1);\n            i--;\n          }\n        }\n      }\n    }\n    // ------ some getters/setters\n  }, {\n    key: \"getPrimaryCursorState\",\n    value: function getPrimaryCursorState() {\n      return this._cursors.getPrimaryCursor();\n    }\n  }, {\n    key: \"getLastAddedCursorIndex\",\n    value: function getLastAddedCursorIndex() {\n      return this._cursors.getLastAddedCursorIndex();\n    }\n  }, {\n    key: \"getCursorStates\",\n    value: function getCursorStates() {\n      return this._cursors.getAll();\n    }\n  }, {\n    key: \"setStates\",\n    value: function setStates(eventsCollector, source, reason, states) {\n      var reachedMaxCursorCount = false;\n      var multiCursorLimit = this.context.cursorConfig.multiCursorLimit;\n      if (states !== null && states.length > multiCursorLimit) {\n        states = states.slice(0, multiCursorLimit);\n        reachedMaxCursorCount = true;\n      }\n      var oldState = CursorModelState.from(this._model, this);\n      this._cursors.setStates(states);\n      this._cursors.normalize();\n      this._columnSelectData = null;\n      this._validateAutoClosedActions();\n      return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n    }\n  }, {\n    key: \"setCursorColumnSelectData\",\n    value: function setCursorColumnSelectData(columnSelectData) {\n      this._columnSelectData = columnSelectData;\n    }\n  }, {\n    key: \"revealAll\",\n    value: function revealAll(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n      var viewPositions = this._cursors.getViewPositions();\n      var revealViewRange = null;\n      var revealViewSelections = null;\n      if (viewPositions.length > 1) {\n        revealViewSelections = this._cursors.getViewSelections();\n      } else {\n        revealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n      }\n      eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n  }, {\n    key: \"revealPrimary\",\n    value: function revealPrimary(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n      var primaryCursor = this._cursors.getPrimaryCursor();\n      var revealViewSelections = [primaryCursor.viewState.selection];\n      eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, null, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n  }, {\n    key: \"saveState\",\n    value: function saveState() {\n      var result = [];\n      var selections = this._cursors.getSelections();\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n        result.push({\n          inSelectionMode: !selection.isEmpty(),\n          selectionStart: {\n            lineNumber: selection.selectionStartLineNumber,\n            column: selection.selectionStartColumn\n          },\n          position: {\n            lineNumber: selection.positionLineNumber,\n            column: selection.positionColumn\n          }\n        });\n      }\n      return result;\n    }\n  }, {\n    key: \"restoreState\",\n    value: function restoreState(eventsCollector, states) {\n      var desiredSelections = [];\n      for (var i = 0, len = states.length; i < len; i++) {\n        var state = states[i];\n        var positionLineNumber = 1;\n        var positionColumn = 1;\n        // Avoid missing properties on the literal\n        if (state.position && state.position.lineNumber) {\n          positionLineNumber = state.position.lineNumber;\n        }\n        if (state.position && state.position.column) {\n          positionColumn = state.position.column;\n        }\n        var selectionStartLineNumber = positionLineNumber;\n        var selectionStartColumn = positionColumn;\n        // Avoid missing properties on the literal\n        if (state.selectionStart && state.selectionStart.lineNumber) {\n          selectionStartLineNumber = state.selectionStart.lineNumber;\n        }\n        if (state.selectionStart && state.selectionStart.column) {\n          selectionStartColumn = state.selectionStart.column;\n        }\n        desiredSelections.push({\n          selectionStartLineNumber: selectionStartLineNumber,\n          selectionStartColumn: selectionStartColumn,\n          positionLineNumber: positionLineNumber,\n          positionColumn: positionColumn\n        });\n      }\n      this.setStates(eventsCollector, 'restoreState', 0 /* CursorChangeReason.NotSet */, CursorState.fromModelSelections(desiredSelections));\n      this.revealAll(eventsCollector, 'restoreState', false, 0 /* VerticalRevealType.Simple */, true, 1 /* editorCommon.ScrollType.Immediate */);\n    }\n  }, {\n    key: \"onModelContentChanged\",\n    value: function onModelContentChanged(eventsCollector, event) {\n      if (event instanceof ModelInjectedTextChangedEvent) {\n        // If injected texts change, the view positions of all cursors need to be updated.\n        if (this._isHandling) {\n          // The view positions will be updated when handling finishes\n          return;\n        }\n        // setStates might remove markers, which could trigger a decoration change.\n        // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n        // and an endless recursion happens.\n        // _isHandling prevents that.\n        this._isHandling = true;\n        try {\n          this.setStates(eventsCollector, 'modelChange', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n        } finally {\n          this._isHandling = false;\n        }\n      } else {\n        var e = event.rawContentChangedEvent;\n        this._knownModelVersionId = e.versionId;\n        if (this._isHandling) {\n          return;\n        }\n        var hadFlushEvent = e.containsEvent(1 /* RawContentChangedType.Flush */);\n        this._prevEditOperationType = 0 /* EditOperationType.Other */;\n        if (hadFlushEvent) {\n          // a model.setValue() was called\n          this._cursors.dispose();\n          this._cursors = new CursorCollection(this.context);\n          this._validateAutoClosedActions();\n          this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* CursorChangeReason.ContentFlush */, null, false);\n        } else {\n          if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n            var cursorState = CursorState.fromModelSelections(e.resultingSelection);\n            if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* CursorChangeReason.Undo */ : e.isRedoing ? 6 /* CursorChangeReason.Redo */ : 2 /* CursorChangeReason.RecoverFromMarkers */, cursorState)) {\n              this.revealAll(eventsCollector, 'modelChange', false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n            }\n          } else {\n            var selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n            this.setStates(eventsCollector, 'modelChange', 2 /* CursorChangeReason.RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n          }\n        }\n      }\n    }\n  }, {\n    key: \"getSelection\",\n    value: function getSelection() {\n      return this._cursors.getPrimaryCursor().modelState.selection;\n    }\n  }, {\n    key: \"getTopMostViewPosition\",\n    value: function getTopMostViewPosition() {\n      return this._cursors.getTopMostViewPosition();\n    }\n  }, {\n    key: \"getBottomMostViewPosition\",\n    value: function getBottomMostViewPosition() {\n      return this._cursors.getBottomMostViewPosition();\n    }\n  }, {\n    key: \"getCursorColumnSelectData\",\n    value: function getCursorColumnSelectData() {\n      if (this._columnSelectData) {\n        return this._columnSelectData;\n      }\n      var primaryCursor = this._cursors.getPrimaryCursor();\n      var viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n      var viewPosition = primaryCursor.viewState.position;\n      return {\n        isReal: false,\n        fromViewLineNumber: viewSelectionStart.lineNumber,\n        fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n        toViewLineNumber: viewPosition.lineNumber,\n        toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition)\n      };\n    }\n  }, {\n    key: \"getSelections\",\n    value: function getSelections() {\n      return this._cursors.getSelections();\n    }\n  }, {\n    key: \"setSelections\",\n    value: function setSelections(eventsCollector, source, selections, reason) {\n      this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n    }\n  }, {\n    key: \"getPrevEditOperationType\",\n    value: function getPrevEditOperationType() {\n      return this._prevEditOperationType;\n    }\n  }, {\n    key: \"setPrevEditOperationType\",\n    value: function setPrevEditOperationType(type) {\n      this._prevEditOperationType = type;\n    }\n    // ------ auxiliary handling logic\n  }, {\n    key: \"_pushAutoClosedAction\",\n    value: function _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n      var autoClosedCharactersDeltaDecorations = [];\n      var autoClosedEnclosingDeltaDecorations = [];\n      for (var i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n        autoClosedCharactersDeltaDecorations.push({\n          range: autoClosedCharactersRanges[i],\n          options: {\n            description: 'auto-closed-character',\n            inlineClassName: 'auto-closed-character',\n            stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n          }\n        });\n        autoClosedEnclosingDeltaDecorations.push({\n          range: autoClosedEnclosingRanges[i],\n          options: {\n            description: 'auto-closed-enclosing',\n            stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n          }\n        });\n      }\n      var autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n      var autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n      this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n    }\n  }, {\n    key: \"_executeEditOperation\",\n    value: function _executeEditOperation(opResult) {\n      if (!opResult) {\n        // Nothing to execute\n        return;\n      }\n      if (opResult.shouldPushStackElementBefore) {\n        this._model.pushStackElement();\n      }\n      var result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n      if (result) {\n        // The commands were applied correctly\n        this._interpretCommandResult(result);\n        // Check for auto-closing closed characters\n        var autoClosedCharactersRanges = [];\n        var autoClosedEnclosingRanges = [];\n        for (var i = 0; i < opResult.commands.length; i++) {\n          var command = opResult.commands[i];\n          if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n            autoClosedCharactersRanges.push(command.closeCharacterRange);\n            autoClosedEnclosingRanges.push(command.enclosingRange);\n          }\n        }\n        if (autoClosedCharactersRanges.length > 0) {\n          this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n        }\n        this._prevEditOperationType = opResult.type;\n      }\n      if (opResult.shouldPushStackElementAfter) {\n        this._model.pushStackElement();\n      }\n    }\n  }, {\n    key: \"_interpretCommandResult\",\n    value: function _interpretCommandResult(cursorState) {\n      if (!cursorState || cursorState.length === 0) {\n        cursorState = this._cursors.readSelectionFromMarkers();\n      }\n      this._columnSelectData = null;\n      this._cursors.setSelections(cursorState);\n      this._cursors.normalize();\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- emitting events\n  }, {\n    key: \"_emitStateChangedIfNecessary\",\n    value: function _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n      var newState = CursorModelState.from(this._model, this);\n      if (newState.equals(oldState)) {\n        return false;\n      }\n      var selections = this._cursors.getSelections();\n      var viewSelections = this._cursors.getViewSelections();\n      // Let the view get the event first.\n      eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections, reason));\n      // Only after the view has been notified, let the rest of the world know...\n      if (!oldState || oldState.cursorState.length !== newState.cursorState.length || newState.cursorState.some(function (newCursorState, i) {\n        return !newCursorState.modelState.equals(oldState.cursorState[i].modelState);\n      })) {\n        var oldSelections = oldState ? oldState.cursorState.map(function (s) {\n          return s.modelState.selection;\n        }) : null;\n        var oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n        eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n      }\n      return true;\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- handlers beyond this point\n  }, {\n    key: \"_findAutoClosingPairs\",\n    value: function _findAutoClosingPairs(edits) {\n      if (!edits.length) {\n        return null;\n      }\n      var indices = [];\n      for (var i = 0, len = edits.length; i < len; i++) {\n        var edit = edits[i];\n        if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n          return null;\n        }\n        var m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n        if (!m) {\n          return null;\n        }\n        var closeChar = m[1];\n        var autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n        if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n          return null;\n        }\n        var openChar = autoClosingPairsCandidates[0].open;\n        var closeCharIndex = edit.text.length - m[2].length - 1;\n        var openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n        if (openCharIndex === -1) {\n          return null;\n        }\n        indices.push([openCharIndex, closeCharIndex]);\n      }\n      return indices;\n    }\n  }, {\n    key: \"executeEdits\",\n    value: function executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n      var _this2 = this;\n      var autoClosingIndices = null;\n      if (source === 'snippet') {\n        autoClosingIndices = this._findAutoClosingPairs(edits);\n      }\n      if (autoClosingIndices) {\n        edits[0]._isTracked = true;\n      }\n      var autoClosedCharactersRanges = [];\n      var autoClosedEnclosingRanges = [];\n      var selections = this._model.pushEditOperations(this.getSelections(), edits, function (undoEdits) {\n        if (autoClosingIndices) {\n          for (var i = 0, len = autoClosingIndices.length; i < len; i++) {\n            var _autoClosingIndices$i = _slicedToArray(autoClosingIndices[i], 2),\n              openCharInnerIndex = _autoClosingIndices$i[0],\n              closeCharInnerIndex = _autoClosingIndices$i[1];\n            var undoEdit = undoEdits[i];\n            var lineNumber = undoEdit.range.startLineNumber;\n            var openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n            var closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n            autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n            autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n          }\n        }\n        var selections = cursorStateComputer(undoEdits);\n        if (selections) {\n          // Don't recover the selection from markers because\n          // we know what it should be.\n          _this2._isHandling = true;\n        }\n        return selections;\n      });\n      if (selections) {\n        this._isHandling = false;\n        this.setSelections(eventsCollector, source, selections, 0 /* CursorChangeReason.NotSet */);\n      }\n      if (autoClosedCharactersRanges.length > 0) {\n        this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n      }\n    }\n  }, {\n    key: \"_executeEdit\",\n    value: function _executeEdit(callback, eventsCollector, source) {\n      var cursorChangeReason = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      if (this.context.cursorConfig.readOnly) {\n        // we cannot edit when read only...\n        return;\n      }\n      var oldState = CursorModelState.from(this._model, this);\n      this._cursors.stopTrackingSelections();\n      this._isHandling = true;\n      try {\n        this._cursors.ensureValidState();\n        callback();\n      } catch (err) {\n        onUnexpectedError(err);\n      }\n      this._isHandling = false;\n      this._cursors.startTrackingSelections();\n      this._validateAutoClosedActions();\n      if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n        this.revealAll(eventsCollector, source, false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n      }\n    }\n  }, {\n    key: \"getAutoClosedCharacters\",\n    value: function getAutoClosedCharacters() {\n      return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n    }\n  }, {\n    key: \"startComposition\",\n    value: function startComposition(eventsCollector) {\n      this._compositionState = new CompositionState(this._model, this.getSelections());\n    }\n  }, {\n    key: \"endComposition\",\n    value: function endComposition(eventsCollector, source) {\n      var _this3 = this;\n      var compositionOutcome = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;\n      this._compositionState = null;\n      this._executeEdit(function () {\n        if (source === 'keyboard') {\n          // composition finishes, let's check if we need to auto complete if necessary.\n          _this3._executeEditOperation(TypeOperations.compositionEndWithInterceptors(_this3._prevEditOperationType, _this3.context.cursorConfig, _this3._model, compositionOutcome, _this3.getSelections(), _this3.getAutoClosedCharacters()));\n        }\n      }, eventsCollector, source);\n    }\n  }, {\n    key: \"type\",\n    value: function type(eventsCollector, text, source) {\n      var _this4 = this;\n      this._executeEdit(function () {\n        if (source === 'keyboard') {\n          // If this event is coming straight from the keyboard, look for electric characters and enter\n          var len = text.length;\n          var offset = 0;\n          while (offset < len) {\n            var charLength = strings.nextCharLength(text, offset);\n            var chr = text.substr(offset, charLength);\n            // Here we must interpret each typed character individually\n            _this4._executeEditOperation(TypeOperations.typeWithInterceptors(!!_this4._compositionState, _this4._prevEditOperationType, _this4.context.cursorConfig, _this4._model, _this4.getSelections(), _this4.getAutoClosedCharacters(), chr));\n            offset += charLength;\n          }\n        } else {\n          _this4._executeEditOperation(TypeOperations.typeWithoutInterceptors(_this4._prevEditOperationType, _this4.context.cursorConfig, _this4._model, _this4.getSelections(), text));\n        }\n      }, eventsCollector, source);\n    }\n  }, {\n    key: \"compositionType\",\n    value: function compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n      var _this5 = this;\n      if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n        // this edit is a no-op\n        if (positionDelta !== 0) {\n          // but it still wants to move the cursor\n          var newSelections = this.getSelections().map(function (selection) {\n            var position = selection.getPosition();\n            return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n          });\n          this.setSelections(eventsCollector, source, newSelections, 0 /* CursorChangeReason.NotSet */);\n        }\n        return;\n      }\n      this._executeEdit(function () {\n        _this5._executeEditOperation(TypeOperations.compositionType(_this5._prevEditOperationType, _this5.context.cursorConfig, _this5._model, _this5.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n      }, eventsCollector, source);\n    }\n  }, {\n    key: \"paste\",\n    value: function paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n      var _this6 = this;\n      this._executeEdit(function () {\n        _this6._executeEditOperation(TypeOperations.paste(_this6.context.cursorConfig, _this6._model, _this6.getSelections(), text, pasteOnNewLine, multicursorText || []));\n      }, eventsCollector, source, 4 /* CursorChangeReason.Paste */);\n    }\n  }, {\n    key: \"cut\",\n    value: function cut(eventsCollector, source) {\n      var _this7 = this;\n      this._executeEdit(function () {\n        _this7._executeEditOperation(DeleteOperations.cut(_this7.context.cursorConfig, _this7._model, _this7.getSelections()));\n      }, eventsCollector, source);\n    }\n  }, {\n    key: \"executeCommand\",\n    value: function executeCommand(eventsCollector, command, source) {\n      var _this8 = this;\n      this._executeEdit(function () {\n        _this8._cursors.killSecondaryCursors();\n        _this8._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, [command], {\n          shouldPushStackElementBefore: false,\n          shouldPushStackElementAfter: false\n        }));\n      }, eventsCollector, source);\n    }\n  }, {\n    key: \"executeCommands\",\n    value: function executeCommands(eventsCollector, commands, source) {\n      var _this9 = this;\n      this._executeEdit(function () {\n        _this9._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n          shouldPushStackElementBefore: false,\n          shouldPushStackElementAfter: false\n        }));\n      }, eventsCollector, source);\n    }\n  }]);\n}(Disposable);\n/**\n * A snapshot of the cursor and the model state\n */\nvar CursorModelState = /*#__PURE__*/function () {\n  function CursorModelState(modelVersionId, cursorState) {\n    _classCallCheck(this, CursorModelState);\n    this.modelVersionId = modelVersionId;\n    this.cursorState = cursorState;\n  }\n  return _createClass(CursorModelState, [{\n    key: \"equals\",\n    value: function equals(other) {\n      if (!other) {\n        return false;\n      }\n      if (this.modelVersionId !== other.modelVersionId) {\n        return false;\n      }\n      if (this.cursorState.length !== other.cursorState.length) {\n        return false;\n      }\n      for (var i = 0, len = this.cursorState.length; i < len; i++) {\n        if (!this.cursorState[i].equals(other.cursorState[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }], [{\n    key: \"from\",\n    value: function from(model, cursor) {\n      return new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n    }\n  }]);\n}();\nvar AutoClosedAction = /*#__PURE__*/function () {\n  function AutoClosedAction(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n    _classCallCheck(this, AutoClosedAction);\n    this._model = model;\n    this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n    this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n  }\n  return _createClass(AutoClosedAction, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n      this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n    }\n  }, {\n    key: \"getAutoClosedCharactersRanges\",\n    value: function getAutoClosedCharactersRanges() {\n      var result = [];\n      for (var i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n        var decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n        if (decorationRange) {\n          result.push(decorationRange);\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"isValid\",\n    value: function isValid(selections) {\n      var enclosingRanges = [];\n      for (var i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n        var decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n        if (decorationRange) {\n          enclosingRanges.push(decorationRange);\n          if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n            // Stop tracking if the range becomes multiline...\n            return false;\n          }\n        }\n      }\n      enclosingRanges.sort(Range.compareRangesUsingStarts);\n      selections.sort(Range.compareRangesUsingStarts);\n      for (var _i = 0; _i < selections.length; _i++) {\n        if (_i >= enclosingRanges.length) {\n          return false;\n        }\n        if (!enclosingRanges[_i].strictContainsRange(selections[_i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }], [{\n    key: \"getAllAutoClosedCharacters\",\n    value: function getAllAutoClosedCharacters(autoClosedActions) {\n      var autoClosedCharacters = [];\n      var _iterator = _createForOfIteratorHelper(autoClosedActions),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var autoClosedAction = _step.value;\n          autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return autoClosedCharacters;\n    }\n  }]);\n}();\nvar CommandExecutor = /*#__PURE__*/function () {\n  function CommandExecutor() {\n    _classCallCheck(this, CommandExecutor);\n  }\n  return _createClass(CommandExecutor, null, [{\n    key: \"executeCommands\",\n    value: function executeCommands(model, selectionsBefore, commands) {\n      var ctx = {\n        model: model,\n        selectionsBefore: selectionsBefore,\n        trackedRanges: [],\n        trackedRangesDirection: []\n      };\n      var result = this._innerExecuteCommands(ctx, commands);\n      for (var i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n        ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n      }\n      return result;\n    }\n  }, {\n    key: \"_innerExecuteCommands\",\n    value: function _innerExecuteCommands(ctx, commands) {\n      if (this._arrayIsEmpty(commands)) {\n        return null;\n      }\n      var commandsData = this._getEditOperations(ctx, commands);\n      if (commandsData.operations.length === 0) {\n        return null;\n      }\n      var rawOperations = commandsData.operations;\n      var loserCursorsMap = this._getLoserCursorMap(rawOperations);\n      if (loserCursorsMap.hasOwnProperty('0')) {\n        // These commands are very messed up\n        console.warn('Ignoring commands');\n        return null;\n      }\n      // Remove operations belonging to losing cursors\n      var filteredOperations = [];\n      for (var i = 0, len = rawOperations.length; i < len; i++) {\n        if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n          filteredOperations.push(rawOperations[i]);\n        }\n      }\n      // TODO@Alex: find a better way to do this.\n      // give the hint that edit operations are tracked to the model\n      if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n        filteredOperations[0]._isTracked = true;\n      }\n      var selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, function (inverseEditOperations) {\n        var groupedInverseEditOperations = [];\n        for (var _i2 = 0; _i2 < ctx.selectionsBefore.length; _i2++) {\n          groupedInverseEditOperations[_i2] = [];\n        }\n        var _iterator2 = _createForOfIteratorHelper(inverseEditOperations),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var op = _step2.value;\n            if (!op.identifier) {\n              // perhaps auto whitespace trim edits\n              continue;\n            }\n            groupedInverseEditOperations[op.identifier.major].push(op);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        var minorBasedSorter = function minorBasedSorter(a, b) {\n          return a.identifier.minor - b.identifier.minor;\n        };\n        var cursorSelections = [];\n        var _loop = function _loop(_i3) {\n          if (groupedInverseEditOperations[_i3].length > 0) {\n            groupedInverseEditOperations[_i3].sort(minorBasedSorter);\n            cursorSelections[_i3] = commands[_i3].computeCursorState(ctx.model, {\n              getInverseEditOperations: function getInverseEditOperations() {\n                return groupedInverseEditOperations[_i3];\n              },\n              getTrackedSelection: function getTrackedSelection(id) {\n                var idx = parseInt(id, 10);\n                var range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n                if (ctx.trackedRangesDirection[idx] === 0 /* SelectionDirection.LTR */) {\n                  return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                }\n                return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n              }\n            });\n          } else {\n            cursorSelections[_i3] = ctx.selectionsBefore[_i3];\n          }\n        };\n        for (var _i3 = 0; _i3 < ctx.selectionsBefore.length; _i3++) {\n          _loop(_i3);\n        }\n        return cursorSelections;\n      });\n      if (!selectionsAfter) {\n        selectionsAfter = ctx.selectionsBefore;\n      }\n      // Extract losing cursors\n      var losingCursors = [];\n      for (var losingCursorIndex in loserCursorsMap) {\n        if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n          losingCursors.push(parseInt(losingCursorIndex, 10));\n        }\n      }\n      // Sort losing cursors descending\n      losingCursors.sort(function (a, b) {\n        return b - a;\n      });\n      // Remove losing cursors\n      for (var _i4 = 0, _losingCursors = losingCursors; _i4 < _losingCursors.length; _i4++) {\n        var losingCursor = _losingCursors[_i4];\n        selectionsAfter.splice(losingCursor, 1);\n      }\n      return selectionsAfter;\n    }\n  }, {\n    key: \"_arrayIsEmpty\",\n    value: function _arrayIsEmpty(commands) {\n      for (var i = 0, len = commands.length; i < len; i++) {\n        if (commands[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"_getEditOperations\",\n    value: function _getEditOperations(ctx, commands) {\n      var operations = [];\n      var hadTrackedEditOperation = false;\n      for (var i = 0, len = commands.length; i < len; i++) {\n        var command = commands[i];\n        if (command) {\n          var r = this._getEditOperationsFromCommand(ctx, i, command);\n          operations = operations.concat(r.operations);\n          hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n        }\n      }\n      return {\n        operations: operations,\n        hadTrackedEditOperation: hadTrackedEditOperation\n      };\n    }\n  }, {\n    key: \"_getEditOperationsFromCommand\",\n    value: function _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n      // This method acts as a transaction, if the command fails\n      // everything it has done is ignored\n      var operations = [];\n      var operationMinor = 0;\n      var addEditOperation = function addEditOperation(range, text) {\n        var forceMoveMarkers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        if (Range.isEmpty(range) && text === '') {\n          // This command wants to add a no-op => no thank you\n          return;\n        }\n        operations.push({\n          identifier: {\n            major: majorIdentifier,\n            minor: operationMinor++\n          },\n          range: range,\n          text: text,\n          forceMoveMarkers: forceMoveMarkers,\n          isAutoWhitespaceEdit: command.insertsAutoWhitespace\n        });\n      };\n      var hadTrackedEditOperation = false;\n      var addTrackedEditOperation = function addTrackedEditOperation(selection, text, forceMoveMarkers) {\n        hadTrackedEditOperation = true;\n        addEditOperation(selection, text, forceMoveMarkers);\n      };\n      var trackSelection = function trackSelection(_selection, trackPreviousOnEmpty) {\n        var selection = Selection.liftSelection(_selection);\n        var stickiness;\n        if (selection.isEmpty()) {\n          if (typeof trackPreviousOnEmpty === 'boolean') {\n            if (trackPreviousOnEmpty) {\n              stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n            } else {\n              stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n            }\n          } else {\n            // Try to lock it with surrounding text\n            var maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n            if (selection.startColumn === maxLineColumn) {\n              stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n            } else {\n              stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n            }\n          }\n        } else {\n          stickiness = 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */;\n        }\n        var l = ctx.trackedRanges.length;\n        var id = ctx.model._setTrackedRange(null, selection, stickiness);\n        ctx.trackedRanges[l] = id;\n        ctx.trackedRangesDirection[l] = selection.getDirection();\n        return l.toString();\n      };\n      var editOperationBuilder = {\n        addEditOperation: addEditOperation,\n        addTrackedEditOperation: addTrackedEditOperation,\n        trackSelection: trackSelection\n      };\n      try {\n        command.getEditOperations(ctx.model, editOperationBuilder);\n      } catch (e) {\n        // TODO@Alex use notification service if this should be user facing\n        // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n        onUnexpectedError(e);\n        return {\n          operations: [],\n          hadTrackedEditOperation: false\n        };\n      }\n      return {\n        operations: operations,\n        hadTrackedEditOperation: hadTrackedEditOperation\n      };\n    }\n  }, {\n    key: \"_getLoserCursorMap\",\n    value: function _getLoserCursorMap(operations) {\n      // This is destructive on the array\n      operations = operations.slice(0);\n      // Sort operations with last one first\n      operations.sort(function (a, b) {\n        // Note the minus!\n        return -Range.compareRangesUsingEnds(a.range, b.range);\n      });\n      // Operations can not overlap!\n      var loserCursorsMap = {};\n      for (var i = 1; i < operations.length; i++) {\n        var previousOp = operations[i - 1];\n        var currentOp = operations[i];\n        if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n          var loserMajor = void 0;\n          if (previousOp.identifier.major > currentOp.identifier.major) {\n            // previousOp loses the battle\n            loserMajor = previousOp.identifier.major;\n          } else {\n            loserMajor = currentOp.identifier.major;\n          }\n          loserCursorsMap[loserMajor.toString()] = true;\n          for (var j = 0; j < operations.length; j++) {\n            if (operations[j].identifier.major === loserMajor) {\n              operations.splice(j, 1);\n              if (j < i) {\n                i--;\n              }\n              j--;\n            }\n          }\n          if (i > 0) {\n            i--;\n          }\n        }\n      }\n      return loserCursorsMap;\n    }\n  }]);\n}();\nvar CompositionLineState = /*#__PURE__*/_createClass(function CompositionLineState(text, startSelection, endSelection) {\n  _classCallCheck(this, CompositionLineState);\n  this.text = text;\n  this.startSelection = startSelection;\n  this.endSelection = endSelection;\n});\nvar CompositionState = /*#__PURE__*/function () {\n  function CompositionState(textModel, selections) {\n    _classCallCheck(this, CompositionState);\n    this._original = CompositionState._capture(textModel, selections);\n  }\n  /**\n   * Returns the inserted text during this composition.\n   * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.\n   */\n  return _createClass(CompositionState, [{\n    key: \"deduceOutcome\",\n    value: function deduceOutcome(textModel, selections) {\n      if (!this._original) {\n        return null;\n      }\n      var current = CompositionState._capture(textModel, selections);\n      if (!current) {\n        return null;\n      }\n      if (this._original.length !== current.length) {\n        return null;\n      }\n      var result = [];\n      for (var i = 0, len = this._original.length; i < len; i++) {\n        result.push(CompositionState._deduceOutcome(this._original[i], current[i]));\n      }\n      return result;\n    }\n  }], [{\n    key: \"_capture\",\n    value: function _capture(textModel, selections) {\n      var result = [];\n      var _iterator3 = _createForOfIteratorHelper(selections),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var selection = _step3.value;\n          if (selection.startLineNumber !== selection.endLineNumber) {\n            return null;\n          }\n          result.push(new CompositionLineState(textModel.getLineContent(selection.startLineNumber), selection.startColumn - 1, selection.endColumn - 1));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return result;\n    }\n  }, {\n    key: \"_deduceOutcome\",\n    value: function _deduceOutcome(original, current) {\n      var commonPrefix = Math.min(original.startSelection, current.startSelection, strings.commonPrefixLength(original.text, current.text));\n      var commonSuffix = Math.min(original.text.length - original.endSelection, current.text.length - current.endSelection, strings.commonSuffixLength(original.text, current.text));\n      var deletedText = original.text.substring(commonPrefix, original.text.length - commonSuffix);\n      var insertedText = current.text.substring(commonPrefix, current.text.length - commonSuffix);\n      return new CompositionOutcome(deletedText, original.startSelection - commonPrefix, original.endSelection - commonPrefix, insertedText, current.startSelection - commonPrefix, current.endSelection - commonPrefix);\n    }\n  }]);\n}();","map":{"version":3,"names":["onUnexpectedError","strings","CursorCollection","CursorState","EditOperationResult","CursorContext","DeleteOperations","CompositionOutcome","TypeOperations","TypeWithAutoClosingCommand","Range","Selection","ModelInjectedTextChangedEvent","ViewCursorStateChangedEvent","ViewRevealRangeRequestEvent","dispose","Disposable","CursorStateChangedEvent","CursorsController","_Disposable","model","viewModel","coordinatesConverter","cursorConfig","_this","_classCallCheck","_callSuper","_model","_knownModelVersionId","getVersionId","_viewModel","_coordinatesConverter","context","_cursors","_hasFocus","_isHandling","_compositionState","_columnSelectData","_autoClosedActions","_prevEditOperationType","_inherits","_createClass","key","value","_get","_getPrototypeOf","prototype","call","updateConfiguration","updateContext","onLineMappingChanged","eventsCollector","setStates","getCursorStates","setHasFocus","hasFocus","_validateAutoClosedActions","length","selections","getSelections","i","autoClosedAction","isValid","splice","getPrimaryCursorState","getPrimaryCursor","getLastAddedCursorIndex","getAll","source","reason","states","reachedMaxCursorCount","multiCursorLimit","slice","oldState","CursorModelState","from","normalize","_emitStateChangedIfNecessary","setCursorColumnSelectData","columnSelectData","revealAll","minimalReveal","verticalType","revealHorizontal","scrollType","viewPositions","getViewPositions","revealViewRange","revealViewSelections","getViewSelections","fromPositions","emitViewEvent","revealPrimary","primaryCursor","viewState","selection","saveState","result","len","push","inSelectionMode","isEmpty","selectionStart","lineNumber","selectionStartLineNumber","column","selectionStartColumn","position","positionLineNumber","positionColumn","restoreState","desiredSelections","state","fromModelSelections","onModelContentChanged","event","e","rawContentChangedEvent","versionId","hadFlushEvent","containsEvent","resultingSelection","cursorState","isUndoing","isRedoing","selectionsFromMarkers","readSelectionFromMarkers","getSelection","modelState","getTopMostViewPosition","getBottomMostViewPosition","getCursorColumnSelectData","viewSelectionStart","getStartPosition","viewPosition","isReal","fromViewLineNumber","fromViewVisualColumn","visibleColumnFromColumn","toViewLineNumber","toViewVisualColumn","setSelections","getPrevEditOperationType","setPrevEditOperationType","type","_pushAutoClosedAction","autoClosedCharactersRanges","autoClosedEnclosingRanges","autoClosedCharactersDeltaDecorations","autoClosedEnclosingDeltaDecorations","range","options","description","inlineClassName","stickiness","autoClosedCharactersDecorations","deltaDecorations","autoClosedEnclosingDecorations","AutoClosedAction","_executeEditOperation","opResult","shouldPushStackElementBefore","pushStackElement","CommandExecutor","executeCommands","commands","_interpretCommandResult","command","enclosingRange","closeCharacterRange","shouldPushStackElementAfter","newState","equals","viewSelections","some","newCursorState","oldSelections","map","s","oldModelVersionId","modelVersionId","emitOutgoingEvent","_findAutoClosingPairs","edits","indices","edit","text","indexOf","m","match","closeChar","autoClosingPairsCandidates","autoClosingPairs","autoClosingPairsCloseSingleChar","get","openChar","open","closeCharIndex","openCharIndex","lastIndexOf","executeEdits","cursorStateComputer","_this2","autoClosingIndices","_isTracked","pushEditOperations","undoEdits","_autoClosingIndices$i","_slicedToArray","openCharInnerIndex","closeCharInnerIndex","undoEdit","startLineNumber","startColumn","_executeEdit","callback","cursorChangeReason","arguments","undefined","readOnly","stopTrackingSelections","ensureValidState","err","startTrackingSelections","getAutoClosedCharacters","getAllAutoClosedCharacters","startComposition","CompositionState","endComposition","_this3","compositionOutcome","deduceOutcome","compositionEndWithInterceptors","_this4","offset","charLength","nextCharLength","chr","substr","typeWithInterceptors","typeWithoutInterceptors","compositionType","replacePrevCharCnt","replaceNextCharCnt","positionDelta","_this5","newSelections","getPosition","paste","pasteOnNewLine","multicursorText","_this6","cut","_this7","executeCommand","_this8","killSecondaryCursors","_this9","other","cursor","_autoClosedCharactersDecorations","_autoClosedEnclosingDecorations","getAutoClosedCharactersRanges","decorationRange","getDecorationRange","enclosingRanges","endLineNumber","sort","compareRangesUsingStarts","strictContainsRange","autoClosedActions","autoClosedCharacters","_iterator","_createForOfIteratorHelper","_step","n","done","concat","f","selectionsBefore","ctx","trackedRanges","trackedRangesDirection","_innerExecuteCommands","_setTrackedRange","_arrayIsEmpty","commandsData","_getEditOperations","operations","rawOperations","loserCursorsMap","_getLoserCursorMap","hasOwnProperty","console","warn","filteredOperations","identifier","major","toString","hadTrackedEditOperation","selectionsAfter","inverseEditOperations","groupedInverseEditOperations","_iterator2","_step2","op","minorBasedSorter","a","b","minor","cursorSelections","_loop","_i3","computeCursorState","getInverseEditOperations","getTrackedSelection","id","idx","parseInt","_getTrackedRange","endColumn","losingCursors","losingCursorIndex","_i4","_losingCursors","losingCursor","r","_getEditOperationsFromCommand","majorIdentifier","operationMinor","addEditOperation","forceMoveMarkers","isAutoWhitespaceEdit","insertsAutoWhitespace","addTrackedEditOperation","trackSelection","_selection","trackPreviousOnEmpty","liftSelection","maxLineColumn","getLineMaxColumn","l","getDirection","editOperationBuilder","getEditOperations","compareRangesUsingEnds","previousOp","currentOp","isBefore","getEndPosition","loserMajor","j","CompositionLineState","startSelection","endSelection","textModel","_original","_capture","current","_deduceOutcome","_iterator3","_step3","getLineContent","original","commonPrefix","Math","min","commonPrefixLength","commonSuffix","commonSuffixLength","deletedText","substring","insertedText"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursor.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorState, EditOperationResult } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { CompositionOutcome, TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModelEventDispatcher.js';\nexport class CursorsController extends Disposable {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        super();\n        this._model = model;\n        this._knownModelVersionId = this._model.getVersionId();\n        this._viewModel = viewModel;\n        this._coordinatesConverter = coordinatesConverter;\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors = new CursorCollection(this.context);\n        this._hasFocus = false;\n        this._isHandling = false;\n        this._compositionState = null;\n        this._columnSelectData = null;\n        this._autoClosedActions = [];\n        this._prevEditOperationType = 0 /* EditOperationType.Other */;\n    }\n    dispose() {\n        this._cursors.dispose();\n        this._autoClosedActions = dispose(this._autoClosedActions);\n        super.dispose();\n    }\n    updateConfiguration(cursorConfig) {\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors.updateContext(this.context);\n    }\n    onLineMappingChanged(eventsCollector) {\n        if (this._knownModelVersionId !== this._model.getVersionId()) {\n            // There are model change events that I didn't yet receive.\n            //\n            // This can happen when editing the model, and the view model receives the change events first,\n            // and the view model emits line mapping changed events, all before the cursor gets a chance to\n            // recover from markers.\n            //\n            // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n            return;\n        }\n        // Ensure valid state\n        this.setStates(eventsCollector, 'viewModel', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n    }\n    _validateAutoClosedActions() {\n        if (this._autoClosedActions.length > 0) {\n            const selections = this._cursors.getSelections();\n            for (let i = 0; i < this._autoClosedActions.length; i++) {\n                const autoClosedAction = this._autoClosedActions[i];\n                if (!autoClosedAction.isValid(selections)) {\n                    autoClosedAction.dispose();\n                    this._autoClosedActions.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    }\n    // ------ some getters/setters\n    getPrimaryCursorState() {\n        return this._cursors.getPrimaryCursor();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursors.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursors.getAll();\n    }\n    setStates(eventsCollector, source, reason, states) {\n        let reachedMaxCursorCount = false;\n        const multiCursorLimit = this.context.cursorConfig.multiCursorLimit;\n        if (states !== null && states.length > multiCursorLimit) {\n            states = states.slice(0, multiCursorLimit);\n            reachedMaxCursorCount = true;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.setStates(states);\n        this._cursors.normalize();\n        this._columnSelectData = null;\n        this._validateAutoClosedActions();\n        return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._columnSelectData = columnSelectData;\n    }\n    revealAll(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const viewPositions = this._cursors.getViewPositions();\n        let revealViewRange = null;\n        let revealViewSelections = null;\n        if (viewPositions.length > 1) {\n            revealViewSelections = this._cursors.getViewSelections();\n        }\n        else {\n            revealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n        }\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    revealPrimary(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const revealViewSelections = [primaryCursor.viewState.selection];\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, null, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    saveState() {\n        const result = [];\n        const selections = this._cursors.getSelections();\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            result.push({\n                inSelectionMode: !selection.isEmpty(),\n                selectionStart: {\n                    lineNumber: selection.selectionStartLineNumber,\n                    column: selection.selectionStartColumn,\n                },\n                position: {\n                    lineNumber: selection.positionLineNumber,\n                    column: selection.positionColumn,\n                }\n            });\n        }\n        return result;\n    }\n    restoreState(eventsCollector, states) {\n        const desiredSelections = [];\n        for (let i = 0, len = states.length; i < len; i++) {\n            const state = states[i];\n            let positionLineNumber = 1;\n            let positionColumn = 1;\n            // Avoid missing properties on the literal\n            if (state.position && state.position.lineNumber) {\n                positionLineNumber = state.position.lineNumber;\n            }\n            if (state.position && state.position.column) {\n                positionColumn = state.position.column;\n            }\n            let selectionStartLineNumber = positionLineNumber;\n            let selectionStartColumn = positionColumn;\n            // Avoid missing properties on the literal\n            if (state.selectionStart && state.selectionStart.lineNumber) {\n                selectionStartLineNumber = state.selectionStart.lineNumber;\n            }\n            if (state.selectionStart && state.selectionStart.column) {\n                selectionStartColumn = state.selectionStart.column;\n            }\n            desiredSelections.push({\n                selectionStartLineNumber: selectionStartLineNumber,\n                selectionStartColumn: selectionStartColumn,\n                positionLineNumber: positionLineNumber,\n                positionColumn: positionColumn\n            });\n        }\n        this.setStates(eventsCollector, 'restoreState', 0 /* CursorChangeReason.NotSet */, CursorState.fromModelSelections(desiredSelections));\n        this.revealAll(eventsCollector, 'restoreState', false, 0 /* VerticalRevealType.Simple */, true, 1 /* editorCommon.ScrollType.Immediate */);\n    }\n    onModelContentChanged(eventsCollector, event) {\n        if (event instanceof ModelInjectedTextChangedEvent) {\n            // If injected texts change, the view positions of all cursors need to be updated.\n            if (this._isHandling) {\n                // The view positions will be updated when handling finishes\n                return;\n            }\n            // setStates might remove markers, which could trigger a decoration change.\n            // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n            // and an endless recursion happens.\n            // _isHandling prevents that.\n            this._isHandling = true;\n            try {\n                this.setStates(eventsCollector, 'modelChange', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n            }\n            finally {\n                this._isHandling = false;\n            }\n        }\n        else {\n            const e = event.rawContentChangedEvent;\n            this._knownModelVersionId = e.versionId;\n            if (this._isHandling) {\n                return;\n            }\n            const hadFlushEvent = e.containsEvent(1 /* RawContentChangedType.Flush */);\n            this._prevEditOperationType = 0 /* EditOperationType.Other */;\n            if (hadFlushEvent) {\n                // a model.setValue() was called\n                this._cursors.dispose();\n                this._cursors = new CursorCollection(this.context);\n                this._validateAutoClosedActions();\n                this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* CursorChangeReason.ContentFlush */, null, false);\n            }\n            else {\n                if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n                    const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n                    if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* CursorChangeReason.Undo */ : e.isRedoing ? 6 /* CursorChangeReason.Redo */ : 2 /* CursorChangeReason.RecoverFromMarkers */, cursorState)) {\n                        this.revealAll(eventsCollector, 'modelChange', false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n                    }\n                }\n                else {\n                    const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n                    this.setStates(eventsCollector, 'modelChange', 2 /* CursorChangeReason.RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n                }\n            }\n        }\n    }\n    getSelection() {\n        return this._cursors.getPrimaryCursor().modelState.selection;\n    }\n    getTopMostViewPosition() {\n        return this._cursors.getTopMostViewPosition();\n    }\n    getBottomMostViewPosition() {\n        return this._cursors.getBottomMostViewPosition();\n    }\n    getCursorColumnSelectData() {\n        if (this._columnSelectData) {\n            return this._columnSelectData;\n        }\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n        const viewPosition = primaryCursor.viewState.position;\n        return {\n            isReal: false,\n            fromViewLineNumber: viewSelectionStart.lineNumber,\n            fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n            toViewLineNumber: viewPosition.lineNumber,\n            toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition),\n        };\n    }\n    getSelections() {\n        return this._cursors.getSelections();\n    }\n    setSelections(eventsCollector, source, selections, reason) {\n        this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n    }\n    getPrevEditOperationType() {\n        return this._prevEditOperationType;\n    }\n    setPrevEditOperationType(type) {\n        this._prevEditOperationType = type;\n    }\n    // ------ auxiliary handling logic\n    _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n        const autoClosedCharactersDeltaDecorations = [];\n        const autoClosedEnclosingDeltaDecorations = [];\n        for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n            autoClosedCharactersDeltaDecorations.push({\n                range: autoClosedCharactersRanges[i],\n                options: {\n                    description: 'auto-closed-character',\n                    inlineClassName: 'auto-closed-character',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n            autoClosedEnclosingDeltaDecorations.push({\n                range: autoClosedEnclosingRanges[i],\n                options: {\n                    description: 'auto-closed-enclosing',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n        }\n        const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n        const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n        this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n    }\n    _executeEditOperation(opResult) {\n        if (!opResult) {\n            // Nothing to execute\n            return;\n        }\n        if (opResult.shouldPushStackElementBefore) {\n            this._model.pushStackElement();\n        }\n        const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n        if (result) {\n            // The commands were applied correctly\n            this._interpretCommandResult(result);\n            // Check for auto-closing closed characters\n            const autoClosedCharactersRanges = [];\n            const autoClosedEnclosingRanges = [];\n            for (let i = 0; i < opResult.commands.length; i++) {\n                const command = opResult.commands[i];\n                if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n                    autoClosedCharactersRanges.push(command.closeCharacterRange);\n                    autoClosedEnclosingRanges.push(command.enclosingRange);\n                }\n            }\n            if (autoClosedCharactersRanges.length > 0) {\n                this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n            }\n            this._prevEditOperationType = opResult.type;\n        }\n        if (opResult.shouldPushStackElementAfter) {\n            this._model.pushStackElement();\n        }\n    }\n    _interpretCommandResult(cursorState) {\n        if (!cursorState || cursorState.length === 0) {\n            cursorState = this._cursors.readSelectionFromMarkers();\n        }\n        this._columnSelectData = null;\n        this._cursors.setSelections(cursorState);\n        this._cursors.normalize();\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- emitting events\n    _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n        const newState = CursorModelState.from(this._model, this);\n        if (newState.equals(oldState)) {\n            return false;\n        }\n        const selections = this._cursors.getSelections();\n        const viewSelections = this._cursors.getViewSelections();\n        // Let the view get the event first.\n        eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections, reason));\n        // Only after the view has been notified, let the rest of the world know...\n        if (!oldState\n            || oldState.cursorState.length !== newState.cursorState.length\n            || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n            const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n            const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n            eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n        }\n        return true;\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- handlers beyond this point\n    _findAutoClosingPairs(edits) {\n        if (!edits.length) {\n            return null;\n        }\n        const indices = [];\n        for (let i = 0, len = edits.length; i < len; i++) {\n            const edit = edits[i];\n            if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n                return null;\n            }\n            const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n            if (!m) {\n                return null;\n            }\n            const closeChar = m[1];\n            const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n            if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n                return null;\n            }\n            const openChar = autoClosingPairsCandidates[0].open;\n            const closeCharIndex = edit.text.length - m[2].length - 1;\n            const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n            if (openCharIndex === -1) {\n                return null;\n            }\n            indices.push([openCharIndex, closeCharIndex]);\n        }\n        return indices;\n    }\n    executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n        let autoClosingIndices = null;\n        if (source === 'snippet') {\n            autoClosingIndices = this._findAutoClosingPairs(edits);\n        }\n        if (autoClosingIndices) {\n            edits[0]._isTracked = true;\n        }\n        const autoClosedCharactersRanges = [];\n        const autoClosedEnclosingRanges = [];\n        const selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\n            if (autoClosingIndices) {\n                for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n                    const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n                    const undoEdit = undoEdits[i];\n                    const lineNumber = undoEdit.range.startLineNumber;\n                    const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n                    const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n                    autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n                    autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n                }\n            }\n            const selections = cursorStateComputer(undoEdits);\n            if (selections) {\n                // Don't recover the selection from markers because\n                // we know what it should be.\n                this._isHandling = true;\n            }\n            return selections;\n        });\n        if (selections) {\n            this._isHandling = false;\n            this.setSelections(eventsCollector, source, selections, 0 /* CursorChangeReason.NotSet */);\n        }\n        if (autoClosedCharactersRanges.length > 0) {\n            this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n        }\n    }\n    _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0 /* CursorChangeReason.NotSet */) {\n        if (this.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            return;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.stopTrackingSelections();\n        this._isHandling = true;\n        try {\n            this._cursors.ensureValidState();\n            callback();\n        }\n        catch (err) {\n            onUnexpectedError(err);\n        }\n        this._isHandling = false;\n        this._cursors.startTrackingSelections();\n        this._validateAutoClosedActions();\n        if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n            this.revealAll(eventsCollector, source, false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n        }\n    }\n    getAutoClosedCharacters() {\n        return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n    }\n    startComposition(eventsCollector) {\n        this._compositionState = new CompositionState(this._model, this.getSelections());\n    }\n    endComposition(eventsCollector, source) {\n        const compositionOutcome = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;\n        this._compositionState = null;\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // composition finishes, let's check if we need to auto complete if necessary.\n                this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, compositionOutcome, this.getSelections(), this.getAutoClosedCharacters()));\n            }\n        }, eventsCollector, source);\n    }\n    type(eventsCollector, text, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // If this event is coming straight from the keyboard, look for electric characters and enter\n                const len = text.length;\n                let offset = 0;\n                while (offset < len) {\n                    const charLength = strings.nextCharLength(text, offset);\n                    const chr = text.substr(offset, charLength);\n                    // Here we must interpret each typed character individually\n                    this._executeEditOperation(TypeOperations.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n                    offset += charLength;\n                }\n            }\n            else {\n                this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n            }\n        }, eventsCollector, source);\n    }\n    compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n            // this edit is a no-op\n            if (positionDelta !== 0) {\n                // but it still wants to move the cursor\n                const newSelections = this.getSelections().map(selection => {\n                    const position = selection.getPosition();\n                    return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n                });\n                this.setSelections(eventsCollector, source, newSelections, 0 /* CursorChangeReason.NotSet */);\n            }\n            return;\n        }\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        }, eventsCollector, source);\n    }\n    paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n        }, eventsCollector, source, 4 /* CursorChangeReason.Paste */);\n    }\n    cut(eventsCollector, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n        }, eventsCollector, source);\n    }\n    executeCommand(eventsCollector, command, source) {\n        this._executeEdit(() => {\n            this._cursors.killSecondaryCursors();\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, [command], {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n    executeCommands(eventsCollector, commands, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n}\n/**\n * A snapshot of the cursor and the model state\n */\nclass CursorModelState {\n    static from(model, cursor) {\n        return new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n    }\n    constructor(modelVersionId, cursorState) {\n        this.modelVersionId = modelVersionId;\n        this.cursorState = cursorState;\n    }\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        if (this.modelVersionId !== other.modelVersionId) {\n            return false;\n        }\n        if (this.cursorState.length !== other.cursorState.length) {\n            return false;\n        }\n        for (let i = 0, len = this.cursorState.length; i < len; i++) {\n            if (!this.cursorState[i].equals(other.cursorState[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass AutoClosedAction {\n    static getAllAutoClosedCharacters(autoClosedActions) {\n        let autoClosedCharacters = [];\n        for (const autoClosedAction of autoClosedActions) {\n            autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n        }\n        return autoClosedCharacters;\n    }\n    constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n        this._model = model;\n        this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n        this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n    }\n    dispose() {\n        this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n        this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n    }\n    getAutoClosedCharactersRanges() {\n        const result = [];\n        for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n            if (decorationRange) {\n                result.push(decorationRange);\n            }\n        }\n        return result;\n    }\n    isValid(selections) {\n        const enclosingRanges = [];\n        for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n            if (decorationRange) {\n                enclosingRanges.push(decorationRange);\n                if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n                    // Stop tracking if the range becomes multiline...\n                    return false;\n                }\n            }\n        }\n        enclosingRanges.sort(Range.compareRangesUsingStarts);\n        selections.sort(Range.compareRangesUsingStarts);\n        for (let i = 0; i < selections.length; i++) {\n            if (i >= enclosingRanges.length) {\n                return false;\n            }\n            if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass CommandExecutor {\n    static executeCommands(model, selectionsBefore, commands) {\n        const ctx = {\n            model: model,\n            selectionsBefore: selectionsBefore,\n            trackedRanges: [],\n            trackedRangesDirection: []\n        };\n        const result = this._innerExecuteCommands(ctx, commands);\n        for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n        }\n        return result;\n    }\n    static _innerExecuteCommands(ctx, commands) {\n        if (this._arrayIsEmpty(commands)) {\n            return null;\n        }\n        const commandsData = this._getEditOperations(ctx, commands);\n        if (commandsData.operations.length === 0) {\n            return null;\n        }\n        const rawOperations = commandsData.operations;\n        const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n        if (loserCursorsMap.hasOwnProperty('0')) {\n            // These commands are very messed up\n            console.warn('Ignoring commands');\n            return null;\n        }\n        // Remove operations belonging to losing cursors\n        const filteredOperations = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n                filteredOperations.push(rawOperations[i]);\n            }\n        }\n        // TODO@Alex: find a better way to do this.\n        // give the hint that edit operations are tracked to the model\n        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n            filteredOperations[0]._isTracked = true;\n        }\n        let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {\n            const groupedInverseEditOperations = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                groupedInverseEditOperations[i] = [];\n            }\n            for (const op of inverseEditOperations) {\n                if (!op.identifier) {\n                    // perhaps auto whitespace trim edits\n                    continue;\n                }\n                groupedInverseEditOperations[op.identifier.major].push(op);\n            }\n            const minorBasedSorter = (a, b) => {\n                return a.identifier.minor - b.identifier.minor;\n            };\n            const cursorSelections = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                if (groupedInverseEditOperations[i].length > 0) {\n                    groupedInverseEditOperations[i].sort(minorBasedSorter);\n                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n                        getInverseEditOperations: () => {\n                            return groupedInverseEditOperations[i];\n                        },\n                        getTrackedSelection: (id) => {\n                            const idx = parseInt(id, 10);\n                            const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n                            if (ctx.trackedRangesDirection[idx] === 0 /* SelectionDirection.LTR */) {\n                                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                            }\n                            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n                        }\n                    });\n                }\n                else {\n                    cursorSelections[i] = ctx.selectionsBefore[i];\n                }\n            }\n            return cursorSelections;\n        });\n        if (!selectionsAfter) {\n            selectionsAfter = ctx.selectionsBefore;\n        }\n        // Extract losing cursors\n        const losingCursors = [];\n        for (const losingCursorIndex in loserCursorsMap) {\n            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n                losingCursors.push(parseInt(losingCursorIndex, 10));\n            }\n        }\n        // Sort losing cursors descending\n        losingCursors.sort((a, b) => {\n            return b - a;\n        });\n        // Remove losing cursors\n        for (const losingCursor of losingCursors) {\n            selectionsAfter.splice(losingCursor, 1);\n        }\n        return selectionsAfter;\n    }\n    static _arrayIsEmpty(commands) {\n        for (let i = 0, len = commands.length; i < len; i++) {\n            if (commands[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _getEditOperations(ctx, commands) {\n        let operations = [];\n        let hadTrackedEditOperation = false;\n        for (let i = 0, len = commands.length; i < len; i++) {\n            const command = commands[i];\n            if (command) {\n                const r = this._getEditOperationsFromCommand(ctx, i, command);\n                operations = operations.concat(r.operations);\n                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n            }\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n        // This method acts as a transaction, if the command fails\n        // everything it has done is ignored\n        const operations = [];\n        let operationMinor = 0;\n        const addEditOperation = (range, text, forceMoveMarkers = false) => {\n            if (Range.isEmpty(range) && text === '') {\n                // This command wants to add a no-op => no thank you\n                return;\n            }\n            operations.push({\n                identifier: {\n                    major: majorIdentifier,\n                    minor: operationMinor++\n                },\n                range: range,\n                text: text,\n                forceMoveMarkers: forceMoveMarkers,\n                isAutoWhitespaceEdit: command.insertsAutoWhitespace\n            });\n        };\n        let hadTrackedEditOperation = false;\n        const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n            hadTrackedEditOperation = true;\n            addEditOperation(selection, text, forceMoveMarkers);\n        };\n        const trackSelection = (_selection, trackPreviousOnEmpty) => {\n            const selection = Selection.liftSelection(_selection);\n            let stickiness;\n            if (selection.isEmpty()) {\n                if (typeof trackPreviousOnEmpty === 'boolean') {\n                    if (trackPreviousOnEmpty) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n                else {\n                    // Try to lock it with surrounding text\n                    const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn === maxLineColumn) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n            }\n            else {\n                stickiness = 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */;\n            }\n            const l = ctx.trackedRanges.length;\n            const id = ctx.model._setTrackedRange(null, selection, stickiness);\n            ctx.trackedRanges[l] = id;\n            ctx.trackedRangesDirection[l] = selection.getDirection();\n            return l.toString();\n        };\n        const editOperationBuilder = {\n            addEditOperation: addEditOperation,\n            addTrackedEditOperation: addTrackedEditOperation,\n            trackSelection: trackSelection\n        };\n        try {\n            command.getEditOperations(ctx.model, editOperationBuilder);\n        }\n        catch (e) {\n            // TODO@Alex use notification service if this should be user facing\n            // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n            onUnexpectedError(e);\n            return {\n                operations: [],\n                hadTrackedEditOperation: false\n            };\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getLoserCursorMap(operations) {\n        // This is destructive on the array\n        operations = operations.slice(0);\n        // Sort operations with last one first\n        operations.sort((a, b) => {\n            // Note the minus!\n            return -(Range.compareRangesUsingEnds(a.range, b.range));\n        });\n        // Operations can not overlap!\n        const loserCursorsMap = {};\n        for (let i = 1; i < operations.length; i++) {\n            const previousOp = operations[i - 1];\n            const currentOp = operations[i];\n            if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n                let loserMajor;\n                if (previousOp.identifier.major > currentOp.identifier.major) {\n                    // previousOp loses the battle\n                    loserMajor = previousOp.identifier.major;\n                }\n                else {\n                    loserMajor = currentOp.identifier.major;\n                }\n                loserCursorsMap[loserMajor.toString()] = true;\n                for (let j = 0; j < operations.length; j++) {\n                    if (operations[j].identifier.major === loserMajor) {\n                        operations.splice(j, 1);\n                        if (j < i) {\n                            i--;\n                        }\n                        j--;\n                    }\n                }\n                if (i > 0) {\n                    i--;\n                }\n            }\n        }\n        return loserCursorsMap;\n    }\n}\nclass CompositionLineState {\n    constructor(text, startSelection, endSelection) {\n        this.text = text;\n        this.startSelection = startSelection;\n        this.endSelection = endSelection;\n    }\n}\nclass CompositionState {\n    static _capture(textModel, selections) {\n        const result = [];\n        for (const selection of selections) {\n            if (selection.startLineNumber !== selection.endLineNumber) {\n                return null;\n            }\n            result.push(new CompositionLineState(textModel.getLineContent(selection.startLineNumber), selection.startColumn - 1, selection.endColumn - 1));\n        }\n        return result;\n    }\n    constructor(textModel, selections) {\n        this._original = CompositionState._capture(textModel, selections);\n    }\n    /**\n     * Returns the inserted text during this composition.\n     * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.\n     */\n    deduceOutcome(textModel, selections) {\n        if (!this._original) {\n            return null;\n        }\n        const current = CompositionState._capture(textModel, selections);\n        if (!current) {\n            return null;\n        }\n        if (this._original.length !== current.length) {\n            return null;\n        }\n        const result = [];\n        for (let i = 0, len = this._original.length; i < len; i++) {\n            result.push(CompositionState._deduceOutcome(this._original[i], current[i]));\n        }\n        return result;\n    }\n    static _deduceOutcome(original, current) {\n        const commonPrefix = Math.min(original.startSelection, current.startSelection, strings.commonPrefixLength(original.text, current.text));\n        const commonSuffix = Math.min(original.text.length - original.endSelection, current.text.length - current.endSelection, strings.commonSuffixLength(original.text, current.text));\n        const deletedText = original.text.substring(commonPrefix, original.text.length - commonSuffix);\n        const insertedText = current.text.substring(commonPrefix, current.text.length - commonSuffix);\n        return new CompositionOutcome(deletedText, original.startSelection - commonPrefix, original.endSelection - commonPrefix, insertedText, current.startSelection - commonPrefix, current.endSelection - commonPrefix);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}