{"ast":null,"code":"import _toConsumableArray from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _typeof from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.flags.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.string.includes.js\";\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {Content | Root} Node\n *\n * @typedef {Properties[string]} PropertyValue\n *   Possible property values.\n * @typedef {string | number | boolean} PrimitivePropertyValue\n *   Possible primitive HTML attribute values.\n *\n * @typedef {Record<string, Array<string | [string, ...Array<PrimitivePropertyValue | RegExp>]>>} Attributes\n *  Map of tag names to allow lists for each property.\n * @typedef {Record<string, Array<PrimitivePropertyValue | RegExp>>} AttributeClean\n *   Normalized input.\n *\n * @typedef Schema\n *   Sanitization configuration.\n * @property {Attributes | undefined} [attributes]\n *   Map of tag names to allowed properties.\n *\n *   The special `'*'` key defines property names allowed on all elements.\n * @property {Record<string, Record<string, PropertyValue>> | undefined} [required]\n *   Map of tag names to required property names and their default property value.\n * @property {Array<string> | undefined} [tagNames]\n *   List of allowed tag names.\n * @property {Record<string, Array<string>> | undefined} [protocols]\n *   Map of protocols to allow in property values.\n * @property {Record<string, Array<string>> | undefined} [ancestors]\n *   Map of tag names to their required ancestor elements.\n * @property {Array<string> | undefined} [clobber]\n *   List of allowed property names which can clobber.\n * @property {string | undefined} [clobberPrefix]\n *   Prefix to use before potentially clobbering property names.\n * @property {Array<string> | undefined} [strip]\n *   Names of elements to strip from the tree.\n * @property {boolean | undefined} [allowComments]\n *   Whether to allow comments.\n * @property {boolean | undefined} [allowDoctypes]\n *   Whether to allow doctypes.\n *\n * @typedef {(schema: Schema, value: any, node: any, stack: Array<string>) => unknown} Handler\n * @typedef {Record<string, Handler>} NodeDefinition\n * @typedef {((schema: Schema, node: Node) => NodeDefinition | undefined)} NodeDefinitionGetter\n * @typedef {Record<string, NodeDefinition | NodeDefinitionGetter>} NodeSchema\n */\n\nimport { defaultSchema } from './schema.js';\nvar own = {}.hasOwnProperty;\n\n/** @type {NodeSchema} */\nvar nodeSchema = {\n  root: {\n    children: all\n  },\n  doctype: handleDoctype,\n  comment: handleComment,\n  element: {\n    tagName: handleTagName,\n    properties: handleProperties,\n    children: all\n  },\n  text: {\n    value: handleValue\n  },\n  '*': {\n    data: allow,\n    position: allow\n  }\n};\n\n/**\n * Utility to sanitize a tree\n *\n * @param {Node} node\n *   Hast tree to sanitize\n * @param {Schema} [schema]\n *   Schema defining how to sanitize - defaults to Github style sanitation\n */\nexport function sanitize(node, schema) {\n  /** @type {Node} */\n  var ctx = {\n    type: 'root',\n    children: []\n  };\n  if (node && _typeof(node) === 'object' && node.type) {\n    var replace = one(Object.assign({}, defaultSchema, schema || {}), node, []);\n    if (replace) {\n      if (Array.isArray(replace)) {\n        if (replace.length === 1) {\n          ctx = replace[0];\n        } else {\n          // @ts-expect-error Assume `root` is not a child.\n          ctx.children = replace;\n        }\n      } else {\n        ctx = replace;\n      }\n    }\n  }\n  return ctx;\n}\n\n/**\n * Sanitize `node`.\n *\n * @param {Schema} schema\n * @param {Node} node\n * @param {Array<string>} stack\n * @returns {Node | Array<Node> | undefined}\n */\nfunction one(schema, node, stack) {\n  var type = node && node.type;\n  /** @type {Node} */\n  // @ts-expect-error rest of props added later.\n  var replacement = {\n    type: node.type\n  };\n  /** @type {boolean | undefined} */\n  var replace;\n  if (own.call(nodeSchema, type)) {\n    /** @type {NodeDefinition | NodeDefinitionGetter | undefined} */\n    var definition = nodeSchema[type];\n    if (typeof definition === 'function') {\n      definition = definition(schema, node);\n    }\n    if (definition) {\n      var allowed = Object.assign({}, definition, nodeSchema['*']);\n      /** @type {string} */\n      var key;\n      replace = true;\n      for (key in allowed) {\n        if (own.call(allowed, key)) {\n          // @ts-expect-error: fine.\n          // type-coverage:ignore-next-line\n          var result = allowed[key](schema, node[key], node, stack);\n\n          // eslint-disable-next-line max-depth\n          if (result === false) {\n            replace = undefined;\n            // Set the non-safe value.\n            // @ts-expect-error: fine.\n            // type-coverage:ignore-next-line\n            replacement[key] = node[key];\n          } else if (result !== undefined && result !== null) {\n            // @ts-expect-error: fine.\n            // type-coverage:ignore-next-line\n            replacement[key] = result;\n          }\n        }\n      }\n    }\n  }\n  if (replace) {\n    return replacement;\n  }\n  return replacement.type === 'element' && schema.strip && !schema.strip.includes(replacement.tagName) ? replacement.children : undefined;\n}\n\n/**\n * Sanitize `children`.\n *\n * @type {Handler}\n * @param {Array<Node>} children\n * @param {Node} node\n * @returns {Array<Node>}\n */\nfunction all(schema, children, node, stack) {\n  /** @type {Array<Node>} */\n  var results = [];\n  if (Array.isArray(children)) {\n    var index = -1;\n    if (node.type === 'element') {\n      stack.push(node.tagName);\n    }\n    while (++index < children.length) {\n      var value = one(schema, children[index], stack);\n      if (value) {\n        if (Array.isArray(value)) {\n          results.push.apply(results, _toConsumableArray(value));\n        } else {\n          results.push(value);\n        }\n      }\n    }\n    if (node.type === 'element') {\n      stack.pop();\n    }\n  }\n  return results;\n}\n\n/** @type {NodeDefinitionGetter} */\nfunction handleDoctype(schema) {\n  return schema.allowDoctypes ? {\n    name: handleDoctypeName\n  } : undefined;\n}\n\n/** @type {NodeDefinitionGetter} */\nfunction handleComment(schema) {\n  return schema.allowComments ? {\n    value: handleCommentValue\n  } : undefined;\n}\n\n/**\n * Sanitize `properties`.\n *\n * @type {Handler}\n * @param {Properties} properties\n * @param {Element} node\n * @returns {Properties}\n */\nfunction handleProperties(schema, properties, node, stack) {\n  var name = handleTagName(schema, node.tagName, node, stack);\n  /* c8 ignore next */\n  var attrs = schema.attributes || {};\n  /* c8 ignore next */\n  var reqs = schema.required || {};\n  var props = properties || {};\n  var allowed = Object.assign({}, toPropertyValueMap(attrs['*']), toPropertyValueMap(name && own.call(attrs, name) ? attrs[name] : []));\n  /** @type {Properties} */\n  var result = {};\n  /** @type {string} */\n  var key;\n  for (key in props) {\n    if (own.call(props, key)) {\n      var value = props[key];\n      /** @type {AttributeClean[string]} */\n      var definition = void 0;\n      if (own.call(allowed, key)) {\n        definition = allowed[key];\n      } else if (data(key) && own.call(allowed, 'data*')) {\n        definition = allowed['data*'];\n      } else {\n        continue;\n      }\n      value = Array.isArray(value) ? handlePropertyValues(schema, value, key, definition) : handlePropertyValue(schema, value, key, definition);\n      if (value !== undefined && value !== null) {\n        result[key] = value;\n      }\n    }\n  }\n  if (name && own.call(reqs, name)) {\n    for (key in reqs[name]) {\n      if (!own.call(result, key)) {\n        result[key] = reqs[name][key];\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Always return a valid HTML5 doctype.\n *\n * @type {Handler}\n * @returns {string}\n */\nfunction handleDoctypeName() {\n  return 'html';\n}\n\n/**\n * Sanitize `tagName`.\n *\n * @param {Schema} schema\n * @param {string} tagName\n * @param {Node} _\n * @param {Array<string>} stack\n * @returns {string | false}\n */\nfunction handleTagName(schema, tagName, _, stack) {\n  var name = typeof tagName === 'string' ? tagName : '';\n  var index = -1;\n  if (!name || name === '*' || schema.tagNames && !schema.tagNames.includes(name)) {\n    return false;\n  }\n\n  // Some nodes can break out of their context if they donâ€™t have a certain\n  // ancestor.\n  if (schema.ancestors && own.call(schema.ancestors, name)) {\n    while (++index < schema.ancestors[name].length) {\n      if (stack.includes(schema.ancestors[name][index])) {\n        return name;\n      }\n    }\n    return false;\n  }\n  return name;\n}\n\n/**\n * See <https://html.spec.whatwg.org/multipage/parsing.html#serialising-html-fragments>\n *\n * @type {Handler}\n * @param {unknown} value\n * @returns {string}\n */\nfunction handleCommentValue(_, value) {\n  /** @type {string} */\n  var result = typeof value === 'string' ? value : '';\n  var index = result.indexOf('-->');\n  return index < 0 ? result : result.slice(0, index);\n}\n\n/**\n * Sanitize `value`.\n *\n * @type {Handler}\n * @param {unknown} value\n * @returns {string}\n */\nfunction handleValue(_, value) {\n  return typeof value === 'string' ? value : '';\n}\n\n/**\n * Allow `value`.\n *\n * @type {Handler}\n * @param {unknown} value\n */\nfunction allow(_, value) {\n  return value;\n}\n\n/**\n * Sanitize a property value which is a list.\n *\n * @param {Schema} schema\n * @param {Array<unknown>} values\n * @param {string} prop\n * @param {AttributeClean[string]} definition\n * @returns {Array<string | number>}\n */\nfunction handlePropertyValues(schema, values, prop, definition) {\n  var index = -1;\n  /** @type {Array<string | number>} */\n  var result = [];\n  while (++index < values.length) {\n    var value = handlePropertyValue(schema, values[index], prop, definition);\n    if (value !== undefined && value !== null) {\n      // @ts-expect-error Assume no booleans were in arrays.\n      result.push(value);\n    }\n  }\n  return result;\n}\n\n/**\n * Sanitize a property value.\n *\n * @param {Schema} schema\n * @param {unknown} value\n * @param {string} prop\n * @param {AttributeClean[string]} definition\n * @returns {PropertyValue}\n */\nfunction handlePropertyValue(schema, value, prop, definition) {\n  if ((typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string') && safeProtocol(schema, value, prop) && (definition.length === 0 || definition.some(function (allowed) {\n    return allowed && _typeof(allowed) === 'object' && 'flags' in allowed ? allowed.test(String(value)) : allowed === value;\n  }))) {\n    return schema.clobberPrefix && schema.clobber && schema.clobber.includes(prop) ? schema.clobberPrefix + value : value;\n  }\n}\n\n/**\n * Check whether `value` is a safe URL.\n *\n * @param {Schema} schema\n * @param {unknown} value\n * @param {string} prop\n * @returns {boolean}\n */\nfunction safeProtocol(schema, value, prop) {\n  var url = String(value);\n  var colon = url.indexOf(':');\n  var questionMark = url.indexOf('?');\n  var numberSign = url.indexOf('#');\n  var slash = url.indexOf('/');\n  var protocols = schema.protocols && own.call(schema.protocols, prop) ? schema.protocols[prop].concat() : [];\n  var index = -1;\n  if (protocols.length === 0 || colon < 0 ||\n  // If the first colon is after a `?`, `#`, or `/`, itâ€™s not a protocol.\n  slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign) {\n    return true;\n  }\n  while (++index < protocols.length) {\n    if (colon === protocols[index].length && url.slice(0, protocols[index].length) === protocols[index]) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Create a map from a list of props or a list of properties and values.\n *\n * @param {Attributes[string]} values\n * @returns {AttributeClean}\n */\nfunction toPropertyValueMap(values) {\n  /** @type {AttributeClean} */\n  var result = {};\n  var index = -1;\n  while (++index < values.length) {\n    var value = values[index];\n    if (Array.isArray(value)) {\n      result[value[0]] = value.slice(1);\n    } else {\n      result[value] = [];\n    }\n  }\n  return result;\n}\n\n/**\n * Check if `prop` is a data property.\n *\n * @param {string} prop\n * @returns {boolean}\n */\nfunction data(prop) {\n  return prop.length > 4 && prop.slice(0, 4).toLowerCase() === 'data';\n}","map":{"version":3,"names":["defaultSchema","own","hasOwnProperty","nodeSchema","root","children","all","doctype","handleDoctype","comment","handleComment","element","tagName","handleTagName","properties","handleProperties","text","value","handleValue","data","allow","position","sanitize","node","schema","ctx","type","_typeof","replace","one","Object","assign","Array","isArray","length","stack","replacement","call","definition","allowed","key","result","undefined","strip","includes","results","index","push","apply","_toConsumableArray","pop","allowDoctypes","name","handleDoctypeName","allowComments","handleCommentValue","attrs","attributes","reqs","required","props","toPropertyValueMap","handlePropertyValues","handlePropertyValue","_","tagNames","ancestors","indexOf","slice","values","prop","safeProtocol","some","test","String","clobberPrefix","clobber","url","colon","questionMark","numberSign","slash","protocols","concat","toLowerCase"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/hast-util-sanitize/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {Content | Root} Node\n *\n * @typedef {Properties[string]} PropertyValue\n *   Possible property values.\n * @typedef {string | number | boolean} PrimitivePropertyValue\n *   Possible primitive HTML attribute values.\n *\n * @typedef {Record<string, Array<string | [string, ...Array<PrimitivePropertyValue | RegExp>]>>} Attributes\n *  Map of tag names to allow lists for each property.\n * @typedef {Record<string, Array<PrimitivePropertyValue | RegExp>>} AttributeClean\n *   Normalized input.\n *\n * @typedef Schema\n *   Sanitization configuration.\n * @property {Attributes | undefined} [attributes]\n *   Map of tag names to allowed properties.\n *\n *   The special `'*'` key defines property names allowed on all elements.\n * @property {Record<string, Record<string, PropertyValue>> | undefined} [required]\n *   Map of tag names to required property names and their default property value.\n * @property {Array<string> | undefined} [tagNames]\n *   List of allowed tag names.\n * @property {Record<string, Array<string>> | undefined} [protocols]\n *   Map of protocols to allow in property values.\n * @property {Record<string, Array<string>> | undefined} [ancestors]\n *   Map of tag names to their required ancestor elements.\n * @property {Array<string> | undefined} [clobber]\n *   List of allowed property names which can clobber.\n * @property {string | undefined} [clobberPrefix]\n *   Prefix to use before potentially clobbering property names.\n * @property {Array<string> | undefined} [strip]\n *   Names of elements to strip from the tree.\n * @property {boolean | undefined} [allowComments]\n *   Whether to allow comments.\n * @property {boolean | undefined} [allowDoctypes]\n *   Whether to allow doctypes.\n *\n * @typedef {(schema: Schema, value: any, node: any, stack: Array<string>) => unknown} Handler\n * @typedef {Record<string, Handler>} NodeDefinition\n * @typedef {((schema: Schema, node: Node) => NodeDefinition | undefined)} NodeDefinitionGetter\n * @typedef {Record<string, NodeDefinition | NodeDefinitionGetter>} NodeSchema\n */\n\nimport {defaultSchema} from './schema.js'\n\nconst own = {}.hasOwnProperty\n\n/** @type {NodeSchema} */\nconst nodeSchema = {\n  root: {children: all},\n  doctype: handleDoctype,\n  comment: handleComment,\n  element: {\n    tagName: handleTagName,\n    properties: handleProperties,\n    children: all\n  },\n  text: {value: handleValue},\n  '*': {data: allow, position: allow}\n}\n\n/**\n * Utility to sanitize a tree\n *\n * @param {Node} node\n *   Hast tree to sanitize\n * @param {Schema} [schema]\n *   Schema defining how to sanitize - defaults to Github style sanitation\n */\nexport function sanitize(node, schema) {\n  /** @type {Node} */\n  let ctx = {type: 'root', children: []}\n\n  if (node && typeof node === 'object' && node.type) {\n    const replace = one(\n      Object.assign({}, defaultSchema, schema || {}),\n      node,\n      []\n    )\n\n    if (replace) {\n      if (Array.isArray(replace)) {\n        if (replace.length === 1) {\n          ctx = replace[0]\n        } else {\n          // @ts-expect-error Assume `root` is not a child.\n          ctx.children = replace\n        }\n      } else {\n        ctx = replace\n      }\n    }\n  }\n\n  return ctx\n}\n\n/**\n * Sanitize `node`.\n *\n * @param {Schema} schema\n * @param {Node} node\n * @param {Array<string>} stack\n * @returns {Node | Array<Node> | undefined}\n */\nfunction one(schema, node, stack) {\n  const type = node && node.type\n  /** @type {Node} */\n  // @ts-expect-error rest of props added later.\n  const replacement = {type: node.type}\n  /** @type {boolean | undefined} */\n  let replace\n\n  if (own.call(nodeSchema, type)) {\n    /** @type {NodeDefinition | NodeDefinitionGetter | undefined} */\n    let definition = nodeSchema[type]\n\n    if (typeof definition === 'function') {\n      definition = definition(schema, node)\n    }\n\n    if (definition) {\n      const allowed = Object.assign({}, definition, nodeSchema['*'])\n      /** @type {string} */\n      let key\n\n      replace = true\n\n      for (key in allowed) {\n        if (own.call(allowed, key)) {\n          // @ts-expect-error: fine.\n          // type-coverage:ignore-next-line\n          const result = allowed[key](schema, node[key], node, stack)\n\n          // eslint-disable-next-line max-depth\n          if (result === false) {\n            replace = undefined\n            // Set the non-safe value.\n            // @ts-expect-error: fine.\n            // type-coverage:ignore-next-line\n            replacement[key] = node[key]\n          } else if (result !== undefined && result !== null) {\n            // @ts-expect-error: fine.\n            // type-coverage:ignore-next-line\n            replacement[key] = result\n          }\n        }\n      }\n    }\n  }\n\n  if (replace) {\n    return replacement\n  }\n\n  return replacement.type === 'element' &&\n    schema.strip &&\n    !schema.strip.includes(replacement.tagName)\n    ? replacement.children\n    : undefined\n}\n\n/**\n * Sanitize `children`.\n *\n * @type {Handler}\n * @param {Array<Node>} children\n * @param {Node} node\n * @returns {Array<Node>}\n */\nfunction all(schema, children, node, stack) {\n  /** @type {Array<Node>} */\n  const results = []\n\n  if (Array.isArray(children)) {\n    let index = -1\n\n    if (node.type === 'element') {\n      stack.push(node.tagName)\n    }\n\n    while (++index < children.length) {\n      const value = one(schema, children[index], stack)\n\n      if (value) {\n        if (Array.isArray(value)) {\n          results.push(...value)\n        } else {\n          results.push(value)\n        }\n      }\n    }\n\n    if (node.type === 'element') {\n      stack.pop()\n    }\n  }\n\n  return results\n}\n\n/** @type {NodeDefinitionGetter} */\nfunction handleDoctype(schema) {\n  return schema.allowDoctypes ? {name: handleDoctypeName} : undefined\n}\n\n/** @type {NodeDefinitionGetter} */\nfunction handleComment(schema) {\n  return schema.allowComments ? {value: handleCommentValue} : undefined\n}\n\n/**\n * Sanitize `properties`.\n *\n * @type {Handler}\n * @param {Properties} properties\n * @param {Element} node\n * @returns {Properties}\n */\nfunction handleProperties(schema, properties, node, stack) {\n  const name = handleTagName(schema, node.tagName, node, stack)\n  /* c8 ignore next */\n  const attrs = schema.attributes || {}\n  /* c8 ignore next */\n  const reqs = schema.required || {}\n  const props = properties || {}\n  const allowed = Object.assign(\n    {},\n    toPropertyValueMap(attrs['*']),\n    toPropertyValueMap(name && own.call(attrs, name) ? attrs[name] : [])\n  )\n  /** @type {Properties} */\n  const result = {}\n  /** @type {string} */\n  let key\n\n  for (key in props) {\n    if (own.call(props, key)) {\n      let value = props[key]\n      /** @type {AttributeClean[string]} */\n      let definition\n\n      if (own.call(allowed, key)) {\n        definition = allowed[key]\n      } else if (data(key) && own.call(allowed, 'data*')) {\n        definition = allowed['data*']\n      } else {\n        continue\n      }\n\n      value = Array.isArray(value)\n        ? handlePropertyValues(schema, value, key, definition)\n        : handlePropertyValue(schema, value, key, definition)\n\n      if (value !== undefined && value !== null) {\n        result[key] = value\n      }\n    }\n  }\n\n  if (name && own.call(reqs, name)) {\n    for (key in reqs[name]) {\n      if (!own.call(result, key)) {\n        result[key] = reqs[name][key]\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * Always return a valid HTML5 doctype.\n *\n * @type {Handler}\n * @returns {string}\n */\nfunction handleDoctypeName() {\n  return 'html'\n}\n\n/**\n * Sanitize `tagName`.\n *\n * @param {Schema} schema\n * @param {string} tagName\n * @param {Node} _\n * @param {Array<string>} stack\n * @returns {string | false}\n */\nfunction handleTagName(schema, tagName, _, stack) {\n  const name = typeof tagName === 'string' ? tagName : ''\n  let index = -1\n\n  if (\n    !name ||\n    name === '*' ||\n    (schema.tagNames && !schema.tagNames.includes(name))\n  ) {\n    return false\n  }\n\n  // Some nodes can break out of their context if they donâ€™t have a certain\n  // ancestor.\n  if (schema.ancestors && own.call(schema.ancestors, name)) {\n    while (++index < schema.ancestors[name].length) {\n      if (stack.includes(schema.ancestors[name][index])) {\n        return name\n      }\n    }\n\n    return false\n  }\n\n  return name\n}\n\n/**\n * See <https://html.spec.whatwg.org/multipage/parsing.html#serialising-html-fragments>\n *\n * @type {Handler}\n * @param {unknown} value\n * @returns {string}\n */\nfunction handleCommentValue(_, value) {\n  /** @type {string} */\n  const result = typeof value === 'string' ? value : ''\n  const index = result.indexOf('-->')\n  return index < 0 ? result : result.slice(0, index)\n}\n\n/**\n * Sanitize `value`.\n *\n * @type {Handler}\n * @param {unknown} value\n * @returns {string}\n */\nfunction handleValue(_, value) {\n  return typeof value === 'string' ? value : ''\n}\n\n/**\n * Allow `value`.\n *\n * @type {Handler}\n * @param {unknown} value\n */\nfunction allow(_, value) {\n  return value\n}\n\n/**\n * Sanitize a property value which is a list.\n *\n * @param {Schema} schema\n * @param {Array<unknown>} values\n * @param {string} prop\n * @param {AttributeClean[string]} definition\n * @returns {Array<string | number>}\n */\nfunction handlePropertyValues(schema, values, prop, definition) {\n  let index = -1\n  /** @type {Array<string | number>} */\n  const result = []\n\n  while (++index < values.length) {\n    const value = handlePropertyValue(schema, values[index], prop, definition)\n\n    if (value !== undefined && value !== null) {\n      // @ts-expect-error Assume no booleans were in arrays.\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n/**\n * Sanitize a property value.\n *\n * @param {Schema} schema\n * @param {unknown} value\n * @param {string} prop\n * @param {AttributeClean[string]} definition\n * @returns {PropertyValue}\n */\nfunction handlePropertyValue(schema, value, prop, definition) {\n  if (\n    (typeof value === 'boolean' ||\n      typeof value === 'number' ||\n      typeof value === 'string') &&\n    safeProtocol(schema, value, prop) &&\n    (definition.length === 0 ||\n      definition.some((allowed) =>\n        allowed && typeof allowed === 'object' && 'flags' in allowed\n          ? allowed.test(String(value))\n          : allowed === value\n      ))\n  ) {\n    return schema.clobberPrefix &&\n      schema.clobber &&\n      schema.clobber.includes(prop)\n      ? schema.clobberPrefix + value\n      : value\n  }\n}\n\n/**\n * Check whether `value` is a safe URL.\n *\n * @param {Schema} schema\n * @param {unknown} value\n * @param {string} prop\n * @returns {boolean}\n */\nfunction safeProtocol(schema, value, prop) {\n  const url = String(value)\n  const colon = url.indexOf(':')\n  const questionMark = url.indexOf('?')\n  const numberSign = url.indexOf('#')\n  const slash = url.indexOf('/')\n  const protocols =\n    schema.protocols && own.call(schema.protocols, prop)\n      ? schema.protocols[prop].concat()\n      : []\n  let index = -1\n\n  if (\n    protocols.length === 0 ||\n    colon < 0 ||\n    // If the first colon is after a `?`, `#`, or `/`, itâ€™s not a protocol.\n    (slash > -1 && colon > slash) ||\n    (questionMark > -1 && colon > questionMark) ||\n    (numberSign > -1 && colon > numberSign)\n  ) {\n    return true\n  }\n\n  while (++index < protocols.length) {\n    if (\n      colon === protocols[index].length &&\n      url.slice(0, protocols[index].length) === protocols[index]\n    ) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Create a map from a list of props or a list of properties and values.\n *\n * @param {Attributes[string]} values\n * @returns {AttributeClean}\n */\nfunction toPropertyValueMap(values) {\n  /** @type {AttributeClean} */\n  const result = {}\n  let index = -1\n\n  while (++index < values.length) {\n    const value = values[index]\n\n    if (Array.isArray(value)) {\n      result[value[0]] = value.slice(1)\n    } else {\n      result[value] = []\n    }\n  }\n\n  return result\n}\n\n/**\n * Check if `prop` is a data property.\n *\n * @param {string} prop\n * @returns {boolean}\n */\nfunction data(prop) {\n  return prop.length > 4 && prop.slice(0, 4).toLowerCase() === 'data'\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}