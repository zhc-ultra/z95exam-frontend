{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.number.to-fixed.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.pad-start.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { StringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\nimport { LinePart } from './linePart.js';\nexport var LineRange = /*#__PURE__*/function () {\n  function LineRange(startIndex, endIndex) {\n    _classCallCheck(this, LineRange);\n    this.startOffset = startIndex;\n    this.endOffset = endIndex;\n  }\n  return _createClass(LineRange, [{\n    key: \"equals\",\n    value: function equals(otherLineRange) {\n      return this.startOffset === otherLineRange.startOffset && this.endOffset === otherLineRange.endOffset;\n    }\n  }]);\n}();\nexport var RenderLineInput = /*#__PURE__*/function () {\n  function RenderLineInput(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\n    _classCallCheck(this, RenderLineInput);\n    this.useMonospaceOptimizations = useMonospaceOptimizations;\n    this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n    this.lineContent = lineContent;\n    this.continuesWithWrappedLine = continuesWithWrappedLine;\n    this.isBasicASCII = isBasicASCII;\n    this.containsRTL = containsRTL;\n    this.fauxIndentLength = fauxIndentLength;\n    this.lineTokens = lineTokens;\n    this.lineDecorations = lineDecorations.sort(LineDecoration.compare);\n    this.tabSize = tabSize;\n    this.startVisibleColumn = startVisibleColumn;\n    this.spaceWidth = spaceWidth;\n    this.stopRenderingLineAfter = stopRenderingLineAfter;\n    this.renderWhitespace = renderWhitespace === 'all' ? 4 /* RenderWhitespace.All */ : renderWhitespace === 'boundary' ? 1 /* RenderWhitespace.Boundary */ : renderWhitespace === 'selection' ? 2 /* RenderWhitespace.Selection */ : renderWhitespace === 'trailing' ? 3 /* RenderWhitespace.Trailing */ : 0 /* RenderWhitespace.None */;\n    this.renderControlCharacters = renderControlCharacters;\n    this.fontLigatures = fontLigatures;\n    this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort(function (a, b) {\n      return a.startOffset < b.startOffset ? -1 : 1;\n    });\n    var wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);\n    var middotDiff = Math.abs(middotWidth - spaceWidth);\n    if (wsmiddotDiff < middotDiff) {\n      this.renderSpaceWidth = wsmiddotWidth;\n      this.renderSpaceCharCode = 0x2E31; // U+2E31 - WORD SEPARATOR MIDDLE DOT\n    } else {\n      this.renderSpaceWidth = middotWidth;\n      this.renderSpaceCharCode = 0xB7; // U+00B7 - MIDDLE DOT\n    }\n  }\n  return _createClass(RenderLineInput, [{\n    key: \"sameSelection\",\n    value: function sameSelection(otherSelections) {\n      if (this.selectionsOnLine === null) {\n        return otherSelections === null;\n      }\n      if (otherSelections === null) {\n        return false;\n      }\n      if (otherSelections.length !== this.selectionsOnLine.length) {\n        return false;\n      }\n      for (var i = 0; i < this.selectionsOnLine.length; i++) {\n        if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.useMonospaceOptimizations === other.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow && this.lineContent === other.lineContent && this.continuesWithWrappedLine === other.continuesWithWrappedLine && this.isBasicASCII === other.isBasicASCII && this.containsRTL === other.containsRTL && this.fauxIndentLength === other.fauxIndentLength && this.tabSize === other.tabSize && this.startVisibleColumn === other.startVisibleColumn && this.spaceWidth === other.spaceWidth && this.renderSpaceWidth === other.renderSpaceWidth && this.renderSpaceCharCode === other.renderSpaceCharCode && this.stopRenderingLineAfter === other.stopRenderingLineAfter && this.renderWhitespace === other.renderWhitespace && this.renderControlCharacters === other.renderControlCharacters && this.fontLigatures === other.fontLigatures && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations) && this.lineTokens.equals(other.lineTokens) && this.sameSelection(other.selectionsOnLine);\n    }\n  }]);\n}();\nexport var DomPosition = /*#__PURE__*/_createClass(function DomPosition(partIndex, charIndex) {\n  _classCallCheck(this, DomPosition);\n  this.partIndex = partIndex;\n  this.charIndex = charIndex;\n});\n/**\n * Provides a both direction mapping between a line's character and its rendered position.\n */\nexport var CharacterMapping = /*#__PURE__*/function () {\n  function CharacterMapping(length, partCount) {\n    _classCallCheck(this, CharacterMapping);\n    this.length = length;\n    this._data = new Uint32Array(this.length);\n    this._horizontalOffset = new Uint32Array(this.length);\n  }\n  return _createClass(CharacterMapping, [{\n    key: \"setColumnInfo\",\n    value: function setColumnInfo(column, partIndex, charIndex, horizontalOffset) {\n      var partData = (partIndex << 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */ | charIndex << 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */) >>> 0;\n      this._data[column - 1] = partData;\n      this._horizontalOffset[column - 1] = horizontalOffset;\n    }\n  }, {\n    key: \"getHorizontalOffset\",\n    value: function getHorizontalOffset(column) {\n      if (this._horizontalOffset.length === 0) {\n        // No characters on this line\n        return 0;\n      }\n      return this._horizontalOffset[column - 1];\n    }\n  }, {\n    key: \"charOffsetToPartData\",\n    value: function charOffsetToPartData(charOffset) {\n      if (this.length === 0) {\n        return 0;\n      }\n      if (charOffset < 0) {\n        return this._data[0];\n      }\n      if (charOffset >= this.length) {\n        return this._data[this.length - 1];\n      }\n      return this._data[charOffset];\n    }\n  }, {\n    key: \"getDomPosition\",\n    value: function getDomPosition(column) {\n      var partData = this.charOffsetToPartData(column - 1);\n      var partIndex = CharacterMapping.getPartIndex(partData);\n      var charIndex = CharacterMapping.getCharIndex(partData);\n      return new DomPosition(partIndex, charIndex);\n    }\n  }, {\n    key: \"getColumn\",\n    value: function getColumn(domPosition, partLength) {\n      var charOffset = this.partDataToCharOffset(domPosition.partIndex, partLength, domPosition.charIndex);\n      return charOffset + 1;\n    }\n  }, {\n    key: \"partDataToCharOffset\",\n    value: function partDataToCharOffset(partIndex, partLength, charIndex) {\n      if (this.length === 0) {\n        return 0;\n      }\n      var searchEntry = (partIndex << 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */ | charIndex << 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */) >>> 0;\n      var min = 0;\n      var max = this.length - 1;\n      while (min + 1 < max) {\n        var mid = min + max >>> 1;\n        var midEntry = this._data[mid];\n        if (midEntry === searchEntry) {\n          return mid;\n        } else if (midEntry > searchEntry) {\n          max = mid;\n        } else {\n          min = mid;\n        }\n      }\n      if (min === max) {\n        return min;\n      }\n      var minEntry = this._data[min];\n      var maxEntry = this._data[max];\n      if (minEntry === searchEntry) {\n        return min;\n      }\n      if (maxEntry === searchEntry) {\n        return max;\n      }\n      var minPartIndex = CharacterMapping.getPartIndex(minEntry);\n      var minCharIndex = CharacterMapping.getCharIndex(minEntry);\n      var maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n      var maxCharIndex;\n      if (minPartIndex !== maxPartIndex) {\n        // sitting between parts\n        maxCharIndex = partLength;\n      } else {\n        maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n      }\n      var minEntryDistance = charIndex - minCharIndex;\n      var maxEntryDistance = maxCharIndex - charIndex;\n      if (minEntryDistance <= maxEntryDistance) {\n        return min;\n      }\n      return max;\n    }\n  }], [{\n    key: \"getPartIndex\",\n    value: function getPartIndex(partData) {\n      return (partData & 4294901760 /* CharacterMappingConstants.PART_INDEX_MASK */) >>> 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */;\n    }\n  }, {\n    key: \"getCharIndex\",\n    value: function getCharIndex(partData) {\n      return (partData & 65535 /* CharacterMappingConstants.CHAR_INDEX_MASK */) >>> 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */;\n    }\n  }]);\n}();\nexport var RenderLineOutput = /*#__PURE__*/_createClass(function RenderLineOutput(characterMapping, containsRTL, containsForeignElements) {\n  _classCallCheck(this, RenderLineOutput);\n  this._renderLineOutputBrand = undefined;\n  this.characterMapping = characterMapping;\n  this.containsRTL = containsRTL;\n  this.containsForeignElements = containsForeignElements;\n});\nexport function renderViewLine(input, sb) {\n  if (input.lineContent.length === 0) {\n    if (input.lineDecorations.length > 0) {\n      // This line is empty, but it contains inline decorations\n      sb.appendString(\"<span>\");\n      var beforeCount = 0;\n      var afterCount = 0;\n      var containsForeignElements = 0 /* ForeignElementType.None */;\n      var _iterator = _createForOfIteratorHelper(input.lineDecorations),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var lineDecoration = _step.value;\n          if (lineDecoration.type === 1 /* InlineDecorationType.Before */ || lineDecoration.type === 2 /* InlineDecorationType.After */) {\n            sb.appendString(\"<span class=\\\"\");\n            sb.appendString(lineDecoration.className);\n            sb.appendString(\"\\\"></span>\");\n            if (lineDecoration.type === 1 /* InlineDecorationType.Before */) {\n              containsForeignElements |= 1 /* ForeignElementType.Before */;\n              beforeCount++;\n            }\n            if (lineDecoration.type === 2 /* InlineDecorationType.After */) {\n              containsForeignElements |= 2 /* ForeignElementType.After */;\n              afterCount++;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      sb.appendString(\"</span>\");\n      var characterMapping = new CharacterMapping(1, beforeCount + afterCount);\n      characterMapping.setColumnInfo(1, beforeCount, 0, 0);\n      return new RenderLineOutput(characterMapping, false, containsForeignElements);\n    }\n    // completely empty line\n    sb.appendString('<span><span></span></span>');\n    return new RenderLineOutput(new CharacterMapping(0, 0), false, 0 /* ForeignElementType.None */);\n  }\n  return _renderLine(resolveRenderLineInput(input), sb);\n}\nexport var RenderLineOutput2 = /*#__PURE__*/_createClass(function RenderLineOutput2(characterMapping, html, containsRTL, containsForeignElements) {\n  _classCallCheck(this, RenderLineOutput2);\n  this.characterMapping = characterMapping;\n  this.html = html;\n  this.containsRTL = containsRTL;\n  this.containsForeignElements = containsForeignElements;\n});\nexport function renderViewLine2(input) {\n  var sb = new StringBuilder(10000);\n  var out = renderViewLine(input, sb);\n  return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\nvar ResolvedRenderLineInput = /*#__PURE__*/_createClass(function ResolvedRenderLineInput(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, overflowingCharCount, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, renderSpaceCharCode, renderWhitespace, renderControlCharacters) {\n  _classCallCheck(this, ResolvedRenderLineInput);\n  this.fontIsMonospace = fontIsMonospace;\n  this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n  this.lineContent = lineContent;\n  this.len = len;\n  this.isOverflowing = isOverflowing;\n  this.overflowingCharCount = overflowingCharCount;\n  this.parts = parts;\n  this.containsForeignElements = containsForeignElements;\n  this.fauxIndentLength = fauxIndentLength;\n  this.tabSize = tabSize;\n  this.startVisibleColumn = startVisibleColumn;\n  this.containsRTL = containsRTL;\n  this.spaceWidth = spaceWidth;\n  this.renderSpaceCharCode = renderSpaceCharCode;\n  this.renderWhitespace = renderWhitespace;\n  this.renderControlCharacters = renderControlCharacters;\n  //\n});\nfunction resolveRenderLineInput(input) {\n  var lineContent = input.lineContent;\n  var isOverflowing;\n  var overflowingCharCount;\n  var len;\n  if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n    isOverflowing = true;\n    overflowingCharCount = lineContent.length - input.stopRenderingLineAfter;\n    len = input.stopRenderingLineAfter;\n  } else {\n    isOverflowing = false;\n    overflowingCharCount = 0;\n    len = lineContent.length;\n  }\n  var tokens = transformAndRemoveOverflowing(lineContent, input.containsRTL, input.lineTokens, input.fauxIndentLength, len);\n  if (input.renderControlCharacters && !input.isBasicASCII) {\n    // Calling `extractControlCharacters` before adding (possibly empty) line parts\n    // for inline decorations. `extractControlCharacters` removes empty line parts.\n    tokens = extractControlCharacters(lineContent, tokens);\n  }\n  if (input.renderWhitespace === 4 /* RenderWhitespace.All */ || input.renderWhitespace === 1 /* RenderWhitespace.Boundary */ || input.renderWhitespace === 2 /* RenderWhitespace.Selection */ && !!input.selectionsOnLine || input.renderWhitespace === 3 /* RenderWhitespace.Trailing */ && !input.continuesWithWrappedLine) {\n    tokens = _applyRenderWhitespace(input, lineContent, len, tokens);\n  }\n  var containsForeignElements = 0 /* ForeignElementType.None */;\n  if (input.lineDecorations.length > 0) {\n    for (var i = 0, _len = input.lineDecorations.length; i < _len; i++) {\n      var lineDecoration = input.lineDecorations[i];\n      if (lineDecoration.type === 3 /* InlineDecorationType.RegularAffectingLetterSpacing */) {\n        // Pretend there are foreign elements... although not 100% accurate.\n        containsForeignElements |= 1 /* ForeignElementType.Before */;\n      } else if (lineDecoration.type === 1 /* InlineDecorationType.Before */) {\n        containsForeignElements |= 1 /* ForeignElementType.Before */;\n      } else if (lineDecoration.type === 2 /* InlineDecorationType.After */) {\n        containsForeignElements |= 2 /* ForeignElementType.After */;\n      }\n    }\n    tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n  }\n  if (!input.containsRTL) {\n    // We can never split RTL text, as it ruins the rendering\n    tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n  }\n  return new ResolvedRenderLineInput(input.useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, overflowingCharCount, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.renderSpaceCharCode, input.renderWhitespace, input.renderControlCharacters);\n}\n/**\n * In the rendering phase, characters are always looped until token.endIndex.\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\n */\nfunction transformAndRemoveOverflowing(lineContent, lineContainsRTL, tokens, fauxIndentLength, len) {\n  var result = [];\n  var resultLen = 0;\n  // The faux indent part of the line should have no token type\n  if (fauxIndentLength > 0) {\n    result[resultLen++] = new LinePart(fauxIndentLength, '', 0, false);\n  }\n  var startOffset = fauxIndentLength;\n  for (var tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n    var endIndex = tokens.getEndOffset(tokenIndex);\n    if (endIndex <= fauxIndentLength) {\n      // The faux indent part of the line should have no token type\n      continue;\n    }\n    var type = tokens.getClassName(tokenIndex);\n    if (endIndex >= len) {\n      var _tokenContainsRTL = lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, len)) : false;\n      result[resultLen++] = new LinePart(len, type, 0, _tokenContainsRTL);\n      break;\n    }\n    var tokenContainsRTL = lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, endIndex)) : false;\n    result[resultLen++] = new LinePart(endIndex, type, 0, tokenContainsRTL);\n    startOffset = endIndex;\n  }\n  return result;\n}\n/**\n * See https://github.com/microsoft/vscode/issues/6885.\n * It appears that having very large spans causes very slow reading of character positions.\n * So here we try to avoid that.\n */\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n  var lastTokenEndIndex = 0;\n  var result = [];\n  var resultLen = 0;\n  if (onlyAtSpaces) {\n    // Split only at spaces => we need to walk each character\n    for (var i = 0, len = tokens.length; i < len; i++) {\n      var token = tokens[i];\n      var tokenEndIndex = token.endIndex;\n      if (lastTokenEndIndex + 50 /* Constants.LongToken */ < tokenEndIndex) {\n        var tokenType = token.type;\n        var tokenMetadata = token.metadata;\n        var tokenContainsRTL = token.containsRTL;\n        var lastSpaceOffset = -1;\n        var currTokenStart = lastTokenEndIndex;\n        for (var j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n          if (lineContent.charCodeAt(j) === 32 /* CharCode.Space */) {\n            lastSpaceOffset = j;\n          }\n          if (lastSpaceOffset !== -1 && j - currTokenStart >= 50 /* Constants.LongToken */) {\n            // Split at `lastSpaceOffset` + 1\n            result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata, tokenContainsRTL);\n            currTokenStart = lastSpaceOffset + 1;\n            lastSpaceOffset = -1;\n          }\n        }\n        if (currTokenStart !== tokenEndIndex) {\n          result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n        }\n      } else {\n        result[resultLen++] = token;\n      }\n      lastTokenEndIndex = tokenEndIndex;\n    }\n  } else {\n    // Split anywhere => we don't need to walk each character\n    for (var _i = 0, _len2 = tokens.length; _i < _len2; _i++) {\n      var _token = tokens[_i];\n      var _tokenEndIndex = _token.endIndex;\n      var diff = _tokenEndIndex - lastTokenEndIndex;\n      if (diff > 50 /* Constants.LongToken */) {\n        var _tokenType = _token.type;\n        var _tokenMetadata = _token.metadata;\n        var _tokenContainsRTL2 = _token.containsRTL;\n        var piecesCount = Math.ceil(diff / 50 /* Constants.LongToken */);\n        for (var _j = 1; _j < piecesCount; _j++) {\n          var pieceEndIndex = lastTokenEndIndex + _j * 50 /* Constants.LongToken */;\n          result[resultLen++] = new LinePart(pieceEndIndex, _tokenType, _tokenMetadata, _tokenContainsRTL2);\n        }\n        result[resultLen++] = new LinePart(_tokenEndIndex, _tokenType, _tokenMetadata, _tokenContainsRTL2);\n      } else {\n        result[resultLen++] = _token;\n      }\n      lastTokenEndIndex = _tokenEndIndex;\n    }\n  }\n  return result;\n}\nfunction isControlCharacter(charCode) {\n  if (charCode < 32) {\n    return charCode !== 9 /* CharCode.Tab */;\n  }\n  if (charCode === 127) {\n    // DEL\n    return true;\n  }\n  if (charCode >= 0x202A && charCode <= 0x202E || charCode >= 0x2066 && charCode <= 0x2069 || charCode >= 0x200E && charCode <= 0x200F || charCode === 0x061C) {\n    // Unicode Directional Formatting Characters\n    // LRE\tU+202A\tLEFT-TO-RIGHT EMBEDDING\n    // RLE\tU+202B\tRIGHT-TO-LEFT EMBEDDING\n    // PDF\tU+202C\tPOP DIRECTIONAL FORMATTING\n    // LRO\tU+202D\tLEFT-TO-RIGHT OVERRIDE\n    // RLO\tU+202E\tRIGHT-TO-LEFT OVERRIDE\n    // LRI\tU+2066\tLEFT-TO-RIGHT ISOLATE\n    // RLI\tU+2067\tRIGHT-TO-LEFT ISOLATE\n    // FSI\tU+2068\tFIRST STRONG ISOLATE\n    // PDI\tU+2069\tPOP DIRECTIONAL ISOLATE\n    // LRM\tU+200E\tLEFT-TO-RIGHT MARK\n    // RLM\tU+200F\tRIGHT-TO-LEFT MARK\n    // ALM\tU+061C\tARABIC LETTER MARK\n    return true;\n  }\n  return false;\n}\nfunction extractControlCharacters(lineContent, tokens) {\n  var result = [];\n  var lastLinePart = new LinePart(0, '', 0, false);\n  var charOffset = 0;\n  var _iterator2 = _createForOfIteratorHelper(tokens),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var token = _step2.value;\n      var tokenEndIndex = token.endIndex;\n      for (; charOffset < tokenEndIndex; charOffset++) {\n        var charCode = lineContent.charCodeAt(charOffset);\n        if (isControlCharacter(charCode)) {\n          if (charOffset > lastLinePart.endIndex) {\n            // emit previous part if it has text\n            lastLinePart = new LinePart(charOffset, token.type, token.metadata, token.containsRTL);\n            result.push(lastLinePart);\n          }\n          lastLinePart = new LinePart(charOffset + 1, 'mtkcontrol', token.metadata, false);\n          result.push(lastLinePart);\n        }\n      }\n      if (charOffset > lastLinePart.endIndex) {\n        // emit previous part if it has text\n        lastLinePart = new LinePart(tokenEndIndex, token.type, token.metadata, token.containsRTL);\n        result.push(lastLinePart);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return result;\n}\n/**\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `mtkw` type that is later recognized in the rendering phase.\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\n */\nfunction _applyRenderWhitespace(input, lineContent, len, tokens) {\n  var continuesWithWrappedLine = input.continuesWithWrappedLine;\n  var fauxIndentLength = input.fauxIndentLength;\n  var tabSize = input.tabSize;\n  var startVisibleColumn = input.startVisibleColumn;\n  var useMonospaceOptimizations = input.useMonospaceOptimizations;\n  var selections = input.selectionsOnLine;\n  var onlyBoundary = input.renderWhitespace === 1 /* RenderWhitespace.Boundary */;\n  var onlyTrailing = input.renderWhitespace === 3 /* RenderWhitespace.Trailing */;\n  var generateLinePartForEachWhitespace = input.renderSpaceWidth !== input.spaceWidth;\n  var result = [];\n  var resultLen = 0;\n  var tokenIndex = 0;\n  var tokenType = tokens[tokenIndex].type;\n  var tokenContainsRTL = tokens[tokenIndex].containsRTL;\n  var tokenEndIndex = tokens[tokenIndex].endIndex;\n  var tokensLength = tokens.length;\n  var lineIsEmptyOrWhitespace = false;\n  var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n  var lastNonWhitespaceIndex;\n  if (firstNonWhitespaceIndex === -1) {\n    lineIsEmptyOrWhitespace = true;\n    firstNonWhitespaceIndex = len;\n    lastNonWhitespaceIndex = len;\n  } else {\n    lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n  }\n  var wasInWhitespace = false;\n  var currentSelectionIndex = 0;\n  var currentSelection = selections && selections[currentSelectionIndex];\n  var tmpIndent = startVisibleColumn % tabSize;\n  for (var charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n    var chCode = lineContent.charCodeAt(charIndex);\n    if (currentSelection && charIndex >= currentSelection.endOffset) {\n      currentSelectionIndex++;\n      currentSelection = selections && selections[currentSelectionIndex];\n    }\n    var isInWhitespace = void 0;\n    if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n      // in leading or trailing whitespace\n      isInWhitespace = true;\n    } else if (chCode === 9 /* CharCode.Tab */) {\n      // a tab character is rendered both in all and boundary cases\n      isInWhitespace = true;\n    } else if (chCode === 32 /* CharCode.Space */) {\n      // hit a space character\n      if (onlyBoundary) {\n        // rendering only boundary whitespace\n        if (wasInWhitespace) {\n          isInWhitespace = true;\n        } else {\n          var nextChCode = charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* CharCode.Null */;\n          isInWhitespace = nextChCode === 32 /* CharCode.Space */ || nextChCode === 9 /* CharCode.Tab */;\n        }\n      } else {\n        isInWhitespace = true;\n      }\n    } else {\n      isInWhitespace = false;\n    }\n    // If rendering whitespace on selection, check that the charIndex falls within a selection\n    if (isInWhitespace && selections) {\n      isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\n    }\n    // If rendering only trailing whitespace, check that the charIndex points to trailing whitespace.\n    if (isInWhitespace && onlyTrailing) {\n      isInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex;\n    }\n    if (isInWhitespace && tokenContainsRTL) {\n      // If the token contains RTL text, breaking it up into multiple line parts\n      // to render whitespace might affect the browser's bidi layout.\n      //\n      // We render whitespace in such tokens only if the whitespace\n      // is the leading or the trailing whitespace of the line,\n      // which doesn't affect the browser's bidi layout.\n      if (charIndex >= firstNonWhitespaceIndex && charIndex <= lastNonWhitespaceIndex) {\n        isInWhitespace = false;\n      }\n    }\n    if (wasInWhitespace) {\n      // was in whitespace token\n      if (!isInWhitespace || !useMonospaceOptimizations && tmpIndent >= tabSize) {\n        // leaving whitespace token or entering a new indent\n        if (generateLinePartForEachWhitespace) {\n          var lastEndIndex = resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength;\n          for (var i = lastEndIndex + 1; i <= charIndex; i++) {\n            result[resultLen++] = new LinePart(i, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n          }\n        } else {\n          result[resultLen++] = new LinePart(charIndex, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n        }\n        tmpIndent = tmpIndent % tabSize;\n      }\n    } else {\n      // was in regular token\n      if (charIndex === tokenEndIndex || isInWhitespace && charIndex > fauxIndentLength) {\n        result[resultLen++] = new LinePart(charIndex, tokenType, 0, tokenContainsRTL);\n        tmpIndent = tmpIndent % tabSize;\n      }\n    }\n    if (chCode === 9 /* CharCode.Tab */) {\n      tmpIndent = tabSize;\n    } else if (strings.isFullWidthCharacter(chCode)) {\n      tmpIndent += 2;\n    } else {\n      tmpIndent++;\n    }\n    wasInWhitespace = isInWhitespace;\n    while (charIndex === tokenEndIndex) {\n      tokenIndex++;\n      if (tokenIndex < tokensLength) {\n        tokenType = tokens[tokenIndex].type;\n        tokenContainsRTL = tokens[tokenIndex].containsRTL;\n        tokenEndIndex = tokens[tokenIndex].endIndex;\n      } else {\n        break;\n      }\n    }\n  }\n  var generateWhitespace = false;\n  if (wasInWhitespace) {\n    // was in whitespace token\n    if (continuesWithWrappedLine && onlyBoundary) {\n      var lastCharCode = len > 0 ? lineContent.charCodeAt(len - 1) : 0 /* CharCode.Null */;\n      var prevCharCode = len > 1 ? lineContent.charCodeAt(len - 2) : 0 /* CharCode.Null */;\n      var isSingleTrailingSpace = lastCharCode === 32 /* CharCode.Space */ && prevCharCode !== 32 /* CharCode.Space */ && prevCharCode !== 9 /* CharCode.Tab */;\n      if (!isSingleTrailingSpace) {\n        generateWhitespace = true;\n      }\n    } else {\n      generateWhitespace = true;\n    }\n  }\n  if (generateWhitespace) {\n    if (generateLinePartForEachWhitespace) {\n      var _lastEndIndex = resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength;\n      for (var _i2 = _lastEndIndex + 1; _i2 <= len; _i2++) {\n        result[resultLen++] = new LinePart(_i2, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n      }\n    } else {\n      result[resultLen++] = new LinePart(len, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n    }\n  } else {\n    result[resultLen++] = new LinePart(len, tokenType, 0, tokenContainsRTL);\n  }\n  return result;\n}\n/**\n * Inline decorations are \"merged\" on top of tokens.\n * Special care must be taken when multiple inline decorations are at play and they overlap.\n */\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n  _lineDecorations.sort(LineDecoration.compare);\n  var lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n  var lineDecorationsLen = lineDecorations.length;\n  var lineDecorationIndex = 0;\n  var result = [];\n  var resultLen = 0;\n  var lastResultEndIndex = 0;\n  for (var tokenIndex = 0, _len3 = tokens.length; tokenIndex < _len3; tokenIndex++) {\n    var token = tokens[tokenIndex];\n    var tokenEndIndex = token.endIndex;\n    var tokenType = token.type;\n    var tokenMetadata = token.metadata;\n    var tokenContainsRTL = token.containsRTL;\n    while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n      var lineDecoration = lineDecorations[lineDecorationIndex];\n      if (lineDecoration.startOffset > lastResultEndIndex) {\n        lastResultEndIndex = lineDecoration.startOffset;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n      }\n      if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n        // This line decoration ends before this token ends\n        lastResultEndIndex = lineDecoration.endOffset + 1;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n        lineDecorationIndex++;\n      } else {\n        // This line decoration continues on to the next token\n        lastResultEndIndex = tokenEndIndex;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n        break;\n      }\n    }\n    if (tokenEndIndex > lastResultEndIndex) {\n      lastResultEndIndex = tokenEndIndex;\n      result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n    }\n  }\n  var lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n  if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n    while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n      var _lineDecoration = lineDecorations[lineDecorationIndex];\n      result[resultLen++] = new LinePart(lastResultEndIndex, _lineDecoration.className, _lineDecoration.metadata, false);\n      lineDecorationIndex++;\n    }\n  }\n  return result;\n}\n/**\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\n */\nfunction _renderLine(input, sb) {\n  var fontIsMonospace = input.fontIsMonospace;\n  var canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n  var containsForeignElements = input.containsForeignElements;\n  var lineContent = input.lineContent;\n  var len = input.len;\n  var isOverflowing = input.isOverflowing;\n  var overflowingCharCount = input.overflowingCharCount;\n  var parts = input.parts;\n  var fauxIndentLength = input.fauxIndentLength;\n  var tabSize = input.tabSize;\n  var startVisibleColumn = input.startVisibleColumn;\n  var containsRTL = input.containsRTL;\n  var spaceWidth = input.spaceWidth;\n  var renderSpaceCharCode = input.renderSpaceCharCode;\n  var renderWhitespace = input.renderWhitespace;\n  var renderControlCharacters = input.renderControlCharacters;\n  var characterMapping = new CharacterMapping(len + 1, parts.length);\n  var lastCharacterMappingDefined = false;\n  var charIndex = 0;\n  var visibleColumn = startVisibleColumn;\n  var charOffsetInPart = 0; // the character offset in the current part\n  var charHorizontalOffset = 0; // the character horizontal position in terms of chars relative to line start\n  var partDisplacement = 0;\n  if (containsRTL) {\n    sb.appendString('<span dir=\"ltr\">');\n  } else {\n    sb.appendString('<span>');\n  }\n  for (var partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n    var part = parts[partIndex];\n    var partEndIndex = part.endIndex;\n    var partType = part.type;\n    var partContainsRTL = part.containsRTL;\n    var partRendersWhitespace = renderWhitespace !== 0 /* RenderWhitespace.None */ && part.isWhitespace();\n    var partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === 'mtkw' /*only whitespace*/ || !containsForeignElements);\n    var partIsEmptyAndHasPseudoAfter = charIndex === partEndIndex && part.isPseudoAfter();\n    charOffsetInPart = 0;\n    sb.appendString('<span ');\n    if (partContainsRTL) {\n      sb.appendString('style=\"unicode-bidi:isolate\" ');\n    }\n    sb.appendString('class=\"');\n    sb.appendString(partRendersWhitespaceWithWidth ? 'mtkz' : partType);\n    sb.appendASCIICharCode(34 /* CharCode.DoubleQuote */);\n    if (partRendersWhitespace) {\n      var partWidth = 0;\n      {\n        var _charIndex = charIndex;\n        var _visibleColumn = visibleColumn;\n        for (; _charIndex < partEndIndex; _charIndex++) {\n          var charCode = lineContent.charCodeAt(_charIndex);\n          var charWidth = (charCode === 9 /* CharCode.Tab */ ? tabSize - _visibleColumn % tabSize : 1) | 0;\n          partWidth += charWidth;\n          if (_charIndex >= fauxIndentLength) {\n            _visibleColumn += charWidth;\n          }\n        }\n      }\n      if (partRendersWhitespaceWithWidth) {\n        sb.appendString(' style=\"width:');\n        sb.appendString(String(spaceWidth * partWidth));\n        sb.appendString('px\"');\n      }\n      sb.appendASCIICharCode(62 /* CharCode.GreaterThan */);\n      for (; charIndex < partEndIndex; charIndex++) {\n        characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n        partDisplacement = 0;\n        var _charCode = lineContent.charCodeAt(charIndex);\n        var producedCharacters = void 0;\n        var _charWidth = void 0;\n        if (_charCode === 9 /* CharCode.Tab */) {\n          producedCharacters = tabSize - visibleColumn % tabSize | 0;\n          _charWidth = producedCharacters;\n          if (!canUseHalfwidthRightwardsArrow || _charWidth > 1) {\n            sb.appendCharCode(0x2192); // RIGHTWARDS ARROW\n          } else {\n            sb.appendCharCode(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n          }\n          for (var space = 2; space <= _charWidth; space++) {\n            sb.appendCharCode(0xA0); // &nbsp;\n          }\n        } else {\n          // must be CharCode.Space\n          producedCharacters = 2;\n          _charWidth = 1;\n          sb.appendCharCode(renderSpaceCharCode); // &middot; or word separator middle dot\n          sb.appendCharCode(0x200C); // ZERO WIDTH NON-JOINER\n        }\n        charOffsetInPart += producedCharacters;\n        charHorizontalOffset += _charWidth;\n        if (charIndex >= fauxIndentLength) {\n          visibleColumn += _charWidth;\n        }\n      }\n    } else {\n      sb.appendASCIICharCode(62 /* CharCode.GreaterThan */);\n      for (; charIndex < partEndIndex; charIndex++) {\n        characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n        partDisplacement = 0;\n        var _charCode2 = lineContent.charCodeAt(charIndex);\n        var _producedCharacters = 1;\n        var _charWidth2 = 1;\n        switch (_charCode2) {\n          case 9 /* CharCode.Tab */:\n            _producedCharacters = tabSize - visibleColumn % tabSize;\n            _charWidth2 = _producedCharacters;\n            for (var _space = 1; _space <= _producedCharacters; _space++) {\n              sb.appendCharCode(0xA0); // &nbsp;\n            }\n            break;\n          case 32 /* CharCode.Space */:\n            sb.appendCharCode(0xA0); // &nbsp;\n            break;\n          case 60 /* CharCode.LessThan */:\n            sb.appendString('&lt;');\n            break;\n          case 62 /* CharCode.GreaterThan */:\n            sb.appendString('&gt;');\n            break;\n          case 38 /* CharCode.Ampersand */:\n            sb.appendString('&amp;');\n            break;\n          case 0 /* CharCode.Null */:\n            if (renderControlCharacters) {\n              // See https://unicode-table.com/en/blocks/control-pictures/\n              sb.appendCharCode(9216);\n            } else {\n              sb.appendString('&#00;');\n            }\n            break;\n          case 65279 /* CharCode.UTF8_BOM */:\n          case 8232 /* CharCode.LINE_SEPARATOR */:\n          case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n          case 133 /* CharCode.NEXT_LINE */:\n            sb.appendCharCode(0xFFFD);\n            break;\n          default:\n            if (strings.isFullWidthCharacter(_charCode2)) {\n              _charWidth2++;\n            }\n            // See https://unicode-table.com/en/blocks/control-pictures/\n            if (renderControlCharacters && _charCode2 < 32) {\n              sb.appendCharCode(9216 + _charCode2);\n            } else if (renderControlCharacters && _charCode2 === 127) {\n              // DEL\n              sb.appendCharCode(9249);\n            } else if (renderControlCharacters && isControlCharacter(_charCode2)) {\n              sb.appendString('[U+');\n              sb.appendString(to4CharHex(_charCode2));\n              sb.appendString(']');\n              _producedCharacters = 8;\n              _charWidth2 = _producedCharacters;\n            } else {\n              sb.appendCharCode(_charCode2);\n            }\n        }\n        charOffsetInPart += _producedCharacters;\n        charHorizontalOffset += _charWidth2;\n        if (charIndex >= fauxIndentLength) {\n          visibleColumn += _charWidth2;\n        }\n      }\n    }\n    if (partIsEmptyAndHasPseudoAfter) {\n      partDisplacement++;\n    } else {\n      partDisplacement = 0;\n    }\n    if (charIndex >= len && !lastCharacterMappingDefined && part.isPseudoAfter()) {\n      lastCharacterMappingDefined = true;\n      characterMapping.setColumnInfo(charIndex + 1, partIndex, charOffsetInPart, charHorizontalOffset);\n    }\n    sb.appendString('</span>');\n  }\n  if (!lastCharacterMappingDefined) {\n    // When getting client rects for the last character, we will position the\n    // text range at the end of the span, insteaf of at the beginning of next span\n    characterMapping.setColumnInfo(len + 1, parts.length - 1, charOffsetInPart, charHorizontalOffset);\n  }\n  if (isOverflowing) {\n    sb.appendString('<span class=\"mtkoverflow\">');\n    sb.appendString(nls.localize('showMore', \"Show more ({0})\", renderOverflowingCharCount(overflowingCharCount)));\n    sb.appendString('</span>');\n  }\n  sb.appendString('</span>');\n  return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}\nfunction to4CharHex(n) {\n  return n.toString(16).toUpperCase().padStart(4, '0');\n}\nfunction renderOverflowingCharCount(n) {\n  if (n < 1024) {\n    return nls.localize('overflow.chars', \"{0} chars\", n);\n  }\n  if (n < 1024 * 1024) {\n    return \"\".concat((n / 1024).toFixed(1), \" KB\");\n  }\n  return \"\".concat((n / 1024 / 1024).toFixed(1), \" MB\");\n}","map":{"version":3,"names":["nls","strings","StringBuilder","LineDecoration","LineDecorationsNormalizer","LinePart","LineRange","startIndex","endIndex","_classCallCheck","startOffset","endOffset","_createClass","key","value","equals","otherLineRange","RenderLineInput","useMonospaceOptimizations","canUseHalfwidthRightwardsArrow","lineContent","continuesWithWrappedLine","isBasicASCII","containsRTL","fauxIndentLength","lineTokens","lineDecorations","tabSize","startVisibleColumn","spaceWidth","middotWidth","wsmiddotWidth","stopRenderingLineAfter","renderWhitespace","renderControlCharacters","fontLigatures","selectionsOnLine","sort","compare","a","b","wsmiddotDiff","Math","abs","middotDiff","renderSpaceWidth","renderSpaceCharCode","sameSelection","otherSelections","length","i","other","equalsArr","DomPosition","partIndex","charIndex","CharacterMapping","partCount","_data","Uint32Array","_horizontalOffset","setColumnInfo","column","horizontalOffset","partData","getHorizontalOffset","charOffsetToPartData","charOffset","getDomPosition","getPartIndex","getCharIndex","getColumn","domPosition","partLength","partDataToCharOffset","searchEntry","min","max","mid","midEntry","minEntry","maxEntry","minPartIndex","minCharIndex","maxPartIndex","maxCharIndex","minEntryDistance","maxEntryDistance","RenderLineOutput","characterMapping","containsForeignElements","_renderLineOutputBrand","undefined","renderViewLine","input","sb","appendString","beforeCount","afterCount","_iterator","_createForOfIteratorHelper","_step","s","n","done","lineDecoration","type","className","err","e","f","_renderLine","resolveRenderLineInput","RenderLineOutput2","html","renderViewLine2","out","build","ResolvedRenderLineInput","fontIsMonospace","len","isOverflowing","overflowingCharCount","parts","tokens","transformAndRemoveOverflowing","extractControlCharacters","_applyRenderWhitespace","_applyInlineDecorations","splitLargeTokens","lineContainsRTL","result","resultLen","tokenIndex","tokensLen","getCount","getEndOffset","getClassName","tokenContainsRTL","substring","onlyAtSpaces","lastTokenEndIndex","token","tokenEndIndex","tokenType","tokenMetadata","metadata","lastSpaceOffset","currTokenStart","j","charCodeAt","diff","piecesCount","ceil","pieceEndIndex","isControlCharacter","charCode","lastLinePart","_iterator2","_step2","push","selections","onlyBoundary","onlyTrailing","generateLinePartForEachWhitespace","tokensLength","lineIsEmptyOrWhitespace","firstNonWhitespaceIndex","lastNonWhitespaceIndex","wasInWhitespace","currentSelectionIndex","currentSelection","tmpIndent","chCode","isInWhitespace","nextChCode","lastEndIndex","isFullWidthCharacter","generateWhitespace","lastCharCode","prevCharCode","isSingleTrailingSpace","_lineDecorations","normalize","lineDecorationsLen","lineDecorationIndex","lastResultEndIndex","lastCharacterMappingDefined","visibleColumn","charOffsetInPart","charHorizontalOffset","partDisplacement","part","partEndIndex","partType","partContainsRTL","partRendersWhitespace","isWhitespace","partRendersWhitespaceWithWidth","partIsEmptyAndHasPseudoAfter","isPseudoAfter","appendASCIICharCode","partWidth","_charIndex","_visibleColumn","charWidth","String","producedCharacters","appendCharCode","space","to4CharHex","localize","renderOverflowingCharCount","toString","toUpperCase","padStart","concat","toFixed"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { StringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\nimport { LinePart } from './linePart.js';\nexport class LineRange {\n    constructor(startIndex, endIndex) {\n        this.startOffset = startIndex;\n        this.endOffset = endIndex;\n    }\n    equals(otherLineRange) {\n        return this.startOffset === otherLineRange.startOffset\n            && this.endOffset === otherLineRange.endOffset;\n    }\n}\nexport class RenderLineInput {\n    constructor(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\n        this.useMonospaceOptimizations = useMonospaceOptimizations;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.isBasicASCII = isBasicASCII;\n        this.containsRTL = containsRTL;\n        this.fauxIndentLength = fauxIndentLength;\n        this.lineTokens = lineTokens;\n        this.lineDecorations = lineDecorations.sort(LineDecoration.compare);\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.spaceWidth = spaceWidth;\n        this.stopRenderingLineAfter = stopRenderingLineAfter;\n        this.renderWhitespace = (renderWhitespace === 'all'\n            ? 4 /* RenderWhitespace.All */\n            : renderWhitespace === 'boundary'\n                ? 1 /* RenderWhitespace.Boundary */\n                : renderWhitespace === 'selection'\n                    ? 2 /* RenderWhitespace.Selection */\n                    : renderWhitespace === 'trailing'\n                        ? 3 /* RenderWhitespace.Trailing */\n                        : 0 /* RenderWhitespace.None */);\n        this.renderControlCharacters = renderControlCharacters;\n        this.fontLigatures = fontLigatures;\n        this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort((a, b) => a.startOffset < b.startOffset ? -1 : 1);\n        const wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);\n        const middotDiff = Math.abs(middotWidth - spaceWidth);\n        if (wsmiddotDiff < middotDiff) {\n            this.renderSpaceWidth = wsmiddotWidth;\n            this.renderSpaceCharCode = 0x2E31; // U+2E31 - WORD SEPARATOR MIDDLE DOT\n        }\n        else {\n            this.renderSpaceWidth = middotWidth;\n            this.renderSpaceCharCode = 0xB7; // U+00B7 - MIDDLE DOT\n        }\n    }\n    sameSelection(otherSelections) {\n        if (this.selectionsOnLine === null) {\n            return otherSelections === null;\n        }\n        if (otherSelections === null) {\n            return false;\n        }\n        if (otherSelections.length !== this.selectionsOnLine.length) {\n            return false;\n        }\n        for (let i = 0; i < this.selectionsOnLine.length; i++) {\n            if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    equals(other) {\n        return (this.useMonospaceOptimizations === other.useMonospaceOptimizations\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n            && this.lineContent === other.lineContent\n            && this.continuesWithWrappedLine === other.continuesWithWrappedLine\n            && this.isBasicASCII === other.isBasicASCII\n            && this.containsRTL === other.containsRTL\n            && this.fauxIndentLength === other.fauxIndentLength\n            && this.tabSize === other.tabSize\n            && this.startVisibleColumn === other.startVisibleColumn\n            && this.spaceWidth === other.spaceWidth\n            && this.renderSpaceWidth === other.renderSpaceWidth\n            && this.renderSpaceCharCode === other.renderSpaceCharCode\n            && this.stopRenderingLineAfter === other.stopRenderingLineAfter\n            && this.renderWhitespace === other.renderWhitespace\n            && this.renderControlCharacters === other.renderControlCharacters\n            && this.fontLigatures === other.fontLigatures\n            && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)\n            && this.lineTokens.equals(other.lineTokens)\n            && this.sameSelection(other.selectionsOnLine));\n    }\n}\nexport class DomPosition {\n    constructor(partIndex, charIndex) {\n        this.partIndex = partIndex;\n        this.charIndex = charIndex;\n    }\n}\n/**\n * Provides a both direction mapping between a line's character and its rendered position.\n */\nexport class CharacterMapping {\n    static getPartIndex(partData) {\n        return (partData & 4294901760 /* CharacterMappingConstants.PART_INDEX_MASK */) >>> 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */;\n    }\n    static getCharIndex(partData) {\n        return (partData & 65535 /* CharacterMappingConstants.CHAR_INDEX_MASK */) >>> 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */;\n    }\n    constructor(length, partCount) {\n        this.length = length;\n        this._data = new Uint32Array(this.length);\n        this._horizontalOffset = new Uint32Array(this.length);\n    }\n    setColumnInfo(column, partIndex, charIndex, horizontalOffset) {\n        const partData = ((partIndex << 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */)) >>> 0;\n        this._data[column - 1] = partData;\n        this._horizontalOffset[column - 1] = horizontalOffset;\n    }\n    getHorizontalOffset(column) {\n        if (this._horizontalOffset.length === 0) {\n            // No characters on this line\n            return 0;\n        }\n        return this._horizontalOffset[column - 1];\n    }\n    charOffsetToPartData(charOffset) {\n        if (this.length === 0) {\n            return 0;\n        }\n        if (charOffset < 0) {\n            return this._data[0];\n        }\n        if (charOffset >= this.length) {\n            return this._data[this.length - 1];\n        }\n        return this._data[charOffset];\n    }\n    getDomPosition(column) {\n        const partData = this.charOffsetToPartData(column - 1);\n        const partIndex = CharacterMapping.getPartIndex(partData);\n        const charIndex = CharacterMapping.getCharIndex(partData);\n        return new DomPosition(partIndex, charIndex);\n    }\n    getColumn(domPosition, partLength) {\n        const charOffset = this.partDataToCharOffset(domPosition.partIndex, partLength, domPosition.charIndex);\n        return charOffset + 1;\n    }\n    partDataToCharOffset(partIndex, partLength, charIndex) {\n        if (this.length === 0) {\n            return 0;\n        }\n        const searchEntry = ((partIndex << 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */)) >>> 0;\n        let min = 0;\n        let max = this.length - 1;\n        while (min + 1 < max) {\n            const mid = ((min + max) >>> 1);\n            const midEntry = this._data[mid];\n            if (midEntry === searchEntry) {\n                return mid;\n            }\n            else if (midEntry > searchEntry) {\n                max = mid;\n            }\n            else {\n                min = mid;\n            }\n        }\n        if (min === max) {\n            return min;\n        }\n        const minEntry = this._data[min];\n        const maxEntry = this._data[max];\n        if (minEntry === searchEntry) {\n            return min;\n        }\n        if (maxEntry === searchEntry) {\n            return max;\n        }\n        const minPartIndex = CharacterMapping.getPartIndex(minEntry);\n        const minCharIndex = CharacterMapping.getCharIndex(minEntry);\n        const maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n        let maxCharIndex;\n        if (minPartIndex !== maxPartIndex) {\n            // sitting between parts\n            maxCharIndex = partLength;\n        }\n        else {\n            maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n        }\n        const minEntryDistance = charIndex - minCharIndex;\n        const maxEntryDistance = maxCharIndex - charIndex;\n        if (minEntryDistance <= maxEntryDistance) {\n            return min;\n        }\n        return max;\n    }\n}\nexport class RenderLineOutput {\n    constructor(characterMapping, containsRTL, containsForeignElements) {\n        this._renderLineOutputBrand = undefined;\n        this.characterMapping = characterMapping;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine(input, sb) {\n    if (input.lineContent.length === 0) {\n        if (input.lineDecorations.length > 0) {\n            // This line is empty, but it contains inline decorations\n            sb.appendString(`<span>`);\n            let beforeCount = 0;\n            let afterCount = 0;\n            let containsForeignElements = 0 /* ForeignElementType.None */;\n            for (const lineDecoration of input.lineDecorations) {\n                if (lineDecoration.type === 1 /* InlineDecorationType.Before */ || lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                    sb.appendString(`<span class=\"`);\n                    sb.appendString(lineDecoration.className);\n                    sb.appendString(`\"></span>`);\n                    if (lineDecoration.type === 1 /* InlineDecorationType.Before */) {\n                        containsForeignElements |= 1 /* ForeignElementType.Before */;\n                        beforeCount++;\n                    }\n                    if (lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                        containsForeignElements |= 2 /* ForeignElementType.After */;\n                        afterCount++;\n                    }\n                }\n            }\n            sb.appendString(`</span>`);\n            const characterMapping = new CharacterMapping(1, beforeCount + afterCount);\n            characterMapping.setColumnInfo(1, beforeCount, 0, 0);\n            return new RenderLineOutput(characterMapping, false, containsForeignElements);\n        }\n        // completely empty line\n        sb.appendString('<span><span></span></span>');\n        return new RenderLineOutput(new CharacterMapping(0, 0), false, 0 /* ForeignElementType.None */);\n    }\n    return _renderLine(resolveRenderLineInput(input), sb);\n}\nexport class RenderLineOutput2 {\n    constructor(characterMapping, html, containsRTL, containsForeignElements) {\n        this.characterMapping = characterMapping;\n        this.html = html;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine2(input) {\n    const sb = new StringBuilder(10000);\n    const out = renderViewLine(input, sb);\n    return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\nclass ResolvedRenderLineInput {\n    constructor(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, overflowingCharCount, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, renderSpaceCharCode, renderWhitespace, renderControlCharacters) {\n        this.fontIsMonospace = fontIsMonospace;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.len = len;\n        this.isOverflowing = isOverflowing;\n        this.overflowingCharCount = overflowingCharCount;\n        this.parts = parts;\n        this.containsForeignElements = containsForeignElements;\n        this.fauxIndentLength = fauxIndentLength;\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.containsRTL = containsRTL;\n        this.spaceWidth = spaceWidth;\n        this.renderSpaceCharCode = renderSpaceCharCode;\n        this.renderWhitespace = renderWhitespace;\n        this.renderControlCharacters = renderControlCharacters;\n        //\n    }\n}\nfunction resolveRenderLineInput(input) {\n    const lineContent = input.lineContent;\n    let isOverflowing;\n    let overflowingCharCount;\n    let len;\n    if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n        isOverflowing = true;\n        overflowingCharCount = lineContent.length - input.stopRenderingLineAfter;\n        len = input.stopRenderingLineAfter;\n    }\n    else {\n        isOverflowing = false;\n        overflowingCharCount = 0;\n        len = lineContent.length;\n    }\n    let tokens = transformAndRemoveOverflowing(lineContent, input.containsRTL, input.lineTokens, input.fauxIndentLength, len);\n    if (input.renderControlCharacters && !input.isBasicASCII) {\n        // Calling `extractControlCharacters` before adding (possibly empty) line parts\n        // for inline decorations. `extractControlCharacters` removes empty line parts.\n        tokens = extractControlCharacters(lineContent, tokens);\n    }\n    if (input.renderWhitespace === 4 /* RenderWhitespace.All */ ||\n        input.renderWhitespace === 1 /* RenderWhitespace.Boundary */ ||\n        (input.renderWhitespace === 2 /* RenderWhitespace.Selection */ && !!input.selectionsOnLine) ||\n        (input.renderWhitespace === 3 /* RenderWhitespace.Trailing */ && !input.continuesWithWrappedLine)) {\n        tokens = _applyRenderWhitespace(input, lineContent, len, tokens);\n    }\n    let containsForeignElements = 0 /* ForeignElementType.None */;\n    if (input.lineDecorations.length > 0) {\n        for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n            const lineDecoration = input.lineDecorations[i];\n            if (lineDecoration.type === 3 /* InlineDecorationType.RegularAffectingLetterSpacing */) {\n                // Pretend there are foreign elements... although not 100% accurate.\n                containsForeignElements |= 1 /* ForeignElementType.Before */;\n            }\n            else if (lineDecoration.type === 1 /* InlineDecorationType.Before */) {\n                containsForeignElements |= 1 /* ForeignElementType.Before */;\n            }\n            else if (lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                containsForeignElements |= 2 /* ForeignElementType.After */;\n            }\n        }\n        tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n    }\n    if (!input.containsRTL) {\n        // We can never split RTL text, as it ruins the rendering\n        tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n    }\n    return new ResolvedRenderLineInput(input.useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, overflowingCharCount, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.renderSpaceCharCode, input.renderWhitespace, input.renderControlCharacters);\n}\n/**\n * In the rendering phase, characters are always looped until token.endIndex.\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\n */\nfunction transformAndRemoveOverflowing(lineContent, lineContainsRTL, tokens, fauxIndentLength, len) {\n    const result = [];\n    let resultLen = 0;\n    // The faux indent part of the line should have no token type\n    if (fauxIndentLength > 0) {\n        result[resultLen++] = new LinePart(fauxIndentLength, '', 0, false);\n    }\n    let startOffset = fauxIndentLength;\n    for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n        const endIndex = tokens.getEndOffset(tokenIndex);\n        if (endIndex <= fauxIndentLength) {\n            // The faux indent part of the line should have no token type\n            continue;\n        }\n        const type = tokens.getClassName(tokenIndex);\n        if (endIndex >= len) {\n            const tokenContainsRTL = (lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, len)) : false);\n            result[resultLen++] = new LinePart(len, type, 0, tokenContainsRTL);\n            break;\n        }\n        const tokenContainsRTL = (lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, endIndex)) : false);\n        result[resultLen++] = new LinePart(endIndex, type, 0, tokenContainsRTL);\n        startOffset = endIndex;\n    }\n    return result;\n}\n/**\n * See https://github.com/microsoft/vscode/issues/6885.\n * It appears that having very large spans causes very slow reading of character positions.\n * So here we try to avoid that.\n */\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n    let lastTokenEndIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    if (onlyAtSpaces) {\n        // Split only at spaces => we need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            if (lastTokenEndIndex + 50 /* Constants.LongToken */ < tokenEndIndex) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                const tokenContainsRTL = token.containsRTL;\n                let lastSpaceOffset = -1;\n                let currTokenStart = lastTokenEndIndex;\n                for (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n                    if (lineContent.charCodeAt(j) === 32 /* CharCode.Space */) {\n                        lastSpaceOffset = j;\n                    }\n                    if (lastSpaceOffset !== -1 && j - currTokenStart >= 50 /* Constants.LongToken */) {\n                        // Split at `lastSpaceOffset` + 1\n                        result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata, tokenContainsRTL);\n                        currTokenStart = lastSpaceOffset + 1;\n                        lastSpaceOffset = -1;\n                    }\n                }\n                if (currTokenStart !== tokenEndIndex) {\n                    result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n                }\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    else {\n        // Split anywhere => we don't need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            const diff = (tokenEndIndex - lastTokenEndIndex);\n            if (diff > 50 /* Constants.LongToken */) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                const tokenContainsRTL = token.containsRTL;\n                const piecesCount = Math.ceil(diff / 50 /* Constants.LongToken */);\n                for (let j = 1; j < piecesCount; j++) {\n                    const pieceEndIndex = lastTokenEndIndex + (j * 50 /* Constants.LongToken */);\n                    result[resultLen++] = new LinePart(pieceEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n                }\n                result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    return result;\n}\nfunction isControlCharacter(charCode) {\n    if (charCode < 32) {\n        return (charCode !== 9 /* CharCode.Tab */);\n    }\n    if (charCode === 127) {\n        // DEL\n        return true;\n    }\n    if ((charCode >= 0x202A && charCode <= 0x202E)\n        || (charCode >= 0x2066 && charCode <= 0x2069)\n        || (charCode >= 0x200E && charCode <= 0x200F)\n        || charCode === 0x061C) {\n        // Unicode Directional Formatting Characters\n        // LRE\tU+202A\tLEFT-TO-RIGHT EMBEDDING\n        // RLE\tU+202B\tRIGHT-TO-LEFT EMBEDDING\n        // PDF\tU+202C\tPOP DIRECTIONAL FORMATTING\n        // LRO\tU+202D\tLEFT-TO-RIGHT OVERRIDE\n        // RLO\tU+202E\tRIGHT-TO-LEFT OVERRIDE\n        // LRI\tU+2066\tLEFT-TO-RIGHT ISOLATE\n        // RLI\tU+2067\tRIGHT-TO-LEFT ISOLATE\n        // FSI\tU+2068\tFIRST STRONG ISOLATE\n        // PDI\tU+2069\tPOP DIRECTIONAL ISOLATE\n        // LRM\tU+200E\tLEFT-TO-RIGHT MARK\n        // RLM\tU+200F\tRIGHT-TO-LEFT MARK\n        // ALM\tU+061C\tARABIC LETTER MARK\n        return true;\n    }\n    return false;\n}\nfunction extractControlCharacters(lineContent, tokens) {\n    const result = [];\n    let lastLinePart = new LinePart(0, '', 0, false);\n    let charOffset = 0;\n    for (const token of tokens) {\n        const tokenEndIndex = token.endIndex;\n        for (; charOffset < tokenEndIndex; charOffset++) {\n            const charCode = lineContent.charCodeAt(charOffset);\n            if (isControlCharacter(charCode)) {\n                if (charOffset > lastLinePart.endIndex) {\n                    // emit previous part if it has text\n                    lastLinePart = new LinePart(charOffset, token.type, token.metadata, token.containsRTL);\n                    result.push(lastLinePart);\n                }\n                lastLinePart = new LinePart(charOffset + 1, 'mtkcontrol', token.metadata, false);\n                result.push(lastLinePart);\n            }\n        }\n        if (charOffset > lastLinePart.endIndex) {\n            // emit previous part if it has text\n            lastLinePart = new LinePart(tokenEndIndex, token.type, token.metadata, token.containsRTL);\n            result.push(lastLinePart);\n        }\n    }\n    return result;\n}\n/**\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `mtkw` type that is later recognized in the rendering phase.\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\n */\nfunction _applyRenderWhitespace(input, lineContent, len, tokens) {\n    const continuesWithWrappedLine = input.continuesWithWrappedLine;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const useMonospaceOptimizations = input.useMonospaceOptimizations;\n    const selections = input.selectionsOnLine;\n    const onlyBoundary = (input.renderWhitespace === 1 /* RenderWhitespace.Boundary */);\n    const onlyTrailing = (input.renderWhitespace === 3 /* RenderWhitespace.Trailing */);\n    const generateLinePartForEachWhitespace = (input.renderSpaceWidth !== input.spaceWidth);\n    const result = [];\n    let resultLen = 0;\n    let tokenIndex = 0;\n    let tokenType = tokens[tokenIndex].type;\n    let tokenContainsRTL = tokens[tokenIndex].containsRTL;\n    let tokenEndIndex = tokens[tokenIndex].endIndex;\n    const tokensLength = tokens.length;\n    let lineIsEmptyOrWhitespace = false;\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n    let lastNonWhitespaceIndex;\n    if (firstNonWhitespaceIndex === -1) {\n        lineIsEmptyOrWhitespace = true;\n        firstNonWhitespaceIndex = len;\n        lastNonWhitespaceIndex = len;\n    }\n    else {\n        lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n    }\n    let wasInWhitespace = false;\n    let currentSelectionIndex = 0;\n    let currentSelection = selections && selections[currentSelectionIndex];\n    let tmpIndent = startVisibleColumn % tabSize;\n    for (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n        const chCode = lineContent.charCodeAt(charIndex);\n        if (currentSelection && charIndex >= currentSelection.endOffset) {\n            currentSelectionIndex++;\n            currentSelection = selections && selections[currentSelectionIndex];\n        }\n        let isInWhitespace;\n        if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n            // in leading or trailing whitespace\n            isInWhitespace = true;\n        }\n        else if (chCode === 9 /* CharCode.Tab */) {\n            // a tab character is rendered both in all and boundary cases\n            isInWhitespace = true;\n        }\n        else if (chCode === 32 /* CharCode.Space */) {\n            // hit a space character\n            if (onlyBoundary) {\n                // rendering only boundary whitespace\n                if (wasInWhitespace) {\n                    isInWhitespace = true;\n                }\n                else {\n                    const nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* CharCode.Null */);\n                    isInWhitespace = (nextChCode === 32 /* CharCode.Space */ || nextChCode === 9 /* CharCode.Tab */);\n                }\n            }\n            else {\n                isInWhitespace = true;\n            }\n        }\n        else {\n            isInWhitespace = false;\n        }\n        // If rendering whitespace on selection, check that the charIndex falls within a selection\n        if (isInWhitespace && selections) {\n            isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\n        }\n        // If rendering only trailing whitespace, check that the charIndex points to trailing whitespace.\n        if (isInWhitespace && onlyTrailing) {\n            isInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex;\n        }\n        if (isInWhitespace && tokenContainsRTL) {\n            // If the token contains RTL text, breaking it up into multiple line parts\n            // to render whitespace might affect the browser's bidi layout.\n            //\n            // We render whitespace in such tokens only if the whitespace\n            // is the leading or the trailing whitespace of the line,\n            // which doesn't affect the browser's bidi layout.\n            if (charIndex >= firstNonWhitespaceIndex && charIndex <= lastNonWhitespaceIndex) {\n                isInWhitespace = false;\n            }\n        }\n        if (wasInWhitespace) {\n            // was in whitespace token\n            if (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {\n                // leaving whitespace token or entering a new indent\n                if (generateLinePartForEachWhitespace) {\n                    const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n                    for (let i = lastEndIndex + 1; i <= charIndex; i++) {\n                        result[resultLen++] = new LinePart(i, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n                    }\n                }\n                else {\n                    result[resultLen++] = new LinePart(charIndex, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n                }\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        else {\n            // was in regular token\n            if (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {\n                result[resultLen++] = new LinePart(charIndex, tokenType, 0, tokenContainsRTL);\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        if (chCode === 9 /* CharCode.Tab */) {\n            tmpIndent = tabSize;\n        }\n        else if (strings.isFullWidthCharacter(chCode)) {\n            tmpIndent += 2;\n        }\n        else {\n            tmpIndent++;\n        }\n        wasInWhitespace = isInWhitespace;\n        while (charIndex === tokenEndIndex) {\n            tokenIndex++;\n            if (tokenIndex < tokensLength) {\n                tokenType = tokens[tokenIndex].type;\n                tokenContainsRTL = tokens[tokenIndex].containsRTL;\n                tokenEndIndex = tokens[tokenIndex].endIndex;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    let generateWhitespace = false;\n    if (wasInWhitespace) {\n        // was in whitespace token\n        if (continuesWithWrappedLine && onlyBoundary) {\n            const lastCharCode = (len > 0 ? lineContent.charCodeAt(len - 1) : 0 /* CharCode.Null */);\n            const prevCharCode = (len > 1 ? lineContent.charCodeAt(len - 2) : 0 /* CharCode.Null */);\n            const isSingleTrailingSpace = (lastCharCode === 32 /* CharCode.Space */ && (prevCharCode !== 32 /* CharCode.Space */ && prevCharCode !== 9 /* CharCode.Tab */));\n            if (!isSingleTrailingSpace) {\n                generateWhitespace = true;\n            }\n        }\n        else {\n            generateWhitespace = true;\n        }\n    }\n    if (generateWhitespace) {\n        if (generateLinePartForEachWhitespace) {\n            const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n            for (let i = lastEndIndex + 1; i <= len; i++) {\n                result[resultLen++] = new LinePart(i, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n            }\n        }\n        else {\n            result[resultLen++] = new LinePart(len, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n        }\n    }\n    else {\n        result[resultLen++] = new LinePart(len, tokenType, 0, tokenContainsRTL);\n    }\n    return result;\n}\n/**\n * Inline decorations are \"merged\" on top of tokens.\n * Special care must be taken when multiple inline decorations are at play and they overlap.\n */\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n    _lineDecorations.sort(LineDecoration.compare);\n    const lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n    const lineDecorationsLen = lineDecorations.length;\n    let lineDecorationIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    let lastResultEndIndex = 0;\n    for (let tokenIndex = 0, len = tokens.length; tokenIndex < len; tokenIndex++) {\n        const token = tokens[tokenIndex];\n        const tokenEndIndex = token.endIndex;\n        const tokenType = token.type;\n        const tokenMetadata = token.metadata;\n        const tokenContainsRTL = token.containsRTL;\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            if (lineDecoration.startOffset > lastResultEndIndex) {\n                lastResultEndIndex = lineDecoration.startOffset;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n            }\n            if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n                // This line decoration ends before this token ends\n                lastResultEndIndex = lineDecoration.endOffset + 1;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n                lineDecorationIndex++;\n            }\n            else {\n                // This line decoration continues on to the next token\n                lastResultEndIndex = tokenEndIndex;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n                break;\n            }\n        }\n        if (tokenEndIndex > lastResultEndIndex) {\n            lastResultEndIndex = tokenEndIndex;\n            result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n        }\n    }\n    const lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n    if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            result[resultLen++] = new LinePart(lastResultEndIndex, lineDecoration.className, lineDecoration.metadata, false);\n            lineDecorationIndex++;\n        }\n    }\n    return result;\n}\n/**\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\n */\nfunction _renderLine(input, sb) {\n    const fontIsMonospace = input.fontIsMonospace;\n    const canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n    const containsForeignElements = input.containsForeignElements;\n    const lineContent = input.lineContent;\n    const len = input.len;\n    const isOverflowing = input.isOverflowing;\n    const overflowingCharCount = input.overflowingCharCount;\n    const parts = input.parts;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const containsRTL = input.containsRTL;\n    const spaceWidth = input.spaceWidth;\n    const renderSpaceCharCode = input.renderSpaceCharCode;\n    const renderWhitespace = input.renderWhitespace;\n    const renderControlCharacters = input.renderControlCharacters;\n    const characterMapping = new CharacterMapping(len + 1, parts.length);\n    let lastCharacterMappingDefined = false;\n    let charIndex = 0;\n    let visibleColumn = startVisibleColumn;\n    let charOffsetInPart = 0; // the character offset in the current part\n    let charHorizontalOffset = 0; // the character horizontal position in terms of chars relative to line start\n    let partDisplacement = 0;\n    if (containsRTL) {\n        sb.appendString('<span dir=\"ltr\">');\n    }\n    else {\n        sb.appendString('<span>');\n    }\n    for (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n        const part = parts[partIndex];\n        const partEndIndex = part.endIndex;\n        const partType = part.type;\n        const partContainsRTL = part.containsRTL;\n        const partRendersWhitespace = (renderWhitespace !== 0 /* RenderWhitespace.None */ && part.isWhitespace());\n        const partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === 'mtkw' /*only whitespace*/ || !containsForeignElements);\n        const partIsEmptyAndHasPseudoAfter = (charIndex === partEndIndex && part.isPseudoAfter());\n        charOffsetInPart = 0;\n        sb.appendString('<span ');\n        if (partContainsRTL) {\n            sb.appendString('style=\"unicode-bidi:isolate\" ');\n        }\n        sb.appendString('class=\"');\n        sb.appendString(partRendersWhitespaceWithWidth ? 'mtkz' : partType);\n        sb.appendASCIICharCode(34 /* CharCode.DoubleQuote */);\n        if (partRendersWhitespace) {\n            let partWidth = 0;\n            {\n                let _charIndex = charIndex;\n                let _visibleColumn = visibleColumn;\n                for (; _charIndex < partEndIndex; _charIndex++) {\n                    const charCode = lineContent.charCodeAt(_charIndex);\n                    const charWidth = (charCode === 9 /* CharCode.Tab */ ? (tabSize - (_visibleColumn % tabSize)) : 1) | 0;\n                    partWidth += charWidth;\n                    if (_charIndex >= fauxIndentLength) {\n                        _visibleColumn += charWidth;\n                    }\n                }\n            }\n            if (partRendersWhitespaceWithWidth) {\n                sb.appendString(' style=\"width:');\n                sb.appendString(String(spaceWidth * partWidth));\n                sb.appendString('px\"');\n            }\n            sb.appendASCIICharCode(62 /* CharCode.GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let producedCharacters;\n                let charWidth;\n                if (charCode === 9 /* CharCode.Tab */) {\n                    producedCharacters = (tabSize - (visibleColumn % tabSize)) | 0;\n                    charWidth = producedCharacters;\n                    if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\n                        sb.appendCharCode(0x2192); // RIGHTWARDS ARROW\n                    }\n                    else {\n                        sb.appendCharCode(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n                    }\n                    for (let space = 2; space <= charWidth; space++) {\n                        sb.appendCharCode(0xA0); // &nbsp;\n                    }\n                }\n                else { // must be CharCode.Space\n                    producedCharacters = 2;\n                    charWidth = 1;\n                    sb.appendCharCode(renderSpaceCharCode); // &middot; or word separator middle dot\n                    sb.appendCharCode(0x200C); // ZERO WIDTH NON-JOINER\n                }\n                charOffsetInPart += producedCharacters;\n                charHorizontalOffset += charWidth;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n        }\n        else {\n            sb.appendASCIICharCode(62 /* CharCode.GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let producedCharacters = 1;\n                let charWidth = 1;\n                switch (charCode) {\n                    case 9 /* CharCode.Tab */:\n                        producedCharacters = (tabSize - (visibleColumn % tabSize));\n                        charWidth = producedCharacters;\n                        for (let space = 1; space <= producedCharacters; space++) {\n                            sb.appendCharCode(0xA0); // &nbsp;\n                        }\n                        break;\n                    case 32 /* CharCode.Space */:\n                        sb.appendCharCode(0xA0); // &nbsp;\n                        break;\n                    case 60 /* CharCode.LessThan */:\n                        sb.appendString('&lt;');\n                        break;\n                    case 62 /* CharCode.GreaterThan */:\n                        sb.appendString('&gt;');\n                        break;\n                    case 38 /* CharCode.Ampersand */:\n                        sb.appendString('&amp;');\n                        break;\n                    case 0 /* CharCode.Null */:\n                        if (renderControlCharacters) {\n                            // See https://unicode-table.com/en/blocks/control-pictures/\n                            sb.appendCharCode(9216);\n                        }\n                        else {\n                            sb.appendString('&#00;');\n                        }\n                        break;\n                    case 65279 /* CharCode.UTF8_BOM */:\n                    case 8232 /* CharCode.LINE_SEPARATOR */:\n                    case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n                    case 133 /* CharCode.NEXT_LINE */:\n                        sb.appendCharCode(0xFFFD);\n                        break;\n                    default:\n                        if (strings.isFullWidthCharacter(charCode)) {\n                            charWidth++;\n                        }\n                        // See https://unicode-table.com/en/blocks/control-pictures/\n                        if (renderControlCharacters && charCode < 32) {\n                            sb.appendCharCode(9216 + charCode);\n                        }\n                        else if (renderControlCharacters && charCode === 127) {\n                            // DEL\n                            sb.appendCharCode(9249);\n                        }\n                        else if (renderControlCharacters && isControlCharacter(charCode)) {\n                            sb.appendString('[U+');\n                            sb.appendString(to4CharHex(charCode));\n                            sb.appendString(']');\n                            producedCharacters = 8;\n                            charWidth = producedCharacters;\n                        }\n                        else {\n                            sb.appendCharCode(charCode);\n                        }\n                }\n                charOffsetInPart += producedCharacters;\n                charHorizontalOffset += charWidth;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n        }\n        if (partIsEmptyAndHasPseudoAfter) {\n            partDisplacement++;\n        }\n        else {\n            partDisplacement = 0;\n        }\n        if (charIndex >= len && !lastCharacterMappingDefined && part.isPseudoAfter()) {\n            lastCharacterMappingDefined = true;\n            characterMapping.setColumnInfo(charIndex + 1, partIndex, charOffsetInPart, charHorizontalOffset);\n        }\n        sb.appendString('</span>');\n    }\n    if (!lastCharacterMappingDefined) {\n        // When getting client rects for the last character, we will position the\n        // text range at the end of the span, insteaf of at the beginning of next span\n        characterMapping.setColumnInfo(len + 1, parts.length - 1, charOffsetInPart, charHorizontalOffset);\n    }\n    if (isOverflowing) {\n        sb.appendString('<span class=\"mtkoverflow\">');\n        sb.appendString(nls.localize('showMore', \"Show more ({0})\", renderOverflowingCharCount(overflowingCharCount)));\n        sb.appendString('</span>');\n    }\n    sb.appendString('</span>');\n    return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}\nfunction to4CharHex(n) {\n    return n.toString(16).toUpperCase().padStart(4, '0');\n}\nfunction renderOverflowingCharCount(n) {\n    if (n < 1024) {\n        return nls.localize('overflow.chars', \"{0} chars\", n);\n    }\n    if (n < 1024 * 1024) {\n        return `${(n / 1024).toFixed(1)} KB`;\n    }\n    return `${(n / 1024 / 1024).toFixed(1)} MB`;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}