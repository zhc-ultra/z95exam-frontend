{"ast":null,"code":"import _slicedToArray from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport var PieceTreeTextBuffer = /*#__PURE__*/function (_Disposable) {\n  function PieceTreeTextBuffer(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n    var _this;\n    _classCallCheck(this, PieceTreeTextBuffer);\n    _this = _callSuper(this, PieceTreeTextBuffer);\n    _this._onDidChangeContent = _this._register(new Emitter());\n    _this._BOM = BOM;\n    _this._mightContainNonBasicASCII = !isBasicASCII;\n    _this._mightContainRTL = containsRTL;\n    _this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n    _this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    return _this;\n  }\n  _inherits(PieceTreeTextBuffer, _Disposable);\n  return _createClass(PieceTreeTextBuffer, [{\n    key: \"mightContainRTL\",\n    value: function mightContainRTL() {\n      return this._mightContainRTL;\n    }\n  }, {\n    key: \"mightContainUnusualLineTerminators\",\n    value: function mightContainUnusualLineTerminators() {\n      return this._mightContainUnusualLineTerminators;\n    }\n  }, {\n    key: \"resetMightContainUnusualLineTerminators\",\n    value: function resetMightContainUnusualLineTerminators() {\n      this._mightContainUnusualLineTerminators = false;\n    }\n  }, {\n    key: \"mightContainNonBasicASCII\",\n    value: function mightContainNonBasicASCII() {\n      return this._mightContainNonBasicASCII;\n    }\n  }, {\n    key: \"getBOM\",\n    value: function getBOM() {\n      return this._BOM;\n    }\n  }, {\n    key: \"getEOL\",\n    value: function getEOL() {\n      return this._pieceTree.getEOL();\n    }\n  }, {\n    key: \"createSnapshot\",\n    value: function createSnapshot(preserveBOM) {\n      return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n  }, {\n    key: \"getOffsetAt\",\n    value: function getOffsetAt(lineNumber, column) {\n      return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n  }, {\n    key: \"getPositionAt\",\n    value: function getPositionAt(offset) {\n      return this._pieceTree.getPositionAt(offset);\n    }\n  }, {\n    key: \"getRangeAt\",\n    value: function getRangeAt(start, length) {\n      var end = start + length;\n      var startPosition = this.getPositionAt(start);\n      var endPosition = this.getPositionAt(end);\n      return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n  }, {\n    key: \"getValueInRange\",\n    value: function getValueInRange(range) {\n      var eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      if (range.isEmpty()) {\n        return '';\n      }\n      var lineEnding = this._getEndOfLine(eol);\n      return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n  }, {\n    key: \"getValueLengthInRange\",\n    value: function getValueLengthInRange(range) {\n      var eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      if (range.isEmpty()) {\n        return 0;\n      }\n      if (range.startLineNumber === range.endLineNumber) {\n        return range.endColumn - range.startColumn;\n      }\n      var startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n      var endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n      // offsets use the text EOL, so we need to compensate for length differences\n      // if the requested EOL doesn't match the text EOL\n      var eolOffsetCompensation = 0;\n      var desiredEOL = this._getEndOfLine(eol);\n      var actualEOL = this.getEOL();\n      if (desiredEOL.length !== actualEOL.length) {\n        var delta = desiredEOL.length - actualEOL.length;\n        var eolCount = range.endLineNumber - range.startLineNumber;\n        eolOffsetCompensation = delta * eolCount;\n      }\n      return endOffset - startOffset + eolOffsetCompensation;\n    }\n  }, {\n    key: \"getCharacterCountInRange\",\n    value: function getCharacterCountInRange(range) {\n      var eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      if (this._mightContainNonBasicASCII) {\n        // we must count by iterating\n        var result = 0;\n        var fromLineNumber = range.startLineNumber;\n        var toLineNumber = range.endLineNumber;\n        for (var lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n          var lineContent = this.getLineContent(lineNumber);\n          var fromOffset = lineNumber === fromLineNumber ? range.startColumn - 1 : 0;\n          var toOffset = lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length;\n          for (var offset = fromOffset; offset < toOffset; offset++) {\n            if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n              result = result + 1;\n              offset = offset + 1;\n            } else {\n              result = result + 1;\n            }\n          }\n        }\n        result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n        return result;\n      }\n      return this.getValueLengthInRange(range, eol);\n    }\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return this._pieceTree.getLength();\n    }\n  }, {\n    key: \"getLineCount\",\n    value: function getLineCount() {\n      return this._pieceTree.getLineCount();\n    }\n  }, {\n    key: \"getLinesContent\",\n    value: function getLinesContent() {\n      return this._pieceTree.getLinesContent();\n    }\n  }, {\n    key: \"getLineContent\",\n    value: function getLineContent(lineNumber) {\n      return this._pieceTree.getLineContent(lineNumber);\n    }\n  }, {\n    key: \"getLineCharCode\",\n    value: function getLineCharCode(lineNumber, index) {\n      return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n  }, {\n    key: \"getLineLength\",\n    value: function getLineLength(lineNumber) {\n      return this._pieceTree.getLineLength(lineNumber);\n    }\n  }, {\n    key: \"getLineFirstNonWhitespaceColumn\",\n    value: function getLineFirstNonWhitespaceColumn(lineNumber) {\n      var result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n      if (result === -1) {\n        return 0;\n      }\n      return result + 1;\n    }\n  }, {\n    key: \"getLineLastNonWhitespaceColumn\",\n    value: function getLineLastNonWhitespaceColumn(lineNumber) {\n      var result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n      if (result === -1) {\n        return 0;\n      }\n      return result + 2;\n    }\n  }, {\n    key: \"_getEndOfLine\",\n    value: function _getEndOfLine(eol) {\n      switch (eol) {\n        case 1 /* EndOfLinePreference.LF */:\n          return '\\n';\n        case 2 /* EndOfLinePreference.CRLF */:\n          return '\\r\\n';\n        case 0 /* EndOfLinePreference.TextDefined */:\n          return this.getEOL();\n        default:\n          throw new Error('Unknown EOL preference');\n      }\n    }\n  }, {\n    key: \"setEOL\",\n    value: function setEOL(newEOL) {\n      this._pieceTree.setEOL(newEOL);\n    }\n  }, {\n    key: \"applyEdits\",\n    value: function applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n      var mightContainRTL = this._mightContainRTL;\n      var mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n      var mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n      var canReduceOperations = true;\n      var operations = [];\n      for (var i = 0; i < rawOperations.length; i++) {\n        var op = rawOperations[i];\n        if (canReduceOperations && op._isTracked) {\n          canReduceOperations = false;\n        }\n        var validatedRange = op.range;\n        if (op.text) {\n          var textMightContainNonBasicASCII = true;\n          if (!mightContainNonBasicASCII) {\n            textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n            mightContainNonBasicASCII = textMightContainNonBasicASCII;\n          }\n          if (!mightContainRTL && textMightContainNonBasicASCII) {\n            // check if the new inserted text contains RTL\n            mightContainRTL = strings.containsRTL(op.text);\n          }\n          if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n            // check if the new inserted text contains unusual line terminators\n            mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n          }\n        }\n        var validText = '';\n        var eolCount = 0;\n        var firstLineLength = 0;\n        var lastLineLength = 0;\n        if (op.text) {\n          var strEOL = void 0;\n          var _countEOL = countEOL(op.text);\n          var _countEOL2 = _slicedToArray(_countEOL, 4);\n          eolCount = _countEOL2[0];\n          firstLineLength = _countEOL2[1];\n          lastLineLength = _countEOL2[2];\n          strEOL = _countEOL2[3];\n          var bufferEOL = this.getEOL();\n          var expectedStrEOL = bufferEOL === '\\r\\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */;\n          if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {\n            validText = op.text;\n          } else {\n            validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n          }\n        }\n        operations[i] = {\n          sortIndex: i,\n          identifier: op.identifier || null,\n          range: validatedRange,\n          rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n          rangeLength: this.getValueLengthInRange(validatedRange),\n          text: validText,\n          eolCount: eolCount,\n          firstLineLength: firstLineLength,\n          lastLineLength: lastLineLength,\n          forceMoveMarkers: Boolean(op.forceMoveMarkers),\n          isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n        };\n      }\n      // Sort operations ascending\n      operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n      var hasTouchingRanges = false;\n      for (var _i = 0, count = operations.length - 1; _i < count; _i++) {\n        var rangeEnd = operations[_i].range.getEndPosition();\n        var nextRangeStart = operations[_i + 1].range.getStartPosition();\n        if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n          if (nextRangeStart.isBefore(rangeEnd)) {\n            // overlapping ranges\n            throw new Error('Overlapping ranges are not allowed!');\n          }\n          hasTouchingRanges = true;\n        }\n      }\n      if (canReduceOperations) {\n        operations = this._reduceOperations(operations);\n      }\n      // Delta encode operations\n      var reverseRanges = computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : [];\n      var newTrimAutoWhitespaceCandidates = [];\n      if (recordTrimAutoWhitespace) {\n        for (var _i2 = 0; _i2 < operations.length; _i2++) {\n          var _op = operations[_i2];\n          var reverseRange = reverseRanges[_i2];\n          if (_op.isAutoWhitespaceEdit && _op.range.isEmpty()) {\n            // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n            for (var lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n              var currentLineContent = '';\n              if (lineNumber === reverseRange.startLineNumber) {\n                currentLineContent = this.getLineContent(_op.range.startLineNumber);\n                if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                  continue;\n                }\n              }\n              newTrimAutoWhitespaceCandidates.push({\n                lineNumber: lineNumber,\n                oldContent: currentLineContent\n              });\n            }\n          }\n        }\n      }\n      var reverseOperations = null;\n      if (computeUndoEdits) {\n        var reverseRangeDeltaOffset = 0;\n        reverseOperations = [];\n        for (var _i3 = 0; _i3 < operations.length; _i3++) {\n          var _op2 = operations[_i3];\n          var _reverseRange = reverseRanges[_i3];\n          var bufferText = this.getValueInRange(_op2.range);\n          var reverseRangeOffset = _op2.rangeOffset + reverseRangeDeltaOffset;\n          reverseRangeDeltaOffset += _op2.text.length - bufferText.length;\n          reverseOperations[_i3] = {\n            sortIndex: _op2.sortIndex,\n            identifier: _op2.identifier,\n            range: _reverseRange,\n            text: bufferText,\n            textChange: new TextChange(_op2.rangeOffset, bufferText, reverseRangeOffset, _op2.text)\n          };\n        }\n        // Can only sort reverse operations when the order is not significant\n        if (!hasTouchingRanges) {\n          reverseOperations.sort(function (a, b) {\n            return a.sortIndex - b.sortIndex;\n          });\n        }\n      }\n      this._mightContainRTL = mightContainRTL;\n      this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n      this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n      var contentChanges = this._doApplyEdits(operations);\n      var trimAutoWhitespaceLineNumbers = null;\n      if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n        // sort line numbers auto whitespace removal candidates for next edit descending\n        newTrimAutoWhitespaceCandidates.sort(function (a, b) {\n          return b.lineNumber - a.lineNumber;\n        });\n        trimAutoWhitespaceLineNumbers = [];\n        for (var _i4 = 0, len = newTrimAutoWhitespaceCandidates.length; _i4 < len; _i4++) {\n          var _lineNumber = newTrimAutoWhitespaceCandidates[_i4].lineNumber;\n          if (_i4 > 0 && newTrimAutoWhitespaceCandidates[_i4 - 1].lineNumber === _lineNumber) {\n            // Do not have the same line number twice\n            continue;\n          }\n          var prevContent = newTrimAutoWhitespaceCandidates[_i4].oldContent;\n          var lineContent = this.getLineContent(_lineNumber);\n          if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n            continue;\n          }\n          trimAutoWhitespaceLineNumbers.push(_lineNumber);\n        }\n      }\n      this._onDidChangeContent.fire();\n      return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n  }, {\n    key: \"_reduceOperations\",\n    value: function _reduceOperations(operations) {\n      if (operations.length < 1000) {\n        // We know from empirical testing that a thousand edits work fine regardless of their shape.\n        return operations;\n      }\n      // At one point, due to how events are emitted and how each operation is handled,\n      // some operations can trigger a high amount of temporary string allocations,\n      // that will immediately get edited again.\n      // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n      // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n      return [this._toSingleEditOperation(operations)];\n    }\n  }, {\n    key: \"_toSingleEditOperation\",\n    value: function _toSingleEditOperation(operations) {\n      var forceMoveMarkers = false;\n      var firstEditRange = operations[0].range;\n      var lastEditRange = operations[operations.length - 1].range;\n      var entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n      var lastEndLineNumber = firstEditRange.startLineNumber;\n      var lastEndColumn = firstEditRange.startColumn;\n      var result = [];\n      for (var i = 0, len = operations.length; i < len; i++) {\n        var operation = operations[i];\n        var range = operation.range;\n        forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n        // (1) -- Push old text\n        result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n        // (2) -- Push new text\n        if (operation.text.length > 0) {\n          result.push(operation.text);\n        }\n        lastEndLineNumber = range.endLineNumber;\n        lastEndColumn = range.endColumn;\n      }\n      var text = result.join('');\n      var _countEOL3 = countEOL(text),\n        _countEOL4 = _slicedToArray(_countEOL3, 3),\n        eolCount = _countEOL4[0],\n        firstLineLength = _countEOL4[1],\n        lastLineLength = _countEOL4[2];\n      return {\n        sortIndex: 0,\n        identifier: operations[0].identifier,\n        range: entireEditRange,\n        rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n        rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),\n        text: text,\n        eolCount: eolCount,\n        firstLineLength: firstLineLength,\n        lastLineLength: lastLineLength,\n        forceMoveMarkers: forceMoveMarkers,\n        isAutoWhitespaceEdit: false\n      };\n    }\n  }, {\n    key: \"_doApplyEdits\",\n    value: function _doApplyEdits(operations) {\n      operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n      var contentChanges = [];\n      // operations are from bottom to top\n      for (var i = 0; i < operations.length; i++) {\n        var op = operations[i];\n        var startLineNumber = op.range.startLineNumber;\n        var startColumn = op.range.startColumn;\n        var endLineNumber = op.range.endLineNumber;\n        var endColumn = op.range.endColumn;\n        if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n          // no-op\n          continue;\n        }\n        if (op.text) {\n          // replacement\n          this._pieceTree[\"delete\"](op.rangeOffset, op.rangeLength);\n          this._pieceTree.insert(op.rangeOffset, op.text, true);\n        } else {\n          // deletion\n          this._pieceTree[\"delete\"](op.rangeOffset, op.rangeLength);\n        }\n        var contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n        contentChanges.push({\n          range: contentChangeRange,\n          rangeLength: op.rangeLength,\n          text: op.text,\n          rangeOffset: op.rangeOffset,\n          forceMoveMarkers: op.forceMoveMarkers\n        });\n      }\n      return contentChanges;\n    }\n  }, {\n    key: \"findMatchesLineByLine\",\n    value: function findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n      return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n  }], [{\n    key: \"_getInverseEditRanges\",\n    value: function _getInverseEditRanges(operations) {\n      var result = [];\n      var prevOpEndLineNumber = 0;\n      var prevOpEndColumn = 0;\n      var prevOp = null;\n      for (var i = 0, len = operations.length; i < len; i++) {\n        var op = operations[i];\n        var startLineNumber = void 0;\n        var startColumn = void 0;\n        if (prevOp) {\n          if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n            startLineNumber = prevOpEndLineNumber;\n            startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n          } else {\n            startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n            startColumn = op.range.startColumn;\n          }\n        } else {\n          startLineNumber = op.range.startLineNumber;\n          startColumn = op.range.startColumn;\n        }\n        var resultRange = void 0;\n        if (op.text.length > 0) {\n          // the operation inserts something\n          var lineCount = op.eolCount + 1;\n          if (lineCount === 1) {\n            // single line insert\n            resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n          } else {\n            // multi line insert\n            resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n          }\n        } else {\n          // There is nothing to insert\n          resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n        }\n        prevOpEndLineNumber = resultRange.endLineNumber;\n        prevOpEndColumn = resultRange.endColumn;\n        result.push(resultRange);\n        prevOp = op;\n      }\n      return result;\n    }\n  }, {\n    key: \"_sortOpsAscending\",\n    value: function _sortOpsAscending(a, b) {\n      var r = Range.compareRangesUsingEnds(a.range, b.range);\n      if (r === 0) {\n        return a.sortIndex - b.sortIndex;\n      }\n      return r;\n    }\n  }, {\n    key: \"_sortOpsDescending\",\n    value: function _sortOpsDescending(a, b) {\n      var r = Range.compareRangesUsingEnds(a.range, b.range);\n      if (r === 0) {\n        return b.sortIndex - a.sortIndex;\n      }\n      return -r;\n    }\n  }]);\n}(Disposable);","map":{"version":3,"names":["Emitter","strings","Range","ApplyEditsResult","PieceTreeBase","countEOL","TextChange","Disposable","PieceTreeTextBuffer","_Disposable","chunks","BOM","eol","containsRTL","containsUnusualLineTerminators","isBasicASCII","eolNormalized","_this","_classCallCheck","_callSuper","_onDidChangeContent","_register","_BOM","_mightContainNonBasicASCII","_mightContainRTL","_mightContainUnusualLineTerminators","_pieceTree","_inherits","_createClass","key","value","mightContainRTL","mightContainUnusualLineTerminators","resetMightContainUnusualLineTerminators","mightContainNonBasicASCII","getBOM","getEOL","createSnapshot","preserveBOM","getOffsetAt","lineNumber","column","getPositionAt","offset","getRangeAt","start","length","end","startPosition","endPosition","getValueInRange","range","arguments","undefined","isEmpty","lineEnding","_getEndOfLine","getValueLengthInRange","startLineNumber","endLineNumber","endColumn","startColumn","startOffset","endOffset","eolOffsetCompensation","desiredEOL","actualEOL","delta","eolCount","getCharacterCountInRange","result","fromLineNumber","toLineNumber","lineContent","getLineContent","fromOffset","toOffset","isHighSurrogate","charCodeAt","getLength","getLineCount","getLinesContent","getLineCharCode","index","getLineLength","getLineFirstNonWhitespaceColumn","firstNonWhitespaceIndex","getLineLastNonWhitespaceColumn","lastNonWhitespaceIndex","Error","setEOL","newEOL","applyEdits","rawOperations","recordTrimAutoWhitespace","computeUndoEdits","canReduceOperations","operations","i","op","_isTracked","validatedRange","text","textMightContainNonBasicASCII","validText","firstLineLength","lastLineLength","strEOL","_countEOL","_countEOL2","_slicedToArray","bufferEOL","expectedStrEOL","replace","sortIndex","identifier","rangeOffset","rangeLength","forceMoveMarkers","Boolean","isAutoWhitespaceEdit","sort","_sortOpsAscending","hasTouchingRanges","count","rangeEnd","getEndPosition","nextRangeStart","getStartPosition","isBeforeOrEqual","isBefore","_reduceOperations","reverseRanges","_getInverseEditRanges","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","push","oldContent","reverseOperations","reverseRangeDeltaOffset","bufferText","reverseRangeOffset","textChange","a","b","contentChanges","_doApplyEdits","trimAutoWhitespaceLineNumbers","len","prevContent","fire","_toSingleEditOperation","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","join","_countEOL3","_countEOL4","_sortOpsDescending","insert","contentChangeRange","findMatchesLineByLine","searchRange","searchData","captureMatches","limitResultCount","prevOpEndLineNumber","prevOpEndColumn","prevOp","resultRange","lineCount","r","compareRangesUsingEnds"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(new Emitter());\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        const end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    getValueInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        // offsets use the text EOL, so we need to compensate for length differences\n        // if the requested EOL doesn't match the text EOL\n        let eolOffsetCompensation = 0;\n        const desiredEOL = this._getEndOfLine(eol);\n        const actualEOL = this.getEOL();\n        if (desiredEOL.length !== actualEOL.length) {\n            const delta = desiredEOL.length - actualEOL.length;\n            const eolCount = range.endLineNumber - range.startLineNumber;\n            eolOffsetCompensation = delta * eolCount;\n        }\n        return endOffset - startOffset + eolOffsetCompensation;\n    }\n    getCharacterCountInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (this._mightContainNonBasicASCII) {\n            // we must count by iterating\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 /* EndOfLinePreference.LF */:\n                return '\\n';\n            case 2 /* EndOfLinePreference.CRLF */:\n                return '\\r\\n';\n            case 0 /* EndOfLinePreference.TextDefined */:\n                return this.getEOL();\n            default:\n                throw new Error('Unknown EOL preference');\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            const op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            const validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = strings.containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains unusual line terminators\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */);\n                if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            const rangeEnd = operations[i].range.getEndPosition();\n            const nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        const newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                const lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n            // (2) -- Push new text\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        const contentChanges = [];\n        // operations are from bottom to top\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                // no-op\n                continue;\n            }\n            if (op.text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    static _getInverseEditRanges(operations) {\n        const result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                // the operation inserts something\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}