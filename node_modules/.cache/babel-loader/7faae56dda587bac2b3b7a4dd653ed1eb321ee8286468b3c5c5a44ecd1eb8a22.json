{"ast":null,"code":"import _toConsumableArray from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.every.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { FoldingRegions } from './foldingRanges.js';\nimport { hash } from '../../../../base/common/hash.js';\nexport var FoldingModel = /*#__PURE__*/function () {\n  function FoldingModel(textModel, decorationProvider) {\n    _classCallCheck(this, FoldingModel);\n    this._updateEventEmitter = new Emitter();\n    this.onDidChange = this._updateEventEmitter.event;\n    this._textModel = textModel;\n    this._decorationProvider = decorationProvider;\n    this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));\n    this._editorDecorationIds = [];\n  }\n  return _createClass(FoldingModel, [{\n    key: \"regions\",\n    get: function get() {\n      return this._regions;\n    }\n  }, {\n    key: \"textModel\",\n    get: function get() {\n      return this._textModel;\n    }\n  }, {\n    key: \"toggleCollapseState\",\n    value: function toggleCollapseState(toggledRegions) {\n      var _this = this;\n      if (!toggledRegions.length) {\n        return;\n      }\n      toggledRegions = toggledRegions.sort(function (r1, r2) {\n        return r1.regionIndex - r2.regionIndex;\n      });\n      var processed = {};\n      this._decorationProvider.changeDecorations(function (accessor) {\n        var k = 0; // index from [0 ... this.regions.length]\n        var dirtyRegionEndLine = -1; // end of the range where decorations need to be updated\n        var lastHiddenLine = -1; // the end of the last hidden lines\n        var updateDecorationsUntil = function updateDecorationsUntil(index) {\n          while (k < index) {\n            var endLineNumber = _this._regions.getEndLineNumber(k);\n            var isCollapsed = _this._regions.isCollapsed(k);\n            if (endLineNumber <= dirtyRegionEndLine) {\n              var isManual = _this.regions.getSource(k) !== 0 /* FoldSource.provider */;\n              accessor.changeDecorationOptions(_this._editorDecorationIds[k], _this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual));\n            }\n            if (isCollapsed && endLineNumber > lastHiddenLine) {\n              lastHiddenLine = endLineNumber;\n            }\n            k++;\n          }\n        };\n        var _iterator = _createForOfIteratorHelper(toggledRegions),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var region = _step.value;\n            var index = region.regionIndex;\n            var editorDecorationId = _this._editorDecorationIds[index];\n            if (editorDecorationId && !processed[editorDecorationId]) {\n              processed[editorDecorationId] = true;\n              updateDecorationsUntil(index); // update all decorations up to current index using the old dirtyRegionEndLine\n              var newCollapseState = !_this._regions.isCollapsed(index);\n              _this._regions.setCollapsed(index, newCollapseState);\n              dirtyRegionEndLine = Math.max(dirtyRegionEndLine, _this._regions.getEndLineNumber(index));\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        updateDecorationsUntil(_this._regions.length);\n      });\n      this._updateEventEmitter.fire({\n        model: this,\n        collapseStateChanged: toggledRegions\n      });\n    }\n  }, {\n    key: \"removeManualRanges\",\n    value: function removeManualRanges(ranges) {\n      var newFoldingRanges = new Array();\n      var intersects = function intersects(foldRange) {\n        var _iterator2 = _createForOfIteratorHelper(ranges),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var range = _step2.value;\n            if (!(range.startLineNumber > foldRange.endLineNumber || foldRange.startLineNumber > range.endLineNumber)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        return false;\n      };\n      for (var i = 0; i < this._regions.length; i++) {\n        var foldRange = this._regions.toFoldRange(i);\n        if (foldRange.source === 0 /* FoldSource.provider */ || !intersects(foldRange)) {\n          newFoldingRanges.push(foldRange);\n        }\n      }\n      this.updatePost(FoldingRegions.fromFoldRanges(newFoldingRanges));\n    }\n  }, {\n    key: \"update\",\n    value: function update(newRegions) {\n      var blockedLineNumers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var foldedOrManualRanges = this._currentFoldedOrManualRanges(blockedLineNumers);\n      var newRanges = FoldingRegions.sanitizeAndMerge(newRegions, foldedOrManualRanges, this._textModel.getLineCount());\n      this.updatePost(FoldingRegions.fromFoldRanges(newRanges));\n    }\n  }, {\n    key: \"updatePost\",\n    value: function updatePost(newRegions) {\n      var _this2 = this;\n      var newEditorDecorations = [];\n      var lastHiddenLine = -1;\n      for (var index = 0, limit = newRegions.length; index < limit; index++) {\n        var startLineNumber = newRegions.getStartLineNumber(index);\n        var endLineNumber = newRegions.getEndLineNumber(index);\n        var isCollapsed = newRegions.isCollapsed(index);\n        var isManual = newRegions.getSource(index) !== 0 /* FoldSource.provider */;\n        var decorationRange = {\n          startLineNumber: startLineNumber,\n          startColumn: this._textModel.getLineMaxColumn(startLineNumber),\n          endLineNumber: endLineNumber,\n          endColumn: this._textModel.getLineMaxColumn(endLineNumber) + 1\n        };\n        newEditorDecorations.push({\n          range: decorationRange,\n          options: this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual)\n        });\n        if (isCollapsed && endLineNumber > lastHiddenLine) {\n          lastHiddenLine = endLineNumber;\n        }\n      }\n      this._decorationProvider.changeDecorations(function (accessor) {\n        return _this2._editorDecorationIds = accessor.deltaDecorations(_this2._editorDecorationIds, newEditorDecorations);\n      });\n      this._regions = newRegions;\n      this._updateEventEmitter.fire({\n        model: this\n      });\n    }\n  }, {\n    key: \"_currentFoldedOrManualRanges\",\n    value: function _currentFoldedOrManualRanges() {\n      var blockedLineNumers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var isBlocked = function isBlocked(startLineNumber, endLineNumber) {\n        var _iterator3 = _createForOfIteratorHelper(blockedLineNumers),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var blockedLineNumber = _step3.value;\n            if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) {\n              // first line is visible\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        return false;\n      };\n      var foldedRanges = [];\n      for (var i = 0, limit = this._regions.length; i < limit; i++) {\n        var isCollapsed = this.regions.isCollapsed(i);\n        var source = this.regions.getSource(i);\n        if (isCollapsed || source !== 0 /* FoldSource.provider */) {\n          var foldRange = this._regions.toFoldRange(i);\n          var decRange = this._textModel.getDecorationRange(this._editorDecorationIds[i]);\n          if (decRange) {\n            if (isCollapsed && isBlocked(decRange.startLineNumber, decRange.endLineNumber)) {\n              isCollapsed = false; // uncollapse is the range is blocked\n            }\n            foldedRanges.push({\n              startLineNumber: decRange.startLineNumber,\n              endLineNumber: decRange.endLineNumber,\n              type: foldRange.type,\n              isCollapsed: isCollapsed,\n              source: source\n            });\n          }\n        }\n      }\n      return foldedRanges;\n    }\n    /**\n     * Collapse state memento, for persistence only\n     */\n  }, {\n    key: \"getMemento\",\n    value: function getMemento() {\n      var foldedOrManualRanges = this._currentFoldedOrManualRanges();\n      var result = [];\n      var maxLineNumber = this._textModel.getLineCount();\n      for (var i = 0, limit = foldedOrManualRanges.length; i < limit; i++) {\n        var range = foldedOrManualRanges[i];\n        if (range.startLineNumber >= range.endLineNumber || range.startLineNumber < 1 || range.endLineNumber > maxLineNumber) {\n          continue;\n        }\n        var checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);\n        result.push({\n          startLineNumber: range.startLineNumber,\n          endLineNumber: range.endLineNumber,\n          isCollapsed: range.isCollapsed,\n          source: range.source,\n          checksum: checksum\n        });\n      }\n      return result.length > 0 ? result : undefined;\n    }\n    /**\n     * Apply persisted state, for persistence only\n     */\n  }, {\n    key: \"applyMemento\",\n    value: function applyMemento(state) {\n      var _a, _b;\n      if (!Array.isArray(state)) {\n        return;\n      }\n      var rangesToRestore = [];\n      var maxLineNumber = this._textModel.getLineCount();\n      var _iterator4 = _createForOfIteratorHelper(state),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var range = _step4.value;\n          if (range.startLineNumber >= range.endLineNumber || range.startLineNumber < 1 || range.endLineNumber > maxLineNumber) {\n            continue;\n          }\n          var checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);\n          if (!range.checksum || checksum === range.checksum) {\n            rangesToRestore.push({\n              startLineNumber: range.startLineNumber,\n              endLineNumber: range.endLineNumber,\n              type: undefined,\n              isCollapsed: (_a = range.isCollapsed) !== null && _a !== void 0 ? _a : true,\n              source: (_b = range.source) !== null && _b !== void 0 ? _b : 0 /* FoldSource.provider */\n            });\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      var newRanges = FoldingRegions.sanitizeAndMerge(this._regions, rangesToRestore, maxLineNumber);\n      this.updatePost(FoldingRegions.fromFoldRanges(newRanges));\n    }\n  }, {\n    key: \"_getLinesChecksum\",\n    value: function _getLinesChecksum(lineNumber1, lineNumber2) {\n      var h = hash(this._textModel.getLineContent(lineNumber1) + this._textModel.getLineContent(lineNumber2));\n      return h % 1000000; // 6 digits is plenty\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this._decorationProvider.removeDecorations(this._editorDecorationIds);\n    }\n  }, {\n    key: \"getAllRegionsAtLine\",\n    value: function getAllRegionsAtLine(lineNumber, filter) {\n      var result = [];\n      if (this._regions) {\n        var index = this._regions.findRange(lineNumber);\n        var level = 1;\n        while (index >= 0) {\n          var current = this._regions.toRegion(index);\n          if (!filter || filter(current, level)) {\n            result.push(current);\n          }\n          level++;\n          index = current.parentIndex;\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"getRegionAtLine\",\n    value: function getRegionAtLine(lineNumber) {\n      if (this._regions) {\n        var index = this._regions.findRange(lineNumber);\n        if (index >= 0) {\n          return this._regions.toRegion(index);\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"getRegionsInside\",\n    value: function getRegionsInside(region, filter) {\n      var result = [];\n      var index = region ? region.regionIndex + 1 : 0;\n      var endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\n      if (filter && filter.length === 2) {\n        var levelStack = [];\n        for (var i = index, len = this._regions.length; i < len; i++) {\n          var current = this._regions.toRegion(i);\n          if (this._regions.getStartLineNumber(i) < endLineNumber) {\n            while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {\n              levelStack.pop();\n            }\n            levelStack.push(current);\n            if (filter(current, levelStack.length)) {\n              result.push(current);\n            }\n          } else {\n            break;\n          }\n        }\n      } else {\n        for (var _i = index, _len = this._regions.length; _i < _len; _i++) {\n          var _current = this._regions.toRegion(_i);\n          if (this._regions.getStartLineNumber(_i) < endLineNumber) {\n            if (!filter || filter(_current)) {\n              result.push(_current);\n            }\n          } else {\n            break;\n          }\n        }\n      }\n      return result;\n    }\n  }]);\n}();\n/**\n * Collapse or expand the regions at the given locations\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function toggleCollapseState(foldingModel, levels, lineNumbers) {\n  var toToggle = [];\n  var _iterator5 = _createForOfIteratorHelper(lineNumbers),\n    _step5;\n  try {\n    var _loop = function _loop() {\n      var lineNumber = _step5.value;\n      var region = foldingModel.getRegionAtLine(lineNumber);\n      if (region) {\n        var doCollapse = !region.isCollapsed;\n        toToggle.push(region);\n        if (levels > 1) {\n          var regionsInside = foldingModel.getRegionsInside(region, function (r, level) {\n            return r.isCollapsed !== doCollapse && level < levels;\n          });\n          toToggle.push.apply(toToggle, _toConsumableArray(regionsInside));\n        }\n      }\n    };\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand the regions at the given locations including all children.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function setCollapseStateLevelsDown(foldingModel, doCollapse) {\n  var levels = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.MAX_VALUE;\n  var lineNumbers = arguments.length > 3 ? arguments[3] : undefined;\n  var toToggle = [];\n  if (lineNumbers && lineNumbers.length > 0) {\n    var _iterator6 = _createForOfIteratorHelper(lineNumbers),\n      _step6;\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var lineNumber = _step6.value;\n        var region = foldingModel.getRegionAtLine(lineNumber);\n        if (region) {\n          if (region.isCollapsed !== doCollapse) {\n            toToggle.push(region);\n          }\n          if (levels > 1) {\n            var regionsInside = foldingModel.getRegionsInside(region, function (r, level) {\n              return r.isCollapsed !== doCollapse && level < levels;\n            });\n            toToggle.push.apply(toToggle, _toConsumableArray(regionsInside));\n          }\n        }\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n  } else {\n    var _regionsInside = foldingModel.getRegionsInside(null, function (r, level) {\n      return r.isCollapsed !== doCollapse && level < levels;\n    });\n    toToggle.push.apply(toToggle, _toConsumableArray(_regionsInside));\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand the regions at the given locations including all parents.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand.\n */\nexport function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {\n  var toToggle = [];\n  var _iterator7 = _createForOfIteratorHelper(lineNumbers),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var lineNumber = _step7.value;\n      var regions = foldingModel.getAllRegionsAtLine(lineNumber, function (region, level) {\n        return region.isCollapsed !== doCollapse && level <= levels;\n      });\n      toToggle.push.apply(toToggle, _toConsumableArray(regions));\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand a region at the given locations. If the inner most region is already collapsed/expanded, uses the first parent instead.\n * @param doCollapse Whether to collapse or expand\n * @param lineNumbers the location of the regions to collapse or expand.\n */\nexport function setCollapseStateUp(foldingModel, doCollapse, lineNumbers) {\n  var toToggle = [];\n  var _iterator8 = _createForOfIteratorHelper(lineNumbers),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var lineNumber = _step8.value;\n      var regions = foldingModel.getAllRegionsAtLine(lineNumber, function (region) {\n        return region.isCollapsed !== doCollapse;\n      });\n      if (regions.length > 0) {\n        toToggle.push(regions[0]);\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.\n * @param foldLevel level. Level == 1 is the top level\n * @param doCollapse Whether to collapse or expand\n*/\nexport function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {\n  var filter = function filter(region, level) {\n    return level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some(function (line) {\n      return region.containsLine(line);\n    });\n  };\n  var toToggle = foldingModel.getRegionsInside(null, filter);\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds or unfolds all regions, except if they contain or are contained by a region of one of the blocked lines.\n * @param doCollapse Whether to collapse or expand\n * @param blockedLineNumbers the location of regions to not collapse or expand\n */\nexport function setCollapseStateForRest(foldingModel, doCollapse, blockedLineNumbers) {\n  var filteredRegions = [];\n  var _iterator9 = _createForOfIteratorHelper(blockedLineNumbers),\n    _step9;\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var lineNumber = _step9.value;\n      var regions = foldingModel.getAllRegionsAtLine(lineNumber, undefined);\n      if (regions.length > 0) {\n        filteredRegions.push(regions[0]);\n      }\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n  var filter = function filter(region) {\n    return filteredRegions.every(function (filteredRegion) {\n      return !filteredRegion.containedBy(region) && !region.containedBy(filteredRegion);\n    }) && region.isCollapsed !== doCollapse;\n  };\n  var toToggle = foldingModel.getRegionsInside(null, filter);\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds all regions for which the lines start with a given regex\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {\n  var editorModel = foldingModel.textModel;\n  var regions = foldingModel.regions;\n  var toToggle = [];\n  for (var i = regions.length - 1; i >= 0; i--) {\n    if (doCollapse !== regions.isCollapsed(i)) {\n      var startLineNumber = regions.getStartLineNumber(i);\n      if (regExp.test(editorModel.getLineContent(startLineNumber))) {\n        toToggle.push(regions.toRegion(i));\n      }\n    }\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds all regions of the given type\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForType(foldingModel, type, doCollapse) {\n  var regions = foldingModel.regions;\n  var toToggle = [];\n  for (var i = regions.length - 1; i >= 0; i--) {\n    if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {\n      toToggle.push(regions.toRegion(i));\n    }\n  }\n  foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Get line to go to for parent fold of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Parent fold start line\n */\nexport function getParentFoldLine(lineNumber, foldingModel) {\n  var startLineNumber = null;\n  var foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n  if (foldingRegion !== null) {\n    startLineNumber = foldingRegion.startLineNumber;\n    // If current line is not the start of the current fold, go to top line of current fold. If not, go to parent fold\n    if (lineNumber === startLineNumber) {\n      var parentFoldingIdx = foldingRegion.parentIndex;\n      if (parentFoldingIdx !== -1) {\n        startLineNumber = foldingModel.regions.getStartLineNumber(parentFoldingIdx);\n      } else {\n        startLineNumber = null;\n      }\n    }\n  }\n  return startLineNumber;\n}\n/**\n * Get line to go to for previous fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Previous fold start line\n */\nexport function getPreviousFoldLine(lineNumber, foldingModel) {\n  var foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n  // If on the folding range start line, go to previous sibling.\n  if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {\n    // If current line is not the start of the current fold, go to top line of current fold. If not, go to previous fold.\n    if (lineNumber !== foldingRegion.startLineNumber) {\n      return foldingRegion.startLineNumber;\n    } else {\n      // Find min line number to stay within parent.\n      var expectedParentIndex = foldingRegion.parentIndex;\n      var minLineNumber = 0;\n      if (expectedParentIndex !== -1) {\n        minLineNumber = foldingModel.regions.getStartLineNumber(foldingRegion.parentIndex);\n      }\n      // Find fold at same level.\n      while (foldingRegion !== null) {\n        if (foldingRegion.regionIndex > 0) {\n          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);\n          // Keep at same level.\n          if (foldingRegion.startLineNumber <= minLineNumber) {\n            return null;\n          } else if (foldingRegion.parentIndex === expectedParentIndex) {\n            return foldingRegion.startLineNumber;\n          }\n        } else {\n          return null;\n        }\n      }\n    }\n  } else {\n    // Go to last fold that's before the current line.\n    if (foldingModel.regions.length > 0) {\n      foldingRegion = foldingModel.regions.toRegion(foldingModel.regions.length - 1);\n      while (foldingRegion !== null) {\n        // Found fold before current line.\n        if (foldingRegion.startLineNumber < lineNumber) {\n          return foldingRegion.startLineNumber;\n        }\n        if (foldingRegion.regionIndex > 0) {\n          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);\n        } else {\n          foldingRegion = null;\n        }\n      }\n    }\n  }\n  return null;\n}\n/**\n * Get line to go to next fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Next fold start line\n */\nexport function getNextFoldLine(lineNumber, foldingModel) {\n  var foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n  // If on the folding range start line, go to next sibling.\n  if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {\n    // Find max line number to stay within parent.\n    var expectedParentIndex = foldingRegion.parentIndex;\n    var maxLineNumber = 0;\n    if (expectedParentIndex !== -1) {\n      maxLineNumber = foldingModel.regions.getEndLineNumber(foldingRegion.parentIndex);\n    } else if (foldingModel.regions.length === 0) {\n      return null;\n    } else {\n      maxLineNumber = foldingModel.regions.getEndLineNumber(foldingModel.regions.length - 1);\n    }\n    // Find fold at same level.\n    while (foldingRegion !== null) {\n      if (foldingRegion.regionIndex < foldingModel.regions.length) {\n        foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);\n        // Keep at same level.\n        if (foldingRegion.startLineNumber >= maxLineNumber) {\n          return null;\n        } else if (foldingRegion.parentIndex === expectedParentIndex) {\n          return foldingRegion.startLineNumber;\n        }\n      } else {\n        return null;\n      }\n    }\n  } else {\n    // Go to first fold that's after the current line.\n    if (foldingModel.regions.length > 0) {\n      foldingRegion = foldingModel.regions.toRegion(0);\n      while (foldingRegion !== null) {\n        // Found fold after current line.\n        if (foldingRegion.startLineNumber > lineNumber) {\n          return foldingRegion.startLineNumber;\n        }\n        if (foldingRegion.regionIndex < foldingModel.regions.length) {\n          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);\n        } else {\n          foldingRegion = null;\n        }\n      }\n    }\n  }\n  return null;\n}","map":{"version":3,"names":["Emitter","FoldingRegions","hash","FoldingModel","textModel","decorationProvider","_classCallCheck","_updateEventEmitter","onDidChange","event","_textModel","_decorationProvider","_regions","Uint32Array","_editorDecorationIds","_createClass","key","get","value","toggleCollapseState","toggledRegions","_this","length","sort","r1","r2","regionIndex","processed","changeDecorations","accessor","k","dirtyRegionEndLine","lastHiddenLine","updateDecorationsUntil","index","endLineNumber","getEndLineNumber","isCollapsed","isManual","regions","getSource","changeDecorationOptions","getDecorationOption","_iterator","_createForOfIteratorHelper","_step","s","n","done","region","editorDecorationId","newCollapseState","setCollapsed","Math","max","err","e","f","fire","model","collapseStateChanged","removeManualRanges","ranges","newFoldingRanges","Array","intersects","foldRange","_iterator2","_step2","range","startLineNumber","i","toFoldRange","source","push","updatePost","fromFoldRanges","update","newRegions","blockedLineNumers","arguments","undefined","foldedOrManualRanges","_currentFoldedOrManualRanges","newRanges","sanitizeAndMerge","getLineCount","_this2","newEditorDecorations","limit","getStartLineNumber","decorationRange","startColumn","getLineMaxColumn","endColumn","options","deltaDecorations","isBlocked","_iterator3","_step3","blockedLineNumber","foldedRanges","decRange","getDecorationRange","type","getMemento","result","maxLineNumber","checksum","_getLinesChecksum","applyMemento","state","_a","_b","isArray","rangesToRestore","_iterator4","_step4","lineNumber1","lineNumber2","h","getLineContent","dispose","removeDecorations","getAllRegionsAtLine","lineNumber","filter","findRange","level","current","toRegion","parentIndex","getRegionAtLine","getRegionsInside","Number","MAX_VALUE","levelStack","len","containedBy","pop","foldingModel","levels","lineNumbers","toToggle","_iterator5","_step5","_loop","doCollapse","regionsInside","r","apply","_toConsumableArray","setCollapseStateLevelsDown","_iterator6","_step6","setCollapseStateLevelsUp","_iterator7","_step7","setCollapseStateUp","_iterator8","_step8","setCollapseStateAtLevel","foldLevel","blockedLineNumbers","some","line","containsLine","setCollapseStateForRest","filteredRegions","_iterator9","_step9","every","filteredRegion","setCollapseStateForMatchingLines","regExp","editorModel","test","setCollapseStateForType","getType","getParentFoldLine","foldingRegion","parentFoldingIdx","getPreviousFoldLine","expectedParentIndex","minLineNumber","getNextFoldLine"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { FoldingRegions } from './foldingRanges.js';\nimport { hash } from '../../../../base/common/hash.js';\nexport class FoldingModel {\n    get regions() { return this._regions; }\n    get textModel() { return this._textModel; }\n    constructor(textModel, decorationProvider) {\n        this._updateEventEmitter = new Emitter();\n        this.onDidChange = this._updateEventEmitter.event;\n        this._textModel = textModel;\n        this._decorationProvider = decorationProvider;\n        this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));\n        this._editorDecorationIds = [];\n    }\n    toggleCollapseState(toggledRegions) {\n        if (!toggledRegions.length) {\n            return;\n        }\n        toggledRegions = toggledRegions.sort((r1, r2) => r1.regionIndex - r2.regionIndex);\n        const processed = {};\n        this._decorationProvider.changeDecorations(accessor => {\n            let k = 0; // index from [0 ... this.regions.length]\n            let dirtyRegionEndLine = -1; // end of the range where decorations need to be updated\n            let lastHiddenLine = -1; // the end of the last hidden lines\n            const updateDecorationsUntil = (index) => {\n                while (k < index) {\n                    const endLineNumber = this._regions.getEndLineNumber(k);\n                    const isCollapsed = this._regions.isCollapsed(k);\n                    if (endLineNumber <= dirtyRegionEndLine) {\n                        const isManual = this.regions.getSource(k) !== 0 /* FoldSource.provider */;\n                        accessor.changeDecorationOptions(this._editorDecorationIds[k], this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual));\n                    }\n                    if (isCollapsed && endLineNumber > lastHiddenLine) {\n                        lastHiddenLine = endLineNumber;\n                    }\n                    k++;\n                }\n            };\n            for (const region of toggledRegions) {\n                const index = region.regionIndex;\n                const editorDecorationId = this._editorDecorationIds[index];\n                if (editorDecorationId && !processed[editorDecorationId]) {\n                    processed[editorDecorationId] = true;\n                    updateDecorationsUntil(index); // update all decorations up to current index using the old dirtyRegionEndLine\n                    const newCollapseState = !this._regions.isCollapsed(index);\n                    this._regions.setCollapsed(index, newCollapseState);\n                    dirtyRegionEndLine = Math.max(dirtyRegionEndLine, this._regions.getEndLineNumber(index));\n                }\n            }\n            updateDecorationsUntil(this._regions.length);\n        });\n        this._updateEventEmitter.fire({ model: this, collapseStateChanged: toggledRegions });\n    }\n    removeManualRanges(ranges) {\n        const newFoldingRanges = new Array();\n        const intersects = (foldRange) => {\n            for (const range of ranges) {\n                if (!(range.startLineNumber > foldRange.endLineNumber || foldRange.startLineNumber > range.endLineNumber)) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        for (let i = 0; i < this._regions.length; i++) {\n            const foldRange = this._regions.toFoldRange(i);\n            if (foldRange.source === 0 /* FoldSource.provider */ || !intersects(foldRange)) {\n                newFoldingRanges.push(foldRange);\n            }\n        }\n        this.updatePost(FoldingRegions.fromFoldRanges(newFoldingRanges));\n    }\n    update(newRegions, blockedLineNumers = []) {\n        const foldedOrManualRanges = this._currentFoldedOrManualRanges(blockedLineNumers);\n        const newRanges = FoldingRegions.sanitizeAndMerge(newRegions, foldedOrManualRanges, this._textModel.getLineCount());\n        this.updatePost(FoldingRegions.fromFoldRanges(newRanges));\n    }\n    updatePost(newRegions) {\n        const newEditorDecorations = [];\n        let lastHiddenLine = -1;\n        for (let index = 0, limit = newRegions.length; index < limit; index++) {\n            const startLineNumber = newRegions.getStartLineNumber(index);\n            const endLineNumber = newRegions.getEndLineNumber(index);\n            const isCollapsed = newRegions.isCollapsed(index);\n            const isManual = newRegions.getSource(index) !== 0 /* FoldSource.provider */;\n            const decorationRange = {\n                startLineNumber: startLineNumber,\n                startColumn: this._textModel.getLineMaxColumn(startLineNumber),\n                endLineNumber: endLineNumber,\n                endColumn: this._textModel.getLineMaxColumn(endLineNumber) + 1\n            };\n            newEditorDecorations.push({ range: decorationRange, options: this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual) });\n            if (isCollapsed && endLineNumber > lastHiddenLine) {\n                lastHiddenLine = endLineNumber;\n            }\n        }\n        this._decorationProvider.changeDecorations(accessor => this._editorDecorationIds = accessor.deltaDecorations(this._editorDecorationIds, newEditorDecorations));\n        this._regions = newRegions;\n        this._updateEventEmitter.fire({ model: this });\n    }\n    _currentFoldedOrManualRanges(blockedLineNumers = []) {\n        const isBlocked = (startLineNumber, endLineNumber) => {\n            for (const blockedLineNumber of blockedLineNumers) {\n                if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) { // first line is visible\n                    return true;\n                }\n            }\n            return false;\n        };\n        const foldedRanges = [];\n        for (let i = 0, limit = this._regions.length; i < limit; i++) {\n            let isCollapsed = this.regions.isCollapsed(i);\n            const source = this.regions.getSource(i);\n            if (isCollapsed || source !== 0 /* FoldSource.provider */) {\n                const foldRange = this._regions.toFoldRange(i);\n                const decRange = this._textModel.getDecorationRange(this._editorDecorationIds[i]);\n                if (decRange) {\n                    if (isCollapsed && isBlocked(decRange.startLineNumber, decRange.endLineNumber)) {\n                        isCollapsed = false; // uncollapse is the range is blocked\n                    }\n                    foldedRanges.push({\n                        startLineNumber: decRange.startLineNumber,\n                        endLineNumber: decRange.endLineNumber,\n                        type: foldRange.type,\n                        isCollapsed,\n                        source\n                    });\n                }\n            }\n        }\n        return foldedRanges;\n    }\n    /**\n     * Collapse state memento, for persistence only\n     */\n    getMemento() {\n        const foldedOrManualRanges = this._currentFoldedOrManualRanges();\n        const result = [];\n        const maxLineNumber = this._textModel.getLineCount();\n        for (let i = 0, limit = foldedOrManualRanges.length; i < limit; i++) {\n            const range = foldedOrManualRanges[i];\n            if (range.startLineNumber >= range.endLineNumber || range.startLineNumber < 1 || range.endLineNumber > maxLineNumber) {\n                continue;\n            }\n            const checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);\n            result.push({\n                startLineNumber: range.startLineNumber,\n                endLineNumber: range.endLineNumber,\n                isCollapsed: range.isCollapsed,\n                source: range.source,\n                checksum: checksum\n            });\n        }\n        return (result.length > 0) ? result : undefined;\n    }\n    /**\n     * Apply persisted state, for persistence only\n     */\n    applyMemento(state) {\n        var _a, _b;\n        if (!Array.isArray(state)) {\n            return;\n        }\n        const rangesToRestore = [];\n        const maxLineNumber = this._textModel.getLineCount();\n        for (const range of state) {\n            if (range.startLineNumber >= range.endLineNumber || range.startLineNumber < 1 || range.endLineNumber > maxLineNumber) {\n                continue;\n            }\n            const checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);\n            if (!range.checksum || checksum === range.checksum) {\n                rangesToRestore.push({\n                    startLineNumber: range.startLineNumber,\n                    endLineNumber: range.endLineNumber,\n                    type: undefined,\n                    isCollapsed: (_a = range.isCollapsed) !== null && _a !== void 0 ? _a : true,\n                    source: (_b = range.source) !== null && _b !== void 0 ? _b : 0 /* FoldSource.provider */\n                });\n            }\n        }\n        const newRanges = FoldingRegions.sanitizeAndMerge(this._regions, rangesToRestore, maxLineNumber);\n        this.updatePost(FoldingRegions.fromFoldRanges(newRanges));\n    }\n    _getLinesChecksum(lineNumber1, lineNumber2) {\n        const h = hash(this._textModel.getLineContent(lineNumber1)\n            + this._textModel.getLineContent(lineNumber2));\n        return h % 1000000; // 6 digits is plenty\n    }\n    dispose() {\n        this._decorationProvider.removeDecorations(this._editorDecorationIds);\n    }\n    getAllRegionsAtLine(lineNumber, filter) {\n        const result = [];\n        if (this._regions) {\n            let index = this._regions.findRange(lineNumber);\n            let level = 1;\n            while (index >= 0) {\n                const current = this._regions.toRegion(index);\n                if (!filter || filter(current, level)) {\n                    result.push(current);\n                }\n                level++;\n                index = current.parentIndex;\n            }\n        }\n        return result;\n    }\n    getRegionAtLine(lineNumber) {\n        if (this._regions) {\n            const index = this._regions.findRange(lineNumber);\n            if (index >= 0) {\n                return this._regions.toRegion(index);\n            }\n        }\n        return null;\n    }\n    getRegionsInside(region, filter) {\n        const result = [];\n        const index = region ? region.regionIndex + 1 : 0;\n        const endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\n        if (filter && filter.length === 2) {\n            const levelStack = [];\n            for (let i = index, len = this._regions.length; i < len; i++) {\n                const current = this._regions.toRegion(i);\n                if (this._regions.getStartLineNumber(i) < endLineNumber) {\n                    while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {\n                        levelStack.pop();\n                    }\n                    levelStack.push(current);\n                    if (filter(current, levelStack.length)) {\n                        result.push(current);\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        else {\n            for (let i = index, len = this._regions.length; i < len; i++) {\n                const current = this._regions.toRegion(i);\n                if (this._regions.getStartLineNumber(i) < endLineNumber) {\n                    if (!filter || filter(current)) {\n                        result.push(current);\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}\n/**\n * Collapse or expand the regions at the given locations\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function toggleCollapseState(foldingModel, levels, lineNumbers) {\n    const toToggle = [];\n    for (const lineNumber of lineNumbers) {\n        const region = foldingModel.getRegionAtLine(lineNumber);\n        if (region) {\n            const doCollapse = !region.isCollapsed;\n            toToggle.push(region);\n            if (levels > 1) {\n                const regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n                toToggle.push(...regionsInside);\n            }\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand the regions at the given locations including all children.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n */\nexport function setCollapseStateLevelsDown(foldingModel, doCollapse, levels = Number.MAX_VALUE, lineNumbers) {\n    const toToggle = [];\n    if (lineNumbers && lineNumbers.length > 0) {\n        for (const lineNumber of lineNumbers) {\n            const region = foldingModel.getRegionAtLine(lineNumber);\n            if (region) {\n                if (region.isCollapsed !== doCollapse) {\n                    toToggle.push(region);\n                }\n                if (levels > 1) {\n                    const regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n                    toToggle.push(...regionsInside);\n                }\n            }\n        }\n    }\n    else {\n        const regionsInside = foldingModel.getRegionsInside(null, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n        toToggle.push(...regionsInside);\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand the regions at the given locations including all parents.\n * @param doCollapse Whether to collapse or expand\n * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n * @param lineNumbers the location of the regions to collapse or expand.\n */\nexport function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {\n    const toToggle = [];\n    for (const lineNumber of lineNumbers) {\n        const regions = foldingModel.getAllRegionsAtLine(lineNumber, (region, level) => region.isCollapsed !== doCollapse && level <= levels);\n        toToggle.push(...regions);\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Collapse or expand a region at the given locations. If the inner most region is already collapsed/expanded, uses the first parent instead.\n * @param doCollapse Whether to collapse or expand\n * @param lineNumbers the location of the regions to collapse or expand.\n */\nexport function setCollapseStateUp(foldingModel, doCollapse, lineNumbers) {\n    const toToggle = [];\n    for (const lineNumber of lineNumbers) {\n        const regions = foldingModel.getAllRegionsAtLine(lineNumber, (region) => region.isCollapsed !== doCollapse);\n        if (regions.length > 0) {\n            toToggle.push(regions[0]);\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.\n * @param foldLevel level. Level == 1 is the top level\n * @param doCollapse Whether to collapse or expand\n*/\nexport function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {\n    const filter = (region, level) => level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some(line => region.containsLine(line));\n    const toToggle = foldingModel.getRegionsInside(null, filter);\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds or unfolds all regions, except if they contain or are contained by a region of one of the blocked lines.\n * @param doCollapse Whether to collapse or expand\n * @param blockedLineNumbers the location of regions to not collapse or expand\n */\nexport function setCollapseStateForRest(foldingModel, doCollapse, blockedLineNumbers) {\n    const filteredRegions = [];\n    for (const lineNumber of blockedLineNumbers) {\n        const regions = foldingModel.getAllRegionsAtLine(lineNumber, undefined);\n        if (regions.length > 0) {\n            filteredRegions.push(regions[0]);\n        }\n    }\n    const filter = (region) => filteredRegions.every((filteredRegion) => !filteredRegion.containedBy(region) && !region.containedBy(filteredRegion)) && region.isCollapsed !== doCollapse;\n    const toToggle = foldingModel.getRegionsInside(null, filter);\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds all regions for which the lines start with a given regex\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {\n    const editorModel = foldingModel.textModel;\n    const regions = foldingModel.regions;\n    const toToggle = [];\n    for (let i = regions.length - 1; i >= 0; i--) {\n        if (doCollapse !== regions.isCollapsed(i)) {\n            const startLineNumber = regions.getStartLineNumber(i);\n            if (regExp.test(editorModel.getLineContent(startLineNumber))) {\n                toToggle.push(regions.toRegion(i));\n            }\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Folds all regions of the given type\n * @param foldingModel the folding model\n */\nexport function setCollapseStateForType(foldingModel, type, doCollapse) {\n    const regions = foldingModel.regions;\n    const toToggle = [];\n    for (let i = regions.length - 1; i >= 0; i--) {\n        if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {\n            toToggle.push(regions.toRegion(i));\n        }\n    }\n    foldingModel.toggleCollapseState(toToggle);\n}\n/**\n * Get line to go to for parent fold of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Parent fold start line\n */\nexport function getParentFoldLine(lineNumber, foldingModel) {\n    let startLineNumber = null;\n    const foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n    if (foldingRegion !== null) {\n        startLineNumber = foldingRegion.startLineNumber;\n        // If current line is not the start of the current fold, go to top line of current fold. If not, go to parent fold\n        if (lineNumber === startLineNumber) {\n            const parentFoldingIdx = foldingRegion.parentIndex;\n            if (parentFoldingIdx !== -1) {\n                startLineNumber = foldingModel.regions.getStartLineNumber(parentFoldingIdx);\n            }\n            else {\n                startLineNumber = null;\n            }\n        }\n    }\n    return startLineNumber;\n}\n/**\n * Get line to go to for previous fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Previous fold start line\n */\nexport function getPreviousFoldLine(lineNumber, foldingModel) {\n    let foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n    // If on the folding range start line, go to previous sibling.\n    if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {\n        // If current line is not the start of the current fold, go to top line of current fold. If not, go to previous fold.\n        if (lineNumber !== foldingRegion.startLineNumber) {\n            return foldingRegion.startLineNumber;\n        }\n        else {\n            // Find min line number to stay within parent.\n            const expectedParentIndex = foldingRegion.parentIndex;\n            let minLineNumber = 0;\n            if (expectedParentIndex !== -1) {\n                minLineNumber = foldingModel.regions.getStartLineNumber(foldingRegion.parentIndex);\n            }\n            // Find fold at same level.\n            while (foldingRegion !== null) {\n                if (foldingRegion.regionIndex > 0) {\n                    foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);\n                    // Keep at same level.\n                    if (foldingRegion.startLineNumber <= minLineNumber) {\n                        return null;\n                    }\n                    else if (foldingRegion.parentIndex === expectedParentIndex) {\n                        return foldingRegion.startLineNumber;\n                    }\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n    }\n    else {\n        // Go to last fold that's before the current line.\n        if (foldingModel.regions.length > 0) {\n            foldingRegion = foldingModel.regions.toRegion(foldingModel.regions.length - 1);\n            while (foldingRegion !== null) {\n                // Found fold before current line.\n                if (foldingRegion.startLineNumber < lineNumber) {\n                    return foldingRegion.startLineNumber;\n                }\n                if (foldingRegion.regionIndex > 0) {\n                    foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);\n                }\n                else {\n                    foldingRegion = null;\n                }\n            }\n        }\n    }\n    return null;\n}\n/**\n * Get line to go to next fold at the same level of current line\n * @param lineNumber the current line number\n * @param foldingModel the folding model\n *\n * @return Next fold start line\n */\nexport function getNextFoldLine(lineNumber, foldingModel) {\n    let foldingRegion = foldingModel.getRegionAtLine(lineNumber);\n    // If on the folding range start line, go to next sibling.\n    if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {\n        // Find max line number to stay within parent.\n        const expectedParentIndex = foldingRegion.parentIndex;\n        let maxLineNumber = 0;\n        if (expectedParentIndex !== -1) {\n            maxLineNumber = foldingModel.regions.getEndLineNumber(foldingRegion.parentIndex);\n        }\n        else if (foldingModel.regions.length === 0) {\n            return null;\n        }\n        else {\n            maxLineNumber = foldingModel.regions.getEndLineNumber(foldingModel.regions.length - 1);\n        }\n        // Find fold at same level.\n        while (foldingRegion !== null) {\n            if (foldingRegion.regionIndex < foldingModel.regions.length) {\n                foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);\n                // Keep at same level.\n                if (foldingRegion.startLineNumber >= maxLineNumber) {\n                    return null;\n                }\n                else if (foldingRegion.parentIndex === expectedParentIndex) {\n                    return foldingRegion.startLineNumber;\n                }\n            }\n            else {\n                return null;\n            }\n        }\n    }\n    else {\n        // Go to first fold that's after the current line.\n        if (foldingModel.regions.length > 0) {\n            foldingRegion = foldingModel.regions.toRegion(0);\n            while (foldingRegion !== null) {\n                // Found fold after current line.\n                if (foldingRegion.startLineNumber > lineNumber) {\n                    return foldingRegion.startLineNumber;\n                }\n                if (foldingRegion.regionIndex < foldingModel.regions.length) {\n                    foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);\n                }\n                else {\n                    foldingRegion = null;\n                }\n            }\n        }\n    }\n    return null;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}