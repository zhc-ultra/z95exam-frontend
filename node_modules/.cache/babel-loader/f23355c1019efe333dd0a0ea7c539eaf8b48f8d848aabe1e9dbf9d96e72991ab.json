{"ast":null,"code":"import _slicedToArray from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.last-index-of.js\";\nimport \"core-js/modules/es.array.with.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.substr.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as extpath from './extpath.js';\nimport { Schemas } from './network.js';\nimport * as paths from './path.js';\nimport { isLinux, isWindows } from './platform.js';\nimport { compare as strCompare, equalsIgnoreCase } from './strings.js';\nimport { URI, uriToFsPath } from './uri.js';\nexport function originalFSPath(uri) {\n  return uriToFsPath(uri, true);\n}\nexport var ExtUri = /*#__PURE__*/function () {\n  function ExtUri(_ignorePathCasing) {\n    _classCallCheck(this, ExtUri);\n    this._ignorePathCasing = _ignorePathCasing;\n  }\n  return _createClass(ExtUri, [{\n    key: \"compare\",\n    value: function compare(uri1, uri2) {\n      var ignoreFragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (uri1 === uri2) {\n        return 0;\n      }\n      return strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(uri1, uri2) {\n      var ignoreFragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (uri1 === uri2) {\n        return true;\n      }\n      if (!uri1 || !uri2) {\n        return false;\n      }\n      return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n    }\n  }, {\n    key: \"getComparisonKey\",\n    value: function getComparisonKey(uri) {\n      var ignoreFragment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return uri[\"with\"]({\n        path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n        fragment: ignoreFragment ? null : undefined\n      }).toString();\n    }\n  }, {\n    key: \"isEqualOrParent\",\n    value: function isEqualOrParent(base, parentCandidate) {\n      var ignoreFragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (base.scheme === parentCandidate.scheme) {\n        if (base.scheme === Schemas.file) {\n          return extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n        }\n        if (isEqualAuthority(base.authority, parentCandidate.authority)) {\n          return extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n        }\n      }\n      return false;\n    }\n    // --- path math\n  }, {\n    key: \"joinPath\",\n    value: function joinPath(resource) {\n      for (var _len = arguments.length, pathFragment = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        pathFragment[_key - 1] = arguments[_key];\n      }\n      return URI.joinPath.apply(URI, [resource].concat(pathFragment));\n    }\n  }, {\n    key: \"basenameOrAuthority\",\n    value: function basenameOrAuthority(resource) {\n      return basename(resource) || resource.authority;\n    }\n  }, {\n    key: \"basename\",\n    value: function basename(resource) {\n      return paths.posix.basename(resource.path);\n    }\n  }, {\n    key: \"extname\",\n    value: function extname(resource) {\n      return paths.posix.extname(resource.path);\n    }\n  }, {\n    key: \"dirname\",\n    value: function dirname(resource) {\n      if (resource.path.length === 0) {\n        return resource;\n      }\n      var dirname;\n      if (resource.scheme === Schemas.file) {\n        dirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n      } else {\n        dirname = paths.posix.dirname(resource.path);\n        if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47 /* CharCode.Slash */) {\n          console.error(\"dirname(\\\"\".concat(resource.toString, \")) resulted in a relative path\"));\n          dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n        }\n      }\n      return resource[\"with\"]({\n        path: dirname\n      });\n    }\n  }, {\n    key: \"normalizePath\",\n    value: function normalizePath(resource) {\n      if (!resource.path.length) {\n        return resource;\n      }\n      var normalizedPath;\n      if (resource.scheme === Schemas.file) {\n        normalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n      } else {\n        normalizedPath = paths.posix.normalize(resource.path);\n      }\n      return resource[\"with\"]({\n        path: normalizedPath\n      });\n    }\n  }, {\n    key: \"relativePath\",\n    value: function relativePath(from, to) {\n      if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n        return undefined;\n      }\n      if (from.scheme === Schemas.file) {\n        var _relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n        return isWindows ? extpath.toSlashes(_relativePath) : _relativePath;\n      }\n      var fromPath = from.path || '/';\n      var toPath = to.path || '/';\n      if (this._ignorePathCasing(from)) {\n        // make casing of fromPath match toPath\n        var i = 0;\n        for (var len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n          if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n            if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n              break;\n            }\n          }\n        }\n        fromPath = toPath.substr(0, i) + fromPath.substr(i);\n      }\n      return paths.posix.relative(fromPath, toPath);\n    }\n  }, {\n    key: \"resolvePath\",\n    value: function resolvePath(base, path) {\n      if (base.scheme === Schemas.file) {\n        var newURI = URI.file(paths.resolve(originalFSPath(base), path));\n        return base[\"with\"]({\n          authority: newURI.authority,\n          path: newURI.path\n        });\n      }\n      path = extpath.toPosixPath(path); // we allow path to be a windows path\n      return base[\"with\"]({\n        path: paths.posix.resolve(base.path, path)\n      });\n    }\n    // --- misc\n  }, {\n    key: \"isAbsolutePath\",\n    value: function isAbsolutePath(resource) {\n      return !!resource.path && resource.path[0] === '/';\n    }\n  }, {\n    key: \"isEqualAuthority\",\n    value: function isEqualAuthority(a1, a2) {\n      return a1 === a2 || a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2);\n    }\n  }, {\n    key: \"hasTrailingPathSeparator\",\n    value: function hasTrailingPathSeparator(resource) {\n      var sep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : paths.sep;\n      if (resource.scheme === Schemas.file) {\n        var fsp = originalFSPath(resource);\n        return fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n      } else {\n        var p = resource.path;\n        return p.length > 1 && p.charCodeAt(p.length - 1) === 47 /* CharCode.Slash */ && !/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath); // ignore the slash at offset 0\n      }\n    }\n  }, {\n    key: \"removeTrailingPathSeparator\",\n    value: function removeTrailingPathSeparator(resource) {\n      var sep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : paths.sep;\n      // Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n      if (hasTrailingPathSeparator(resource, sep)) {\n        return resource[\"with\"]({\n          path: resource.path.substr(0, resource.path.length - 1)\n        });\n      }\n      return resource;\n    }\n  }, {\n    key: \"addTrailingPathSeparator\",\n    value: function addTrailingPathSeparator(resource) {\n      var sep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : paths.sep;\n      var isRootSep = false;\n      if (resource.scheme === Schemas.file) {\n        var fsp = originalFSPath(resource);\n        isRootSep = fsp !== undefined && fsp.length === extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n      } else {\n        sep = '/';\n        var p = resource.path;\n        isRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === 47 /* CharCode.Slash */;\n      }\n      if (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n        return resource[\"with\"]({\n          path: resource.path + '/'\n        });\n      }\n      return resource;\n    }\n  }]);\n}();\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport var extUri = new ExtUri(function () {\n  return false;\n});\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport var extUriBiasedIgnorePathCase = new ExtUri(function (uri) {\n  // A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n  // Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n  return uri.scheme === Schemas.file ? !isLinux : true;\n});\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport var extUriIgnorePathCase = new ExtUri(function (_) {\n  return true;\n});\nexport var isEqual = extUri.isEqual.bind(extUri);\nexport var isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport var getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport var basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport var basename = extUri.basename.bind(extUri);\nexport var extname = extUri.extname.bind(extUri);\nexport var dirname = extUri.dirname.bind(extUri);\nexport var joinPath = extUri.joinPath.bind(extUri);\nexport var normalizePath = extUri.normalizePath.bind(extUri);\nexport var relativePath = extUri.relativePath.bind(extUri);\nexport var resolvePath = extUri.resolvePath.bind(extUri);\nexport var isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport var isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport var hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport var removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport var addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n/**\n * Data URI related helpers.\n */\nexport var DataUri;\n(function (DataUri) {\n  DataUri.META_DATA_LABEL = 'label';\n  DataUri.META_DATA_DESCRIPTION = 'description';\n  DataUri.META_DATA_SIZE = 'size';\n  DataUri.META_DATA_MIME = 'mime';\n  function parseMetaData(dataUri) {\n    var metadata = new Map();\n    // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n    // the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n    var meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n    meta.split(';').forEach(function (property) {\n      var _property$split = property.split(':'),\n        _property$split2 = _slicedToArray(_property$split, 2),\n        key = _property$split2[0],\n        value = _property$split2[1];\n      if (key && value) {\n        metadata.set(key, value);\n      }\n    });\n    // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n    // the mime is: image/png\n    var mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n    if (mime) {\n      metadata.set(DataUri.META_DATA_MIME, mime);\n    }\n    return metadata;\n  }\n  DataUri.parseMetaData = parseMetaData;\n})(DataUri || (DataUri = {}));","map":{"version":3,"names":["extpath","Schemas","paths","isLinux","isWindows","compare","strCompare","equalsIgnoreCase","URI","uriToFsPath","originalFSPath","uri","ExtUri","_ignorePathCasing","_classCallCheck","_createClass","key","value","uri1","uri2","ignoreFragment","arguments","length","undefined","getComparisonKey","isEqual","path","toLowerCase","fragment","toString","isEqualOrParent","base","parentCandidate","scheme","file","query","isEqualAuthority","authority","joinPath","resource","_len","pathFragment","Array","_key","apply","concat","basenameOrAuthority","basename","posix","extname","dirname","charCodeAt","console","error","normalizePath","normalizedPath","normalize","relativePath","from","to","relative","toSlashes","fromPath","toPath","i","len","Math","min","charAt","substr","resolvePath","newURI","resolve","toPosixPath","isAbsolutePath","a1","a2","hasTrailingPathSeparator","sep","fsp","getRoot","p","test","fsPath","removeTrailingPathSeparator","addTrailingPathSeparator","isRootSep","extUri","extUriBiasedIgnorePathCase","extUriIgnorePathCase","_","bind","DataUri","META_DATA_LABEL","META_DATA_DESCRIPTION","META_DATA_SIZE","META_DATA_MIME","parseMetaData","dataUri","metadata","Map","meta","substring","indexOf","lastIndexOf","split","forEach","property","_property$split","_property$split2","_slicedToArray","set","mime"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/base/common/resources.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as extpath from './extpath.js';\nimport { Schemas } from './network.js';\nimport * as paths from './path.js';\nimport { isLinux, isWindows } from './platform.js';\nimport { compare as strCompare, equalsIgnoreCase } from './strings.js';\nimport { URI, uriToFsPath } from './uri.js';\nexport function originalFSPath(uri) {\n    return uriToFsPath(uri, true);\n}\nexport class ExtUri {\n    constructor(_ignorePathCasing) {\n        this._ignorePathCasing = _ignorePathCasing;\n    }\n    compare(uri1, uri2, ignoreFragment = false) {\n        if (uri1 === uri2) {\n            return 0;\n        }\n        return strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n    }\n    isEqual(uri1, uri2, ignoreFragment = false) {\n        if (uri1 === uri2) {\n            return true;\n        }\n        if (!uri1 || !uri2) {\n            return false;\n        }\n        return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n    }\n    getComparisonKey(uri, ignoreFragment = false) {\n        return uri.with({\n            path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n            fragment: ignoreFragment ? null : undefined\n        }).toString();\n    }\n    isEqualOrParent(base, parentCandidate, ignoreFragment = false) {\n        if (base.scheme === parentCandidate.scheme) {\n            if (base.scheme === Schemas.file) {\n                return extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n            }\n            if (isEqualAuthority(base.authority, parentCandidate.authority)) {\n                return extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n            }\n        }\n        return false;\n    }\n    // --- path math\n    joinPath(resource, ...pathFragment) {\n        return URI.joinPath(resource, ...pathFragment);\n    }\n    basenameOrAuthority(resource) {\n        return basename(resource) || resource.authority;\n    }\n    basename(resource) {\n        return paths.posix.basename(resource.path);\n    }\n    extname(resource) {\n        return paths.posix.extname(resource.path);\n    }\n    dirname(resource) {\n        if (resource.path.length === 0) {\n            return resource;\n        }\n        let dirname;\n        if (resource.scheme === Schemas.file) {\n            dirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n        }\n        else {\n            dirname = paths.posix.dirname(resource.path);\n            if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47 /* CharCode.Slash */) {\n                console.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n                dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n            }\n        }\n        return resource.with({\n            path: dirname\n        });\n    }\n    normalizePath(resource) {\n        if (!resource.path.length) {\n            return resource;\n        }\n        let normalizedPath;\n        if (resource.scheme === Schemas.file) {\n            normalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n        }\n        else {\n            normalizedPath = paths.posix.normalize(resource.path);\n        }\n        return resource.with({\n            path: normalizedPath\n        });\n    }\n    relativePath(from, to) {\n        if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n            return undefined;\n        }\n        if (from.scheme === Schemas.file) {\n            const relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n            return isWindows ? extpath.toSlashes(relativePath) : relativePath;\n        }\n        let fromPath = from.path || '/';\n        const toPath = to.path || '/';\n        if (this._ignorePathCasing(from)) {\n            // make casing of fromPath match toPath\n            let i = 0;\n            for (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n                if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n                    if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n                        break;\n                    }\n                }\n            }\n            fromPath = toPath.substr(0, i) + fromPath.substr(i);\n        }\n        return paths.posix.relative(fromPath, toPath);\n    }\n    resolvePath(base, path) {\n        if (base.scheme === Schemas.file) {\n            const newURI = URI.file(paths.resolve(originalFSPath(base), path));\n            return base.with({\n                authority: newURI.authority,\n                path: newURI.path\n            });\n        }\n        path = extpath.toPosixPath(path); // we allow path to be a windows path\n        return base.with({\n            path: paths.posix.resolve(base.path, path)\n        });\n    }\n    // --- misc\n    isAbsolutePath(resource) {\n        return !!resource.path && resource.path[0] === '/';\n    }\n    isEqualAuthority(a1, a2) {\n        return a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n    }\n    hasTrailingPathSeparator(resource, sep = paths.sep) {\n        if (resource.scheme === Schemas.file) {\n            const fsp = originalFSPath(resource);\n            return fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n        }\n        else {\n            const p = resource.path;\n            return (p.length > 1 && p.charCodeAt(p.length - 1) === 47 /* CharCode.Slash */) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n        }\n    }\n    removeTrailingPathSeparator(resource, sep = paths.sep) {\n        // Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n        if (hasTrailingPathSeparator(resource, sep)) {\n            return resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n        }\n        return resource;\n    }\n    addTrailingPathSeparator(resource, sep = paths.sep) {\n        let isRootSep = false;\n        if (resource.scheme === Schemas.file) {\n            const fsp = originalFSPath(resource);\n            isRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n        }\n        else {\n            sep = '/';\n            const p = resource.path;\n            isRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === 47 /* CharCode.Slash */;\n        }\n        if (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n            return resource.with({ path: resource.path + '/' });\n        }\n        return resource;\n    }\n}\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n    // A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n    // Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n    return uri.scheme === Schemas.file ? !isLinux : true;\n});\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n/**\n * Data URI related helpers.\n */\nexport var DataUri;\n(function (DataUri) {\n    DataUri.META_DATA_LABEL = 'label';\n    DataUri.META_DATA_DESCRIPTION = 'description';\n    DataUri.META_DATA_SIZE = 'size';\n    DataUri.META_DATA_MIME = 'mime';\n    function parseMetaData(dataUri) {\n        const metadata = new Map();\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n        // the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n        const meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n        meta.split(';').forEach(property => {\n            const [key, value] = property.split(':');\n            if (key && value) {\n                metadata.set(key, value);\n            }\n        });\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n        // the mime is: image/png\n        const mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n        if (mime) {\n            metadata.set(DataUri.META_DATA_MIME, mime);\n        }\n        return metadata;\n    }\n    DataUri.parseMetaData = parseMetaData;\n})(DataUri || (DataUri = {}));\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}