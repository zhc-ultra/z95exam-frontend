{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthZero, lengthLessThan } from './length.js';\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport var NodeReader = /*#__PURE__*/function () {\n  function NodeReader(node) {\n    _classCallCheck(this, NodeReader);\n    this.lastOffset = lengthZero;\n    this.nextNodes = [node];\n    this.offsets = [lengthZero];\n    this.idxs = [];\n  }\n  /**\n   * Returns the longest node at `offset` that satisfies the predicate.\n   * @param offset must be greater than or equal to the last offset this method has been called with!\n  */\n  return _createClass(NodeReader, [{\n    key: \"readLongestNodeAt\",\n    value: function readLongestNodeAt(offset, predicate) {\n      if (lengthLessThan(offset, this.lastOffset)) {\n        throw new Error('Invalid offset');\n      }\n      this.lastOffset = offset;\n      // Find the longest node of all those that are closest to the current offset.\n      while (true) {\n        var curNode = lastOrUndefined(this.nextNodes);\n        if (!curNode) {\n          return undefined;\n        }\n        var curNodeOffset = lastOrUndefined(this.offsets);\n        if (lengthLessThan(offset, curNodeOffset)) {\n          // The next best node is not here yet.\n          // The reader must advance before a cached node is hit.\n          return undefined;\n        }\n        if (lengthLessThan(curNodeOffset, offset)) {\n          // The reader is ahead of the current node.\n          if (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n            // The reader is after the end of the current node.\n            this.nextNodeAfterCurrent();\n          } else {\n            // The reader is somewhere in the current node.\n            var nextChildIdx = getNextChildIdx(curNode);\n            if (nextChildIdx !== -1) {\n              // Go to the first child and repeat.\n              this.nextNodes.push(curNode.getChild(nextChildIdx));\n              this.offsets.push(curNodeOffset);\n              this.idxs.push(nextChildIdx);\n            } else {\n              // We don't have children\n              this.nextNodeAfterCurrent();\n            }\n          }\n        } else {\n          // readerOffsetBeforeChange === curNodeOffset\n          if (predicate(curNode)) {\n            this.nextNodeAfterCurrent();\n            return curNode;\n          } else {\n            var _nextChildIdx = getNextChildIdx(curNode);\n            // look for shorter node\n            if (_nextChildIdx === -1) {\n              // There is no shorter node.\n              this.nextNodeAfterCurrent();\n              return undefined;\n            } else {\n              // Descend into first child & repeat.\n              this.nextNodes.push(curNode.getChild(_nextChildIdx));\n              this.offsets.push(curNodeOffset);\n              this.idxs.push(_nextChildIdx);\n            }\n          }\n        }\n      }\n    }\n    // Navigates to the longest node that continues after the current node.\n  }, {\n    key: \"nextNodeAfterCurrent\",\n    value: function nextNodeAfterCurrent() {\n      while (true) {\n        var currentOffset = lastOrUndefined(this.offsets);\n        var currentNode = lastOrUndefined(this.nextNodes);\n        this.nextNodes.pop();\n        this.offsets.pop();\n        if (this.idxs.length === 0) {\n          // We just popped the root node, there is no next node.\n          break;\n        }\n        // Parent is not undefined, because idxs is not empty\n        var parent = lastOrUndefined(this.nextNodes);\n        var nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n        if (nextChildIdx !== -1) {\n          this.nextNodes.push(parent.getChild(nextChildIdx));\n          this.offsets.push(lengthAdd(currentOffset, currentNode.length));\n          this.idxs[this.idxs.length - 1] = nextChildIdx;\n          break;\n        } else {\n          this.idxs.pop();\n        }\n        // We fully consumed the parent.\n        // Current node is now parent, so call nextNodeAfterCurrent again\n      }\n    }\n  }]);\n}();\nfunction getNextChildIdx(node) {\n  var curIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n  while (true) {\n    curIdx++;\n    if (curIdx >= node.childrenLength) {\n      return -1;\n    }\n    if (node.getChild(curIdx)) {\n      return curIdx;\n    }\n  }\n}\nfunction lastOrUndefined(arr) {\n  return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}","map":{"version":3,"names":["lengthAdd","lengthZero","lengthLessThan","NodeReader","node","_classCallCheck","lastOffset","nextNodes","offsets","idxs","_createClass","key","value","readLongestNodeAt","offset","predicate","Error","curNode","lastOrUndefined","undefined","curNodeOffset","length","nextNodeAfterCurrent","nextChildIdx","getNextChildIdx","push","getChild","currentOffset","currentNode","pop","parent","curIdx","arguments","childrenLength","arr"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthZero, lengthLessThan } from './length.js';\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n    constructor(node) {\n        this.lastOffset = lengthZero;\n        this.nextNodes = [node];\n        this.offsets = [lengthZero];\n        this.idxs = [];\n    }\n    /**\n     * Returns the longest node at `offset` that satisfies the predicate.\n     * @param offset must be greater than or equal to the last offset this method has been called with!\n    */\n    readLongestNodeAt(offset, predicate) {\n        if (lengthLessThan(offset, this.lastOffset)) {\n            throw new Error('Invalid offset');\n        }\n        this.lastOffset = offset;\n        // Find the longest node of all those that are closest to the current offset.\n        while (true) {\n            const curNode = lastOrUndefined(this.nextNodes);\n            if (!curNode) {\n                return undefined;\n            }\n            const curNodeOffset = lastOrUndefined(this.offsets);\n            if (lengthLessThan(offset, curNodeOffset)) {\n                // The next best node is not here yet.\n                // The reader must advance before a cached node is hit.\n                return undefined;\n            }\n            if (lengthLessThan(curNodeOffset, offset)) {\n                // The reader is ahead of the current node.\n                if (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n                    // The reader is after the end of the current node.\n                    this.nextNodeAfterCurrent();\n                }\n                else {\n                    // The reader is somewhere in the current node.\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    if (nextChildIdx !== -1) {\n                        // Go to the first child and repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                    else {\n                        // We don't have children\n                        this.nextNodeAfterCurrent();\n                    }\n                }\n            }\n            else {\n                // readerOffsetBeforeChange === curNodeOffset\n                if (predicate(curNode)) {\n                    this.nextNodeAfterCurrent();\n                    return curNode;\n                }\n                else {\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    // look for shorter node\n                    if (nextChildIdx === -1) {\n                        // There is no shorter node.\n                        this.nextNodeAfterCurrent();\n                        return undefined;\n                    }\n                    else {\n                        // Descend into first child & repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                }\n            }\n        }\n    }\n    // Navigates to the longest node that continues after the current node.\n    nextNodeAfterCurrent() {\n        while (true) {\n            const currentOffset = lastOrUndefined(this.offsets);\n            const currentNode = lastOrUndefined(this.nextNodes);\n            this.nextNodes.pop();\n            this.offsets.pop();\n            if (this.idxs.length === 0) {\n                // We just popped the root node, there is no next node.\n                break;\n            }\n            // Parent is not undefined, because idxs is not empty\n            const parent = lastOrUndefined(this.nextNodes);\n            const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n            if (nextChildIdx !== -1) {\n                this.nextNodes.push(parent.getChild(nextChildIdx));\n                this.offsets.push(lengthAdd(currentOffset, currentNode.length));\n                this.idxs[this.idxs.length - 1] = nextChildIdx;\n                break;\n            }\n            else {\n                this.idxs.pop();\n            }\n            // We fully consumed the parent.\n            // Current node is now parent, so call nextNodeAfterCurrent again\n        }\n    }\n}\nfunction getNextChildIdx(node, curIdx = -1) {\n    while (true) {\n        curIdx++;\n        if (curIdx >= node.childrenLength) {\n            return -1;\n        }\n        if (node.getChild(curIdx)) {\n            return curIdx;\n        }\n    }\n}\nfunction lastOrUndefined(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}