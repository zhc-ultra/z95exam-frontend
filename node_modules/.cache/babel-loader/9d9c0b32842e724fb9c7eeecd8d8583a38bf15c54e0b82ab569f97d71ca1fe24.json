{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * The minimal size of the slider (such that it can still be clickable) -- it is artificially enlarged.\n */\nvar MINIMUM_SLIDER_SIZE = 20;\nexport var ScrollbarState = /*#__PURE__*/function () {\n  function ScrollbarState(arrowSize, scrollbarSize, oppositeScrollbarSize, visibleSize, scrollSize, scrollPosition) {\n    _classCallCheck(this, ScrollbarState);\n    this._scrollbarSize = Math.round(scrollbarSize);\n    this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);\n    this._arrowSize = Math.round(arrowSize);\n    this._visibleSize = visibleSize;\n    this._scrollSize = scrollSize;\n    this._scrollPosition = scrollPosition;\n    this._computedAvailableSize = 0;\n    this._computedIsNeeded = false;\n    this._computedSliderSize = 0;\n    this._computedSliderRatio = 0;\n    this._computedSliderPosition = 0;\n    this._refreshComputedValues();\n  }\n  return _createClass(ScrollbarState, [{\n    key: \"clone\",\n    value: function clone() {\n      return new ScrollbarState(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);\n    }\n  }, {\n    key: \"setVisibleSize\",\n    value: function setVisibleSize(visibleSize) {\n      var iVisibleSize = Math.round(visibleSize);\n      if (this._visibleSize !== iVisibleSize) {\n        this._visibleSize = iVisibleSize;\n        this._refreshComputedValues();\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"setScrollSize\",\n    value: function setScrollSize(scrollSize) {\n      var iScrollSize = Math.round(scrollSize);\n      if (this._scrollSize !== iScrollSize) {\n        this._scrollSize = iScrollSize;\n        this._refreshComputedValues();\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"setScrollPosition\",\n    value: function setScrollPosition(scrollPosition) {\n      var iScrollPosition = Math.round(scrollPosition);\n      if (this._scrollPosition !== iScrollPosition) {\n        this._scrollPosition = iScrollPosition;\n        this._refreshComputedValues();\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"setScrollbarSize\",\n    value: function setScrollbarSize(scrollbarSize) {\n      this._scrollbarSize = Math.round(scrollbarSize);\n    }\n  }, {\n    key: \"setOppositeScrollbarSize\",\n    value: function setOppositeScrollbarSize(oppositeScrollbarSize) {\n      this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);\n    }\n  }, {\n    key: \"_refreshComputedValues\",\n    value: function _refreshComputedValues() {\n      var r = ScrollbarState._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);\n      this._computedAvailableSize = r.computedAvailableSize;\n      this._computedIsNeeded = r.computedIsNeeded;\n      this._computedSliderSize = r.computedSliderSize;\n      this._computedSliderRatio = r.computedSliderRatio;\n      this._computedSliderPosition = r.computedSliderPosition;\n    }\n  }, {\n    key: \"getArrowSize\",\n    value: function getArrowSize() {\n      return this._arrowSize;\n    }\n  }, {\n    key: \"getScrollPosition\",\n    value: function getScrollPosition() {\n      return this._scrollPosition;\n    }\n  }, {\n    key: \"getRectangleLargeSize\",\n    value: function getRectangleLargeSize() {\n      return this._computedAvailableSize;\n    }\n  }, {\n    key: \"getRectangleSmallSize\",\n    value: function getRectangleSmallSize() {\n      return this._scrollbarSize;\n    }\n  }, {\n    key: \"isNeeded\",\n    value: function isNeeded() {\n      return this._computedIsNeeded;\n    }\n  }, {\n    key: \"getSliderSize\",\n    value: function getSliderSize() {\n      return this._computedSliderSize;\n    }\n  }, {\n    key: \"getSliderPosition\",\n    value: function getSliderPosition() {\n      return this._computedSliderPosition;\n    }\n    /**\n     * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.\n     * `offset` is based on the same coordinate system as the `sliderPosition`.\n     */\n  }, {\n    key: \"getDesiredScrollPositionFromOffset\",\n    value: function getDesiredScrollPositionFromOffset(offset) {\n      if (!this._computedIsNeeded) {\n        // no need for a slider\n        return 0;\n      }\n      var desiredSliderPosition = offset - this._arrowSize - this._computedSliderSize / 2;\n      return Math.round(desiredSliderPosition / this._computedSliderRatio);\n    }\n    /**\n     * Compute a desired `scrollPosition` from if offset is before or after the slider position.\n     * If offset is before slider, treat as a page up (or left).  If after, page down (or right).\n     * `offset` and `_computedSliderPosition` are based on the same coordinate system.\n     * `_visibleSize` corresponds to a \"page\" of lines in the returned coordinate system.\n     */\n  }, {\n    key: \"getDesiredScrollPositionFromOffsetPaged\",\n    value: function getDesiredScrollPositionFromOffsetPaged(offset) {\n      if (!this._computedIsNeeded) {\n        // no need for a slider\n        return 0;\n      }\n      var correctedOffset = offset - this._arrowSize; // compensate if has arrows\n      var desiredScrollPosition = this._scrollPosition;\n      if (correctedOffset < this._computedSliderPosition) {\n        desiredScrollPosition -= this._visibleSize; // page up/left\n      } else {\n        desiredScrollPosition += this._visibleSize; // page down/right\n      }\n      return desiredScrollPosition;\n    }\n    /**\n     * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n     */\n  }, {\n    key: \"getDesiredScrollPositionFromDelta\",\n    value: function getDesiredScrollPositionFromDelta(delta) {\n      if (!this._computedIsNeeded) {\n        // no need for a slider\n        return 0;\n      }\n      var desiredSliderPosition = this._computedSliderPosition + delta;\n      return Math.round(desiredSliderPosition / this._computedSliderRatio);\n    }\n  }], [{\n    key: \"_computeValues\",\n    value: function _computeValues(oppositeScrollbarSize, arrowSize, visibleSize, scrollSize, scrollPosition) {\n      var computedAvailableSize = Math.max(0, visibleSize - oppositeScrollbarSize);\n      var computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * arrowSize);\n      var computedIsNeeded = scrollSize > 0 && scrollSize > visibleSize;\n      if (!computedIsNeeded) {\n        // There is no need for a slider\n        return {\n          computedAvailableSize: Math.round(computedAvailableSize),\n          computedIsNeeded: computedIsNeeded,\n          computedSliderSize: Math.round(computedRepresentableSize),\n          computedSliderRatio: 0,\n          computedSliderPosition: 0\n        };\n      }\n      // We must artificially increase the size of the slider if needed, since the slider would be too small to grab with the mouse otherwise\n      var computedSliderSize = Math.round(Math.max(MINIMUM_SLIDER_SIZE, Math.floor(visibleSize * computedRepresentableSize / scrollSize)));\n      // The slider can move from 0 to `computedRepresentableSize` - `computedSliderSize`\n      // in the same way `scrollPosition` can move from 0 to `scrollSize` - `visibleSize`.\n      var computedSliderRatio = (computedRepresentableSize - computedSliderSize) / (scrollSize - visibleSize);\n      var computedSliderPosition = scrollPosition * computedSliderRatio;\n      return {\n        computedAvailableSize: Math.round(computedAvailableSize),\n        computedIsNeeded: computedIsNeeded,\n        computedSliderSize: Math.round(computedSliderSize),\n        computedSliderRatio: computedSliderRatio,\n        computedSliderPosition: Math.round(computedSliderPosition)\n      };\n    }\n  }]);\n}();","map":{"version":3,"names":["MINIMUM_SLIDER_SIZE","ScrollbarState","arrowSize","scrollbarSize","oppositeScrollbarSize","visibleSize","scrollSize","scrollPosition","_classCallCheck","_scrollbarSize","Math","round","_oppositeScrollbarSize","_arrowSize","_visibleSize","_scrollSize","_scrollPosition","_computedAvailableSize","_computedIsNeeded","_computedSliderSize","_computedSliderRatio","_computedSliderPosition","_refreshComputedValues","_createClass","key","value","clone","setVisibleSize","iVisibleSize","setScrollSize","iScrollSize","setScrollPosition","iScrollPosition","setScrollbarSize","setOppositeScrollbarSize","r","_computeValues","computedAvailableSize","computedIsNeeded","computedSliderSize","computedSliderRatio","computedSliderPosition","getArrowSize","getScrollPosition","getRectangleLargeSize","getRectangleSmallSize","isNeeded","getSliderSize","getSliderPosition","getDesiredScrollPositionFromOffset","offset","desiredSliderPosition","getDesiredScrollPositionFromOffsetPaged","correctedOffset","desiredScrollPosition","getDesiredScrollPositionFromDelta","delta","max","computedRepresentableSize","floor"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollbarState.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * The minimal size of the slider (such that it can still be clickable) -- it is artificially enlarged.\n */\nconst MINIMUM_SLIDER_SIZE = 20;\nexport class ScrollbarState {\n    constructor(arrowSize, scrollbarSize, oppositeScrollbarSize, visibleSize, scrollSize, scrollPosition) {\n        this._scrollbarSize = Math.round(scrollbarSize);\n        this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);\n        this._arrowSize = Math.round(arrowSize);\n        this._visibleSize = visibleSize;\n        this._scrollSize = scrollSize;\n        this._scrollPosition = scrollPosition;\n        this._computedAvailableSize = 0;\n        this._computedIsNeeded = false;\n        this._computedSliderSize = 0;\n        this._computedSliderRatio = 0;\n        this._computedSliderPosition = 0;\n        this._refreshComputedValues();\n    }\n    clone() {\n        return new ScrollbarState(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);\n    }\n    setVisibleSize(visibleSize) {\n        const iVisibleSize = Math.round(visibleSize);\n        if (this._visibleSize !== iVisibleSize) {\n            this._visibleSize = iVisibleSize;\n            this._refreshComputedValues();\n            return true;\n        }\n        return false;\n    }\n    setScrollSize(scrollSize) {\n        const iScrollSize = Math.round(scrollSize);\n        if (this._scrollSize !== iScrollSize) {\n            this._scrollSize = iScrollSize;\n            this._refreshComputedValues();\n            return true;\n        }\n        return false;\n    }\n    setScrollPosition(scrollPosition) {\n        const iScrollPosition = Math.round(scrollPosition);\n        if (this._scrollPosition !== iScrollPosition) {\n            this._scrollPosition = iScrollPosition;\n            this._refreshComputedValues();\n            return true;\n        }\n        return false;\n    }\n    setScrollbarSize(scrollbarSize) {\n        this._scrollbarSize = Math.round(scrollbarSize);\n    }\n    setOppositeScrollbarSize(oppositeScrollbarSize) {\n        this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);\n    }\n    static _computeValues(oppositeScrollbarSize, arrowSize, visibleSize, scrollSize, scrollPosition) {\n        const computedAvailableSize = Math.max(0, visibleSize - oppositeScrollbarSize);\n        const computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * arrowSize);\n        const computedIsNeeded = (scrollSize > 0 && scrollSize > visibleSize);\n        if (!computedIsNeeded) {\n            // There is no need for a slider\n            return {\n                computedAvailableSize: Math.round(computedAvailableSize),\n                computedIsNeeded: computedIsNeeded,\n                computedSliderSize: Math.round(computedRepresentableSize),\n                computedSliderRatio: 0,\n                computedSliderPosition: 0,\n            };\n        }\n        // We must artificially increase the size of the slider if needed, since the slider would be too small to grab with the mouse otherwise\n        const computedSliderSize = Math.round(Math.max(MINIMUM_SLIDER_SIZE, Math.floor(visibleSize * computedRepresentableSize / scrollSize)));\n        // The slider can move from 0 to `computedRepresentableSize` - `computedSliderSize`\n        // in the same way `scrollPosition` can move from 0 to `scrollSize` - `visibleSize`.\n        const computedSliderRatio = (computedRepresentableSize - computedSliderSize) / (scrollSize - visibleSize);\n        const computedSliderPosition = (scrollPosition * computedSliderRatio);\n        return {\n            computedAvailableSize: Math.round(computedAvailableSize),\n            computedIsNeeded: computedIsNeeded,\n            computedSliderSize: Math.round(computedSliderSize),\n            computedSliderRatio: computedSliderRatio,\n            computedSliderPosition: Math.round(computedSliderPosition),\n        };\n    }\n    _refreshComputedValues() {\n        const r = ScrollbarState._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);\n        this._computedAvailableSize = r.computedAvailableSize;\n        this._computedIsNeeded = r.computedIsNeeded;\n        this._computedSliderSize = r.computedSliderSize;\n        this._computedSliderRatio = r.computedSliderRatio;\n        this._computedSliderPosition = r.computedSliderPosition;\n    }\n    getArrowSize() {\n        return this._arrowSize;\n    }\n    getScrollPosition() {\n        return this._scrollPosition;\n    }\n    getRectangleLargeSize() {\n        return this._computedAvailableSize;\n    }\n    getRectangleSmallSize() {\n        return this._scrollbarSize;\n    }\n    isNeeded() {\n        return this._computedIsNeeded;\n    }\n    getSliderSize() {\n        return this._computedSliderSize;\n    }\n    getSliderPosition() {\n        return this._computedSliderPosition;\n    }\n    /**\n     * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.\n     * `offset` is based on the same coordinate system as the `sliderPosition`.\n     */\n    getDesiredScrollPositionFromOffset(offset) {\n        if (!this._computedIsNeeded) {\n            // no need for a slider\n            return 0;\n        }\n        const desiredSliderPosition = offset - this._arrowSize - this._computedSliderSize / 2;\n        return Math.round(desiredSliderPosition / this._computedSliderRatio);\n    }\n    /**\n     * Compute a desired `scrollPosition` from if offset is before or after the slider position.\n     * If offset is before slider, treat as a page up (or left).  If after, page down (or right).\n     * `offset` and `_computedSliderPosition` are based on the same coordinate system.\n     * `_visibleSize` corresponds to a \"page\" of lines in the returned coordinate system.\n     */\n    getDesiredScrollPositionFromOffsetPaged(offset) {\n        if (!this._computedIsNeeded) {\n            // no need for a slider\n            return 0;\n        }\n        const correctedOffset = offset - this._arrowSize; // compensate if has arrows\n        let desiredScrollPosition = this._scrollPosition;\n        if (correctedOffset < this._computedSliderPosition) {\n            desiredScrollPosition -= this._visibleSize; // page up/left\n        }\n        else {\n            desiredScrollPosition += this._visibleSize; // page down/right\n        }\n        return desiredScrollPosition;\n    }\n    /**\n     * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n     */\n    getDesiredScrollPositionFromDelta(delta) {\n        if (!this._computedIsNeeded) {\n            // no need for a slider\n            return 0;\n        }\n        const desiredSliderPosition = this._computedSliderPosition + delta;\n        return Math.round(desiredSliderPosition / this._computedSliderRatio);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}