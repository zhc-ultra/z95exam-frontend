{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.trim.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { matchesFuzzy } from './filters.js';\nimport { ltrim } from './strings.js';\nimport { ThemeIcon } from './themables.js';\nvar iconStartMarker = '$(';\nvar iconsRegex = new RegExp(\"\\\\$\\\\(\".concat(ThemeIcon.iconNameExpression, \"(?:\").concat(ThemeIcon.iconModifierExpression, \")?\\\\)\"), 'g'); // no capturing groups\nvar escapeIconsRegex = new RegExp(\"(\\\\\\\\)?\".concat(iconsRegex.source), 'g');\nexport function escapeIcons(text) {\n  return text.replace(escapeIconsRegex, function (match, escaped) {\n    return escaped ? match : \"\\\\\".concat(match);\n  });\n}\nvar markdownEscapedIconsRegex = new RegExp(\"\\\\\\\\\".concat(iconsRegex.source), 'g');\nexport function markdownEscapeEscapedIcons(text) {\n  // Need to add an extra \\ for escaping in markdown\n  return text.replace(markdownEscapedIconsRegex, function (match) {\n    return \"\\\\\".concat(match);\n  });\n}\nvar stripIconsRegex = new RegExp(\"(\\\\s)?(\\\\\\\\)?\".concat(iconsRegex.source, \"(\\\\s)?\"), 'g');\n/**\n * Takes a label with icons (`$(iconId)xyz`)  and strips the icons out (`xyz`)\n */\nexport function stripIcons(text) {\n  if (text.indexOf(iconStartMarker) === -1) {\n    return text;\n  }\n  return text.replace(stripIconsRegex, function (match, preWhitespace, escaped, postWhitespace) {\n    return escaped ? match : preWhitespace || postWhitespace || '';\n  });\n}\n/**\n * Takes a label with icons (`$(iconId)xyz`), removes the icon syntax adds whitespace so that screen readers can read the text better.\n */\nexport function getCodiconAriaLabel(text) {\n  if (!text) {\n    return '';\n  }\n  return text.replace(/\\$\\((.*?)\\)/g, function (_match, codiconName) {\n    return \" \".concat(codiconName, \" \");\n  }).trim();\n}\nvar _parseIconsRegex = new RegExp(\"\\\\$\\\\(\".concat(ThemeIcon.iconNameCharacter, \"+\\\\)\"), 'g');\n/**\n * Takes a label with icons (`abc $(iconId)xyz`) and returns the text (`abc xyz`) and the offsets of the icons (`[3]`)\n */\nexport function parseLabelWithIcons(input) {\n  _parseIconsRegex.lastIndex = 0;\n  var text = '';\n  var iconOffsets = [];\n  var iconsOffset = 0;\n  while (true) {\n    var pos = _parseIconsRegex.lastIndex;\n    var match = _parseIconsRegex.exec(input);\n    var chars = input.substring(pos, match === null || match === void 0 ? void 0 : match.index);\n    if (chars.length > 0) {\n      text += chars;\n      for (var i = 0; i < chars.length; i++) {\n        iconOffsets.push(iconsOffset);\n      }\n    }\n    if (!match) {\n      break;\n    }\n    iconsOffset += match[0].length;\n  }\n  return {\n    text: text,\n    iconOffsets: iconOffsets\n  };\n}\nexport function matchesFuzzyIconAware(query, target) {\n  var enableSeparateSubstringMatching = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var text = target.text,\n    iconOffsets = target.iconOffsets;\n  // Return early if there are no icon markers in the word to match against\n  if (!iconOffsets || iconOffsets.length === 0) {\n    return matchesFuzzy(query, text, enableSeparateSubstringMatching);\n  }\n  // Trim the word to match against because it could have leading\n  // whitespace now if the word started with an icon\n  var wordToMatchAgainstWithoutIconsTrimmed = ltrim(text, ' ');\n  var leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length;\n  // match on value without icon\n  var matches = matchesFuzzy(query, wordToMatchAgainstWithoutIconsTrimmed, enableSeparateSubstringMatching);\n  // Map matches back to offsets with icon and trimming\n  if (matches) {\n    var _iterator = _createForOfIteratorHelper(matches),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var match = _step.value;\n        var iconOffset = iconOffsets[match.start + leadingWhitespaceOffset] /* icon offsets at index */ + leadingWhitespaceOffset /* overall leading whitespace offset */;\n        match.start += iconOffset;\n        match.end += iconOffset;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return matches;\n}","map":{"version":3,"names":["matchesFuzzy","ltrim","ThemeIcon","iconStartMarker","iconsRegex","RegExp","concat","iconNameExpression","iconModifierExpression","escapeIconsRegex","source","escapeIcons","text","replace","match","escaped","markdownEscapedIconsRegex","markdownEscapeEscapedIcons","stripIconsRegex","stripIcons","indexOf","preWhitespace","postWhitespace","getCodiconAriaLabel","_match","codiconName","trim","_parseIconsRegex","iconNameCharacter","parseLabelWithIcons","input","lastIndex","iconOffsets","iconsOffset","pos","exec","chars","substring","index","length","i","push","matchesFuzzyIconAware","query","target","enableSeparateSubstringMatching","arguments","undefined","wordToMatchAgainstWithoutIconsTrimmed","leadingWhitespaceOffset","matches","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","iconOffset","start","end","err","e","f"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/base/common/iconLabels.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { matchesFuzzy } from './filters.js';\nimport { ltrim } from './strings.js';\nimport { ThemeIcon } from './themables.js';\nconst iconStartMarker = '$(';\nconst iconsRegex = new RegExp(`\\\\$\\\\(${ThemeIcon.iconNameExpression}(?:${ThemeIcon.iconModifierExpression})?\\\\)`, 'g'); // no capturing groups\nconst escapeIconsRegex = new RegExp(`(\\\\\\\\)?${iconsRegex.source}`, 'g');\nexport function escapeIcons(text) {\n    return text.replace(escapeIconsRegex, (match, escaped) => escaped ? match : `\\\\${match}`);\n}\nconst markdownEscapedIconsRegex = new RegExp(`\\\\\\\\${iconsRegex.source}`, 'g');\nexport function markdownEscapeEscapedIcons(text) {\n    // Need to add an extra \\ for escaping in markdown\n    return text.replace(markdownEscapedIconsRegex, match => `\\\\${match}`);\n}\nconst stripIconsRegex = new RegExp(`(\\\\s)?(\\\\\\\\)?${iconsRegex.source}(\\\\s)?`, 'g');\n/**\n * Takes a label with icons (`$(iconId)xyz`)  and strips the icons out (`xyz`)\n */\nexport function stripIcons(text) {\n    if (text.indexOf(iconStartMarker) === -1) {\n        return text;\n    }\n    return text.replace(stripIconsRegex, (match, preWhitespace, escaped, postWhitespace) => escaped ? match : preWhitespace || postWhitespace || '');\n}\n/**\n * Takes a label with icons (`$(iconId)xyz`), removes the icon syntax adds whitespace so that screen readers can read the text better.\n */\nexport function getCodiconAriaLabel(text) {\n    if (!text) {\n        return '';\n    }\n    return text.replace(/\\$\\((.*?)\\)/g, (_match, codiconName) => ` ${codiconName} `).trim();\n}\nconst _parseIconsRegex = new RegExp(`\\\\$\\\\(${ThemeIcon.iconNameCharacter}+\\\\)`, 'g');\n/**\n * Takes a label with icons (`abc $(iconId)xyz`) and returns the text (`abc xyz`) and the offsets of the icons (`[3]`)\n */\nexport function parseLabelWithIcons(input) {\n    _parseIconsRegex.lastIndex = 0;\n    let text = '';\n    const iconOffsets = [];\n    let iconsOffset = 0;\n    while (true) {\n        const pos = _parseIconsRegex.lastIndex;\n        const match = _parseIconsRegex.exec(input);\n        const chars = input.substring(pos, match === null || match === void 0 ? void 0 : match.index);\n        if (chars.length > 0) {\n            text += chars;\n            for (let i = 0; i < chars.length; i++) {\n                iconOffsets.push(iconsOffset);\n            }\n        }\n        if (!match) {\n            break;\n        }\n        iconsOffset += match[0].length;\n    }\n    return { text, iconOffsets };\n}\nexport function matchesFuzzyIconAware(query, target, enableSeparateSubstringMatching = false) {\n    const { text, iconOffsets } = target;\n    // Return early if there are no icon markers in the word to match against\n    if (!iconOffsets || iconOffsets.length === 0) {\n        return matchesFuzzy(query, text, enableSeparateSubstringMatching);\n    }\n    // Trim the word to match against because it could have leading\n    // whitespace now if the word started with an icon\n    const wordToMatchAgainstWithoutIconsTrimmed = ltrim(text, ' ');\n    const leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length;\n    // match on value without icon\n    const matches = matchesFuzzy(query, wordToMatchAgainstWithoutIconsTrimmed, enableSeparateSubstringMatching);\n    // Map matches back to offsets with icon and trimming\n    if (matches) {\n        for (const match of matches) {\n            const iconOffset = iconOffsets[match.start + leadingWhitespaceOffset] /* icon offsets at index */ + leadingWhitespaceOffset /* overall leading whitespace offset */;\n            match.start += iconOffset;\n            match.end += iconOffset;\n        }\n    }\n    return matches;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}