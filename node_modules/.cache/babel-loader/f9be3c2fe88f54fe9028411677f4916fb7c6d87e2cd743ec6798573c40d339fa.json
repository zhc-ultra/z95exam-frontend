{"ast":null,"code":"import _toArray from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _typeof from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.number.max-safe-integer.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TreeError } from './tree.js';\nimport { splice, tail2 } from '../../../common/arrays.js';\nimport { Delayer } from '../../../common/async.js';\nimport { MicrotaskDelay } from '../../../common/symbols.js';\nimport { LcsDiff } from '../../../common/diff/diff.js';\nimport { Emitter, EventBufferer } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nexport function isFilterResult(obj) {\n  return _typeof(obj) === 'object' && 'visibility' in obj && 'data' in obj;\n}\nexport function getVisibleState(visibility) {\n  switch (visibility) {\n    case true:\n      return 1 /* TreeVisibility.Visible */;\n    case false:\n      return 0 /* TreeVisibility.Hidden */;\n    default:\n      return visibility;\n  }\n}\nfunction isCollapsibleStateUpdate(update) {\n  return typeof update.collapsible === 'boolean';\n}\nexport var IndexTreeModel = /*#__PURE__*/function () {\n  function IndexTreeModel(user, list, rootElement) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    _classCallCheck(this, IndexTreeModel);\n    var _a;\n    this.user = user;\n    this.list = list;\n    this.rootRef = [];\n    this.eventBufferer = new EventBufferer();\n    this._onDidChangeCollapseState = new Emitter();\n    this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);\n    this._onDidChangeRenderNodeCount = new Emitter();\n    this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);\n    this._onDidSplice = new Emitter();\n    this.onDidSplice = this._onDidSplice.event;\n    this.refilterDelayer = new Delayer(MicrotaskDelay);\n    this.collapseByDefault = typeof options.collapseByDefault === 'undefined' ? false : options.collapseByDefault;\n    this.allowNonCollapsibleParents = (_a = options.allowNonCollapsibleParents) !== null && _a !== void 0 ? _a : false;\n    this.filter = options.filter;\n    this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n    this.root = {\n      parent: undefined,\n      element: rootElement,\n      children: [],\n      depth: 0,\n      visibleChildrenCount: 0,\n      visibleChildIndex: -1,\n      collapsible: false,\n      collapsed: false,\n      renderNodeCount: 0,\n      visibility: 1 /* TreeVisibility.Visible */,\n      visible: true,\n      filterData: undefined\n    };\n  }\n  return _createClass(IndexTreeModel, [{\n    key: \"splice\",\n    value: function splice(location, deleteCount) {\n      var toInsert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Iterable.empty();\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      if (location.length === 0) {\n        throw new TreeError(this.user, 'Invalid tree location');\n      }\n      if (options.diffIdentityProvider) {\n        this.spliceSmart(options.diffIdentityProvider, location, deleteCount, toInsert, options);\n      } else {\n        this.spliceSimple(location, deleteCount, toInsert, options);\n      }\n    }\n  }, {\n    key: \"spliceSmart\",\n    value: function spliceSmart(identity, location, deleteCount, toInsertIterable, options, recurseLevels) {\n      var _this = this;\n      var _a;\n      if (toInsertIterable === void 0) {\n        toInsertIterable = Iterable.empty();\n      }\n      if (recurseLevels === void 0) {\n        recurseLevels = (_a = options.diffDepth) !== null && _a !== void 0 ? _a : 0;\n      }\n      var _this$getParentNodeWi = this.getParentNodeWithListIndex(location),\n        parentNode = _this$getParentNodeWi.parentNode;\n      if (!parentNode.lastDiffIds) {\n        return this.spliceSimple(location, deleteCount, toInsertIterable, options);\n      }\n      var toInsert = _toConsumableArray(toInsertIterable);\n      var index = location[location.length - 1];\n      var diff = new LcsDiff({\n        getElements: function getElements() {\n          return parentNode.lastDiffIds;\n        }\n      }, {\n        getElements: function getElements() {\n          return [].concat(_toConsumableArray(parentNode.children.slice(0, index)), _toConsumableArray(toInsert), _toConsumableArray(parentNode.children.slice(index + deleteCount))).map(function (e) {\n            return identity.getId(e.element).toString();\n          });\n        }\n      }).ComputeDiff(false);\n      // if we were given a 'best effort' diff, use default behavior\n      if (diff.quitEarly) {\n        parentNode.lastDiffIds = undefined;\n        return this.spliceSimple(location, deleteCount, toInsert, options);\n      }\n      var locationPrefix = location.slice(0, -1);\n      var recurseSplice = function recurseSplice(fromOriginal, fromModified, count) {\n        if (recurseLevels > 0) {\n          for (var i = 0; i < count; i++) {\n            fromOriginal--;\n            fromModified--;\n            _this.spliceSmart(identity, [].concat(_toConsumableArray(locationPrefix), [fromOriginal, 0]), Number.MAX_SAFE_INTEGER, toInsert[fromModified].children, options, recurseLevels - 1);\n          }\n        }\n      };\n      var lastStartO = Math.min(parentNode.children.length, index + deleteCount);\n      var lastStartM = toInsert.length;\n      var _iterator = _createForOfIteratorHelper(diff.changes.sort(function (a, b) {\n          return b.originalStart - a.originalStart;\n        })),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var change = _step.value;\n          recurseSplice(lastStartO, lastStartM, lastStartO - (change.originalStart + change.originalLength));\n          lastStartO = change.originalStart;\n          lastStartM = change.modifiedStart - index;\n          this.spliceSimple([].concat(_toConsumableArray(locationPrefix), [lastStartO]), change.originalLength, Iterable.slice(toInsert, lastStartM, lastStartM + change.modifiedLength), options);\n        }\n        // at this point, startO === startM === count since any remaining prefix should match\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      recurseSplice(lastStartO, lastStartM, lastStartO);\n    }\n  }, {\n    key: \"spliceSimple\",\n    value: function spliceSimple(location, deleteCount) {\n      var _this2 = this;\n      var toInsert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Iterable.empty();\n      var _ref = arguments.length > 3 ? arguments[3] : undefined,\n        onDidCreateNode = _ref.onDidCreateNode,\n        onDidDeleteNode = _ref.onDidDeleteNode,\n        diffIdentityProvider = _ref.diffIdentityProvider;\n      var _this$getParentNodeWi2 = this.getParentNodeWithListIndex(location),\n        parentNode = _this$getParentNodeWi2.parentNode,\n        listIndex = _this$getParentNodeWi2.listIndex,\n        revealed = _this$getParentNodeWi2.revealed,\n        visible = _this$getParentNodeWi2.visible;\n      var treeListElementsToInsert = [];\n      var nodesToInsertIterator = Iterable.map(toInsert, function (el) {\n        return _this2.createTreeNode(el, parentNode, parentNode.visible ? 1 /* TreeVisibility.Visible */ : 0 /* TreeVisibility.Hidden */, revealed, treeListElementsToInsert, onDidCreateNode);\n      });\n      var lastIndex = location[location.length - 1];\n      // figure out what's the visible child start index right before the\n      // splice point\n      var visibleChildStartIndex = 0;\n      for (var i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {\n        var child = parentNode.children[i];\n        if (child.visible) {\n          visibleChildStartIndex = child.visibleChildIndex;\n          break;\n        }\n      }\n      var nodesToInsert = [];\n      var insertedVisibleChildrenCount = 0;\n      var renderNodeCount = 0;\n      var _iterator2 = _createForOfIteratorHelper(nodesToInsertIterator),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _child2 = _step2.value;\n          nodesToInsert.push(_child2);\n          renderNodeCount += _child2.renderNodeCount;\n          if (_child2.visible) {\n            _child2.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var deletedNodes = splice(parentNode.children, lastIndex, deleteCount, nodesToInsert);\n      if (!diffIdentityProvider) {\n        parentNode.lastDiffIds = undefined;\n      } else if (parentNode.lastDiffIds) {\n        splice(parentNode.lastDiffIds, lastIndex, deleteCount, nodesToInsert.map(function (n) {\n          return diffIdentityProvider.getId(n.element).toString();\n        }));\n      } else {\n        parentNode.lastDiffIds = parentNode.children.map(function (n) {\n          return diffIdentityProvider.getId(n.element).toString();\n        });\n      }\n      // figure out what is the count of deleted visible children\n      var deletedVisibleChildrenCount = 0;\n      var _iterator3 = _createForOfIteratorHelper(deletedNodes),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _child3 = _step3.value;\n          if (_child3.visible) {\n            deletedVisibleChildrenCount++;\n          }\n        }\n        // and adjust for all visible children after the splice point\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      if (deletedVisibleChildrenCount !== 0) {\n        for (var _i = lastIndex + nodesToInsert.length; _i < parentNode.children.length; _i++) {\n          var _child = parentNode.children[_i];\n          if (_child.visible) {\n            _child.visibleChildIndex -= deletedVisibleChildrenCount;\n          }\n        }\n      }\n      // update parent's visible children count\n      parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;\n      if (revealed && visible) {\n        var visibleDeleteCount = deletedNodes.reduce(function (r, node) {\n          return r + (node.visible ? node.renderNodeCount : 0);\n        }, 0);\n        this._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);\n        this.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);\n      }\n      if (deletedNodes.length > 0 && onDidDeleteNode) {\n        var visit = function visit(node) {\n          onDidDeleteNode(node);\n          node.children.forEach(visit);\n        };\n        deletedNodes.forEach(visit);\n      }\n      this._onDidSplice.fire({\n        insertedNodes: nodesToInsert,\n        deletedNodes: deletedNodes\n      });\n      var node = parentNode;\n      while (node) {\n        if (node.visibility === 2 /* TreeVisibility.Recurse */) {\n          // delayed to avoid excessive refiltering, see #135941\n          this.refilterDelayer.trigger(function () {\n            return _this2.refilter();\n          });\n          break;\n        }\n        node = node.parent;\n      }\n    }\n  }, {\n    key: \"rerender\",\n    value: function rerender(location) {\n      if (location.length === 0) {\n        throw new TreeError(this.user, 'Invalid tree location');\n      }\n      var _this$getTreeNodeWith = this.getTreeNodeWithListIndex(location),\n        node = _this$getTreeNodeWith.node,\n        listIndex = _this$getTreeNodeWith.listIndex,\n        revealed = _this$getTreeNodeWith.revealed;\n      if (node.visible && revealed) {\n        this.list.splice(listIndex, 1, [node]);\n      }\n    }\n  }, {\n    key: \"has\",\n    value: function has(location) {\n      return this.hasTreeNode(location);\n    }\n  }, {\n    key: \"getListIndex\",\n    value: function getListIndex(location) {\n      var _this$getTreeNodeWith2 = this.getTreeNodeWithListIndex(location),\n        listIndex = _this$getTreeNodeWith2.listIndex,\n        visible = _this$getTreeNodeWith2.visible,\n        revealed = _this$getTreeNodeWith2.revealed;\n      return visible && revealed ? listIndex : -1;\n    }\n  }, {\n    key: \"getListRenderCount\",\n    value: function getListRenderCount(location) {\n      return this.getTreeNode(location).renderNodeCount;\n    }\n  }, {\n    key: \"isCollapsible\",\n    value: function isCollapsible(location) {\n      return this.getTreeNode(location).collapsible;\n    }\n  }, {\n    key: \"setCollapsible\",\n    value: function setCollapsible(location, collapsible) {\n      var _this3 = this;\n      var node = this.getTreeNode(location);\n      if (typeof collapsible === 'undefined') {\n        collapsible = !node.collapsible;\n      }\n      var update = {\n        collapsible: collapsible\n      };\n      return this.eventBufferer.bufferEvents(function () {\n        return _this3._setCollapseState(location, update);\n      });\n    }\n  }, {\n    key: \"isCollapsed\",\n    value: function isCollapsed(location) {\n      return this.getTreeNode(location).collapsed;\n    }\n  }, {\n    key: \"setCollapsed\",\n    value: function setCollapsed(location, collapsed, recursive) {\n      var _this4 = this;\n      var node = this.getTreeNode(location);\n      if (typeof collapsed === 'undefined') {\n        collapsed = !node.collapsed;\n      }\n      var update = {\n        collapsed: collapsed,\n        recursive: recursive || false\n      };\n      return this.eventBufferer.bufferEvents(function () {\n        return _this4._setCollapseState(location, update);\n      });\n    }\n  }, {\n    key: \"_setCollapseState\",\n    value: function _setCollapseState(location, update) {\n      var _this$getTreeNodeWith3 = this.getTreeNodeWithListIndex(location),\n        node = _this$getTreeNodeWith3.node,\n        listIndex = _this$getTreeNodeWith3.listIndex,\n        revealed = _this$getTreeNodeWith3.revealed;\n      var result = this._setListNodeCollapseState(node, listIndex, revealed, update);\n      if (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {\n        var onlyVisibleChildIndex = -1;\n        for (var i = 0; i < node.children.length; i++) {\n          var child = node.children[i];\n          if (child.visible) {\n            if (onlyVisibleChildIndex > -1) {\n              onlyVisibleChildIndex = -1;\n              break;\n            } else {\n              onlyVisibleChildIndex = i;\n            }\n          }\n        }\n        if (onlyVisibleChildIndex > -1) {\n          this._setCollapseState([].concat(_toConsumableArray(location), [onlyVisibleChildIndex]), update);\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"_setListNodeCollapseState\",\n    value: function _setListNodeCollapseState(node, listIndex, revealed, update) {\n      var result = this._setNodeCollapseState(node, update, false);\n      if (!revealed || !node.visible || !result) {\n        return result;\n      }\n      var previousRenderNodeCount = node.renderNodeCount;\n      var toInsert = this.updateNodeAfterCollapseChange(node);\n      var deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);\n      this.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));\n      return result;\n    }\n  }, {\n    key: \"_setNodeCollapseState\",\n    value: function _setNodeCollapseState(node, update, deep) {\n      var result;\n      if (node === this.root) {\n        result = false;\n      } else {\n        if (isCollapsibleStateUpdate(update)) {\n          result = node.collapsible !== update.collapsible;\n          node.collapsible = update.collapsible;\n        } else if (!node.collapsible) {\n          result = false;\n        } else {\n          result = node.collapsed !== update.collapsed;\n          node.collapsed = update.collapsed;\n        }\n        if (result) {\n          this._onDidChangeCollapseState.fire({\n            node: node,\n            deep: deep\n          });\n        }\n      }\n      if (!isCollapsibleStateUpdate(update) && update.recursive) {\n        var _iterator4 = _createForOfIteratorHelper(node.children),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var child = _step4.value;\n            result = this._setNodeCollapseState(child, update, true) || result;\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"expandTo\",\n    value: function expandTo(location) {\n      var _this5 = this;\n      this.eventBufferer.bufferEvents(function () {\n        var node = _this5.getTreeNode(location);\n        while (node.parent) {\n          node = node.parent;\n          location = location.slice(0, location.length - 1);\n          if (node.collapsed) {\n            _this5._setCollapseState(location, {\n              collapsed: false,\n              recursive: false\n            });\n          }\n        }\n      });\n    }\n  }, {\n    key: \"refilter\",\n    value: function refilter() {\n      var previousRenderNodeCount = this.root.renderNodeCount;\n      var toInsert = this.updateNodeAfterFilterChange(this.root);\n      this.list.splice(0, previousRenderNodeCount, toInsert);\n      this.refilterDelayer.cancel();\n    }\n  }, {\n    key: \"createTreeNode\",\n    value: function createTreeNode(treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {\n      var node = {\n        parent: parent,\n        element: treeElement.element,\n        children: [],\n        depth: parent.depth + 1,\n        visibleChildrenCount: 0,\n        visibleChildIndex: -1,\n        collapsible: typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : typeof treeElement.collapsed !== 'undefined',\n        collapsed: typeof treeElement.collapsed === 'undefined' ? this.collapseByDefault : treeElement.collapsed,\n        renderNodeCount: 1,\n        visibility: 1 /* TreeVisibility.Visible */,\n        visible: true,\n        filterData: undefined\n      };\n      var visibility = this._filterNode(node, parentVisibility);\n      node.visibility = visibility;\n      if (revealed) {\n        treeListElements.push(node);\n      }\n      var childElements = treeElement.children || Iterable.empty();\n      var childRevealed = revealed && visibility !== 0 /* TreeVisibility.Hidden */ && !node.collapsed;\n      var visibleChildrenCount = 0;\n      var renderNodeCount = 1;\n      var _iterator5 = _createForOfIteratorHelper(childElements),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var el = _step5.value;\n          var child = this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode);\n          node.children.push(child);\n          renderNodeCount += child.renderNodeCount;\n          if (child.visible) {\n            child.visibleChildIndex = visibleChildrenCount++;\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      if (!this.allowNonCollapsibleParents) {\n        node.collapsible = node.collapsible || node.children.length > 0;\n      }\n      node.visibleChildrenCount = visibleChildrenCount;\n      node.visible = visibility === 2 /* TreeVisibility.Recurse */ ? visibleChildrenCount > 0 : visibility === 1 /* TreeVisibility.Visible */;\n      if (!node.visible) {\n        node.renderNodeCount = 0;\n        if (revealed) {\n          treeListElements.pop();\n        }\n      } else if (!node.collapsed) {\n        node.renderNodeCount = renderNodeCount;\n      }\n      onDidCreateNode === null || onDidCreateNode === void 0 ? void 0 : onDidCreateNode(node);\n      return node;\n    }\n  }, {\n    key: \"updateNodeAfterCollapseChange\",\n    value: function updateNodeAfterCollapseChange(node) {\n      var previousRenderNodeCount = node.renderNodeCount;\n      var result = [];\n      this._updateNodeAfterCollapseChange(node, result);\n      this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n      return result;\n    }\n  }, {\n    key: \"_updateNodeAfterCollapseChange\",\n    value: function _updateNodeAfterCollapseChange(node, result) {\n      if (node.visible === false) {\n        return 0;\n      }\n      result.push(node);\n      node.renderNodeCount = 1;\n      if (!node.collapsed) {\n        var _iterator6 = _createForOfIteratorHelper(node.children),\n          _step6;\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var child = _step6.value;\n            node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      }\n      this._onDidChangeRenderNodeCount.fire(node);\n      return node.renderNodeCount;\n    }\n  }, {\n    key: \"updateNodeAfterFilterChange\",\n    value: function updateNodeAfterFilterChange(node) {\n      var previousRenderNodeCount = node.renderNodeCount;\n      var result = [];\n      this._updateNodeAfterFilterChange(node, node.visible ? 1 /* TreeVisibility.Visible */ : 0 /* TreeVisibility.Hidden */, result);\n      this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n      return result;\n    }\n  }, {\n    key: \"_updateNodeAfterFilterChange\",\n    value: function _updateNodeAfterFilterChange(node, parentVisibility, result) {\n      var revealed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var visibility;\n      if (node !== this.root) {\n        visibility = this._filterNode(node, parentVisibility);\n        if (visibility === 0 /* TreeVisibility.Hidden */) {\n          node.visible = false;\n          node.renderNodeCount = 0;\n          return false;\n        }\n        if (revealed) {\n          result.push(node);\n        }\n      }\n      var resultStartLength = result.length;\n      node.renderNodeCount = node === this.root ? 0 : 1;\n      var hasVisibleDescendants = false;\n      if (!node.collapsed || visibility !== 0 /* TreeVisibility.Hidden */) {\n        var visibleChildIndex = 0;\n        var _iterator7 = _createForOfIteratorHelper(node.children),\n          _step7;\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var child = _step7.value;\n            hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants;\n            if (child.visible) {\n              child.visibleChildIndex = visibleChildIndex++;\n            }\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n        node.visibleChildrenCount = visibleChildIndex;\n      } else {\n        node.visibleChildrenCount = 0;\n      }\n      if (node !== this.root) {\n        node.visible = visibility === 2 /* TreeVisibility.Recurse */ ? hasVisibleDescendants : visibility === 1 /* TreeVisibility.Visible */;\n        node.visibility = visibility;\n      }\n      if (!node.visible) {\n        node.renderNodeCount = 0;\n        if (revealed) {\n          result.pop();\n        }\n      } else if (!node.collapsed) {\n        node.renderNodeCount += result.length - resultStartLength;\n      }\n      this._onDidChangeRenderNodeCount.fire(node);\n      return node.visible;\n    }\n  }, {\n    key: \"_updateAncestorsRenderNodeCount\",\n    value: function _updateAncestorsRenderNodeCount(node, diff) {\n      if (diff === 0) {\n        return;\n      }\n      while (node) {\n        node.renderNodeCount += diff;\n        this._onDidChangeRenderNodeCount.fire(node);\n        node = node.parent;\n      }\n    }\n  }, {\n    key: \"_filterNode\",\n    value: function _filterNode(node, parentVisibility) {\n      var result = this.filter ? this.filter.filter(node.element, parentVisibility) : 1 /* TreeVisibility.Visible */;\n      if (typeof result === 'boolean') {\n        node.filterData = undefined;\n        return result ? 1 /* TreeVisibility.Visible */ : 0 /* TreeVisibility.Hidden */;\n      } else if (isFilterResult(result)) {\n        node.filterData = result.data;\n        return getVisibleState(result.visibility);\n      } else {\n        node.filterData = undefined;\n        return getVisibleState(result);\n      }\n    }\n    // cheap\n  }, {\n    key: \"hasTreeNode\",\n    value: function hasTreeNode(location) {\n      var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.root;\n      if (!location || location.length === 0) {\n        return true;\n      }\n      var _location = _toArray(location),\n        index = _location[0],\n        rest = _location.slice(1);\n      if (index < 0 || index > node.children.length) {\n        return false;\n      }\n      return this.hasTreeNode(rest, node.children[index]);\n    }\n    // cheap\n  }, {\n    key: \"getTreeNode\",\n    value: function getTreeNode(location) {\n      var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.root;\n      if (!location || location.length === 0) {\n        return node;\n      }\n      var _location2 = _toArray(location),\n        index = _location2[0],\n        rest = _location2.slice(1);\n      if (index < 0 || index > node.children.length) {\n        throw new TreeError(this.user, 'Invalid tree location');\n      }\n      return this.getTreeNode(rest, node.children[index]);\n    }\n    // expensive\n  }, {\n    key: \"getTreeNodeWithListIndex\",\n    value: function getTreeNodeWithListIndex(location) {\n      if (location.length === 0) {\n        return {\n          node: this.root,\n          listIndex: -1,\n          revealed: true,\n          visible: false\n        };\n      }\n      var _this$getParentNodeWi3 = this.getParentNodeWithListIndex(location),\n        parentNode = _this$getParentNodeWi3.parentNode,\n        listIndex = _this$getParentNodeWi3.listIndex,\n        revealed = _this$getParentNodeWi3.revealed,\n        visible = _this$getParentNodeWi3.visible;\n      var index = location[location.length - 1];\n      if (index < 0 || index > parentNode.children.length) {\n        throw new TreeError(this.user, 'Invalid tree location');\n      }\n      var node = parentNode.children[index];\n      return {\n        node: node,\n        listIndex: listIndex,\n        revealed: revealed,\n        visible: visible && node.visible\n      };\n    }\n  }, {\n    key: \"getParentNodeWithListIndex\",\n    value: function getParentNodeWithListIndex(location) {\n      var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.root;\n      var listIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var revealed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var visible = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n      var _location3 = _toArray(location),\n        index = _location3[0],\n        rest = _location3.slice(1);\n      if (index < 0 || index > node.children.length) {\n        throw new TreeError(this.user, 'Invalid tree location');\n      }\n      // TODO@joao perf!\n      for (var i = 0; i < index; i++) {\n        listIndex += node.children[i].renderNodeCount;\n      }\n      revealed = revealed && !node.collapsed;\n      visible = visible && node.visible;\n      if (rest.length === 0) {\n        return {\n          parentNode: node,\n          listIndex: listIndex,\n          revealed: revealed,\n          visible: visible\n        };\n      }\n      return this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode() {\n      var location = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      return this.getTreeNode(location);\n    }\n    // TODO@joao perf!\n  }, {\n    key: \"getNodeLocation\",\n    value: function getNodeLocation(node) {\n      var location = [];\n      var indexTreeNode = node; // typing woes\n      while (indexTreeNode.parent) {\n        location.push(indexTreeNode.parent.children.indexOf(indexTreeNode));\n        indexTreeNode = indexTreeNode.parent;\n      }\n      return location.reverse();\n    }\n  }, {\n    key: \"getParentNodeLocation\",\n    value: function getParentNodeLocation(location) {\n      if (location.length === 0) {\n        return undefined;\n      } else if (location.length === 1) {\n        return [];\n      } else {\n        return tail2(location)[0];\n      }\n    }\n  }, {\n    key: \"getFirstElementChild\",\n    value: function getFirstElementChild(location) {\n      var node = this.getTreeNode(location);\n      if (node.children.length === 0) {\n        return undefined;\n      }\n      return node.children[0].element;\n    }\n  }]);\n}();","map":{"version":3,"names":["TreeError","splice","tail2","Delayer","MicrotaskDelay","LcsDiff","Emitter","EventBufferer","Iterable","isFilterResult","obj","_typeof","getVisibleState","visibility","isCollapsibleStateUpdate","update","collapsible","IndexTreeModel","user","list","rootElement","options","arguments","length","undefined","_classCallCheck","_a","rootRef","eventBufferer","_onDidChangeCollapseState","onDidChangeCollapseState","wrapEvent","event","_onDidChangeRenderNodeCount","onDidChangeRenderNodeCount","_onDidSplice","onDidSplice","refilterDelayer","collapseByDefault","allowNonCollapsibleParents","filter","autoExpandSingleChildren","root","parent","element","children","depth","visibleChildrenCount","visibleChildIndex","collapsed","renderNodeCount","visible","filterData","_createClass","key","value","location","deleteCount","toInsert","empty","diffIdentityProvider","spliceSmart","spliceSimple","identity","toInsertIterable","recurseLevels","_this","diffDepth","_this$getParentNodeWi","getParentNodeWithListIndex","parentNode","lastDiffIds","_toConsumableArray","index","diff","getElements","concat","slice","map","e","getId","toString","ComputeDiff","quitEarly","locationPrefix","recurseSplice","fromOriginal","fromModified","count","i","Number","MAX_SAFE_INTEGER","lastStartO","Math","min","lastStartM","_iterator","_createForOfIteratorHelper","changes","sort","a","b","originalStart","_step","s","n","done","change","originalLength","modifiedStart","modifiedLength","err","f","_this2","_ref","onDidCreateNode","onDidDeleteNode","_this$getParentNodeWi2","listIndex","revealed","treeListElementsToInsert","nodesToInsertIterator","el","createTreeNode","lastIndex","visibleChildStartIndex","child","nodesToInsert","insertedVisibleChildrenCount","_iterator2","_step2","push","deletedNodes","deletedVisibleChildrenCount","_iterator3","_step3","visibleDeleteCount","reduce","r","node","_updateAncestorsRenderNodeCount","visit","forEach","fire","insertedNodes","trigger","refilter","rerender","_this$getTreeNodeWith","getTreeNodeWithListIndex","has","hasTreeNode","getListIndex","_this$getTreeNodeWith2","getListRenderCount","getTreeNode","isCollapsible","setCollapsible","_this3","bufferEvents","_setCollapseState","isCollapsed","setCollapsed","recursive","_this4","_this$getTreeNodeWith3","result","_setListNodeCollapseState","onlyVisibleChildIndex","_setNodeCollapseState","previousRenderNodeCount","updateNodeAfterCollapseChange","deep","_iterator4","_step4","expandTo","_this5","updateNodeAfterFilterChange","cancel","treeElement","parentVisibility","treeListElements","_filterNode","childElements","childRevealed","_iterator5","_step5","pop","_updateNodeAfterCollapseChange","_iterator6","_step6","_updateNodeAfterFilterChange","resultStartLength","hasVisibleDescendants","_iterator7","_step7","data","_location","_toArray","rest","_location2","_this$getParentNodeWi3","_location3","getNode","getNodeLocation","indexTreeNode","indexOf","reverse","getParentNodeLocation","getFirstElementChild"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/base/browser/ui/tree/indexTreeModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TreeError } from './tree.js';\nimport { splice, tail2 } from '../../../common/arrays.js';\nimport { Delayer } from '../../../common/async.js';\nimport { MicrotaskDelay } from '../../../common/symbols.js';\nimport { LcsDiff } from '../../../common/diff/diff.js';\nimport { Emitter, EventBufferer } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nexport function isFilterResult(obj) {\n    return typeof obj === 'object' && 'visibility' in obj && 'data' in obj;\n}\nexport function getVisibleState(visibility) {\n    switch (visibility) {\n        case true: return 1 /* TreeVisibility.Visible */;\n        case false: return 0 /* TreeVisibility.Hidden */;\n        default: return visibility;\n    }\n}\nfunction isCollapsibleStateUpdate(update) {\n    return typeof update.collapsible === 'boolean';\n}\nexport class IndexTreeModel {\n    constructor(user, list, rootElement, options = {}) {\n        var _a;\n        this.user = user;\n        this.list = list;\n        this.rootRef = [];\n        this.eventBufferer = new EventBufferer();\n        this._onDidChangeCollapseState = new Emitter();\n        this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);\n        this._onDidChangeRenderNodeCount = new Emitter();\n        this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);\n        this._onDidSplice = new Emitter();\n        this.onDidSplice = this._onDidSplice.event;\n        this.refilterDelayer = new Delayer(MicrotaskDelay);\n        this.collapseByDefault = typeof options.collapseByDefault === 'undefined' ? false : options.collapseByDefault;\n        this.allowNonCollapsibleParents = (_a = options.allowNonCollapsibleParents) !== null && _a !== void 0 ? _a : false;\n        this.filter = options.filter;\n        this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n        this.root = {\n            parent: undefined,\n            element: rootElement,\n            children: [],\n            depth: 0,\n            visibleChildrenCount: 0,\n            visibleChildIndex: -1,\n            collapsible: false,\n            collapsed: false,\n            renderNodeCount: 0,\n            visibility: 1 /* TreeVisibility.Visible */,\n            visible: true,\n            filterData: undefined\n        };\n    }\n    splice(location, deleteCount, toInsert = Iterable.empty(), options = {}) {\n        if (location.length === 0) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        if (options.diffIdentityProvider) {\n            this.spliceSmart(options.diffIdentityProvider, location, deleteCount, toInsert, options);\n        }\n        else {\n            this.spliceSimple(location, deleteCount, toInsert, options);\n        }\n    }\n    spliceSmart(identity, location, deleteCount, toInsertIterable, options, recurseLevels) {\n        var _a;\n        if (toInsertIterable === void 0) { toInsertIterable = Iterable.empty(); }\n        if (recurseLevels === void 0) { recurseLevels = (_a = options.diffDepth) !== null && _a !== void 0 ? _a : 0; }\n        const { parentNode } = this.getParentNodeWithListIndex(location);\n        if (!parentNode.lastDiffIds) {\n            return this.spliceSimple(location, deleteCount, toInsertIterable, options);\n        }\n        const toInsert = [...toInsertIterable];\n        const index = location[location.length - 1];\n        const diff = new LcsDiff({ getElements: () => parentNode.lastDiffIds }, {\n            getElements: () => [\n                ...parentNode.children.slice(0, index),\n                ...toInsert,\n                ...parentNode.children.slice(index + deleteCount),\n            ].map(e => identity.getId(e.element).toString())\n        }).ComputeDiff(false);\n        // if we were given a 'best effort' diff, use default behavior\n        if (diff.quitEarly) {\n            parentNode.lastDiffIds = undefined;\n            return this.spliceSimple(location, deleteCount, toInsert, options);\n        }\n        const locationPrefix = location.slice(0, -1);\n        const recurseSplice = (fromOriginal, fromModified, count) => {\n            if (recurseLevels > 0) {\n                for (let i = 0; i < count; i++) {\n                    fromOriginal--;\n                    fromModified--;\n                    this.spliceSmart(identity, [...locationPrefix, fromOriginal, 0], Number.MAX_SAFE_INTEGER, toInsert[fromModified].children, options, recurseLevels - 1);\n                }\n            }\n        };\n        let lastStartO = Math.min(parentNode.children.length, index + deleteCount);\n        let lastStartM = toInsert.length;\n        for (const change of diff.changes.sort((a, b) => b.originalStart - a.originalStart)) {\n            recurseSplice(lastStartO, lastStartM, lastStartO - (change.originalStart + change.originalLength));\n            lastStartO = change.originalStart;\n            lastStartM = change.modifiedStart - index;\n            this.spliceSimple([...locationPrefix, lastStartO], change.originalLength, Iterable.slice(toInsert, lastStartM, lastStartM + change.modifiedLength), options);\n        }\n        // at this point, startO === startM === count since any remaining prefix should match\n        recurseSplice(lastStartO, lastStartM, lastStartO);\n    }\n    spliceSimple(location, deleteCount, toInsert = Iterable.empty(), { onDidCreateNode, onDidDeleteNode, diffIdentityProvider }) {\n        const { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);\n        const treeListElementsToInsert = [];\n        const nodesToInsertIterator = Iterable.map(toInsert, el => this.createTreeNode(el, parentNode, parentNode.visible ? 1 /* TreeVisibility.Visible */ : 0 /* TreeVisibility.Hidden */, revealed, treeListElementsToInsert, onDidCreateNode));\n        const lastIndex = location[location.length - 1];\n        // figure out what's the visible child start index right before the\n        // splice point\n        let visibleChildStartIndex = 0;\n        for (let i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {\n            const child = parentNode.children[i];\n            if (child.visible) {\n                visibleChildStartIndex = child.visibleChildIndex;\n                break;\n            }\n        }\n        const nodesToInsert = [];\n        let insertedVisibleChildrenCount = 0;\n        let renderNodeCount = 0;\n        for (const child of nodesToInsertIterator) {\n            nodesToInsert.push(child);\n            renderNodeCount += child.renderNodeCount;\n            if (child.visible) {\n                child.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;\n            }\n        }\n        const deletedNodes = splice(parentNode.children, lastIndex, deleteCount, nodesToInsert);\n        if (!diffIdentityProvider) {\n            parentNode.lastDiffIds = undefined;\n        }\n        else if (parentNode.lastDiffIds) {\n            splice(parentNode.lastDiffIds, lastIndex, deleteCount, nodesToInsert.map(n => diffIdentityProvider.getId(n.element).toString()));\n        }\n        else {\n            parentNode.lastDiffIds = parentNode.children.map(n => diffIdentityProvider.getId(n.element).toString());\n        }\n        // figure out what is the count of deleted visible children\n        let deletedVisibleChildrenCount = 0;\n        for (const child of deletedNodes) {\n            if (child.visible) {\n                deletedVisibleChildrenCount++;\n            }\n        }\n        // and adjust for all visible children after the splice point\n        if (deletedVisibleChildrenCount !== 0) {\n            for (let i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {\n                const child = parentNode.children[i];\n                if (child.visible) {\n                    child.visibleChildIndex -= deletedVisibleChildrenCount;\n                }\n            }\n        }\n        // update parent's visible children count\n        parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;\n        if (revealed && visible) {\n            const visibleDeleteCount = deletedNodes.reduce((r, node) => r + (node.visible ? node.renderNodeCount : 0), 0);\n            this._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);\n            this.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);\n        }\n        if (deletedNodes.length > 0 && onDidDeleteNode) {\n            const visit = (node) => {\n                onDidDeleteNode(node);\n                node.children.forEach(visit);\n            };\n            deletedNodes.forEach(visit);\n        }\n        this._onDidSplice.fire({ insertedNodes: nodesToInsert, deletedNodes });\n        let node = parentNode;\n        while (node) {\n            if (node.visibility === 2 /* TreeVisibility.Recurse */) {\n                // delayed to avoid excessive refiltering, see #135941\n                this.refilterDelayer.trigger(() => this.refilter());\n                break;\n            }\n            node = node.parent;\n        }\n    }\n    rerender(location) {\n        if (location.length === 0) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        const { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);\n        if (node.visible && revealed) {\n            this.list.splice(listIndex, 1, [node]);\n        }\n    }\n    has(location) {\n        return this.hasTreeNode(location);\n    }\n    getListIndex(location) {\n        const { listIndex, visible, revealed } = this.getTreeNodeWithListIndex(location);\n        return visible && revealed ? listIndex : -1;\n    }\n    getListRenderCount(location) {\n        return this.getTreeNode(location).renderNodeCount;\n    }\n    isCollapsible(location) {\n        return this.getTreeNode(location).collapsible;\n    }\n    setCollapsible(location, collapsible) {\n        const node = this.getTreeNode(location);\n        if (typeof collapsible === 'undefined') {\n            collapsible = !node.collapsible;\n        }\n        const update = { collapsible };\n        return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\n    }\n    isCollapsed(location) {\n        return this.getTreeNode(location).collapsed;\n    }\n    setCollapsed(location, collapsed, recursive) {\n        const node = this.getTreeNode(location);\n        if (typeof collapsed === 'undefined') {\n            collapsed = !node.collapsed;\n        }\n        const update = { collapsed, recursive: recursive || false };\n        return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\n    }\n    _setCollapseState(location, update) {\n        const { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);\n        const result = this._setListNodeCollapseState(node, listIndex, revealed, update);\n        if (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {\n            let onlyVisibleChildIndex = -1;\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                if (child.visible) {\n                    if (onlyVisibleChildIndex > -1) {\n                        onlyVisibleChildIndex = -1;\n                        break;\n                    }\n                    else {\n                        onlyVisibleChildIndex = i;\n                    }\n                }\n            }\n            if (onlyVisibleChildIndex > -1) {\n                this._setCollapseState([...location, onlyVisibleChildIndex], update);\n            }\n        }\n        return result;\n    }\n    _setListNodeCollapseState(node, listIndex, revealed, update) {\n        const result = this._setNodeCollapseState(node, update, false);\n        if (!revealed || !node.visible || !result) {\n            return result;\n        }\n        const previousRenderNodeCount = node.renderNodeCount;\n        const toInsert = this.updateNodeAfterCollapseChange(node);\n        const deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);\n        this.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));\n        return result;\n    }\n    _setNodeCollapseState(node, update, deep) {\n        let result;\n        if (node === this.root) {\n            result = false;\n        }\n        else {\n            if (isCollapsibleStateUpdate(update)) {\n                result = node.collapsible !== update.collapsible;\n                node.collapsible = update.collapsible;\n            }\n            else if (!node.collapsible) {\n                result = false;\n            }\n            else {\n                result = node.collapsed !== update.collapsed;\n                node.collapsed = update.collapsed;\n            }\n            if (result) {\n                this._onDidChangeCollapseState.fire({ node, deep });\n            }\n        }\n        if (!isCollapsibleStateUpdate(update) && update.recursive) {\n            for (const child of node.children) {\n                result = this._setNodeCollapseState(child, update, true) || result;\n            }\n        }\n        return result;\n    }\n    expandTo(location) {\n        this.eventBufferer.bufferEvents(() => {\n            let node = this.getTreeNode(location);\n            while (node.parent) {\n                node = node.parent;\n                location = location.slice(0, location.length - 1);\n                if (node.collapsed) {\n                    this._setCollapseState(location, { collapsed: false, recursive: false });\n                }\n            }\n        });\n    }\n    refilter() {\n        const previousRenderNodeCount = this.root.renderNodeCount;\n        const toInsert = this.updateNodeAfterFilterChange(this.root);\n        this.list.splice(0, previousRenderNodeCount, toInsert);\n        this.refilterDelayer.cancel();\n    }\n    createTreeNode(treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {\n        const node = {\n            parent,\n            element: treeElement.element,\n            children: [],\n            depth: parent.depth + 1,\n            visibleChildrenCount: 0,\n            visibleChildIndex: -1,\n            collapsible: typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : (typeof treeElement.collapsed !== 'undefined'),\n            collapsed: typeof treeElement.collapsed === 'undefined' ? this.collapseByDefault : treeElement.collapsed,\n            renderNodeCount: 1,\n            visibility: 1 /* TreeVisibility.Visible */,\n            visible: true,\n            filterData: undefined\n        };\n        const visibility = this._filterNode(node, parentVisibility);\n        node.visibility = visibility;\n        if (revealed) {\n            treeListElements.push(node);\n        }\n        const childElements = treeElement.children || Iterable.empty();\n        const childRevealed = revealed && visibility !== 0 /* TreeVisibility.Hidden */ && !node.collapsed;\n        let visibleChildrenCount = 0;\n        let renderNodeCount = 1;\n        for (const el of childElements) {\n            const child = this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode);\n            node.children.push(child);\n            renderNodeCount += child.renderNodeCount;\n            if (child.visible) {\n                child.visibleChildIndex = visibleChildrenCount++;\n            }\n        }\n        if (!this.allowNonCollapsibleParents) {\n            node.collapsible = node.collapsible || node.children.length > 0;\n        }\n        node.visibleChildrenCount = visibleChildrenCount;\n        node.visible = visibility === 2 /* TreeVisibility.Recurse */ ? visibleChildrenCount > 0 : (visibility === 1 /* TreeVisibility.Visible */);\n        if (!node.visible) {\n            node.renderNodeCount = 0;\n            if (revealed) {\n                treeListElements.pop();\n            }\n        }\n        else if (!node.collapsed) {\n            node.renderNodeCount = renderNodeCount;\n        }\n        onDidCreateNode === null || onDidCreateNode === void 0 ? void 0 : onDidCreateNode(node);\n        return node;\n    }\n    updateNodeAfterCollapseChange(node) {\n        const previousRenderNodeCount = node.renderNodeCount;\n        const result = [];\n        this._updateNodeAfterCollapseChange(node, result);\n        this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n        return result;\n    }\n    _updateNodeAfterCollapseChange(node, result) {\n        if (node.visible === false) {\n            return 0;\n        }\n        result.push(node);\n        node.renderNodeCount = 1;\n        if (!node.collapsed) {\n            for (const child of node.children) {\n                node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);\n            }\n        }\n        this._onDidChangeRenderNodeCount.fire(node);\n        return node.renderNodeCount;\n    }\n    updateNodeAfterFilterChange(node) {\n        const previousRenderNodeCount = node.renderNodeCount;\n        const result = [];\n        this._updateNodeAfterFilterChange(node, node.visible ? 1 /* TreeVisibility.Visible */ : 0 /* TreeVisibility.Hidden */, result);\n        this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n        return result;\n    }\n    _updateNodeAfterFilterChange(node, parentVisibility, result, revealed = true) {\n        let visibility;\n        if (node !== this.root) {\n            visibility = this._filterNode(node, parentVisibility);\n            if (visibility === 0 /* TreeVisibility.Hidden */) {\n                node.visible = false;\n                node.renderNodeCount = 0;\n                return false;\n            }\n            if (revealed) {\n                result.push(node);\n            }\n        }\n        const resultStartLength = result.length;\n        node.renderNodeCount = node === this.root ? 0 : 1;\n        let hasVisibleDescendants = false;\n        if (!node.collapsed || visibility !== 0 /* TreeVisibility.Hidden */) {\n            let visibleChildIndex = 0;\n            for (const child of node.children) {\n                hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants;\n                if (child.visible) {\n                    child.visibleChildIndex = visibleChildIndex++;\n                }\n            }\n            node.visibleChildrenCount = visibleChildIndex;\n        }\n        else {\n            node.visibleChildrenCount = 0;\n        }\n        if (node !== this.root) {\n            node.visible = visibility === 2 /* TreeVisibility.Recurse */ ? hasVisibleDescendants : (visibility === 1 /* TreeVisibility.Visible */);\n            node.visibility = visibility;\n        }\n        if (!node.visible) {\n            node.renderNodeCount = 0;\n            if (revealed) {\n                result.pop();\n            }\n        }\n        else if (!node.collapsed) {\n            node.renderNodeCount += result.length - resultStartLength;\n        }\n        this._onDidChangeRenderNodeCount.fire(node);\n        return node.visible;\n    }\n    _updateAncestorsRenderNodeCount(node, diff) {\n        if (diff === 0) {\n            return;\n        }\n        while (node) {\n            node.renderNodeCount += diff;\n            this._onDidChangeRenderNodeCount.fire(node);\n            node = node.parent;\n        }\n    }\n    _filterNode(node, parentVisibility) {\n        const result = this.filter ? this.filter.filter(node.element, parentVisibility) : 1 /* TreeVisibility.Visible */;\n        if (typeof result === 'boolean') {\n            node.filterData = undefined;\n            return result ? 1 /* TreeVisibility.Visible */ : 0 /* TreeVisibility.Hidden */;\n        }\n        else if (isFilterResult(result)) {\n            node.filterData = result.data;\n            return getVisibleState(result.visibility);\n        }\n        else {\n            node.filterData = undefined;\n            return getVisibleState(result);\n        }\n    }\n    // cheap\n    hasTreeNode(location, node = this.root) {\n        if (!location || location.length === 0) {\n            return true;\n        }\n        const [index, ...rest] = location;\n        if (index < 0 || index > node.children.length) {\n            return false;\n        }\n        return this.hasTreeNode(rest, node.children[index]);\n    }\n    // cheap\n    getTreeNode(location, node = this.root) {\n        if (!location || location.length === 0) {\n            return node;\n        }\n        const [index, ...rest] = location;\n        if (index < 0 || index > node.children.length) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        return this.getTreeNode(rest, node.children[index]);\n    }\n    // expensive\n    getTreeNodeWithListIndex(location) {\n        if (location.length === 0) {\n            return { node: this.root, listIndex: -1, revealed: true, visible: false };\n        }\n        const { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);\n        const index = location[location.length - 1];\n        if (index < 0 || index > parentNode.children.length) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        const node = parentNode.children[index];\n        return { node, listIndex, revealed, visible: visible && node.visible };\n    }\n    getParentNodeWithListIndex(location, node = this.root, listIndex = 0, revealed = true, visible = true) {\n        const [index, ...rest] = location;\n        if (index < 0 || index > node.children.length) {\n            throw new TreeError(this.user, 'Invalid tree location');\n        }\n        // TODO@joao perf!\n        for (let i = 0; i < index; i++) {\n            listIndex += node.children[i].renderNodeCount;\n        }\n        revealed = revealed && !node.collapsed;\n        visible = visible && node.visible;\n        if (rest.length === 0) {\n            return { parentNode: node, listIndex, revealed, visible };\n        }\n        return this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);\n    }\n    getNode(location = []) {\n        return this.getTreeNode(location);\n    }\n    // TODO@joao perf!\n    getNodeLocation(node) {\n        const location = [];\n        let indexTreeNode = node; // typing woes\n        while (indexTreeNode.parent) {\n            location.push(indexTreeNode.parent.children.indexOf(indexTreeNode));\n            indexTreeNode = indexTreeNode.parent;\n        }\n        return location.reverse();\n    }\n    getParentNodeLocation(location) {\n        if (location.length === 0) {\n            return undefined;\n        }\n        else if (location.length === 1) {\n            return [];\n        }\n        else {\n            return tail2(location)[0];\n        }\n    }\n    getFirstElementChild(location) {\n        const node = this.getTreeNode(location);\n        if (node.children.length === 0) {\n            return undefined;\n        }\n        return node.children[0].element;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}