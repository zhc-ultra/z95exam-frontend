{"ast":null,"code":"import _toConsumableArray from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _get from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn } from '../assert.js';\nimport { DisposableStore } from '../lifecycle.js';\nimport { BaseObservable, _setDerivedOpts } from './base.js';\nimport { DebugNameData } from './debugName.js';\nimport { getLogger } from './logging.js';\nexport var defaultEqualityComparer = function defaultEqualityComparer(a, b) {\n  return a === b;\n};\nexport function derived(computeFnOrOwner, computeFn) {\n  if (computeFn !== undefined) {\n    return new Derived(new DebugNameData(computeFnOrOwner, undefined, computeFn), computeFn, undefined, undefined, undefined, defaultEqualityComparer);\n  }\n  return new Derived(new DebugNameData(undefined, undefined, computeFnOrOwner), computeFnOrOwner, undefined, undefined, undefined, defaultEqualityComparer);\n}\nexport function derivedOpts(options, computeFn) {\n  var _a;\n  return new Derived(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn), computeFn, undefined, undefined, options.onLastObserverRemoved, (_a = options.equalityComparer) !== null && _a !== void 0 ? _a : defaultEqualityComparer);\n}\n_setDerivedOpts(derivedOpts);\n/**\n * Represents an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The compute function is given the last change summary.\n * The change summary is discarded after the compute function was called.\n *\n * @see derived\n */\nexport function derivedHandleChanges(options, computeFn) {\n  var _a;\n  return new Derived(new DebugNameData(options.owner, options.debugName, undefined), computeFn, options.createEmptyChangeSummary, options.handleChange, undefined, (_a = options.equalityComparer) !== null && _a !== void 0 ? _a : defaultEqualityComparer);\n}\nexport function derivedWithStore(computeFnOrOwner, computeFnOrUndefined) {\n  var computeFn;\n  var owner;\n  if (computeFnOrUndefined === undefined) {\n    computeFn = computeFnOrOwner;\n    owner = undefined;\n  } else {\n    owner = computeFnOrOwner;\n    computeFn = computeFnOrUndefined;\n  }\n  var store = new DisposableStore();\n  return new Derived(new DebugNameData(owner, undefined, computeFn), function (r) {\n    store.clear();\n    return computeFn(r, store);\n  }, undefined, undefined, function () {\n    return store.dispose();\n  }, defaultEqualityComparer);\n}\nexport function derivedDisposable(computeFnOrOwner, computeFnOrUndefined) {\n  var computeFn;\n  var owner;\n  if (computeFnOrUndefined === undefined) {\n    computeFn = computeFnOrOwner;\n    owner = undefined;\n  } else {\n    owner = computeFnOrOwner;\n    computeFn = computeFnOrUndefined;\n  }\n  var store = new DisposableStore();\n  return new Derived(new DebugNameData(owner, undefined, computeFn), function (r) {\n    store.clear();\n    var result = computeFn(r);\n    if (result) {\n      store.add(result);\n    }\n    return result;\n  }, undefined, undefined, function () {\n    return store.dispose();\n  }, defaultEqualityComparer);\n}\nexport var Derived = /*#__PURE__*/function (_BaseObservable) {\n  function Derived(_debugNameData, _computeFn, createChangeSummary, _handleChange) {\n    var _this;\n    var _handleLastObserverRemoved = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n    var _equalityComparator = arguments.length > 5 ? arguments[5] : undefined;\n    _classCallCheck(this, Derived);\n    var _a, _b;\n    _this = _callSuper(this, Derived);\n    _this._debugNameData = _debugNameData;\n    _this._computeFn = _computeFn;\n    _this.createChangeSummary = createChangeSummary;\n    _this._handleChange = _handleChange;\n    _this._handleLastObserverRemoved = _handleLastObserverRemoved;\n    _this._equalityComparator = _equalityComparator;\n    _this.state = 0 /* DerivedState.initial */;\n    _this.value = undefined;\n    _this.updateCount = 0;\n    _this.dependencies = new Set();\n    _this.dependenciesToBeRemoved = new Set();\n    _this.changeSummary = undefined;\n    _this.changeSummary = (_a = _this.createChangeSummary) === null || _a === void 0 ? void 0 : _a.call(_this);\n    (_b = getLogger()) === null || _b === void 0 ? void 0 : _b.handleDerivedCreated(_this);\n    return _this;\n  }\n  _inherits(Derived, _BaseObservable);\n  return _createClass(Derived, [{\n    key: \"debugName\",\n    get: function get() {\n      var _a;\n      return (_a = this._debugNameData.getDebugName(this)) !== null && _a !== void 0 ? _a : '(anonymous)';\n    }\n  }, {\n    key: \"onLastObserverRemoved\",\n    value: function onLastObserverRemoved() {\n      var _a;\n      /**\n       * We are not tracking changes anymore, thus we have to assume\n       * that our cache is invalid.\n       */\n      this.state = 0 /* DerivedState.initial */;\n      this.value = undefined;\n      var _iterator = _createForOfIteratorHelper(this.dependencies),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var d = _step.value;\n          d.removeObserver(this);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.dependencies.clear();\n      (_a = this._handleLastObserverRemoved) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n  }, {\n    key: \"get\",\n    value: function get() {\n      var _a;\n      if (this.observers.size === 0) {\n        // Without observers, we don't know when to clean up stuff.\n        // Thus, we don't cache anything to prevent memory leaks.\n        var result = this._computeFn(this, (_a = this.createChangeSummary) === null || _a === void 0 ? void 0 : _a.call(this));\n        // Clear new dependencies\n        this.onLastObserverRemoved();\n        return result;\n      } else {\n        do {\n          // We might not get a notification for a dependency that changed while it is updating,\n          // thus we also have to ask all our depedencies if they changed in this case.\n          if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n            var _iterator2 = _createForOfIteratorHelper(this.dependencies),\n              _step2;\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var d = _step2.value;\n                /** might call {@link handleChange} indirectly, which could make us stale */\n                d.reportChanges();\n                if (this.state === 2 /* DerivedState.stale */) {\n                  // The other dependencies will refresh on demand, so early break\n                  break;\n                }\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          }\n          // We called report changes of all dependencies.\n          // If we are still not stale, we can assume to be up to date again.\n          if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n            this.state = 3 /* DerivedState.upToDate */;\n          }\n          this._recomputeIfNeeded();\n          // In case recomputation changed one of our dependencies, we need to recompute again.\n        } while (this.state !== 3 /* DerivedState.upToDate */);\n        return this.value;\n      }\n    }\n  }, {\n    key: \"_recomputeIfNeeded\",\n    value: function _recomputeIfNeeded() {\n      var _a, _b;\n      if (this.state === 3 /* DerivedState.upToDate */) {\n        return;\n      }\n      var emptySet = this.dependenciesToBeRemoved;\n      this.dependenciesToBeRemoved = this.dependencies;\n      this.dependencies = emptySet;\n      var hadValue = this.state !== 0 /* DerivedState.initial */;\n      var oldValue = this.value;\n      this.state = 3 /* DerivedState.upToDate */;\n      var changeSummary = this.changeSummary;\n      this.changeSummary = (_a = this.createChangeSummary) === null || _a === void 0 ? void 0 : _a.call(this);\n      try {\n        /** might call {@link handleChange} indirectly, which could invalidate us */\n        this.value = this._computeFn(this, changeSummary);\n      } finally {\n        // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n        // Thus, we only unsubscribe from observables that are definitely not read anymore.\n        var _iterator3 = _createForOfIteratorHelper(this.dependenciesToBeRemoved),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var o = _step3.value;\n            o.removeObserver(this);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        this.dependenciesToBeRemoved.clear();\n      }\n      var didChange = hadValue && !this._equalityComparator(oldValue, this.value);\n      (_b = getLogger()) === null || _b === void 0 ? void 0 : _b.handleDerivedRecomputed(this, {\n        oldValue: oldValue,\n        newValue: this.value,\n        change: undefined,\n        didChange: didChange,\n        hadValue: hadValue\n      });\n      if (didChange) {\n        var _iterator4 = _createForOfIteratorHelper(this.observers),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var r = _step4.value;\n            r.handleChange(this, undefined);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"LazyDerived<\".concat(this.debugName, \">\");\n    }\n    // IObserver Implementation\n  }, {\n    key: \"beginUpdate\",\n    value: function beginUpdate(_observable) {\n      this.updateCount++;\n      var propagateBeginUpdate = this.updateCount === 1;\n      if (this.state === 3 /* DerivedState.upToDate */) {\n        this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n        // If we propagate begin update, that will already signal a possible change.\n        if (!propagateBeginUpdate) {\n          var _iterator5 = _createForOfIteratorHelper(this.observers),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var r = _step5.value;\n              r.handlePossibleChange(this);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      }\n      if (propagateBeginUpdate) {\n        var _iterator6 = _createForOfIteratorHelper(this.observers),\n          _step6;\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var _r = _step6.value;\n            _r.beginUpdate(this); // This signals a possible change\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      }\n    }\n  }, {\n    key: \"endUpdate\",\n    value: function endUpdate(_observable) {\n      var _this2 = this;\n      this.updateCount--;\n      if (this.updateCount === 0) {\n        // End update could change the observer list.\n        var observers = _toConsumableArray(this.observers);\n        var _iterator7 = _createForOfIteratorHelper(observers),\n          _step7;\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var r = _step7.value;\n            r.endUpdate(this);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      }\n      assertFn(function () {\n        return _this2.updateCount >= 0;\n      });\n    }\n  }, {\n    key: \"handlePossibleChange\",\n    value: function handlePossibleChange(observable) {\n      // In all other states, observers already know that we might have changed.\n      if (this.state === 3 /* DerivedState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n        this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n        var _iterator8 = _createForOfIteratorHelper(this.observers),\n          _step8;\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var r = _step8.value;\n            r.handlePossibleChange(this);\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n      }\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange(observable, change) {\n      if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n        var shouldReact = this._handleChange ? this._handleChange({\n          changedObservable: observable,\n          change: change,\n          didChange: function didChange(o) {\n            return o === observable;\n          }\n        }, this.changeSummary) : true;\n        var wasUpToDate = this.state === 3 /* DerivedState.upToDate */;\n        if (shouldReact && (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */ || wasUpToDate)) {\n          this.state = 2 /* DerivedState.stale */;\n          if (wasUpToDate) {\n            var _iterator9 = _createForOfIteratorHelper(this.observers),\n              _step9;\n            try {\n              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                var r = _step9.value;\n                r.handlePossibleChange(this);\n              }\n            } catch (err) {\n              _iterator9.e(err);\n            } finally {\n              _iterator9.f();\n            }\n          }\n        }\n      }\n    }\n    // IReader Implementation\n  }, {\n    key: \"readObservable\",\n    value: function readObservable(observable) {\n      // Subscribe before getting the value to enable caching\n      observable.addObserver(this);\n      /** This might call {@link handleChange} indirectly, which could invalidate us */\n      var value = observable.get();\n      // Which is why we only add the observable to the dependencies now.\n      this.dependencies.add(observable);\n      this.dependenciesToBeRemoved[\"delete\"](observable);\n      return value;\n    }\n  }, {\n    key: \"addObserver\",\n    value: function addObserver(observer) {\n      var shouldCallBeginUpdate = !this.observers.has(observer) && this.updateCount > 0;\n      _get(_getPrototypeOf(Derived.prototype), \"addObserver\", this).call(this, observer);\n      if (shouldCallBeginUpdate) {\n        observer.beginUpdate(this);\n      }\n    }\n  }, {\n    key: \"removeObserver\",\n    value: function removeObserver(observer) {\n      var shouldCallEndUpdate = this.observers.has(observer) && this.updateCount > 0;\n      _get(_getPrototypeOf(Derived.prototype), \"removeObserver\", this).call(this, observer);\n      if (shouldCallEndUpdate) {\n        // Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n        observer.endUpdate(this);\n      }\n    }\n  }]);\n}(BaseObservable);","map":{"version":3,"names":["assertFn","DisposableStore","BaseObservable","_setDerivedOpts","DebugNameData","getLogger","defaultEqualityComparer","a","b","derived","computeFnOrOwner","computeFn","undefined","Derived","derivedOpts","options","_a","owner","debugName","debugReferenceFn","onLastObserverRemoved","equalityComparer","derivedHandleChanges","createEmptyChangeSummary","handleChange","derivedWithStore","computeFnOrUndefined","store","r","clear","dispose","derivedDisposable","result","add","_BaseObservable","_debugNameData","_computeFn","createChangeSummary","_handleChange","_this","_handleLastObserverRemoved","arguments","length","_equalityComparator","_classCallCheck","_b","_callSuper","state","value","updateCount","dependencies","Set","dependenciesToBeRemoved","changeSummary","call","handleDerivedCreated","_inherits","_createClass","key","get","getDebugName","_iterator","_createForOfIteratorHelper","_step","s","n","done","d","removeObserver","err","e","f","observers","size","_iterator2","_step2","reportChanges","_recomputeIfNeeded","emptySet","hadValue","oldValue","_iterator3","_step3","o","didChange","handleDerivedRecomputed","newValue","change","_iterator4","_step4","toString","concat","beginUpdate","_observable","propagateBeginUpdate","_iterator5","_step5","handlePossibleChange","_iterator6","_step6","endUpdate","_this2","_toConsumableArray","_iterator7","_step7","observable","has","_iterator8","_step8","shouldReact","changedObservable","wasUpToDate","_iterator9","_step9","readObservable","addObserver","observer","shouldCallBeginUpdate","_get","_getPrototypeOf","prototype","shouldCallEndUpdate"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/base/common/observableInternal/derived.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn } from '../assert.js';\nimport { DisposableStore } from '../lifecycle.js';\nimport { BaseObservable, _setDerivedOpts } from './base.js';\nimport { DebugNameData } from './debugName.js';\nimport { getLogger } from './logging.js';\nexport const defaultEqualityComparer = (a, b) => a === b;\nexport function derived(computeFnOrOwner, computeFn) {\n    if (computeFn !== undefined) {\n        return new Derived(new DebugNameData(computeFnOrOwner, undefined, computeFn), computeFn, undefined, undefined, undefined, defaultEqualityComparer);\n    }\n    return new Derived(new DebugNameData(undefined, undefined, computeFnOrOwner), computeFnOrOwner, undefined, undefined, undefined, defaultEqualityComparer);\n}\nexport function derivedOpts(options, computeFn) {\n    var _a;\n    return new Derived(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn), computeFn, undefined, undefined, options.onLastObserverRemoved, (_a = options.equalityComparer) !== null && _a !== void 0 ? _a : defaultEqualityComparer);\n}\n_setDerivedOpts(derivedOpts);\n/**\n * Represents an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The compute function is given the last change summary.\n * The change summary is discarded after the compute function was called.\n *\n * @see derived\n */\nexport function derivedHandleChanges(options, computeFn) {\n    var _a;\n    return new Derived(new DebugNameData(options.owner, options.debugName, undefined), computeFn, options.createEmptyChangeSummary, options.handleChange, undefined, (_a = options.equalityComparer) !== null && _a !== void 0 ? _a : defaultEqualityComparer);\n}\nexport function derivedWithStore(computeFnOrOwner, computeFnOrUndefined) {\n    let computeFn;\n    let owner;\n    if (computeFnOrUndefined === undefined) {\n        computeFn = computeFnOrOwner;\n        owner = undefined;\n    }\n    else {\n        owner = computeFnOrOwner;\n        computeFn = computeFnOrUndefined;\n    }\n    const store = new DisposableStore();\n    return new Derived(new DebugNameData(owner, undefined, computeFn), r => {\n        store.clear();\n        return computeFn(r, store);\n    }, undefined, undefined, () => store.dispose(), defaultEqualityComparer);\n}\nexport function derivedDisposable(computeFnOrOwner, computeFnOrUndefined) {\n    let computeFn;\n    let owner;\n    if (computeFnOrUndefined === undefined) {\n        computeFn = computeFnOrOwner;\n        owner = undefined;\n    }\n    else {\n        owner = computeFnOrOwner;\n        computeFn = computeFnOrUndefined;\n    }\n    const store = new DisposableStore();\n    return new Derived(new DebugNameData(owner, undefined, computeFn), r => {\n        store.clear();\n        const result = computeFn(r);\n        if (result) {\n            store.add(result);\n        }\n        return result;\n    }, undefined, undefined, () => store.dispose(), defaultEqualityComparer);\n}\nexport class Derived extends BaseObservable {\n    get debugName() {\n        var _a;\n        return (_a = this._debugNameData.getDebugName(this)) !== null && _a !== void 0 ? _a : '(anonymous)';\n    }\n    constructor(_debugNameData, _computeFn, createChangeSummary, _handleChange, _handleLastObserverRemoved = undefined, _equalityComparator) {\n        var _a, _b;\n        super();\n        this._debugNameData = _debugNameData;\n        this._computeFn = _computeFn;\n        this.createChangeSummary = createChangeSummary;\n        this._handleChange = _handleChange;\n        this._handleLastObserverRemoved = _handleLastObserverRemoved;\n        this._equalityComparator = _equalityComparator;\n        this.state = 0 /* DerivedState.initial */;\n        this.value = undefined;\n        this.updateCount = 0;\n        this.dependencies = new Set();\n        this.dependenciesToBeRemoved = new Set();\n        this.changeSummary = undefined;\n        this.changeSummary = (_a = this.createChangeSummary) === null || _a === void 0 ? void 0 : _a.call(this);\n        (_b = getLogger()) === null || _b === void 0 ? void 0 : _b.handleDerivedCreated(this);\n    }\n    onLastObserverRemoved() {\n        var _a;\n        /**\n         * We are not tracking changes anymore, thus we have to assume\n         * that our cache is invalid.\n         */\n        this.state = 0 /* DerivedState.initial */;\n        this.value = undefined;\n        for (const d of this.dependencies) {\n            d.removeObserver(this);\n        }\n        this.dependencies.clear();\n        (_a = this._handleLastObserverRemoved) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    get() {\n        var _a;\n        if (this.observers.size === 0) {\n            // Without observers, we don't know when to clean up stuff.\n            // Thus, we don't cache anything to prevent memory leaks.\n            const result = this._computeFn(this, (_a = this.createChangeSummary) === null || _a === void 0 ? void 0 : _a.call(this));\n            // Clear new dependencies\n            this.onLastObserverRemoved();\n            return result;\n        }\n        else {\n            do {\n                // We might not get a notification for a dependency that changed while it is updating,\n                // thus we also have to ask all our depedencies if they changed in this case.\n                if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n                    for (const d of this.dependencies) {\n                        /** might call {@link handleChange} indirectly, which could make us stale */\n                        d.reportChanges();\n                        if (this.state === 2 /* DerivedState.stale */) {\n                            // The other dependencies will refresh on demand, so early break\n                            break;\n                        }\n                    }\n                }\n                // We called report changes of all dependencies.\n                // If we are still not stale, we can assume to be up to date again.\n                if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n                    this.state = 3 /* DerivedState.upToDate */;\n                }\n                this._recomputeIfNeeded();\n                // In case recomputation changed one of our dependencies, we need to recompute again.\n            } while (this.state !== 3 /* DerivedState.upToDate */);\n            return this.value;\n        }\n    }\n    _recomputeIfNeeded() {\n        var _a, _b;\n        if (this.state === 3 /* DerivedState.upToDate */) {\n            return;\n        }\n        const emptySet = this.dependenciesToBeRemoved;\n        this.dependenciesToBeRemoved = this.dependencies;\n        this.dependencies = emptySet;\n        const hadValue = this.state !== 0 /* DerivedState.initial */;\n        const oldValue = this.value;\n        this.state = 3 /* DerivedState.upToDate */;\n        const changeSummary = this.changeSummary;\n        this.changeSummary = (_a = this.createChangeSummary) === null || _a === void 0 ? void 0 : _a.call(this);\n        try {\n            /** might call {@link handleChange} indirectly, which could invalidate us */\n            this.value = this._computeFn(this, changeSummary);\n        }\n        finally {\n            // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n            // Thus, we only unsubscribe from observables that are definitely not read anymore.\n            for (const o of this.dependenciesToBeRemoved) {\n                o.removeObserver(this);\n            }\n            this.dependenciesToBeRemoved.clear();\n        }\n        const didChange = hadValue && !(this._equalityComparator(oldValue, this.value));\n        (_b = getLogger()) === null || _b === void 0 ? void 0 : _b.handleDerivedRecomputed(this, {\n            oldValue,\n            newValue: this.value,\n            change: undefined,\n            didChange,\n            hadValue,\n        });\n        if (didChange) {\n            for (const r of this.observers) {\n                r.handleChange(this, undefined);\n            }\n        }\n    }\n    toString() {\n        return `LazyDerived<${this.debugName}>`;\n    }\n    // IObserver Implementation\n    beginUpdate(_observable) {\n        this.updateCount++;\n        const propagateBeginUpdate = this.updateCount === 1;\n        if (this.state === 3 /* DerivedState.upToDate */) {\n            this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n            // If we propagate begin update, that will already signal a possible change.\n            if (!propagateBeginUpdate) {\n                for (const r of this.observers) {\n                    r.handlePossibleChange(this);\n                }\n            }\n        }\n        if (propagateBeginUpdate) {\n            for (const r of this.observers) {\n                r.beginUpdate(this); // This signals a possible change\n            }\n        }\n    }\n    endUpdate(_observable) {\n        this.updateCount--;\n        if (this.updateCount === 0) {\n            // End update could change the observer list.\n            const observers = [...this.observers];\n            for (const r of observers) {\n                r.endUpdate(this);\n            }\n        }\n        assertFn(() => this.updateCount >= 0);\n    }\n    handlePossibleChange(observable) {\n        // In all other states, observers already know that we might have changed.\n        if (this.state === 3 /* DerivedState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n            for (const r of this.observers) {\n                r.handlePossibleChange(this);\n            }\n        }\n    }\n    handleChange(observable, change) {\n        if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            const shouldReact = this._handleChange ? this._handleChange({\n                changedObservable: observable,\n                change,\n                didChange: o => o === observable,\n            }, this.changeSummary) : true;\n            const wasUpToDate = this.state === 3 /* DerivedState.upToDate */;\n            if (shouldReact && (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */ || wasUpToDate)) {\n                this.state = 2 /* DerivedState.stale */;\n                if (wasUpToDate) {\n                    for (const r of this.observers) {\n                        r.handlePossibleChange(this);\n                    }\n                }\n            }\n        }\n    }\n    // IReader Implementation\n    readObservable(observable) {\n        // Subscribe before getting the value to enable caching\n        observable.addObserver(this);\n        /** This might call {@link handleChange} indirectly, which could invalidate us */\n        const value = observable.get();\n        // Which is why we only add the observable to the dependencies now.\n        this.dependencies.add(observable);\n        this.dependenciesToBeRemoved.delete(observable);\n        return value;\n    }\n    addObserver(observer) {\n        const shouldCallBeginUpdate = !this.observers.has(observer) && this.updateCount > 0;\n        super.addObserver(observer);\n        if (shouldCallBeginUpdate) {\n            observer.beginUpdate(this);\n        }\n    }\n    removeObserver(observer) {\n        const shouldCallEndUpdate = this.observers.has(observer) && this.updateCount > 0;\n        super.removeObserver(observer);\n        if (shouldCallEndUpdate) {\n            // Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n            observer.endUpdate(this);\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}