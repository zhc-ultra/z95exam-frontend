{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.substr.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nvar PieceTreeTextBufferFactory = /*#__PURE__*/function () {\n  function PieceTreeTextBufferFactory(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n    _classCallCheck(this, PieceTreeTextBufferFactory);\n    this._chunks = _chunks;\n    this._bom = _bom;\n    this._cr = _cr;\n    this._lf = _lf;\n    this._crlf = _crlf;\n    this._containsRTL = _containsRTL;\n    this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n    this._isBasicASCII = _isBasicASCII;\n    this._normalizeEOL = _normalizeEOL;\n  }\n  return _createClass(PieceTreeTextBufferFactory, [{\n    key: \"_getEOL\",\n    value: function _getEOL(defaultEOL) {\n      var totalEOLCount = this._cr + this._lf + this._crlf;\n      var totalCRCount = this._cr + this._crlf;\n      if (totalEOLCount === 0) {\n        // This is an empty file or a file with precisely one line\n        return defaultEOL === 1 /* DefaultEndOfLine.LF */ ? '\\n' : '\\r\\n';\n      }\n      if (totalCRCount > totalEOLCount / 2) {\n        // More than half of the file contains \\r\\n ending lines\n        return '\\r\\n';\n      }\n      // At least one line more ends in \\n\n      return '\\n';\n    }\n  }, {\n    key: \"create\",\n    value: function create(defaultEOL) {\n      var eol = this._getEOL(defaultEOL);\n      var chunks = this._chunks;\n      if (this._normalizeEOL && (eol === '\\r\\n' && (this._cr > 0 || this._lf > 0) || eol === '\\n' && (this._cr > 0 || this._crlf > 0))) {\n        // Normalize pieces\n        for (var i = 0, len = chunks.length; i < len; i++) {\n          var str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n          var newLineStart = createLineStartsFast(str);\n          chunks[i] = new StringBuffer(str, newLineStart);\n        }\n      }\n      var textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n      return {\n        textBuffer: textBuffer,\n        disposable: textBuffer\n      };\n    }\n  }]);\n}();\nexport var PieceTreeTextBufferBuilder = /*#__PURE__*/function () {\n  function PieceTreeTextBufferBuilder() {\n    _classCallCheck(this, PieceTreeTextBufferBuilder);\n    this.chunks = [];\n    this.BOM = '';\n    this._hasPreviousChar = false;\n    this._previousChar = 0;\n    this._tmpLineStarts = [];\n    this.cr = 0;\n    this.lf = 0;\n    this.crlf = 0;\n    this.containsRTL = false;\n    this.containsUnusualLineTerminators = false;\n    this.isBasicASCII = true;\n  }\n  return _createClass(PieceTreeTextBufferBuilder, [{\n    key: \"acceptChunk\",\n    value: function acceptChunk(chunk) {\n      if (chunk.length === 0) {\n        return;\n      }\n      if (this.chunks.length === 0) {\n        if (strings.startsWithUTF8BOM(chunk)) {\n          this.BOM = strings.UTF8_BOM_CHARACTER;\n          chunk = chunk.substr(1);\n        }\n      }\n      var lastChar = chunk.charCodeAt(chunk.length - 1);\n      if (lastChar === 13 /* CharCode.CarriageReturn */ || lastChar >= 0xD800 && lastChar <= 0xDBFF) {\n        // last character is \\r or a high surrogate => keep it back\n        this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n        this._hasPreviousChar = true;\n        this._previousChar = lastChar;\n      } else {\n        this._acceptChunk1(chunk, false);\n        this._hasPreviousChar = false;\n        this._previousChar = lastChar;\n      }\n    }\n  }, {\n    key: \"_acceptChunk1\",\n    value: function _acceptChunk1(chunk, allowEmptyStrings) {\n      if (!allowEmptyStrings && chunk.length === 0) {\n        // Nothing to do\n        return;\n      }\n      if (this._hasPreviousChar) {\n        this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n      } else {\n        this._acceptChunk2(chunk);\n      }\n    }\n  }, {\n    key: \"_acceptChunk2\",\n    value: function _acceptChunk2(chunk) {\n      var lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n      this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n      this.cr += lineStarts.cr;\n      this.lf += lineStarts.lf;\n      this.crlf += lineStarts.crlf;\n      if (!lineStarts.isBasicASCII) {\n        // this chunk contains non basic ASCII characters\n        this.isBasicASCII = false;\n        if (!this.containsRTL) {\n          this.containsRTL = strings.containsRTL(chunk);\n        }\n        if (!this.containsUnusualLineTerminators) {\n          this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n        }\n      }\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      var normalizeEOL = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this._finish();\n      return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n    }\n  }, {\n    key: \"_finish\",\n    value: function _finish() {\n      if (this.chunks.length === 0) {\n        this._acceptChunk1('', true);\n      }\n      if (this._hasPreviousChar) {\n        this._hasPreviousChar = false;\n        // recreate last chunk\n        var lastChunk = this.chunks[this.chunks.length - 1];\n        lastChunk.buffer += String.fromCharCode(this._previousChar);\n        var newLineStarts = createLineStartsFast(lastChunk.buffer);\n        lastChunk.lineStarts = newLineStarts;\n        if (this._previousChar === 13 /* CharCode.CarriageReturn */) {\n          this.cr++;\n        }\n      }\n    }\n  }]);\n}();","map":{"version":3,"names":["strings","StringBuffer","createLineStarts","createLineStartsFast","PieceTreeTextBuffer","PieceTreeTextBufferFactory","_chunks","_bom","_cr","_lf","_crlf","_containsRTL","_containsUnusualLineTerminators","_isBasicASCII","_normalizeEOL","_classCallCheck","_createClass","key","value","_getEOL","defaultEOL","totalEOLCount","totalCRCount","create","eol","chunks","i","len","length","str","buffer","replace","newLineStart","textBuffer","disposable","PieceTreeTextBufferBuilder","BOM","_hasPreviousChar","_previousChar","_tmpLineStarts","cr","lf","crlf","containsRTL","containsUnusualLineTerminators","isBasicASCII","acceptChunk","chunk","startsWithUTF8BOM","UTF8_BOM_CHARACTER","substr","lastChar","charCodeAt","_acceptChunk1","allowEmptyStrings","_acceptChunk2","String","fromCharCode","lineStarts","push","finish","normalizeEOL","arguments","undefined","_finish","lastChunk","newLineStarts"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nclass PieceTreeTextBufferFactory {\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n        this._chunks = _chunks;\n        this._bom = _bom;\n        this._cr = _cr;\n        this._lf = _lf;\n        this._crlf = _crlf;\n        this._containsRTL = _containsRTL;\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n        this._isBasicASCII = _isBasicASCII;\n        this._normalizeEOL = _normalizeEOL;\n    }\n    _getEOL(defaultEOL) {\n        const totalEOLCount = this._cr + this._lf + this._crlf;\n        const totalCRCount = this._cr + this._crlf;\n        if (totalEOLCount === 0) {\n            // This is an empty file or a file with precisely one line\n            return (defaultEOL === 1 /* DefaultEndOfLine.LF */ ? '\\n' : '\\r\\n');\n        }\n        if (totalCRCount > totalEOLCount / 2) {\n            // More than half of the file contains \\r\\n ending lines\n            return '\\r\\n';\n        }\n        // At least one line more ends in \\n\n        return '\\n';\n    }\n    create(defaultEOL) {\n        const eol = this._getEOL(defaultEOL);\n        const chunks = this._chunks;\n        if (this._normalizeEOL &&\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n            // Normalize pieces\n            for (let i = 0, len = chunks.length; i < len; i++) {\n                const str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                const newLineStart = createLineStartsFast(str);\n                chunks[i] = new StringBuffer(str, newLineStart);\n            }\n        }\n        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n        return { textBuffer: textBuffer, disposable: textBuffer };\n    }\n}\nexport class PieceTreeTextBufferBuilder {\n    constructor() {\n        this.chunks = [];\n        this.BOM = '';\n        this._hasPreviousChar = false;\n        this._previousChar = 0;\n        this._tmpLineStarts = [];\n        this.cr = 0;\n        this.lf = 0;\n        this.crlf = 0;\n        this.containsRTL = false;\n        this.containsUnusualLineTerminators = false;\n        this.isBasicASCII = true;\n    }\n    acceptChunk(chunk) {\n        if (chunk.length === 0) {\n            return;\n        }\n        if (this.chunks.length === 0) {\n            if (strings.startsWithUTF8BOM(chunk)) {\n                this.BOM = strings.UTF8_BOM_CHARACTER;\n                chunk = chunk.substr(1);\n            }\n        }\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\n        if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n            // last character is \\r or a high surrogate => keep it back\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n            this._hasPreviousChar = true;\n            this._previousChar = lastChar;\n        }\n        else {\n            this._acceptChunk1(chunk, false);\n            this._hasPreviousChar = false;\n            this._previousChar = lastChar;\n        }\n    }\n    _acceptChunk1(chunk, allowEmptyStrings) {\n        if (!allowEmptyStrings && chunk.length === 0) {\n            // Nothing to do\n            return;\n        }\n        if (this._hasPreviousChar) {\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n        }\n        else {\n            this._acceptChunk2(chunk);\n        }\n    }\n    _acceptChunk2(chunk) {\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n        this.cr += lineStarts.cr;\n        this.lf += lineStarts.lf;\n        this.crlf += lineStarts.crlf;\n        if (!lineStarts.isBasicASCII) {\n            // this chunk contains non basic ASCII characters\n            this.isBasicASCII = false;\n            if (!this.containsRTL) {\n                this.containsRTL = strings.containsRTL(chunk);\n            }\n            if (!this.containsUnusualLineTerminators) {\n                this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n            }\n        }\n    }\n    finish(normalizeEOL = true) {\n        this._finish();\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n    }\n    _finish() {\n        if (this.chunks.length === 0) {\n            this._acceptChunk1('', true);\n        }\n        if (this._hasPreviousChar) {\n            this._hasPreviousChar = false;\n            // recreate last chunk\n            const lastChunk = this.chunks[this.chunks.length - 1];\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\n            const newLineStarts = createLineStartsFast(lastChunk.buffer);\n            lastChunk.lineStarts = newLineStarts;\n            if (this._previousChar === 13 /* CharCode.CarriageReturn */) {\n                this.cr++;\n            }\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}