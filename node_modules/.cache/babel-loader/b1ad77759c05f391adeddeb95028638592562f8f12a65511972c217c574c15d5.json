{"ast":null,"code":"import _callSuper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { ModelLineProjectionData } from '../modelLineProjectionData.js';\nexport var MonospaceLineBreaksComputerFactory = /*#__PURE__*/function () {\n  function MonospaceLineBreaksComputerFactory(breakBeforeChars, breakAfterChars) {\n    _classCallCheck(this, MonospaceLineBreaksComputerFactory);\n    this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars);\n  }\n  return _createClass(MonospaceLineBreaksComputerFactory, [{\n    key: \"createLineBreaksComputer\",\n    value: function createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent, wordBreak) {\n      var _this = this;\n      var requests = [];\n      var injectedTexts = [];\n      var previousBreakingData = [];\n      return {\n        addRequest: function addRequest(lineText, injectedText, previousLineBreakData) {\n          requests.push(lineText);\n          injectedTexts.push(injectedText);\n          previousBreakingData.push(previousLineBreakData);\n        },\n        finalize: function finalize() {\n          var columnsForFullWidthChar = fontInfo.typicalFullwidthCharacterWidth / fontInfo.typicalHalfwidthCharacterWidth;\n          var result = [];\n          for (var i = 0, len = requests.length; i < len; i++) {\n            var injectedText = injectedTexts[i];\n            var previousLineBreakData = previousBreakingData[i];\n            if (previousLineBreakData && !previousLineBreakData.injectionOptions && !injectedText) {\n              result[i] = createLineBreaksFromPreviousLineBreaks(_this.classifier, previousLineBreakData, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, wordBreak);\n            } else {\n              result[i] = createLineBreaks(_this.classifier, requests[i], injectedText, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, wordBreak);\n            }\n          }\n          arrPool1.length = 0;\n          arrPool2.length = 0;\n          return result;\n        }\n      };\n    }\n  }], [{\n    key: \"create\",\n    value: function create(options) {\n      return new MonospaceLineBreaksComputerFactory(options.get(134 /* EditorOption.wordWrapBreakBeforeCharacters */), options.get(133 /* EditorOption.wordWrapBreakAfterCharacters */));\n    }\n  }]);\n}();\nvar WrappingCharacterClassifier = /*#__PURE__*/function (_CharacterClassifier) {\n  function WrappingCharacterClassifier(BREAK_BEFORE, BREAK_AFTER) {\n    var _this2;\n    _classCallCheck(this, WrappingCharacterClassifier);\n    _this2 = _callSuper(this, WrappingCharacterClassifier, [0 /* CharacterClass.NONE */]);\n    for (var i = 0; i < BREAK_BEFORE.length; i++) {\n      _this2.set(BREAK_BEFORE.charCodeAt(i), 1 /* CharacterClass.BREAK_BEFORE */);\n    }\n    for (var _i = 0; _i < BREAK_AFTER.length; _i++) {\n      _this2.set(BREAK_AFTER.charCodeAt(_i), 2 /* CharacterClass.BREAK_AFTER */);\n    }\n    return _this2;\n  }\n  _inherits(WrappingCharacterClassifier, _CharacterClassifier);\n  return _createClass(WrappingCharacterClassifier, [{\n    key: \"get\",\n    value: function get(charCode) {\n      if (charCode >= 0 && charCode < 256) {\n        return this._asciiMap[charCode];\n      } else {\n        // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n        // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n        // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n        // 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n        if (charCode >= 0x3040 && charCode <= 0x30FF || charCode >= 0x3400 && charCode <= 0x4DBF || charCode >= 0x4E00 && charCode <= 0x9FFF) {\n          return 3 /* CharacterClass.BREAK_IDEOGRAPHIC */;\n        }\n        return this._map.get(charCode) || this._defaultValue;\n      }\n    }\n  }]);\n}(CharacterClassifier);\nvar arrPool1 = [];\nvar arrPool2 = [];\nfunction createLineBreaksFromPreviousLineBreaks(classifier, previousBreakingData, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent, wordBreak) {\n  if (firstLineBreakColumn === -1) {\n    return null;\n  }\n  var len = lineText.length;\n  if (len <= 1) {\n    return null;\n  }\n  var isKeepAll = wordBreak === 'keepAll';\n  var prevBreakingOffsets = previousBreakingData.breakOffsets;\n  var prevBreakingOffsetsVisibleColumn = previousBreakingData.breakOffsetsVisibleColumn;\n  var wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n  var wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n  var breakingOffsets = arrPool1;\n  var breakingOffsetsVisibleColumn = arrPool2;\n  var breakingOffsetsCount = 0;\n  var lastBreakingOffset = 0;\n  var lastBreakingOffsetVisibleColumn = 0;\n  var breakingColumn = firstLineBreakColumn;\n  var prevLen = prevBreakingOffsets.length;\n  var prevIndex = 0;\n  if (prevIndex >= 0) {\n    var bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n    while (prevIndex + 1 < prevLen) {\n      var distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n      if (distance >= bestDistance) {\n        break;\n      }\n      bestDistance = distance;\n      prevIndex++;\n    }\n  }\n  while (prevIndex < prevLen) {\n    // Allow for prevIndex to be -1 (for the case where we hit a tab when walking backwards from the first break)\n    var prevBreakOffset = prevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex];\n    var prevBreakOffsetVisibleColumn = prevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];\n    if (lastBreakingOffset > prevBreakOffset) {\n      prevBreakOffset = lastBreakingOffset;\n      prevBreakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn;\n    }\n    var breakOffset = 0;\n    var breakOffsetVisibleColumn = 0;\n    var forcedBreakOffset = 0;\n    var forcedBreakOffsetVisibleColumn = 0;\n    // initially, we search as much as possible to the right (if it fits)\n    if (prevBreakOffsetVisibleColumn <= breakingColumn) {\n      var visibleColumn = prevBreakOffsetVisibleColumn;\n      var prevCharCode = prevBreakOffset === 0 ? 0 /* CharCode.Null */ : lineText.charCodeAt(prevBreakOffset - 1);\n      var prevCharCodeClass = prevBreakOffset === 0 ? 0 /* CharacterClass.NONE */ : classifier.get(prevCharCode);\n      var entireLineFits = true;\n      for (var i = prevBreakOffset; i < len; i++) {\n        var charStartOffset = i;\n        var charCode = lineText.charCodeAt(i);\n        var charCodeClass = void 0;\n        var charWidth = void 0;\n        if (strings.isHighSurrogate(charCode)) {\n          // A surrogate pair must always be considered as a single unit, so it is never to be broken\n          i++;\n          charCodeClass = 0 /* CharacterClass.NONE */;\n          charWidth = 2;\n        } else {\n          charCodeClass = classifier.get(charCode);\n          charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n        }\n        if (charStartOffset > lastBreakingOffset && canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n          breakOffset = charStartOffset;\n          breakOffsetVisibleColumn = visibleColumn;\n        }\n        visibleColumn += charWidth;\n        // check if adding character at `i` will go over the breaking column\n        if (visibleColumn > breakingColumn) {\n          // We need to break at least before character at `i`:\n          if (charStartOffset > lastBreakingOffset) {\n            forcedBreakOffset = charStartOffset;\n            forcedBreakOffsetVisibleColumn = visibleColumn - charWidth;\n          } else {\n            // we need to advance at least by one character\n            forcedBreakOffset = i + 1;\n            forcedBreakOffsetVisibleColumn = visibleColumn;\n          }\n          if (visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n            // Cannot break at `breakOffset` => reset it if it was set\n            breakOffset = 0;\n          }\n          entireLineFits = false;\n          break;\n        }\n        prevCharCode = charCode;\n        prevCharCodeClass = charCodeClass;\n      }\n      if (entireLineFits) {\n        // there is no more need to break => stop the outer loop!\n        if (breakingOffsetsCount > 0) {\n          // Add last segment, no need to assign to `lastBreakingOffset` and `lastBreakingOffsetVisibleColumn`\n          breakingOffsets[breakingOffsetsCount] = prevBreakingOffsets[prevBreakingOffsets.length - 1];\n          breakingOffsetsVisibleColumn[breakingOffsetsCount] = prevBreakingOffsetsVisibleColumn[prevBreakingOffsets.length - 1];\n          breakingOffsetsCount++;\n        }\n        break;\n      }\n    }\n    if (breakOffset === 0) {\n      // must search left\n      var _visibleColumn = prevBreakOffsetVisibleColumn;\n      var _charCode = lineText.charCodeAt(prevBreakOffset);\n      var _charCodeClass = classifier.get(_charCode);\n      var hitATabCharacter = false;\n      for (var _i2 = prevBreakOffset - 1; _i2 >= lastBreakingOffset; _i2--) {\n        var _charStartOffset = _i2 + 1;\n        var _prevCharCode = lineText.charCodeAt(_i2);\n        if (_prevCharCode === 9 /* CharCode.Tab */) {\n          // cannot determine the width of a tab when going backwards, so we must go forwards\n          hitATabCharacter = true;\n          break;\n        }\n        var _prevCharCodeClass = void 0;\n        var prevCharWidth = void 0;\n        if (strings.isLowSurrogate(_prevCharCode)) {\n          // A surrogate pair must always be considered as a single unit, so it is never to be broken\n          _i2--;\n          _prevCharCodeClass = 0 /* CharacterClass.NONE */;\n          prevCharWidth = 2;\n        } else {\n          _prevCharCodeClass = classifier.get(_prevCharCode);\n          prevCharWidth = strings.isFullWidthCharacter(_prevCharCode) ? columnsForFullWidthChar : 1;\n        }\n        if (_visibleColumn <= breakingColumn) {\n          if (forcedBreakOffset === 0) {\n            forcedBreakOffset = _charStartOffset;\n            forcedBreakOffsetVisibleColumn = _visibleColumn;\n          }\n          if (_visibleColumn <= breakingColumn - wrappedLineBreakColumn) {\n            // went too far!\n            break;\n          }\n          if (canBreak(_prevCharCode, _prevCharCodeClass, _charCode, _charCodeClass, isKeepAll)) {\n            breakOffset = _charStartOffset;\n            breakOffsetVisibleColumn = _visibleColumn;\n            break;\n          }\n        }\n        _visibleColumn -= prevCharWidth;\n        _charCode = _prevCharCode;\n        _charCodeClass = _prevCharCodeClass;\n      }\n      if (breakOffset !== 0) {\n        var remainingWidthOfNextLine = wrappedLineBreakColumn - (forcedBreakOffsetVisibleColumn - breakOffsetVisibleColumn);\n        if (remainingWidthOfNextLine <= tabSize) {\n          var charCodeAtForcedBreakOffset = lineText.charCodeAt(forcedBreakOffset);\n          var _charWidth = void 0;\n          if (strings.isHighSurrogate(charCodeAtForcedBreakOffset)) {\n            // A surrogate pair must always be considered as a single unit, so it is never to be broken\n            _charWidth = 2;\n          } else {\n            _charWidth = computeCharWidth(charCodeAtForcedBreakOffset, forcedBreakOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n          }\n          if (remainingWidthOfNextLine - _charWidth < 0) {\n            // it is not worth it to break at breakOffset, it just introduces an extra needless line!\n            breakOffset = 0;\n          }\n        }\n      }\n      if (hitATabCharacter) {\n        // cannot determine the width of a tab when going backwards, so we must go forwards from the previous break\n        prevIndex--;\n        continue;\n      }\n    }\n    if (breakOffset === 0) {\n      // Could not find a good breaking point\n      breakOffset = forcedBreakOffset;\n      breakOffsetVisibleColumn = forcedBreakOffsetVisibleColumn;\n    }\n    if (breakOffset <= lastBreakingOffset) {\n      // Make sure that we are advancing (at least one character)\n      var _charCode2 = lineText.charCodeAt(lastBreakingOffset);\n      if (strings.isHighSurrogate(_charCode2)) {\n        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n        breakOffset = lastBreakingOffset + 2;\n        breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + 2;\n      } else {\n        breakOffset = lastBreakingOffset + 1;\n        breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + computeCharWidth(_charCode2, lastBreakingOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n      }\n    }\n    lastBreakingOffset = breakOffset;\n    breakingOffsets[breakingOffsetsCount] = breakOffset;\n    lastBreakingOffsetVisibleColumn = breakOffsetVisibleColumn;\n    breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n    breakingOffsetsCount++;\n    breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n    while (prevIndex < 0 || prevIndex < prevLen && prevBreakingOffsetsVisibleColumn[prevIndex] < breakOffsetVisibleColumn) {\n      prevIndex++;\n    }\n    var _bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n    while (prevIndex + 1 < prevLen) {\n      var _distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n      if (_distance >= _bestDistance) {\n        break;\n      }\n      _bestDistance = _distance;\n      prevIndex++;\n    }\n  }\n  if (breakingOffsetsCount === 0) {\n    return null;\n  }\n  // Doing here some object reuse which ends up helping a huge deal with GC pauses!\n  breakingOffsets.length = breakingOffsetsCount;\n  breakingOffsetsVisibleColumn.length = breakingOffsetsCount;\n  arrPool1 = previousBreakingData.breakOffsets;\n  arrPool2 = previousBreakingData.breakOffsetsVisibleColumn;\n  previousBreakingData.breakOffsets = breakingOffsets;\n  previousBreakingData.breakOffsetsVisibleColumn = breakingOffsetsVisibleColumn;\n  previousBreakingData.wrappedTextIndentLength = wrappedTextIndentLength;\n  return previousBreakingData;\n}\nfunction createLineBreaks(classifier, _lineText, injectedTexts, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent, wordBreak) {\n  var lineText = LineInjectedText.applyInjectedText(_lineText, injectedTexts);\n  var injectionOptions;\n  var injectionOffsets;\n  if (injectedTexts && injectedTexts.length > 0) {\n    injectionOptions = injectedTexts.map(function (t) {\n      return t.options;\n    });\n    injectionOffsets = injectedTexts.map(function (text) {\n      return text.column - 1;\n    });\n  } else {\n    injectionOptions = null;\n    injectionOffsets = null;\n  }\n  if (firstLineBreakColumn === -1) {\n    if (!injectionOptions) {\n      return null;\n    }\n    // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n    // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n    return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n  }\n  var len = lineText.length;\n  if (len <= 1) {\n    if (!injectionOptions) {\n      return null;\n    }\n    // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n    // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n    return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n  }\n  var isKeepAll = wordBreak === 'keepAll';\n  var wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n  var wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n  var breakingOffsets = [];\n  var breakingOffsetsVisibleColumn = [];\n  var breakingOffsetsCount = 0;\n  var breakOffset = 0;\n  var breakOffsetVisibleColumn = 0;\n  var breakingColumn = firstLineBreakColumn;\n  var prevCharCode = lineText.charCodeAt(0);\n  var prevCharCodeClass = classifier.get(prevCharCode);\n  var visibleColumn = computeCharWidth(prevCharCode, 0, tabSize, columnsForFullWidthChar);\n  var startOffset = 1;\n  if (strings.isHighSurrogate(prevCharCode)) {\n    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n    visibleColumn += 1;\n    prevCharCode = lineText.charCodeAt(1);\n    prevCharCodeClass = classifier.get(prevCharCode);\n    startOffset++;\n  }\n  for (var i = startOffset; i < len; i++) {\n    var charStartOffset = i;\n    var charCode = lineText.charCodeAt(i);\n    var charCodeClass = void 0;\n    var charWidth = void 0;\n    if (strings.isHighSurrogate(charCode)) {\n      // A surrogate pair must always be considered as a single unit, so it is never to be broken\n      i++;\n      charCodeClass = 0 /* CharacterClass.NONE */;\n      charWidth = 2;\n    } else {\n      charCodeClass = classifier.get(charCode);\n      charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n    }\n    if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n      breakOffset = charStartOffset;\n      breakOffsetVisibleColumn = visibleColumn;\n    }\n    visibleColumn += charWidth;\n    // check if adding character at `i` will go over the breaking column\n    if (visibleColumn > breakingColumn) {\n      // We need to break at least before character at `i`:\n      if (breakOffset === 0 || visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n        // Cannot break at `breakOffset`, must break at `i`\n        breakOffset = charStartOffset;\n        breakOffsetVisibleColumn = visibleColumn - charWidth;\n      }\n      breakingOffsets[breakingOffsetsCount] = breakOffset;\n      breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n      breakingOffsetsCount++;\n      breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n      breakOffset = 0;\n    }\n    prevCharCode = charCode;\n    prevCharCodeClass = charCodeClass;\n  }\n  if (breakingOffsetsCount === 0 && (!injectedTexts || injectedTexts.length === 0)) {\n    return null;\n  }\n  // Add last segment\n  breakingOffsets[breakingOffsetsCount] = len;\n  breakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;\n  return new ModelLineProjectionData(injectionOffsets, injectionOptions, breakingOffsets, breakingOffsetsVisibleColumn, wrappedTextIndentLength);\n}\nfunction computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar) {\n  if (charCode === 9 /* CharCode.Tab */) {\n    return tabSize - visibleColumn % tabSize;\n  }\n  if (strings.isFullWidthCharacter(charCode)) {\n    return columnsForFullWidthChar;\n  }\n  if (charCode < 32) {\n    // when using `editor.renderControlCharacters`, the substitutions are often wide\n    return columnsForFullWidthChar;\n  }\n  return 1;\n}\nfunction tabCharacterWidth(visibleColumn, tabSize) {\n  return tabSize - visibleColumn % tabSize;\n}\n/**\n * Kinsoku Shori : Don't break after a leading character, like an open bracket\n * Kinsoku Shori : Don't break before a trailing character, like a period\n */\nfunction canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll) {\n  return charCode !== 32 /* CharCode.Space */ && (prevCharCodeClass === 2 /* CharacterClass.BREAK_AFTER */ && charCodeClass !== 2 /* CharacterClass.BREAK_AFTER */ // break at the end of multiple BREAK_AFTER\n  || prevCharCodeClass !== 1 /* CharacterClass.BREAK_BEFORE */ && charCodeClass === 1 /* CharacterClass.BREAK_BEFORE */ // break at the start of multiple BREAK_BEFORE\n  || !isKeepAll && prevCharCodeClass === 3 /* CharacterClass.BREAK_IDEOGRAPHIC */ && charCodeClass !== 2 /* CharacterClass.BREAK_AFTER */ || !isKeepAll && charCodeClass === 3 /* CharacterClass.BREAK_IDEOGRAPHIC */ && prevCharCodeClass !== 1 /* CharacterClass.BREAK_BEFORE */);\n}\nfunction computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n  var wrappedTextIndentLength = 0;\n  if (wrappingIndent !== 0 /* WrappingIndent.None */) {\n    var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n    if (firstNonWhitespaceIndex !== -1) {\n      // Track existing indent\n      for (var i = 0; i < firstNonWhitespaceIndex; i++) {\n        var charWidth = lineText.charCodeAt(i) === 9 /* CharCode.Tab */ ? tabCharacterWidth(wrappedTextIndentLength, tabSize) : 1;\n        wrappedTextIndentLength += charWidth;\n      }\n      // Increase indent of continuation lines, if desired\n      var numberOfAdditionalTabs = wrappingIndent === 3 /* WrappingIndent.DeepIndent */ ? 2 : wrappingIndent === 2 /* WrappingIndent.Indent */ ? 1 : 0;\n      for (var _i3 = 0; _i3 < numberOfAdditionalTabs; _i3++) {\n        var _charWidth2 = tabCharacterWidth(wrappedTextIndentLength, tabSize);\n        wrappedTextIndentLength += _charWidth2;\n      }\n      // Force sticking to beginning of line if no character would fit except for the indentation\n      if (wrappedTextIndentLength + columnsForFullWidthChar > firstLineBreakColumn) {\n        wrappedTextIndentLength = 0;\n      }\n    }\n  }\n  return wrappedTextIndentLength;\n}","map":{"version":3,"names":["strings","CharacterClassifier","LineInjectedText","ModelLineProjectionData","MonospaceLineBreaksComputerFactory","breakBeforeChars","breakAfterChars","_classCallCheck","classifier","WrappingCharacterClassifier","_createClass","key","value","createLineBreaksComputer","fontInfo","tabSize","wrappingColumn","wrappingIndent","wordBreak","_this","requests","injectedTexts","previousBreakingData","addRequest","lineText","injectedText","previousLineBreakData","push","finalize","columnsForFullWidthChar","typicalFullwidthCharacterWidth","typicalHalfwidthCharacterWidth","result","i","len","length","injectionOptions","createLineBreaksFromPreviousLineBreaks","createLineBreaks","arrPool1","arrPool2","create","options","get","_CharacterClassifier","BREAK_BEFORE","BREAK_AFTER","_this2","_callSuper","set","charCodeAt","_inherits","charCode","_asciiMap","_map","_defaultValue","firstLineBreakColumn","isKeepAll","prevBreakingOffsets","breakOffsets","prevBreakingOffsetsVisibleColumn","breakOffsetsVisibleColumn","wrappedTextIndentLength","computeWrappedTextIndentLength","wrappedLineBreakColumn","breakingOffsets","breakingOffsetsVisibleColumn","breakingOffsetsCount","lastBreakingOffset","lastBreakingOffsetVisibleColumn","breakingColumn","prevLen","prevIndex","bestDistance","Math","abs","distance","prevBreakOffset","prevBreakOffsetVisibleColumn","breakOffset","breakOffsetVisibleColumn","forcedBreakOffset","forcedBreakOffsetVisibleColumn","visibleColumn","prevCharCode","prevCharCodeClass","entireLineFits","charStartOffset","charCodeClass","charWidth","isHighSurrogate","computeCharWidth","canBreak","hitATabCharacter","prevCharWidth","isLowSurrogate","isFullWidthCharacter","remainingWidthOfNextLine","charCodeAtForcedBreakOffset","_lineText","applyInjectedText","injectionOffsets","map","t","text","column","startOffset","tabCharacterWidth","firstNonWhitespaceIndex","numberOfAdditionalTabs"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/viewModel/monospaceLineBreaksComputer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { ModelLineProjectionData } from '../modelLineProjectionData.js';\nexport class MonospaceLineBreaksComputerFactory {\n    static create(options) {\n        return new MonospaceLineBreaksComputerFactory(options.get(134 /* EditorOption.wordWrapBreakBeforeCharacters */), options.get(133 /* EditorOption.wordWrapBreakAfterCharacters */));\n    }\n    constructor(breakBeforeChars, breakAfterChars) {\n        this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars);\n    }\n    createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent, wordBreak) {\n        const requests = [];\n        const injectedTexts = [];\n        const previousBreakingData = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                requests.push(lineText);\n                injectedTexts.push(injectedText);\n                previousBreakingData.push(previousLineBreakData);\n            },\n            finalize: () => {\n                const columnsForFullWidthChar = fontInfo.typicalFullwidthCharacterWidth / fontInfo.typicalHalfwidthCharacterWidth;\n                const result = [];\n                for (let i = 0, len = requests.length; i < len; i++) {\n                    const injectedText = injectedTexts[i];\n                    const previousLineBreakData = previousBreakingData[i];\n                    if (previousLineBreakData && !previousLineBreakData.injectionOptions && !injectedText) {\n                        result[i] = createLineBreaksFromPreviousLineBreaks(this.classifier, previousLineBreakData, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, wordBreak);\n                    }\n                    else {\n                        result[i] = createLineBreaks(this.classifier, requests[i], injectedText, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, wordBreak);\n                    }\n                }\n                arrPool1.length = 0;\n                arrPool2.length = 0;\n                return result;\n            }\n        };\n    }\n}\nclass WrappingCharacterClassifier extends CharacterClassifier {\n    constructor(BREAK_BEFORE, BREAK_AFTER) {\n        super(0 /* CharacterClass.NONE */);\n        for (let i = 0; i < BREAK_BEFORE.length; i++) {\n            this.set(BREAK_BEFORE.charCodeAt(i), 1 /* CharacterClass.BREAK_BEFORE */);\n        }\n        for (let i = 0; i < BREAK_AFTER.length; i++) {\n            this.set(BREAK_AFTER.charCodeAt(i), 2 /* CharacterClass.BREAK_AFTER */);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n            // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n            // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n            // 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n            if ((charCode >= 0x3040 && charCode <= 0x30FF)\n                || (charCode >= 0x3400 && charCode <= 0x4DBF)\n                || (charCode >= 0x4E00 && charCode <= 0x9FFF)) {\n                return 3 /* CharacterClass.BREAK_IDEOGRAPHIC */;\n            }\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n}\nlet arrPool1 = [];\nlet arrPool2 = [];\nfunction createLineBreaksFromPreviousLineBreaks(classifier, previousBreakingData, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent, wordBreak) {\n    if (firstLineBreakColumn === -1) {\n        return null;\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        return null;\n    }\n    const isKeepAll = (wordBreak === 'keepAll');\n    const prevBreakingOffsets = previousBreakingData.breakOffsets;\n    const prevBreakingOffsetsVisibleColumn = previousBreakingData.breakOffsetsVisibleColumn;\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    const breakingOffsets = arrPool1;\n    const breakingOffsetsVisibleColumn = arrPool2;\n    let breakingOffsetsCount = 0;\n    let lastBreakingOffset = 0;\n    let lastBreakingOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    const prevLen = prevBreakingOffsets.length;\n    let prevIndex = 0;\n    if (prevIndex >= 0) {\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    while (prevIndex < prevLen) {\n        // Allow for prevIndex to be -1 (for the case where we hit a tab when walking backwards from the first break)\n        let prevBreakOffset = prevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex];\n        let prevBreakOffsetVisibleColumn = prevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];\n        if (lastBreakingOffset > prevBreakOffset) {\n            prevBreakOffset = lastBreakingOffset;\n            prevBreakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn;\n        }\n        let breakOffset = 0;\n        let breakOffsetVisibleColumn = 0;\n        let forcedBreakOffset = 0;\n        let forcedBreakOffsetVisibleColumn = 0;\n        // initially, we search as much as possible to the right (if it fits)\n        if (prevBreakOffsetVisibleColumn <= breakingColumn) {\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let prevCharCode = prevBreakOffset === 0 ? 0 /* CharCode.Null */ : lineText.charCodeAt(prevBreakOffset - 1);\n            let prevCharCodeClass = prevBreakOffset === 0 ? 0 /* CharacterClass.NONE */ : classifier.get(prevCharCode);\n            let entireLineFits = true;\n            for (let i = prevBreakOffset; i < len; i++) {\n                const charStartOffset = i;\n                const charCode = lineText.charCodeAt(i);\n                let charCodeClass;\n                let charWidth;\n                if (strings.isHighSurrogate(charCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i++;\n                    charCodeClass = 0 /* CharacterClass.NONE */;\n                    charWidth = 2;\n                }\n                else {\n                    charCodeClass = classifier.get(charCode);\n                    charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n                }\n                if (charStartOffset > lastBreakingOffset && canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n                    breakOffset = charStartOffset;\n                    breakOffsetVisibleColumn = visibleColumn;\n                }\n                visibleColumn += charWidth;\n                // check if adding character at `i` will go over the breaking column\n                if (visibleColumn > breakingColumn) {\n                    // We need to break at least before character at `i`:\n                    if (charStartOffset > lastBreakingOffset) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn - charWidth;\n                    }\n                    else {\n                        // we need to advance at least by one character\n                        forcedBreakOffset = i + 1;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                        // Cannot break at `breakOffset` => reset it if it was set\n                        breakOffset = 0;\n                    }\n                    entireLineFits = false;\n                    break;\n                }\n                prevCharCode = charCode;\n                prevCharCodeClass = charCodeClass;\n            }\n            if (entireLineFits) {\n                // there is no more need to break => stop the outer loop!\n                if (breakingOffsetsCount > 0) {\n                    // Add last segment, no need to assign to `lastBreakingOffset` and `lastBreakingOffsetVisibleColumn`\n                    breakingOffsets[breakingOffsetsCount] = prevBreakingOffsets[prevBreakingOffsets.length - 1];\n                    breakingOffsetsVisibleColumn[breakingOffsetsCount] = prevBreakingOffsetsVisibleColumn[prevBreakingOffsets.length - 1];\n                    breakingOffsetsCount++;\n                }\n                break;\n            }\n        }\n        if (breakOffset === 0) {\n            // must search left\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let charCode = lineText.charCodeAt(prevBreakOffset);\n            let charCodeClass = classifier.get(charCode);\n            let hitATabCharacter = false;\n            for (let i = prevBreakOffset - 1; i >= lastBreakingOffset; i--) {\n                const charStartOffset = i + 1;\n                const prevCharCode = lineText.charCodeAt(i);\n                if (prevCharCode === 9 /* CharCode.Tab */) {\n                    // cannot determine the width of a tab when going backwards, so we must go forwards\n                    hitATabCharacter = true;\n                    break;\n                }\n                let prevCharCodeClass;\n                let prevCharWidth;\n                if (strings.isLowSurrogate(prevCharCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i--;\n                    prevCharCodeClass = 0 /* CharacterClass.NONE */;\n                    prevCharWidth = 2;\n                }\n                else {\n                    prevCharCodeClass = classifier.get(prevCharCode);\n                    prevCharWidth = (strings.isFullWidthCharacter(prevCharCode) ? columnsForFullWidthChar : 1);\n                }\n                if (visibleColumn <= breakingColumn) {\n                    if (forcedBreakOffset === 0) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn <= breakingColumn - wrappedLineBreakColumn) {\n                        // went too far!\n                        break;\n                    }\n                    if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n                        breakOffset = charStartOffset;\n                        breakOffsetVisibleColumn = visibleColumn;\n                        break;\n                    }\n                }\n                visibleColumn -= prevCharWidth;\n                charCode = prevCharCode;\n                charCodeClass = prevCharCodeClass;\n            }\n            if (breakOffset !== 0) {\n                const remainingWidthOfNextLine = wrappedLineBreakColumn - (forcedBreakOffsetVisibleColumn - breakOffsetVisibleColumn);\n                if (remainingWidthOfNextLine <= tabSize) {\n                    const charCodeAtForcedBreakOffset = lineText.charCodeAt(forcedBreakOffset);\n                    let charWidth;\n                    if (strings.isHighSurrogate(charCodeAtForcedBreakOffset)) {\n                        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                        charWidth = 2;\n                    }\n                    else {\n                        charWidth = computeCharWidth(charCodeAtForcedBreakOffset, forcedBreakOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n                    }\n                    if (remainingWidthOfNextLine - charWidth < 0) {\n                        // it is not worth it to break at breakOffset, it just introduces an extra needless line!\n                        breakOffset = 0;\n                    }\n                }\n            }\n            if (hitATabCharacter) {\n                // cannot determine the width of a tab when going backwards, so we must go forwards from the previous break\n                prevIndex--;\n                continue;\n            }\n        }\n        if (breakOffset === 0) {\n            // Could not find a good breaking point\n            breakOffset = forcedBreakOffset;\n            breakOffsetVisibleColumn = forcedBreakOffsetVisibleColumn;\n        }\n        if (breakOffset <= lastBreakingOffset) {\n            // Make sure that we are advancing (at least one character)\n            const charCode = lineText.charCodeAt(lastBreakingOffset);\n            if (strings.isHighSurrogate(charCode)) {\n                // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                breakOffset = lastBreakingOffset + 2;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + 2;\n            }\n            else {\n                breakOffset = lastBreakingOffset + 1;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + computeCharWidth(charCode, lastBreakingOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n            }\n        }\n        lastBreakingOffset = breakOffset;\n        breakingOffsets[breakingOffsetsCount] = breakOffset;\n        lastBreakingOffsetVisibleColumn = breakOffsetVisibleColumn;\n        breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n        breakingOffsetsCount++;\n        breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n        while (prevIndex < 0 || (prevIndex < prevLen && prevBreakingOffsetsVisibleColumn[prevIndex] < breakOffsetVisibleColumn)) {\n            prevIndex++;\n        }\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    if (breakingOffsetsCount === 0) {\n        return null;\n    }\n    // Doing here some object reuse which ends up helping a huge deal with GC pauses!\n    breakingOffsets.length = breakingOffsetsCount;\n    breakingOffsetsVisibleColumn.length = breakingOffsetsCount;\n    arrPool1 = previousBreakingData.breakOffsets;\n    arrPool2 = previousBreakingData.breakOffsetsVisibleColumn;\n    previousBreakingData.breakOffsets = breakingOffsets;\n    previousBreakingData.breakOffsetsVisibleColumn = breakingOffsetsVisibleColumn;\n    previousBreakingData.wrappedTextIndentLength = wrappedTextIndentLength;\n    return previousBreakingData;\n}\nfunction createLineBreaks(classifier, _lineText, injectedTexts, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent, wordBreak) {\n    const lineText = LineInjectedText.applyInjectedText(_lineText, injectedTexts);\n    let injectionOptions;\n    let injectionOffsets;\n    if (injectedTexts && injectedTexts.length > 0) {\n        injectionOptions = injectedTexts.map(t => t.options);\n        injectionOffsets = injectedTexts.map(text => text.column - 1);\n    }\n    else {\n        injectionOptions = null;\n        injectionOffsets = null;\n    }\n    if (firstLineBreakColumn === -1) {\n        if (!injectionOptions) {\n            return null;\n        }\n        // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n        // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n        return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        if (!injectionOptions) {\n            return null;\n        }\n        // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n        // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n        return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    }\n    const isKeepAll = (wordBreak === 'keepAll');\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    const breakingOffsets = [];\n    const breakingOffsetsVisibleColumn = [];\n    let breakingOffsetsCount = 0;\n    let breakOffset = 0;\n    let breakOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    let prevCharCode = lineText.charCodeAt(0);\n    let prevCharCodeClass = classifier.get(prevCharCode);\n    let visibleColumn = computeCharWidth(prevCharCode, 0, tabSize, columnsForFullWidthChar);\n    let startOffset = 1;\n    if (strings.isHighSurrogate(prevCharCode)) {\n        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n        visibleColumn += 1;\n        prevCharCode = lineText.charCodeAt(1);\n        prevCharCodeClass = classifier.get(prevCharCode);\n        startOffset++;\n    }\n    for (let i = startOffset; i < len; i++) {\n        const charStartOffset = i;\n        const charCode = lineText.charCodeAt(i);\n        let charCodeClass;\n        let charWidth;\n        if (strings.isHighSurrogate(charCode)) {\n            // A surrogate pair must always be considered as a single unit, so it is never to be broken\n            i++;\n            charCodeClass = 0 /* CharacterClass.NONE */;\n            charWidth = 2;\n        }\n        else {\n            charCodeClass = classifier.get(charCode);\n            charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n        }\n        if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll)) {\n            breakOffset = charStartOffset;\n            breakOffsetVisibleColumn = visibleColumn;\n        }\n        visibleColumn += charWidth;\n        // check if adding character at `i` will go over the breaking column\n        if (visibleColumn > breakingColumn) {\n            // We need to break at least before character at `i`:\n            if (breakOffset === 0 || visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                // Cannot break at `breakOffset`, must break at `i`\n                breakOffset = charStartOffset;\n                breakOffsetVisibleColumn = visibleColumn - charWidth;\n            }\n            breakingOffsets[breakingOffsetsCount] = breakOffset;\n            breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n            breakingOffsetsCount++;\n            breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n            breakOffset = 0;\n        }\n        prevCharCode = charCode;\n        prevCharCodeClass = charCodeClass;\n    }\n    if (breakingOffsetsCount === 0 && (!injectedTexts || injectedTexts.length === 0)) {\n        return null;\n    }\n    // Add last segment\n    breakingOffsets[breakingOffsetsCount] = len;\n    breakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;\n    return new ModelLineProjectionData(injectionOffsets, injectionOptions, breakingOffsets, breakingOffsetsVisibleColumn, wrappedTextIndentLength);\n}\nfunction computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar) {\n    if (charCode === 9 /* CharCode.Tab */) {\n        return (tabSize - (visibleColumn % tabSize));\n    }\n    if (strings.isFullWidthCharacter(charCode)) {\n        return columnsForFullWidthChar;\n    }\n    if (charCode < 32) {\n        // when using `editor.renderControlCharacters`, the substitutions are often wide\n        return columnsForFullWidthChar;\n    }\n    return 1;\n}\nfunction tabCharacterWidth(visibleColumn, tabSize) {\n    return (tabSize - (visibleColumn % tabSize));\n}\n/**\n * Kinsoku Shori : Don't break after a leading character, like an open bracket\n * Kinsoku Shori : Don't break before a trailing character, like a period\n */\nfunction canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass, isKeepAll) {\n    return (charCode !== 32 /* CharCode.Space */\n        && ((prevCharCodeClass === 2 /* CharacterClass.BREAK_AFTER */ && charCodeClass !== 2 /* CharacterClass.BREAK_AFTER */) // break at the end of multiple BREAK_AFTER\n            || (prevCharCodeClass !== 1 /* CharacterClass.BREAK_BEFORE */ && charCodeClass === 1 /* CharacterClass.BREAK_BEFORE */) // break at the start of multiple BREAK_BEFORE\n            || (!isKeepAll && prevCharCodeClass === 3 /* CharacterClass.BREAK_IDEOGRAPHIC */ && charCodeClass !== 2 /* CharacterClass.BREAK_AFTER */)\n            || (!isKeepAll && charCodeClass === 3 /* CharacterClass.BREAK_IDEOGRAPHIC */ && prevCharCodeClass !== 1 /* CharacterClass.BREAK_BEFORE */)));\n}\nfunction computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    let wrappedTextIndentLength = 0;\n    if (wrappingIndent !== 0 /* WrappingIndent.None */) {\n        const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n        if (firstNonWhitespaceIndex !== -1) {\n            // Track existing indent\n            for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n                const charWidth = (lineText.charCodeAt(i) === 9 /* CharCode.Tab */ ? tabCharacterWidth(wrappedTextIndentLength, tabSize) : 1);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Increase indent of continuation lines, if desired\n            const numberOfAdditionalTabs = (wrappingIndent === 3 /* WrappingIndent.DeepIndent */ ? 2 : wrappingIndent === 2 /* WrappingIndent.Indent */ ? 1 : 0);\n            for (let i = 0; i < numberOfAdditionalTabs; i++) {\n                const charWidth = tabCharacterWidth(wrappedTextIndentLength, tabSize);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Force sticking to beginning of line if no character would fit except for the indentation\n            if (wrappedTextIndentLength + columnsForFullWidthChar > firstLineBreakColumn) {\n                wrappedTextIndentLength = 0;\n            }\n        }\n    }\n    return wrappedTextIndentLength;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}