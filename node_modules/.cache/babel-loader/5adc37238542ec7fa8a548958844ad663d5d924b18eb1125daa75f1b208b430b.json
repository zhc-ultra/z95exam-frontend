{"ast":null,"code":"'use strict';\n\n//Const\nvar _classCallCheck = require(\"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/classCallCheck.js\")[\"default\"];\nvar _createClass = require(\"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/createClass.js\")[\"default\"];\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.array.splice.js\");\nrequire(\"core-js/modules/es.function.name.js\");\nrequire(\"core-js/modules/es.object.create.js\");\nrequire(\"core-js/modules/es.object.to-string.js\");\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\nvar NOAH_ARK_CAPACITY = 3;\n\n//List of formatting elements\nvar FormattingElementList = /*#__PURE__*/function () {\n  function FormattingElementList(treeAdapter) {\n    _classCallCheck(this, FormattingElementList);\n    this.length = 0;\n    this.entries = [];\n    this.treeAdapter = treeAdapter;\n    this.bookmark = null;\n  }\n\n  //Noah Ark's condition\n  //OPTIMIZATION: at first we try to find possible candidates for exclusion using\n  //lightweight heuristics without thorough attributes check.\n  return _createClass(FormattingElementList, [{\n    key: \"_getNoahArkConditionCandidates\",\n    value: function _getNoahArkConditionCandidates(newElement) {\n      var candidates = [];\n      if (this.length >= NOAH_ARK_CAPACITY) {\n        var neAttrsLength = this.treeAdapter.getAttrList(newElement).length;\n        var neTagName = this.treeAdapter.getTagName(newElement);\n        var neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\n        for (var i = this.length - 1; i >= 0; i--) {\n          var entry = this.entries[i];\n          if (entry.type === FormattingElementList.MARKER_ENTRY) {\n            break;\n          }\n          var element = entry.element;\n          var elementAttrs = this.treeAdapter.getAttrList(element);\n          var isCandidate = this.treeAdapter.getTagName(element) === neTagName && this.treeAdapter.getNamespaceURI(element) === neNamespaceURI && elementAttrs.length === neAttrsLength;\n          if (isCandidate) {\n            candidates.push({\n              idx: i,\n              attrs: elementAttrs\n            });\n          }\n        }\n      }\n      return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;\n    }\n  }, {\n    key: \"_ensureNoahArkCondition\",\n    value: function _ensureNoahArkCondition(newElement) {\n      var candidates = this._getNoahArkConditionCandidates(newElement);\n      var cLength = candidates.length;\n      if (cLength) {\n        var neAttrs = this.treeAdapter.getAttrList(newElement);\n        var neAttrsLength = neAttrs.length;\n        var neAttrsMap = Object.create(null);\n\n        //NOTE: build attrs map for the new element so we can perform fast lookups\n        for (var i = 0; i < neAttrsLength; i++) {\n          var neAttr = neAttrs[i];\n          neAttrsMap[neAttr.name] = neAttr.value;\n        }\n        for (var _i = 0; _i < neAttrsLength; _i++) {\n          for (var j = 0; j < cLength; j++) {\n            var cAttr = candidates[j].attrs[_i];\n            if (neAttrsMap[cAttr.name] !== cAttr.value) {\n              candidates.splice(j, 1);\n              cLength--;\n            }\n            if (candidates.length < NOAH_ARK_CAPACITY) {\n              return;\n            }\n          }\n        }\n\n        //NOTE: remove bottommost candidates until Noah's Ark condition will not be met\n        for (var _i2 = cLength - 1; _i2 >= NOAH_ARK_CAPACITY - 1; _i2--) {\n          this.entries.splice(candidates[_i2].idx, 1);\n          this.length--;\n        }\n      }\n    }\n\n    //Mutations\n  }, {\n    key: \"insertMarker\",\n    value: function insertMarker() {\n      this.entries.push({\n        type: FormattingElementList.MARKER_ENTRY\n      });\n      this.length++;\n    }\n  }, {\n    key: \"pushElement\",\n    value: function pushElement(element, token) {\n      this._ensureNoahArkCondition(element);\n      this.entries.push({\n        type: FormattingElementList.ELEMENT_ENTRY,\n        element: element,\n        token: token\n      });\n      this.length++;\n    }\n  }, {\n    key: \"insertElementAfterBookmark\",\n    value: function insertElementAfterBookmark(element, token) {\n      var bookmarkIdx = this.length - 1;\n      for (; bookmarkIdx >= 0; bookmarkIdx--) {\n        if (this.entries[bookmarkIdx] === this.bookmark) {\n          break;\n        }\n      }\n      this.entries.splice(bookmarkIdx + 1, 0, {\n        type: FormattingElementList.ELEMENT_ENTRY,\n        element: element,\n        token: token\n      });\n      this.length++;\n    }\n  }, {\n    key: \"removeEntry\",\n    value: function removeEntry(entry) {\n      for (var i = this.length - 1; i >= 0; i--) {\n        if (this.entries[i] === entry) {\n          this.entries.splice(i, 1);\n          this.length--;\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"clearToLastMarker\",\n    value: function clearToLastMarker() {\n      while (this.length) {\n        var entry = this.entries.pop();\n        this.length--;\n        if (entry.type === FormattingElementList.MARKER_ENTRY) {\n          break;\n        }\n      }\n    }\n\n    //Search\n  }, {\n    key: \"getElementEntryInScopeWithTagName\",\n    value: function getElementEntryInScopeWithTagName(tagName) {\n      for (var i = this.length - 1; i >= 0; i--) {\n        var entry = this.entries[i];\n        if (entry.type === FormattingElementList.MARKER_ENTRY) {\n          return null;\n        }\n        if (this.treeAdapter.getTagName(entry.element) === tagName) {\n          return entry;\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"getElementEntry\",\n    value: function getElementEntry(element) {\n      for (var i = this.length - 1; i >= 0; i--) {\n        var entry = this.entries[i];\n        if (entry.type === FormattingElementList.ELEMENT_ENTRY && entry.element === element) {\n          return entry;\n        }\n      }\n      return null;\n    }\n  }]);\n}(); //Entry types\nFormattingElementList.MARKER_ENTRY = 'MARKER_ENTRY';\nFormattingElementList.ELEMENT_ENTRY = 'ELEMENT_ENTRY';\nmodule.exports = FormattingElementList;","map":{"version":3,"names":["_classCallCheck","require","_createClass","NOAH_ARK_CAPACITY","FormattingElementList","treeAdapter","length","entries","bookmark","key","value","_getNoahArkConditionCandidates","newElement","candidates","neAttrsLength","getAttrList","neTagName","getTagName","neNamespaceURI","getNamespaceURI","i","entry","type","MARKER_ENTRY","element","elementAttrs","isCandidate","push","idx","attrs","_ensureNoahArkCondition","cLength","neAttrs","neAttrsMap","Object","create","neAttr","name","j","cAttr","splice","insertMarker","pushElement","token","ELEMENT_ENTRY","insertElementAfterBookmark","bookmarkIdx","removeEntry","clearToLastMarker","pop","getElementEntryInScopeWithTagName","tagName","getElementEntry","module","exports"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/hast-util-raw/node_modules/parse5/lib/parser/formatting-element-list.js"],"sourcesContent":["'use strict';\n\n//Const\nconst NOAH_ARK_CAPACITY = 3;\n\n//List of formatting elements\nclass FormattingElementList {\n    constructor(treeAdapter) {\n        this.length = 0;\n        this.entries = [];\n        this.treeAdapter = treeAdapter;\n        this.bookmark = null;\n    }\n\n    //Noah Ark's condition\n    //OPTIMIZATION: at first we try to find possible candidates for exclusion using\n    //lightweight heuristics without thorough attributes check.\n    _getNoahArkConditionCandidates(newElement) {\n        const candidates = [];\n\n        if (this.length >= NOAH_ARK_CAPACITY) {\n            const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;\n            const neTagName = this.treeAdapter.getTagName(newElement);\n            const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\n\n            for (let i = this.length - 1; i >= 0; i--) {\n                const entry = this.entries[i];\n\n                if (entry.type === FormattingElementList.MARKER_ENTRY) {\n                    break;\n                }\n\n                const element = entry.element;\n                const elementAttrs = this.treeAdapter.getAttrList(element);\n\n                const isCandidate =\n                    this.treeAdapter.getTagName(element) === neTagName &&\n                    this.treeAdapter.getNamespaceURI(element) === neNamespaceURI &&\n                    elementAttrs.length === neAttrsLength;\n\n                if (isCandidate) {\n                    candidates.push({ idx: i, attrs: elementAttrs });\n                }\n            }\n        }\n\n        return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;\n    }\n\n    _ensureNoahArkCondition(newElement) {\n        const candidates = this._getNoahArkConditionCandidates(newElement);\n        let cLength = candidates.length;\n\n        if (cLength) {\n            const neAttrs = this.treeAdapter.getAttrList(newElement);\n            const neAttrsLength = neAttrs.length;\n            const neAttrsMap = Object.create(null);\n\n            //NOTE: build attrs map for the new element so we can perform fast lookups\n            for (let i = 0; i < neAttrsLength; i++) {\n                const neAttr = neAttrs[i];\n\n                neAttrsMap[neAttr.name] = neAttr.value;\n            }\n\n            for (let i = 0; i < neAttrsLength; i++) {\n                for (let j = 0; j < cLength; j++) {\n                    const cAttr = candidates[j].attrs[i];\n\n                    if (neAttrsMap[cAttr.name] !== cAttr.value) {\n                        candidates.splice(j, 1);\n                        cLength--;\n                    }\n\n                    if (candidates.length < NOAH_ARK_CAPACITY) {\n                        return;\n                    }\n                }\n            }\n\n            //NOTE: remove bottommost candidates until Noah's Ark condition will not be met\n            for (let i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {\n                this.entries.splice(candidates[i].idx, 1);\n                this.length--;\n            }\n        }\n    }\n\n    //Mutations\n    insertMarker() {\n        this.entries.push({ type: FormattingElementList.MARKER_ENTRY });\n        this.length++;\n    }\n\n    pushElement(element, token) {\n        this._ensureNoahArkCondition(element);\n\n        this.entries.push({\n            type: FormattingElementList.ELEMENT_ENTRY,\n            element: element,\n            token: token\n        });\n\n        this.length++;\n    }\n\n    insertElementAfterBookmark(element, token) {\n        let bookmarkIdx = this.length - 1;\n\n        for (; bookmarkIdx >= 0; bookmarkIdx--) {\n            if (this.entries[bookmarkIdx] === this.bookmark) {\n                break;\n            }\n        }\n\n        this.entries.splice(bookmarkIdx + 1, 0, {\n            type: FormattingElementList.ELEMENT_ENTRY,\n            element: element,\n            token: token\n        });\n\n        this.length++;\n    }\n\n    removeEntry(entry) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            if (this.entries[i] === entry) {\n                this.entries.splice(i, 1);\n                this.length--;\n                break;\n            }\n        }\n    }\n\n    clearToLastMarker() {\n        while (this.length) {\n            const entry = this.entries.pop();\n\n            this.length--;\n\n            if (entry.type === FormattingElementList.MARKER_ENTRY) {\n                break;\n            }\n        }\n    }\n\n    //Search\n    getElementEntryInScopeWithTagName(tagName) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            const entry = this.entries[i];\n\n            if (entry.type === FormattingElementList.MARKER_ENTRY) {\n                return null;\n            }\n\n            if (this.treeAdapter.getTagName(entry.element) === tagName) {\n                return entry;\n            }\n        }\n\n        return null;\n    }\n\n    getElementEntry(element) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            const entry = this.entries[i];\n\n            if (entry.type === FormattingElementList.ELEMENT_ENTRY && entry.element === element) {\n                return entry;\n            }\n        }\n\n        return null;\n    }\n}\n\n//Entry types\nFormattingElementList.MARKER_ENTRY = 'MARKER_ENTRY';\nFormattingElementList.ELEMENT_ENTRY = 'ELEMENT_ENTRY';\n\nmodule.exports = FormattingElementList;\n"],"mappings":"AAAA,YAAY;;AAEZ;AAAA,IAAAA,eAAA,GAAAC,OAAA;AAAA,IAAAC,YAAA,GAAAD,OAAA;AAAAA,OAAA;AAAAA,OAAA;AAAAA,OAAA;AAAAA,OAAA;AAAAA,OAAA;AAAAA,OAAA;AACA,IAAME,iBAAiB,GAAG,CAAC;;AAE3B;AAAA,IACMC,qBAAqB;EACvB,SAAAA,sBAAYC,WAAW,EAAE;IAAAL,eAAA,OAAAI,qBAAA;IACrB,IAAI,CAACE,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,OAAO,GAAG,EAAE;IACjB,IAAI,CAACF,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACG,QAAQ,GAAG,IAAI;EACxB;;EAEA;EACA;EACA;EAAA,OAAAN,YAAA,CAAAE,qBAAA;IAAAK,GAAA;IAAAC,KAAA,EACA,SAAAC,+BAA+BC,UAAU,EAAE;MACvC,IAAMC,UAAU,GAAG,EAAE;MAErB,IAAI,IAAI,CAACP,MAAM,IAAIH,iBAAiB,EAAE;QAClC,IAAMW,aAAa,GAAG,IAAI,CAACT,WAAW,CAACU,WAAW,CAACH,UAAU,CAAC,CAACN,MAAM;QACrE,IAAMU,SAAS,GAAG,IAAI,CAACX,WAAW,CAACY,UAAU,CAACL,UAAU,CAAC;QACzD,IAAMM,cAAc,GAAG,IAAI,CAACb,WAAW,CAACc,eAAe,CAACP,UAAU,CAAC;QAEnE,KAAK,IAAIQ,CAAC,GAAG,IAAI,CAACd,MAAM,GAAG,CAAC,EAAEc,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;UACvC,IAAMC,KAAK,GAAG,IAAI,CAACd,OAAO,CAACa,CAAC,CAAC;UAE7B,IAAIC,KAAK,CAACC,IAAI,KAAKlB,qBAAqB,CAACmB,YAAY,EAAE;YACnD;UACJ;UAEA,IAAMC,OAAO,GAAGH,KAAK,CAACG,OAAO;UAC7B,IAAMC,YAAY,GAAG,IAAI,CAACpB,WAAW,CAACU,WAAW,CAACS,OAAO,CAAC;UAE1D,IAAME,WAAW,GACb,IAAI,CAACrB,WAAW,CAACY,UAAU,CAACO,OAAO,CAAC,KAAKR,SAAS,IAClD,IAAI,CAACX,WAAW,CAACc,eAAe,CAACK,OAAO,CAAC,KAAKN,cAAc,IAC5DO,YAAY,CAACnB,MAAM,KAAKQ,aAAa;UAEzC,IAAIY,WAAW,EAAE;YACbb,UAAU,CAACc,IAAI,CAAC;cAAEC,GAAG,EAAER,CAAC;cAAES,KAAK,EAAEJ;YAAa,CAAC,CAAC;UACpD;QACJ;MACJ;MAEA,OAAOZ,UAAU,CAACP,MAAM,GAAGH,iBAAiB,GAAG,EAAE,GAAGU,UAAU;IAClE;EAAC;IAAAJ,GAAA;IAAAC,KAAA,EAED,SAAAoB,wBAAwBlB,UAAU,EAAE;MAChC,IAAMC,UAAU,GAAG,IAAI,CAACF,8BAA8B,CAACC,UAAU,CAAC;MAClE,IAAImB,OAAO,GAAGlB,UAAU,CAACP,MAAM;MAE/B,IAAIyB,OAAO,EAAE;QACT,IAAMC,OAAO,GAAG,IAAI,CAAC3B,WAAW,CAACU,WAAW,CAACH,UAAU,CAAC;QACxD,IAAME,aAAa,GAAGkB,OAAO,CAAC1B,MAAM;QACpC,IAAM2B,UAAU,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;;QAEtC;QACA,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,aAAa,EAAEM,CAAC,EAAE,EAAE;UACpC,IAAMgB,MAAM,GAAGJ,OAAO,CAACZ,CAAC,CAAC;UAEzBa,UAAU,CAACG,MAAM,CAACC,IAAI,CAAC,GAAGD,MAAM,CAAC1B,KAAK;QAC1C;QAEA,KAAK,IAAIU,EAAC,GAAG,CAAC,EAAEA,EAAC,GAAGN,aAAa,EAAEM,EAAC,EAAE,EAAE;UACpC,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,OAAO,EAAEO,CAAC,EAAE,EAAE;YAC9B,IAAMC,KAAK,GAAG1B,UAAU,CAACyB,CAAC,CAAC,CAACT,KAAK,CAACT,EAAC,CAAC;YAEpC,IAAIa,UAAU,CAACM,KAAK,CAACF,IAAI,CAAC,KAAKE,KAAK,CAAC7B,KAAK,EAAE;cACxCG,UAAU,CAAC2B,MAAM,CAACF,CAAC,EAAE,CAAC,CAAC;cACvBP,OAAO,EAAE;YACb;YAEA,IAAIlB,UAAU,CAACP,MAAM,GAAGH,iBAAiB,EAAE;cACvC;YACJ;UACJ;QACJ;;QAEA;QACA,KAAK,IAAIiB,GAAC,GAAGW,OAAO,GAAG,CAAC,EAAEX,GAAC,IAAIjB,iBAAiB,GAAG,CAAC,EAAEiB,GAAC,EAAE,EAAE;UACvD,IAAI,CAACb,OAAO,CAACiC,MAAM,CAAC3B,UAAU,CAACO,GAAC,CAAC,CAACQ,GAAG,EAAE,CAAC,CAAC;UACzC,IAAI,CAACtB,MAAM,EAAE;QACjB;MACJ;IACJ;;IAEA;EAAA;IAAAG,GAAA;IAAAC,KAAA,EACA,SAAA+B,aAAA,EAAe;MACX,IAAI,CAAClC,OAAO,CAACoB,IAAI,CAAC;QAAEL,IAAI,EAAElB,qBAAqB,CAACmB;MAAa,CAAC,CAAC;MAC/D,IAAI,CAACjB,MAAM,EAAE;IACjB;EAAC;IAAAG,GAAA;IAAAC,KAAA,EAED,SAAAgC,YAAYlB,OAAO,EAAEmB,KAAK,EAAE;MACxB,IAAI,CAACb,uBAAuB,CAACN,OAAO,CAAC;MAErC,IAAI,CAACjB,OAAO,CAACoB,IAAI,CAAC;QACdL,IAAI,EAAElB,qBAAqB,CAACwC,aAAa;QACzCpB,OAAO,EAAEA,OAAO;QAChBmB,KAAK,EAAEA;MACX,CAAC,CAAC;MAEF,IAAI,CAACrC,MAAM,EAAE;IACjB;EAAC;IAAAG,GAAA;IAAAC,KAAA,EAED,SAAAmC,2BAA2BrB,OAAO,EAAEmB,KAAK,EAAE;MACvC,IAAIG,WAAW,GAAG,IAAI,CAACxC,MAAM,GAAG,CAAC;MAEjC,OAAOwC,WAAW,IAAI,CAAC,EAAEA,WAAW,EAAE,EAAE;QACpC,IAAI,IAAI,CAACvC,OAAO,CAACuC,WAAW,CAAC,KAAK,IAAI,CAACtC,QAAQ,EAAE;UAC7C;QACJ;MACJ;MAEA,IAAI,CAACD,OAAO,CAACiC,MAAM,CAACM,WAAW,GAAG,CAAC,EAAE,CAAC,EAAE;QACpCxB,IAAI,EAAElB,qBAAqB,CAACwC,aAAa;QACzCpB,OAAO,EAAEA,OAAO;QAChBmB,KAAK,EAAEA;MACX,CAAC,CAAC;MAEF,IAAI,CAACrC,MAAM,EAAE;IACjB;EAAC;IAAAG,GAAA;IAAAC,KAAA,EAED,SAAAqC,YAAY1B,KAAK,EAAE;MACf,KAAK,IAAID,CAAC,GAAG,IAAI,CAACd,MAAM,GAAG,CAAC,EAAEc,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;QACvC,IAAI,IAAI,CAACb,OAAO,CAACa,CAAC,CAAC,KAAKC,KAAK,EAAE;UAC3B,IAAI,CAACd,OAAO,CAACiC,MAAM,CAACpB,CAAC,EAAE,CAAC,CAAC;UACzB,IAAI,CAACd,MAAM,EAAE;UACb;QACJ;MACJ;IACJ;EAAC;IAAAG,GAAA;IAAAC,KAAA,EAED,SAAAsC,kBAAA,EAAoB;MAChB,OAAO,IAAI,CAAC1C,MAAM,EAAE;QAChB,IAAMe,KAAK,GAAG,IAAI,CAACd,OAAO,CAAC0C,GAAG,CAAC,CAAC;QAEhC,IAAI,CAAC3C,MAAM,EAAE;QAEb,IAAIe,KAAK,CAACC,IAAI,KAAKlB,qBAAqB,CAACmB,YAAY,EAAE;UACnD;QACJ;MACJ;IACJ;;IAEA;EAAA;IAAAd,GAAA;IAAAC,KAAA,EACA,SAAAwC,kCAAkCC,OAAO,EAAE;MACvC,KAAK,IAAI/B,CAAC,GAAG,IAAI,CAACd,MAAM,GAAG,CAAC,EAAEc,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;QACvC,IAAMC,KAAK,GAAG,IAAI,CAACd,OAAO,CAACa,CAAC,CAAC;QAE7B,IAAIC,KAAK,CAACC,IAAI,KAAKlB,qBAAqB,CAACmB,YAAY,EAAE;UACnD,OAAO,IAAI;QACf;QAEA,IAAI,IAAI,CAAClB,WAAW,CAACY,UAAU,CAACI,KAAK,CAACG,OAAO,CAAC,KAAK2B,OAAO,EAAE;UACxD,OAAO9B,KAAK;QAChB;MACJ;MAEA,OAAO,IAAI;IACf;EAAC;IAAAZ,GAAA;IAAAC,KAAA,EAED,SAAA0C,gBAAgB5B,OAAO,EAAE;MACrB,KAAK,IAAIJ,CAAC,GAAG,IAAI,CAACd,MAAM,GAAG,CAAC,EAAEc,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;QACvC,IAAMC,KAAK,GAAG,IAAI,CAACd,OAAO,CAACa,CAAC,CAAC;QAE7B,IAAIC,KAAK,CAACC,IAAI,KAAKlB,qBAAqB,CAACwC,aAAa,IAAIvB,KAAK,CAACG,OAAO,KAAKA,OAAO,EAAE;UACjF,OAAOH,KAAK;QAChB;MACJ;MAEA,OAAO,IAAI;IACf;EAAC;AAAA,KAGL;AACAjB,qBAAqB,CAACmB,YAAY,GAAG,cAAc;AACnDnB,qBAAqB,CAACwC,aAAa,GAAG,eAAe;AAErDS,MAAM,CAACC,OAAO,GAAGlD,qBAAqB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}