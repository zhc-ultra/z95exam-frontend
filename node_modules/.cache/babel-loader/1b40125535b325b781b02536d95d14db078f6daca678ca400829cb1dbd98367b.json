{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.last-index-of.js\";\nimport \"core-js/modules/es.array.push.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { BlockCommentCommand } from './blockCommentCommand.js';\nexport var LineCommentCommand = /*#__PURE__*/function () {\n  function LineCommentCommand(languageConfigurationService, selection, indentSize, type, insertSpace, ignoreEmptyLines, ignoreFirstLine) {\n    _classCallCheck(this, LineCommentCommand);\n    this.languageConfigurationService = languageConfigurationService;\n    this._selection = selection;\n    this._indentSize = indentSize;\n    this._type = type;\n    this._insertSpace = insertSpace;\n    this._selectionId = null;\n    this._deltaColumn = 0;\n    this._moveEndPositionDown = false;\n    this._ignoreEmptyLines = ignoreEmptyLines;\n    this._ignoreFirstLine = ignoreFirstLine || false;\n  }\n  /**\n   * Do an initial pass over the lines and gather info about the line comment string.\n   * Returns null if any of the lines doesn't support a line comment string.\n   */\n  return _createClass(LineCommentCommand, [{\n    key: \"_executeLineComments\",\n    value:\n    /**\n     * Given a successful analysis, execute either insert line comments, either remove line comments\n     */\n    function _executeLineComments(model, builder, data, s) {\n      var ops;\n      if (data.shouldRemoveComments) {\n        ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\n      } else {\n        LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._indentSize);\n        ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);\n      }\n      var cursorPosition = new Position(s.positionLineNumber, s.positionColumn);\n      for (var i = 0, len = ops.length; i < len; i++) {\n        builder.addEditOperation(ops[i].range, ops[i].text);\n        if (Range.isEmpty(ops[i].range) && Range.getStartPosition(ops[i].range).equals(cursorPosition)) {\n          var lineContent = model.getLineContent(cursorPosition.lineNumber);\n          if (lineContent.length + 1 === cursorPosition.column) {\n            this._deltaColumn = (ops[i].text || '').length;\n          }\n        }\n      }\n      this._selectionId = builder.trackSelection(s);\n    }\n  }, {\n    key: \"_attemptRemoveBlockComment\",\n    value: function _attemptRemoveBlockComment(model, s, startToken, endToken) {\n      var startLineNumber = s.startLineNumber;\n      var endLineNumber = s.endLineNumber;\n      var startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);\n      var startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\n      var endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\n      if (startTokenIndex !== -1 && endTokenIndex === -1) {\n        endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n        endLineNumber = startLineNumber;\n      }\n      if (startTokenIndex === -1 && endTokenIndex !== -1) {\n        startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\n        startLineNumber = endLineNumber;\n      }\n      if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\n        startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\n        if (startTokenIndex !== -1) {\n          endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n        }\n      }\n      // We have to adjust to possible inner white space.\n      // For Space after startToken, add Space to startToken - range math will work out.\n      if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32 /* CharCode.Space */) {\n        startToken += ' ';\n      }\n      // For Space before endToken, add Space before endToken and shift index one left.\n      if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32 /* CharCode.Space */) {\n        endToken = ' ' + endToken;\n        endTokenIndex -= 1;\n      }\n      if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n        return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n      }\n      return null;\n    }\n    /**\n     * Given an unsuccessful analysis, delegate to the block comment command\n     */\n  }, {\n    key: \"_executeBlockComment\",\n    value: function _executeBlockComment(model, builder, s) {\n      model.tokenization.tokenizeIfCheap(s.startLineNumber);\n      var languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\n      var config = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;\n      if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n        // Mode does not support block comments\n        return;\n      }\n      var startToken = config.blockCommentStartToken;\n      var endToken = config.blockCommentEndToken;\n      var ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\n      if (!ops) {\n        if (s.isEmpty()) {\n          var lineContent = model.getLineContent(s.startLineNumber);\n          var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n          if (firstNonWhitespaceIndex === -1) {\n            // Line is empty or contains only whitespace\n            firstNonWhitespaceIndex = lineContent.length;\n          }\n          ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);\n        } else {\n          ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);\n        }\n        if (ops.length === 1) {\n          // Leave cursor after token and Space\n          this._deltaColumn = startToken.length + 1;\n        }\n      }\n      this._selectionId = builder.trackSelection(s);\n      var _iterator = _createForOfIteratorHelper(ops),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var op = _step.value;\n          builder.addEditOperation(op.range, op.text);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"getEditOperations\",\n    value: function getEditOperations(model, builder) {\n      var s = this._selection;\n      this._moveEndPositionDown = false;\n      if (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {\n        builder.addEditOperation(new Range(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? '' : '\\n');\n        this._selectionId = builder.trackSelection(s);\n        return;\n      }\n      if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n        this._moveEndPositionDown = true;\n        s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n      }\n      var data = LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine, this.languageConfigurationService);\n      if (data.supported) {\n        return this._executeLineComments(model, builder, data, s);\n      }\n      return this._executeBlockComment(model, builder, s);\n    }\n  }, {\n    key: \"computeCursorState\",\n    value: function computeCursorState(model, helper) {\n      var result = helper.getTrackedSelection(this._selectionId);\n      if (this._moveEndPositionDown) {\n        result = result.setEndPosition(result.endLineNumber + 1, 1);\n      }\n      return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);\n    }\n    /**\n     * Generate edit operations in the remove line comment case\n     */\n  }, {\n    key: \"_createAddLineCommentsOperations\",\n    value:\n    /**\n     * Generate edit operations in the add line comment case\n     */\n    function _createAddLineCommentsOperations(lines, startLineNumber) {\n      var res = [];\n      var afterCommentStr = this._insertSpace ? ' ' : '';\n      for (var i = 0, len = lines.length; i < len; i++) {\n        var lineData = lines[i];\n        if (lineData.ignore) {\n          continue;\n        }\n        res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));\n      }\n      return res;\n    }\n  }], [{\n    key: \"_gatherPreflightCommentStrings\",\n    value: function _gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService) {\n      model.tokenization.tokenizeIfCheap(startLineNumber);\n      var languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n      var config = languageConfigurationService.getLanguageConfiguration(languageId).comments;\n      var commentStr = config ? config.lineCommentToken : null;\n      if (!commentStr) {\n        // Mode does not support line comments\n        return null;\n      }\n      var lines = [];\n      for (var i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\n        lines[i] = {\n          ignore: false,\n          commentStr: commentStr,\n          commentStrOffset: 0,\n          commentStrLength: commentStr.length\n        };\n      }\n      return lines;\n    }\n    /**\n     * Analyze lines and decide which lines are relevant and what the toggle should do.\n     * Also, build up several offsets and lengths useful in the generation of editor operations.\n     */\n  }, {\n    key: \"_analyzeLines\",\n    value: function _analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {\n      var onlyWhitespaceLines = true;\n      var shouldRemoveComments;\n      if (type === 0 /* Type.Toggle */) {\n        shouldRemoveComments = true;\n      } else if (type === 1 /* Type.ForceAdd */) {\n        shouldRemoveComments = false;\n      } else {\n        shouldRemoveComments = true;\n      }\n      for (var i = 0, lineCount = lines.length; i < lineCount; i++) {\n        var lineData = lines[i];\n        var lineNumber = startLineNumber + i;\n        if (lineNumber === startLineNumber && ignoreFirstLine) {\n          // first line ignored\n          lineData.ignore = true;\n          continue;\n        }\n        var lineContent = model.getLineContent(lineNumber);\n        var lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\n        if (lineContentStartOffset === -1) {\n          // Empty or whitespace only line\n          lineData.ignore = ignoreEmptyLines;\n          lineData.commentStrOffset = lineContent.length;\n          continue;\n        }\n        onlyWhitespaceLines = false;\n        lineData.ignore = false;\n        lineData.commentStrOffset = lineContentStartOffset;\n        if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {\n          if (type === 0 /* Type.Toggle */) {\n            // Every line so far has been a line comment, but this one is not\n            shouldRemoveComments = false;\n          } else if (type === 1 /* Type.ForceAdd */) {\n            // Will not happen\n          } else {\n            lineData.ignore = true;\n          }\n        }\n        if (shouldRemoveComments && insertSpace) {\n          // Remove a following space if present\n          var commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\n          if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32 /* CharCode.Space */) {\n            lineData.commentStrLength += 1;\n          }\n        }\n      }\n      if (type === 0 /* Type.Toggle */ && onlyWhitespaceLines) {\n        // For only whitespace lines, we insert comments\n        shouldRemoveComments = false;\n        // Also, no longer ignore them\n        for (var _i = 0, _lineCount = lines.length; _i < _lineCount; _i++) {\n          lines[_i].ignore = false;\n        }\n      }\n      return {\n        supported: true,\n        shouldRemoveComments: shouldRemoveComments,\n        lines: lines\n      };\n    }\n    /**\n     * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\n     */\n  }, {\n    key: \"_gatherPreflightData\",\n    value: function _gatherPreflightData(type, insertSpace, model, startLineNumber, endLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {\n      var lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService);\n      if (lines === null) {\n        return {\n          supported: false\n        };\n      }\n      return LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService);\n    }\n  }, {\n    key: \"_createRemoveLineCommentsOperations\",\n    value: function _createRemoveLineCommentsOperations(lines, startLineNumber) {\n      var res = [];\n      for (var i = 0, len = lines.length; i < len; i++) {\n        var lineData = lines[i];\n        if (lineData.ignore) {\n          continue;\n        }\n        res.push(EditOperation[\"delete\"](new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));\n      }\n      return res;\n    }\n  }, {\n    key: \"nextVisibleColumn\",\n    value: function nextVisibleColumn(currentVisibleColumn, indentSize, isTab, columnSize) {\n      if (isTab) {\n        return currentVisibleColumn + (indentSize - currentVisibleColumn % indentSize);\n      }\n      return currentVisibleColumn + columnSize;\n    }\n    /**\n     * Adjust insertion points to have them vertically aligned in the add line comment case\n     */\n  }, {\n    key: \"_normalizeInsertionPoint\",\n    value: function _normalizeInsertionPoint(model, lines, startLineNumber, indentSize) {\n      var minVisibleColumn = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n      var j;\n      var lenJ;\n      for (var i = 0, len = lines.length; i < len; i++) {\n        if (lines[i].ignore) {\n          continue;\n        }\n        var lineContent = model.getLineContent(startLineNumber + i);\n        var currentVisibleColumn = 0;\n        for (var _j = 0, _lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && _j < _lenJ; _j++) {\n          currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, indentSize, lineContent.charCodeAt(_j) === 9 /* CharCode.Tab */, 1);\n        }\n        if (currentVisibleColumn < minVisibleColumn) {\n          minVisibleColumn = currentVisibleColumn;\n        }\n      }\n      minVisibleColumn = Math.floor(minVisibleColumn / indentSize) * indentSize;\n      for (var _i2 = 0, _len = lines.length; _i2 < _len; _i2++) {\n        if (lines[_i2].ignore) {\n          continue;\n        }\n        var _lineContent = model.getLineContent(startLineNumber + _i2);\n        var _currentVisibleColumn = 0;\n        for (j = 0, lenJ = lines[_i2].commentStrOffset; _currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n          _currentVisibleColumn = LineCommentCommand.nextVisibleColumn(_currentVisibleColumn, indentSize, _lineContent.charCodeAt(j) === 9 /* CharCode.Tab */, 1);\n        }\n        if (_currentVisibleColumn > minVisibleColumn) {\n          lines[_i2].commentStrOffset = j - 1;\n        } else {\n          lines[_i2].commentStrOffset = j;\n        }\n      }\n    }\n  }]);\n}();","map":{"version":3,"names":["strings","EditOperation","Position","Range","Selection","BlockCommentCommand","LineCommentCommand","languageConfigurationService","selection","indentSize","type","insertSpace","ignoreEmptyLines","ignoreFirstLine","_classCallCheck","_selection","_indentSize","_type","_insertSpace","_selectionId","_deltaColumn","_moveEndPositionDown","_ignoreEmptyLines","_ignoreFirstLine","_createClass","key","value","_executeLineComments","model","builder","data","s","ops","shouldRemoveComments","_createRemoveLineCommentsOperations","lines","startLineNumber","_normalizeInsertionPoint","_createAddLineCommentsOperations","cursorPosition","positionLineNumber","positionColumn","i","len","length","addEditOperation","range","text","isEmpty","getStartPosition","equals","lineContent","getLineContent","lineNumber","column","trackSelection","_attemptRemoveBlockComment","startToken","endToken","endLineNumber","startTokenAllowedBeforeColumn","Math","max","getLineFirstNonWhitespaceColumn","startColumn","startTokenIndex","lastIndexOf","endTokenIndex","indexOf","endColumn","charCodeAt","_createRemoveBlockCommentOperations","_executeBlockComment","tokenization","tokenizeIfCheap","languageId","getLanguageIdAtPosition","config","getLanguageConfiguration","comments","blockCommentStartToken","blockCommentEndToken","firstNonWhitespaceIndex","_createAddBlockCommentOperations","getLineMaxColumn","_iterator","_createForOfIteratorHelper","_step","n","done","op","err","e","f","getEditOperations","getLineCount","setEndPosition","_gatherPreflightData","supported","computeCursorState","helper","result","getTrackedSelection","selectionStartLineNumber","selectionStartColumn","res","afterCommentStr","lineData","ignore","push","insert","commentStrOffset","commentStr","_gatherPreflightCommentStrings","lineCommentToken","lineCount","commentStrLength","_analyzeLines","onlyWhitespaceLines","lineContentStartOffset","_haystackHasNeedleAtOffset","commentStrEndOffset","nextVisibleColumn","currentVisibleColumn","isTab","columnSize","minVisibleColumn","j","lenJ","floor"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/contrib/comment/browser/lineCommentCommand.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { EditOperation } from '../../../common/core/editOperation.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { BlockCommentCommand } from './blockCommentCommand.js';\nexport class LineCommentCommand {\n    constructor(languageConfigurationService, selection, indentSize, type, insertSpace, ignoreEmptyLines, ignoreFirstLine) {\n        this.languageConfigurationService = languageConfigurationService;\n        this._selection = selection;\n        this._indentSize = indentSize;\n        this._type = type;\n        this._insertSpace = insertSpace;\n        this._selectionId = null;\n        this._deltaColumn = 0;\n        this._moveEndPositionDown = false;\n        this._ignoreEmptyLines = ignoreEmptyLines;\n        this._ignoreFirstLine = ignoreFirstLine || false;\n    }\n    /**\n     * Do an initial pass over the lines and gather info about the line comment string.\n     * Returns null if any of the lines doesn't support a line comment string.\n     */\n    static _gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService) {\n        model.tokenization.tokenizeIfCheap(startLineNumber);\n        const languageId = model.getLanguageIdAtPosition(startLineNumber, 1);\n        const config = languageConfigurationService.getLanguageConfiguration(languageId).comments;\n        const commentStr = (config ? config.lineCommentToken : null);\n        if (!commentStr) {\n            // Mode does not support line comments\n            return null;\n        }\n        const lines = [];\n        for (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {\n            lines[i] = {\n                ignore: false,\n                commentStr: commentStr,\n                commentStrOffset: 0,\n                commentStrLength: commentStr.length\n            };\n        }\n        return lines;\n    }\n    /**\n     * Analyze lines and decide which lines are relevant and what the toggle should do.\n     * Also, build up several offsets and lengths useful in the generation of editor operations.\n     */\n    static _analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {\n        let onlyWhitespaceLines = true;\n        let shouldRemoveComments;\n        if (type === 0 /* Type.Toggle */) {\n            shouldRemoveComments = true;\n        }\n        else if (type === 1 /* Type.ForceAdd */) {\n            shouldRemoveComments = false;\n        }\n        else {\n            shouldRemoveComments = true;\n        }\n        for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n            const lineData = lines[i];\n            const lineNumber = startLineNumber + i;\n            if (lineNumber === startLineNumber && ignoreFirstLine) {\n                // first line ignored\n                lineData.ignore = true;\n                continue;\n            }\n            const lineContent = model.getLineContent(lineNumber);\n            const lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);\n            if (lineContentStartOffset === -1) {\n                // Empty or whitespace only line\n                lineData.ignore = ignoreEmptyLines;\n                lineData.commentStrOffset = lineContent.length;\n                continue;\n            }\n            onlyWhitespaceLines = false;\n            lineData.ignore = false;\n            lineData.commentStrOffset = lineContentStartOffset;\n            if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {\n                if (type === 0 /* Type.Toggle */) {\n                    // Every line so far has been a line comment, but this one is not\n                    shouldRemoveComments = false;\n                }\n                else if (type === 1 /* Type.ForceAdd */) {\n                    // Will not happen\n                }\n                else {\n                    lineData.ignore = true;\n                }\n            }\n            if (shouldRemoveComments && insertSpace) {\n                // Remove a following space if present\n                const commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;\n                if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32 /* CharCode.Space */) {\n                    lineData.commentStrLength += 1;\n                }\n            }\n        }\n        if (type === 0 /* Type.Toggle */ && onlyWhitespaceLines) {\n            // For only whitespace lines, we insert comments\n            shouldRemoveComments = false;\n            // Also, no longer ignore them\n            for (let i = 0, lineCount = lines.length; i < lineCount; i++) {\n                lines[i].ignore = false;\n            }\n        }\n        return {\n            supported: true,\n            shouldRemoveComments: shouldRemoveComments,\n            lines: lines\n        };\n    }\n    /**\n     * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments\n     */\n    static _gatherPreflightData(type, insertSpace, model, startLineNumber, endLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {\n        const lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService);\n        if (lines === null) {\n            return {\n                supported: false\n            };\n        }\n        return LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService);\n    }\n    /**\n     * Given a successful analysis, execute either insert line comments, either remove line comments\n     */\n    _executeLineComments(model, builder, data, s) {\n        let ops;\n        if (data.shouldRemoveComments) {\n            ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);\n        }\n        else {\n            LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._indentSize);\n            ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);\n        }\n        const cursorPosition = new Position(s.positionLineNumber, s.positionColumn);\n        for (let i = 0, len = ops.length; i < len; i++) {\n            builder.addEditOperation(ops[i].range, ops[i].text);\n            if (Range.isEmpty(ops[i].range) && Range.getStartPosition(ops[i].range).equals(cursorPosition)) {\n                const lineContent = model.getLineContent(cursorPosition.lineNumber);\n                if (lineContent.length + 1 === cursorPosition.column) {\n                    this._deltaColumn = (ops[i].text || '').length;\n                }\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n    }\n    _attemptRemoveBlockComment(model, s, startToken, endToken) {\n        let startLineNumber = s.startLineNumber;\n        let endLineNumber = s.endLineNumber;\n        const startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);\n        let startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);\n        let endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);\n        if (startTokenIndex !== -1 && endTokenIndex === -1) {\n            endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n            endLineNumber = startLineNumber;\n        }\n        if (startTokenIndex === -1 && endTokenIndex !== -1) {\n            startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);\n            startLineNumber = endLineNumber;\n        }\n        if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {\n            startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);\n            if (startTokenIndex !== -1) {\n                endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);\n            }\n        }\n        // We have to adjust to possible inner white space.\n        // For Space after startToken, add Space to startToken - range math will work out.\n        if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32 /* CharCode.Space */) {\n            startToken += ' ';\n        }\n        // For Space before endToken, add Space before endToken and shift index one left.\n        if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32 /* CharCode.Space */) {\n            endToken = ' ' + endToken;\n            endTokenIndex -= 1;\n        }\n        if (startTokenIndex !== -1 && endTokenIndex !== -1) {\n            return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);\n        }\n        return null;\n    }\n    /**\n     * Given an unsuccessful analysis, delegate to the block comment command\n     */\n    _executeBlockComment(model, builder, s) {\n        model.tokenization.tokenizeIfCheap(s.startLineNumber);\n        const languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);\n        const config = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;\n        if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {\n            // Mode does not support block comments\n            return;\n        }\n        const startToken = config.blockCommentStartToken;\n        const endToken = config.blockCommentEndToken;\n        let ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);\n        if (!ops) {\n            if (s.isEmpty()) {\n                const lineContent = model.getLineContent(s.startLineNumber);\n                let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n                if (firstNonWhitespaceIndex === -1) {\n                    // Line is empty or contains only whitespace\n                    firstNonWhitespaceIndex = lineContent.length;\n                }\n                ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);\n            }\n            else {\n                ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);\n            }\n            if (ops.length === 1) {\n                // Leave cursor after token and Space\n                this._deltaColumn = startToken.length + 1;\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n        for (const op of ops) {\n            builder.addEditOperation(op.range, op.text);\n        }\n    }\n    getEditOperations(model, builder) {\n        let s = this._selection;\n        this._moveEndPositionDown = false;\n        if (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {\n            builder.addEditOperation(new Range(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? '' : '\\n');\n            this._selectionId = builder.trackSelection(s);\n            return;\n        }\n        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n            this._moveEndPositionDown = true;\n            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n        }\n        const data = LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine, this.languageConfigurationService);\n        if (data.supported) {\n            return this._executeLineComments(model, builder, data, s);\n        }\n        return this._executeBlockComment(model, builder, s);\n    }\n    computeCursorState(model, helper) {\n        let result = helper.getTrackedSelection(this._selectionId);\n        if (this._moveEndPositionDown) {\n            result = result.setEndPosition(result.endLineNumber + 1, 1);\n        }\n        return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);\n    }\n    /**\n     * Generate edit operations in the remove line comment case\n     */\n    static _createRemoveLineCommentsOperations(lines, startLineNumber) {\n        const res = [];\n        for (let i = 0, len = lines.length; i < len; i++) {\n            const lineData = lines[i];\n            if (lineData.ignore) {\n                continue;\n            }\n            res.push(EditOperation.delete(new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));\n        }\n        return res;\n    }\n    /**\n     * Generate edit operations in the add line comment case\n     */\n    _createAddLineCommentsOperations(lines, startLineNumber) {\n        const res = [];\n        const afterCommentStr = this._insertSpace ? ' ' : '';\n        for (let i = 0, len = lines.length; i < len; i++) {\n            const lineData = lines[i];\n            if (lineData.ignore) {\n                continue;\n            }\n            res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));\n        }\n        return res;\n    }\n    static nextVisibleColumn(currentVisibleColumn, indentSize, isTab, columnSize) {\n        if (isTab) {\n            return currentVisibleColumn + (indentSize - (currentVisibleColumn % indentSize));\n        }\n        return currentVisibleColumn + columnSize;\n    }\n    /**\n     * Adjust insertion points to have them vertically aligned in the add line comment case\n     */\n    static _normalizeInsertionPoint(model, lines, startLineNumber, indentSize) {\n        let minVisibleColumn = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n        let j;\n        let lenJ;\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (lines[i].ignore) {\n                continue;\n            }\n            const lineContent = model.getLineContent(startLineNumber + i);\n            let currentVisibleColumn = 0;\n            for (let j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, indentSize, lineContent.charCodeAt(j) === 9 /* CharCode.Tab */, 1);\n            }\n            if (currentVisibleColumn < minVisibleColumn) {\n                minVisibleColumn = currentVisibleColumn;\n            }\n        }\n        minVisibleColumn = Math.floor(minVisibleColumn / indentSize) * indentSize;\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (lines[i].ignore) {\n                continue;\n            }\n            const lineContent = model.getLineContent(startLineNumber + i);\n            let currentVisibleColumn = 0;\n            for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {\n                currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, indentSize, lineContent.charCodeAt(j) === 9 /* CharCode.Tab */, 1);\n            }\n            if (currentVisibleColumn > minVisibleColumn) {\n                lines[i].commentStrOffset = j - 1;\n            }\n            else {\n                lines[i].commentStrOffset = j;\n            }\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}