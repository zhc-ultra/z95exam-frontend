{"ast":null,"code":"import _toConsumableArray from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { implies, expressionsAreEqualWithConstantSubstitution } from '../../contextkey/common/contextkey.js';\n// util definitions to make working with the above types easier within this module:\nexport var NoMatchingKb = {\n  kind: 0 /* ResultKind.NoMatchingKb */\n};\nvar MoreChordsNeeded = {\n  kind: 1 /* ResultKind.MoreChordsNeeded */\n};\nfunction KbFound(commandId, commandArgs, isBubble) {\n  return {\n    kind: 2 /* ResultKind.KbFound */,\n    commandId: commandId,\n    commandArgs: commandArgs,\n    isBubble: isBubble\n  };\n}\n//#endregion\n/**\n * Stores mappings from keybindings to commands and from commands to keybindings.\n * Given a sequence of chords, `resolve`s which keybinding it matches\n */\nexport var KeybindingResolver = /*#__PURE__*/function () {\n  function KeybindingResolver( /** built-in and extension-provided keybindings */\n  defaultKeybindings, /** user's keybindings */\n  overrides, log) {\n    _classCallCheck(this, KeybindingResolver);\n    var _a;\n    this._log = log;\n    this._defaultKeybindings = defaultKeybindings;\n    this._defaultBoundCommands = new Map();\n    var _iterator = _createForOfIteratorHelper(defaultKeybindings),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var defaultKeybinding = _step.value;\n        var command = defaultKeybinding.command;\n        if (command && command.charAt(0) !== '-') {\n          this._defaultBoundCommands.set(command, true);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    this._map = new Map();\n    this._lookupMap = new Map();\n    this._keybindings = KeybindingResolver.handleRemovals([].concat(defaultKeybindings).concat(overrides));\n    for (var i = 0, len = this._keybindings.length; i < len; i++) {\n      var k = this._keybindings[i];\n      if (k.chords.length === 0) {\n        // unbound\n        continue;\n      }\n      // substitute with constants that are registered after startup - https://github.com/microsoft/vscode/issues/174218#issuecomment-1437972127\n      var when = (_a = k.when) === null || _a === void 0 ? void 0 : _a.substituteConstants();\n      if (when && when.type === 0 /* ContextKeyExprType.False */) {\n        // when condition is false\n        continue;\n      }\n      this._addKeyPress(k.chords[0], k);\n    }\n  }\n  return _createClass(KeybindingResolver, [{\n    key: \"_addKeyPress\",\n    value: function _addKeyPress(keypress, item) {\n      var conflicts = this._map.get(keypress);\n      if (typeof conflicts === 'undefined') {\n        // There is no conflict so far\n        this._map.set(keypress, [item]);\n        this._addToLookupMap(item);\n        return;\n      }\n      for (var i = conflicts.length - 1; i >= 0; i--) {\n        var conflict = conflicts[i];\n        if (conflict.command === item.command) {\n          continue;\n        }\n        // Test if the shorter keybinding is a prefix of the longer one.\n        // If the shorter keybinding is a prefix, it effectively will shadow the longer one and is considered a conflict.\n        var isShorterKbPrefix = true;\n        for (var _i = 1; _i < conflict.chords.length && _i < item.chords.length; _i++) {\n          if (conflict.chords[_i] !== item.chords[_i]) {\n            // The ith step does not conflict\n            isShorterKbPrefix = false;\n            break;\n          }\n        }\n        if (!isShorterKbPrefix) {\n          continue;\n        }\n        if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n          // `item` completely overwrites `conflict`\n          // Remove conflict from the lookupMap\n          this._removeFromLookupMap(conflict);\n        }\n      }\n      conflicts.push(item);\n      this._addToLookupMap(item);\n    }\n  }, {\n    key: \"_addToLookupMap\",\n    value: function _addToLookupMap(item) {\n      if (!item.command) {\n        return;\n      }\n      var arr = this._lookupMap.get(item.command);\n      if (typeof arr === 'undefined') {\n        arr = [item];\n        this._lookupMap.set(item.command, arr);\n      } else {\n        arr.push(item);\n      }\n    }\n  }, {\n    key: \"_removeFromLookupMap\",\n    value: function _removeFromLookupMap(item) {\n      if (!item.command) {\n        return;\n      }\n      var arr = this._lookupMap.get(item.command);\n      if (typeof arr === 'undefined') {\n        return;\n      }\n      for (var i = 0, len = arr.length; i < len; i++) {\n        if (arr[i] === item) {\n          arr.splice(i, 1);\n          return;\n        }\n      }\n    }\n    /**\n     * Returns true if it is provable `a` implies `b`.\n     */\n  }, {\n    key: \"getKeybindings\",\n    value: function getKeybindings() {\n      return this._keybindings;\n    }\n  }, {\n    key: \"lookupPrimaryKeybinding\",\n    value: function lookupPrimaryKeybinding(commandId, context) {\n      var items = this._lookupMap.get(commandId);\n      if (typeof items === 'undefined' || items.length === 0) {\n        return null;\n      }\n      if (items.length === 1) {\n        return items[0];\n      }\n      for (var i = items.length - 1; i >= 0; i--) {\n        var item = items[i];\n        if (context.contextMatchesRules(item.when)) {\n          return item;\n        }\n      }\n      return items[items.length - 1];\n    }\n    /**\n     * Looks up a keybinding trigged as a result of pressing a sequence of chords - `[...currentChords, keypress]`\n     *\n     * Example: resolving 3 chords pressed sequentially - `cmd+k cmd+p cmd+i`:\n     * \t`currentChords = [ 'cmd+k' , 'cmd+p' ]` and `keypress = `cmd+i` - last pressed chord\n     */\n  }, {\n    key: \"resolve\",\n    value: function resolve(context, currentChords, keypress) {\n      var pressedChords = [].concat(_toConsumableArray(currentChords), [keypress]);\n      this._log(\"| Resolving \".concat(pressedChords));\n      var kbCandidates = this._map.get(pressedChords[0]);\n      if (kbCandidates === undefined) {\n        // No bindings with such 0-th chord\n        this._log(\"\\\\ No keybinding entries.\");\n        return NoMatchingKb;\n      }\n      var lookupMap = null;\n      if (pressedChords.length < 2) {\n        lookupMap = kbCandidates;\n      } else {\n        // Fetch all chord bindings for `currentChords`\n        lookupMap = [];\n        for (var i = 0, len = kbCandidates.length; i < len; i++) {\n          var candidate = kbCandidates[i];\n          if (pressedChords.length > candidate.chords.length) {\n            // # of pressed chords can't be less than # of chords in a keybinding to invoke\n            continue;\n          }\n          var prefixMatches = true;\n          for (var _i2 = 1; _i2 < pressedChords.length; _i2++) {\n            if (candidate.chords[_i2] !== pressedChords[_i2]) {\n              prefixMatches = false;\n              break;\n            }\n          }\n          if (prefixMatches) {\n            lookupMap.push(candidate);\n          }\n        }\n      }\n      // check there's a keybinding with a matching when clause\n      var result = this._findCommand(context, lookupMap);\n      if (!result) {\n        this._log(\"\\\\ From \".concat(lookupMap.length, \" keybinding entries, no when clauses matched the context.\"));\n        return NoMatchingKb;\n      }\n      // check we got all chords necessary to be sure a particular keybinding needs to be invoked\n      if (pressedChords.length < result.chords.length) {\n        // The chord sequence is not complete\n        this._log(\"\\\\ From \".concat(lookupMap.length, \" keybinding entries, awaiting \").concat(result.chords.length - pressedChords.length, \" more chord(s), when: \").concat(printWhenExplanation(result.when), \", source: \").concat(printSourceExplanation(result), \".\"));\n        return MoreChordsNeeded;\n      }\n      this._log(\"\\\\ From \".concat(lookupMap.length, \" keybinding entries, matched \").concat(result.command, \", when: \").concat(printWhenExplanation(result.when), \", source: \").concat(printSourceExplanation(result), \".\"));\n      return KbFound(result.command, result.commandArgs, result.bubble);\n    }\n  }, {\n    key: \"_findCommand\",\n    value: function _findCommand(context, matches) {\n      for (var i = matches.length - 1; i >= 0; i--) {\n        var k = matches[i];\n        if (!KeybindingResolver._contextMatchesRules(context, k.when)) {\n          continue;\n        }\n        return k;\n      }\n      return null;\n    }\n  }], [{\n    key: \"_isTargetedForRemoval\",\n    value: function _isTargetedForRemoval(defaultKb, keypress, when) {\n      if (keypress) {\n        for (var i = 0; i < keypress.length; i++) {\n          if (keypress[i] !== defaultKb.chords[i]) {\n            return false;\n          }\n        }\n      }\n      // `true` means always, as does `undefined`\n      // so we will treat `true` === `undefined`\n      if (when && when.type !== 1 /* ContextKeyExprType.True */) {\n        if (!defaultKb.when) {\n          return false;\n        }\n        if (!expressionsAreEqualWithConstantSubstitution(when, defaultKb.when)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    /**\n     * Looks for rules containing \"-commandId\" and removes them.\n     */\n  }, {\n    key: \"handleRemovals\",\n    value: function handleRemovals(rules) {\n      // Do a first pass and construct a hash-map for removals\n      var removals = new Map();\n      for (var i = 0, len = rules.length; i < len; i++) {\n        var rule = rules[i];\n        if (rule.command && rule.command.charAt(0) === '-') {\n          var command = rule.command.substring(1);\n          if (!removals.has(command)) {\n            removals.set(command, [rule]);\n          } else {\n            removals.get(command).push(rule);\n          }\n        }\n      }\n      if (removals.size === 0) {\n        // There are no removals\n        return rules;\n      }\n      // Do a second pass and keep only non-removed keybindings\n      var result = [];\n      for (var _i3 = 0, _len = rules.length; _i3 < _len; _i3++) {\n        var _rule = rules[_i3];\n        if (!_rule.command || _rule.command.length === 0) {\n          result.push(_rule);\n          continue;\n        }\n        if (_rule.command.charAt(0) === '-') {\n          continue;\n        }\n        var commandRemovals = removals.get(_rule.command);\n        if (!commandRemovals || !_rule.isDefault) {\n          result.push(_rule);\n          continue;\n        }\n        var isRemoved = false;\n        var _iterator2 = _createForOfIteratorHelper(commandRemovals),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var commandRemoval = _step2.value;\n            var when = commandRemoval.when;\n            if (this._isTargetedForRemoval(_rule, commandRemoval.chords, when)) {\n              isRemoved = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        if (!isRemoved) {\n          result.push(_rule);\n          continue;\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"whenIsEntirelyIncluded\",\n    value: function whenIsEntirelyIncluded(a, b) {\n      if (!b || b.type === 1 /* ContextKeyExprType.True */) {\n        return true;\n      }\n      if (!a || a.type === 1 /* ContextKeyExprType.True */) {\n        return false;\n      }\n      return implies(a, b);\n    }\n  }, {\n    key: \"_contextMatchesRules\",\n    value: function _contextMatchesRules(context, rules) {\n      if (!rules) {\n        return true;\n      }\n      return rules.evaluate(context);\n    }\n  }]);\n}();\nfunction printWhenExplanation(when) {\n  if (!when) {\n    return \"no when condition\";\n  }\n  return \"\".concat(when.serialize());\n}\nfunction printSourceExplanation(kb) {\n  return kb.extensionId ? kb.isBuiltinExtension ? \"built-in extension \".concat(kb.extensionId) : \"user extension \".concat(kb.extensionId) : kb.isDefault ? \"built-in\" : \"user\";\n}","map":{"version":3,"names":["implies","expressionsAreEqualWithConstantSubstitution","NoMatchingKb","kind","MoreChordsNeeded","KbFound","commandId","commandArgs","isBubble","KeybindingResolver","defaultKeybindings","overrides","log","_classCallCheck","_a","_log","_defaultKeybindings","_defaultBoundCommands","Map","_iterator","_createForOfIteratorHelper","_step","s","n","done","defaultKeybinding","value","command","charAt","set","err","e","f","_map","_lookupMap","_keybindings","handleRemovals","concat","i","len","length","k","chords","when","substituteConstants","type","_addKeyPress","_createClass","key","keypress","item","conflicts","get","_addToLookupMap","conflict","isShorterKbPrefix","whenIsEntirelyIncluded","_removeFromLookupMap","push","arr","splice","getKeybindings","lookupPrimaryKeybinding","context","items","contextMatchesRules","resolve","currentChords","pressedChords","_toConsumableArray","kbCandidates","undefined","lookupMap","candidate","prefixMatches","result","_findCommand","printWhenExplanation","printSourceExplanation","bubble","matches","_contextMatchesRules","_isTargetedForRemoval","defaultKb","rules","removals","rule","substring","has","size","commandRemovals","isDefault","isRemoved","_iterator2","_step2","commandRemoval","a","b","evaluate","serialize","kb","extensionId","isBuiltinExtension"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybindingResolver.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { implies, expressionsAreEqualWithConstantSubstitution } from '../../contextkey/common/contextkey.js';\n// util definitions to make working with the above types easier within this module:\nexport const NoMatchingKb = { kind: 0 /* ResultKind.NoMatchingKb */ };\nconst MoreChordsNeeded = { kind: 1 /* ResultKind.MoreChordsNeeded */ };\nfunction KbFound(commandId, commandArgs, isBubble) {\n    return { kind: 2 /* ResultKind.KbFound */, commandId, commandArgs, isBubble };\n}\n//#endregion\n/**\n * Stores mappings from keybindings to commands and from commands to keybindings.\n * Given a sequence of chords, `resolve`s which keybinding it matches\n */\nexport class KeybindingResolver {\n    constructor(\n    /** built-in and extension-provided keybindings */\n    defaultKeybindings, \n    /** user's keybindings */\n    overrides, log) {\n        var _a;\n        this._log = log;\n        this._defaultKeybindings = defaultKeybindings;\n        this._defaultBoundCommands = new Map();\n        for (const defaultKeybinding of defaultKeybindings) {\n            const command = defaultKeybinding.command;\n            if (command && command.charAt(0) !== '-') {\n                this._defaultBoundCommands.set(command, true);\n            }\n        }\n        this._map = new Map();\n        this._lookupMap = new Map();\n        this._keybindings = KeybindingResolver.handleRemovals([].concat(defaultKeybindings).concat(overrides));\n        for (let i = 0, len = this._keybindings.length; i < len; i++) {\n            const k = this._keybindings[i];\n            if (k.chords.length === 0) {\n                // unbound\n                continue;\n            }\n            // substitute with constants that are registered after startup - https://github.com/microsoft/vscode/issues/174218#issuecomment-1437972127\n            const when = (_a = k.when) === null || _a === void 0 ? void 0 : _a.substituteConstants();\n            if (when && when.type === 0 /* ContextKeyExprType.False */) {\n                // when condition is false\n                continue;\n            }\n            this._addKeyPress(k.chords[0], k);\n        }\n    }\n    static _isTargetedForRemoval(defaultKb, keypress, when) {\n        if (keypress) {\n            for (let i = 0; i < keypress.length; i++) {\n                if (keypress[i] !== defaultKb.chords[i]) {\n                    return false;\n                }\n            }\n        }\n        // `true` means always, as does `undefined`\n        // so we will treat `true` === `undefined`\n        if (when && when.type !== 1 /* ContextKeyExprType.True */) {\n            if (!defaultKb.when) {\n                return false;\n            }\n            if (!expressionsAreEqualWithConstantSubstitution(when, defaultKb.when)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Looks for rules containing \"-commandId\" and removes them.\n     */\n    static handleRemovals(rules) {\n        // Do a first pass and construct a hash-map for removals\n        const removals = new Map();\n        for (let i = 0, len = rules.length; i < len; i++) {\n            const rule = rules[i];\n            if (rule.command && rule.command.charAt(0) === '-') {\n                const command = rule.command.substring(1);\n                if (!removals.has(command)) {\n                    removals.set(command, [rule]);\n                }\n                else {\n                    removals.get(command).push(rule);\n                }\n            }\n        }\n        if (removals.size === 0) {\n            // There are no removals\n            return rules;\n        }\n        // Do a second pass and keep only non-removed keybindings\n        const result = [];\n        for (let i = 0, len = rules.length; i < len; i++) {\n            const rule = rules[i];\n            if (!rule.command || rule.command.length === 0) {\n                result.push(rule);\n                continue;\n            }\n            if (rule.command.charAt(0) === '-') {\n                continue;\n            }\n            const commandRemovals = removals.get(rule.command);\n            if (!commandRemovals || !rule.isDefault) {\n                result.push(rule);\n                continue;\n            }\n            let isRemoved = false;\n            for (const commandRemoval of commandRemovals) {\n                const when = commandRemoval.when;\n                if (this._isTargetedForRemoval(rule, commandRemoval.chords, when)) {\n                    isRemoved = true;\n                    break;\n                }\n            }\n            if (!isRemoved) {\n                result.push(rule);\n                continue;\n            }\n        }\n        return result;\n    }\n    _addKeyPress(keypress, item) {\n        const conflicts = this._map.get(keypress);\n        if (typeof conflicts === 'undefined') {\n            // There is no conflict so far\n            this._map.set(keypress, [item]);\n            this._addToLookupMap(item);\n            return;\n        }\n        for (let i = conflicts.length - 1; i >= 0; i--) {\n            const conflict = conflicts[i];\n            if (conflict.command === item.command) {\n                continue;\n            }\n            // Test if the shorter keybinding is a prefix of the longer one.\n            // If the shorter keybinding is a prefix, it effectively will shadow the longer one and is considered a conflict.\n            let isShorterKbPrefix = true;\n            for (let i = 1; i < conflict.chords.length && i < item.chords.length; i++) {\n                if (conflict.chords[i] !== item.chords[i]) {\n                    // The ith step does not conflict\n                    isShorterKbPrefix = false;\n                    break;\n                }\n            }\n            if (!isShorterKbPrefix) {\n                continue;\n            }\n            if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n                // `item` completely overwrites `conflict`\n                // Remove conflict from the lookupMap\n                this._removeFromLookupMap(conflict);\n            }\n        }\n        conflicts.push(item);\n        this._addToLookupMap(item);\n    }\n    _addToLookupMap(item) {\n        if (!item.command) {\n            return;\n        }\n        let arr = this._lookupMap.get(item.command);\n        if (typeof arr === 'undefined') {\n            arr = [item];\n            this._lookupMap.set(item.command, arr);\n        }\n        else {\n            arr.push(item);\n        }\n    }\n    _removeFromLookupMap(item) {\n        if (!item.command) {\n            return;\n        }\n        const arr = this._lookupMap.get(item.command);\n        if (typeof arr === 'undefined') {\n            return;\n        }\n        for (let i = 0, len = arr.length; i < len; i++) {\n            if (arr[i] === item) {\n                arr.splice(i, 1);\n                return;\n            }\n        }\n    }\n    /**\n     * Returns true if it is provable `a` implies `b`.\n     */\n    static whenIsEntirelyIncluded(a, b) {\n        if (!b || b.type === 1 /* ContextKeyExprType.True */) {\n            return true;\n        }\n        if (!a || a.type === 1 /* ContextKeyExprType.True */) {\n            return false;\n        }\n        return implies(a, b);\n    }\n    getKeybindings() {\n        return this._keybindings;\n    }\n    lookupPrimaryKeybinding(commandId, context) {\n        const items = this._lookupMap.get(commandId);\n        if (typeof items === 'undefined' || items.length === 0) {\n            return null;\n        }\n        if (items.length === 1) {\n            return items[0];\n        }\n        for (let i = items.length - 1; i >= 0; i--) {\n            const item = items[i];\n            if (context.contextMatchesRules(item.when)) {\n                return item;\n            }\n        }\n        return items[items.length - 1];\n    }\n    /**\n     * Looks up a keybinding trigged as a result of pressing a sequence of chords - `[...currentChords, keypress]`\n     *\n     * Example: resolving 3 chords pressed sequentially - `cmd+k cmd+p cmd+i`:\n     * \t`currentChords = [ 'cmd+k' , 'cmd+p' ]` and `keypress = `cmd+i` - last pressed chord\n     */\n    resolve(context, currentChords, keypress) {\n        const pressedChords = [...currentChords, keypress];\n        this._log(`| Resolving ${pressedChords}`);\n        const kbCandidates = this._map.get(pressedChords[0]);\n        if (kbCandidates === undefined) {\n            // No bindings with such 0-th chord\n            this._log(`\\\\ No keybinding entries.`);\n            return NoMatchingKb;\n        }\n        let lookupMap = null;\n        if (pressedChords.length < 2) {\n            lookupMap = kbCandidates;\n        }\n        else {\n            // Fetch all chord bindings for `currentChords`\n            lookupMap = [];\n            for (let i = 0, len = kbCandidates.length; i < len; i++) {\n                const candidate = kbCandidates[i];\n                if (pressedChords.length > candidate.chords.length) { // # of pressed chords can't be less than # of chords in a keybinding to invoke\n                    continue;\n                }\n                let prefixMatches = true;\n                for (let i = 1; i < pressedChords.length; i++) {\n                    if (candidate.chords[i] !== pressedChords[i]) {\n                        prefixMatches = false;\n                        break;\n                    }\n                }\n                if (prefixMatches) {\n                    lookupMap.push(candidate);\n                }\n            }\n        }\n        // check there's a keybinding with a matching when clause\n        const result = this._findCommand(context, lookupMap);\n        if (!result) {\n            this._log(`\\\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`);\n            return NoMatchingKb;\n        }\n        // check we got all chords necessary to be sure a particular keybinding needs to be invoked\n        if (pressedChords.length < result.chords.length) {\n            // The chord sequence is not complete\n            this._log(`\\\\ From ${lookupMap.length} keybinding entries, awaiting ${result.chords.length - pressedChords.length} more chord(s), when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n            return MoreChordsNeeded;\n        }\n        this._log(`\\\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\n        return KbFound(result.command, result.commandArgs, result.bubble);\n    }\n    _findCommand(context, matches) {\n        for (let i = matches.length - 1; i >= 0; i--) {\n            const k = matches[i];\n            if (!KeybindingResolver._contextMatchesRules(context, k.when)) {\n                continue;\n            }\n            return k;\n        }\n        return null;\n    }\n    static _contextMatchesRules(context, rules) {\n        if (!rules) {\n            return true;\n        }\n        return rules.evaluate(context);\n    }\n}\nfunction printWhenExplanation(when) {\n    if (!when) {\n        return `no when condition`;\n    }\n    return `${when.serialize()}`;\n}\nfunction printSourceExplanation(kb) {\n    return (kb.extensionId\n        ? (kb.isBuiltinExtension ? `built-in extension ${kb.extensionId}` : `user extension ${kb.extensionId}`)\n        : (kb.isDefault ? `built-in` : `user`));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}