{"ast":null,"code":"import _slicedToArray from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _callSuper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _get from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _typeof from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.date.now.js\";\nimport \"core-js/modules/es.date.to-json.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.reflect.to-string-tag.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.substr.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nimport * as browser from '../../../base/browser/browser.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { DomEmitter } from '../../../base/browser/event.js';\nimport { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';\nimport { inputLatency } from '../../../base/browser/performance.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { TextAreaState, _debugComposition } from './textAreaState.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { IAccessibilityService } from '../../../platform/accessibility/common/accessibility.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nexport var TextAreaSyntethicEvents;\n(function (TextAreaSyntethicEvents) {\n  TextAreaSyntethicEvents.Tap = '-monaco-textarea-synthetic-tap';\n})(TextAreaSyntethicEvents || (TextAreaSyntethicEvents = {}));\nexport var CopyOptions = {\n  forceCopyWithSyntaxHighlighting: false\n};\n/**\n * Every time we write to the clipboard, we record a bit of extra metadata here.\n * Every time we read from the cipboard, if the text matches our last written text,\n * we can fetch the previous metadata.\n */\nexport var InMemoryClipboardMetadataManager = /*#__PURE__*/function () {\n  function InMemoryClipboardMetadataManager() {\n    _classCallCheck(this, InMemoryClipboardMetadataManager);\n    this._lastState = null;\n  }\n  return _createClass(InMemoryClipboardMetadataManager, [{\n    key: \"set\",\n    value: function set(lastCopiedValue, data) {\n      this._lastState = {\n        lastCopiedValue: lastCopiedValue,\n        data: data\n      };\n    }\n  }, {\n    key: \"get\",\n    value: function get(pastedText) {\n      if (this._lastState && this._lastState.lastCopiedValue === pastedText) {\n        // match!\n        return this._lastState.data;\n      }\n      this._lastState = null;\n      return null;\n    }\n  }]);\n}();\nInMemoryClipboardMetadataManager.INSTANCE = new InMemoryClipboardMetadataManager();\nvar CompositionContext = /*#__PURE__*/function () {\n  function CompositionContext() {\n    _classCallCheck(this, CompositionContext);\n    this._lastTypeTextLength = 0;\n  }\n  return _createClass(CompositionContext, [{\n    key: \"handleCompositionUpdate\",\n    value: function handleCompositionUpdate(text) {\n      text = text || '';\n      var typeInput = {\n        text: text,\n        replacePrevCharCnt: this._lastTypeTextLength,\n        replaceNextCharCnt: 0,\n        positionDelta: 0\n      };\n      this._lastTypeTextLength = text.length;\n      return typeInput;\n    }\n  }]);\n}();\n/**\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\n *  - onCut\n *  - onPaste\n *  - onType\n *\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\n */\nvar TextAreaInput = /*#__PURE__*/function (_Disposable) {\n  function TextAreaInput(_host, _textArea, _OS, _browser, _accessibilityService, _logService) {\n    var _this;\n    _classCallCheck(this, TextAreaInput);\n    _this = _callSuper(this, TextAreaInput);\n    _this._host = _host;\n    _this._textArea = _textArea;\n    _this._OS = _OS;\n    _this._browser = _browser;\n    _this._accessibilityService = _accessibilityService;\n    _this._logService = _logService;\n    _this._onFocus = _this._register(new Emitter());\n    _this.onFocus = _this._onFocus.event;\n    _this._onBlur = _this._register(new Emitter());\n    _this.onBlur = _this._onBlur.event;\n    _this._onKeyDown = _this._register(new Emitter());\n    _this.onKeyDown = _this._onKeyDown.event;\n    _this._onKeyUp = _this._register(new Emitter());\n    _this.onKeyUp = _this._onKeyUp.event;\n    _this._onCut = _this._register(new Emitter());\n    _this.onCut = _this._onCut.event;\n    _this._onPaste = _this._register(new Emitter());\n    _this.onPaste = _this._onPaste.event;\n    _this._onType = _this._register(new Emitter());\n    _this.onType = _this._onType.event;\n    _this._onCompositionStart = _this._register(new Emitter());\n    _this.onCompositionStart = _this._onCompositionStart.event;\n    _this._onCompositionUpdate = _this._register(new Emitter());\n    _this.onCompositionUpdate = _this._onCompositionUpdate.event;\n    _this._onCompositionEnd = _this._register(new Emitter());\n    _this.onCompositionEnd = _this._onCompositionEnd.event;\n    _this._onSelectionChangeRequest = _this._register(new Emitter());\n    _this.onSelectionChangeRequest = _this._onSelectionChangeRequest.event;\n    _this._asyncFocusGainWriteScreenReaderContent = _this._register(new MutableDisposable());\n    _this._asyncTriggerCut = _this._register(new RunOnceScheduler(function () {\n      return _this._onCut.fire();\n    }, 0));\n    _this._textAreaState = TextAreaState.EMPTY;\n    _this._selectionChangeListener = null;\n    if (_this._accessibilityService.isScreenReaderOptimized()) {\n      _this.writeNativeTextAreaContent('ctor');\n    }\n    _this._register(Event.runAndSubscribe(_this._accessibilityService.onDidChangeScreenReaderOptimized, function () {\n      if (_this._accessibilityService.isScreenReaderOptimized() && !_this._asyncFocusGainWriteScreenReaderContent.value) {\n        _this._asyncFocusGainWriteScreenReaderContent.value = _this._register(new RunOnceScheduler(function () {\n          return _this.writeNativeTextAreaContent('asyncFocusGain');\n        }, 0));\n      } else {\n        _this._asyncFocusGainWriteScreenReaderContent.clear();\n      }\n    }));\n    _this._hasFocus = false;\n    _this._currentComposition = null;\n    var lastKeyDown = null;\n    _this._register(_this._textArea.onKeyDown(function (_e) {\n      var e = new StandardKeyboardEvent(_e);\n      if (e.keyCode === 114 /* KeyCode.KEY_IN_COMPOSITION */ || _this._currentComposition && e.keyCode === 1 /* KeyCode.Backspace */) {\n        // Stop propagation for keyDown events if the IME is processing key input\n        e.stopPropagation();\n      }\n      if (e.equals(9 /* KeyCode.Escape */)) {\n        // Prevent default always for `Esc`, otherwise it will generate a keypress\n        // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\n        e.preventDefault();\n      }\n      lastKeyDown = e;\n      _this._onKeyDown.fire(e);\n    }));\n    _this._register(_this._textArea.onKeyUp(function (_e) {\n      var e = new StandardKeyboardEvent(_e);\n      _this._onKeyUp.fire(e);\n    }));\n    _this._register(_this._textArea.onCompositionStart(function (e) {\n      if (_debugComposition) {\n        console.log(\"[compositionstart]\", e);\n      }\n      var currentComposition = new CompositionContext();\n      if (_this._currentComposition) {\n        // simply reset the composition context\n        _this._currentComposition = currentComposition;\n        return;\n      }\n      _this._currentComposition = currentComposition;\n      if (_this._OS === 2 /* OperatingSystem.Macintosh */ && lastKeyDown && lastKeyDown.equals(114 /* KeyCode.KEY_IN_COMPOSITION */) && _this._textAreaState.selectionStart === _this._textAreaState.selectionEnd && _this._textAreaState.selectionStart > 0 && _this._textAreaState.value.substr(_this._textAreaState.selectionStart - 1, 1) === e.data && (lastKeyDown.code === 'ArrowRight' || lastKeyDown.code === 'ArrowLeft')) {\n        // Handling long press case on Chromium/Safari macOS + arrow key => pretend the character was selected\n        if (_debugComposition) {\n          console.log(\"[compositionstart] Handling long press case on macOS + arrow key\", e);\n        }\n        // Pretend the previous character was composed (in order to get it removed by subsequent compositionupdate events)\n        currentComposition.handleCompositionUpdate('x');\n        _this._onCompositionStart.fire({\n          data: e.data\n        });\n        return;\n      }\n      if (_this._browser.isAndroid) {\n        // when tapping on the editor, Android enters composition mode to edit the current word\n        // so we cannot clear the textarea on Android and we must pretend the current word was selected\n        _this._onCompositionStart.fire({\n          data: e.data\n        });\n        return;\n      }\n      _this._onCompositionStart.fire({\n        data: e.data\n      });\n    }));\n    _this._register(_this._textArea.onCompositionUpdate(function (e) {\n      if (_debugComposition) {\n        console.log(\"[compositionupdate]\", e);\n      }\n      var currentComposition = _this._currentComposition;\n      if (!currentComposition) {\n        // should not be possible to receive a 'compositionupdate' without a 'compositionstart'\n        return;\n      }\n      if (_this._browser.isAndroid) {\n        // On Android, the data sent with the composition update event is unusable.\n        // For example, if the cursor is in the middle of a word like Mic|osoft\n        // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n        // This is not really usable because it doesn't tell us where the edit began and where it ended.\n        var newState = TextAreaState.readFromTextArea(_this._textArea, _this._textAreaState);\n        var _typeInput = TextAreaState.deduceAndroidCompositionInput(_this._textAreaState, newState);\n        _this._textAreaState = newState;\n        _this._onType.fire(_typeInput);\n        _this._onCompositionUpdate.fire(e);\n        return;\n      }\n      var typeInput = currentComposition.handleCompositionUpdate(e.data);\n      _this._textAreaState = TextAreaState.readFromTextArea(_this._textArea, _this._textAreaState);\n      _this._onType.fire(typeInput);\n      _this._onCompositionUpdate.fire(e);\n    }));\n    _this._register(_this._textArea.onCompositionEnd(function (e) {\n      if (_debugComposition) {\n        console.log(\"[compositionend]\", e);\n      }\n      var currentComposition = _this._currentComposition;\n      if (!currentComposition) {\n        // https://github.com/microsoft/monaco-editor/issues/1663\n        // On iOS 13.2, Chinese system IME randomly trigger an additional compositionend event with empty data\n        return;\n      }\n      _this._currentComposition = null;\n      if (_this._browser.isAndroid) {\n        // On Android, the data sent with the composition update event is unusable.\n        // For example, if the cursor is in the middle of a word like Mic|osoft\n        // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n        // This is not really usable because it doesn't tell us where the edit began and where it ended.\n        var newState = TextAreaState.readFromTextArea(_this._textArea, _this._textAreaState);\n        var _typeInput2 = TextAreaState.deduceAndroidCompositionInput(_this._textAreaState, newState);\n        _this._textAreaState = newState;\n        _this._onType.fire(_typeInput2);\n        _this._onCompositionEnd.fire();\n        return;\n      }\n      var typeInput = currentComposition.handleCompositionUpdate(e.data);\n      _this._textAreaState = TextAreaState.readFromTextArea(_this._textArea, _this._textAreaState);\n      _this._onType.fire(typeInput);\n      _this._onCompositionEnd.fire();\n    }));\n    _this._register(_this._textArea.onInput(function (e) {\n      if (_debugComposition) {\n        console.log(\"[input]\", e);\n      }\n      // Pretend here we touched the text area, as the `input` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      _this._textArea.setIgnoreSelectionChangeTime('received input event');\n      if (_this._currentComposition) {\n        return;\n      }\n      var newState = TextAreaState.readFromTextArea(_this._textArea, _this._textAreaState);\n      var typeInput = TextAreaState.deduceInput(_this._textAreaState, newState, /*couldBeEmojiInput*/_this._OS === 2 /* OperatingSystem.Macintosh */);\n      if (typeInput.replacePrevCharCnt === 0 && typeInput.text.length === 1) {\n        // one character was typed\n        if (strings.isHighSurrogate(typeInput.text.charCodeAt(0)) || typeInput.text.charCodeAt(0) === 0x7f /* Delete */) {\n          // Ignore invalid input but keep it around for next time\n          return;\n        }\n      }\n      _this._textAreaState = newState;\n      if (typeInput.text !== '' || typeInput.replacePrevCharCnt !== 0 || typeInput.replaceNextCharCnt !== 0 || typeInput.positionDelta !== 0) {\n        _this._onType.fire(typeInput);\n      }\n    }));\n    // --- Clipboard operations\n    _this._register(_this._textArea.onCut(function (e) {\n      // Pretend here we touched the text area, as the `cut` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      _this._textArea.setIgnoreSelectionChangeTime('received cut event');\n      _this._ensureClipboardGetsEditorSelection(e);\n      _this._asyncTriggerCut.schedule();\n    }));\n    _this._register(_this._textArea.onCopy(function (e) {\n      _this._ensureClipboardGetsEditorSelection(e);\n    }));\n    _this._register(_this._textArea.onPaste(function (e) {\n      // Pretend here we touched the text area, as the `paste` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      _this._textArea.setIgnoreSelectionChangeTime('received paste event');\n      e.preventDefault();\n      if (!e.clipboardData) {\n        return;\n      }\n      var _ClipboardEventUtils$ = ClipboardEventUtils.getTextData(e.clipboardData),\n        _ClipboardEventUtils$2 = _slicedToArray(_ClipboardEventUtils$, 2),\n        text = _ClipboardEventUtils$2[0],\n        metadata = _ClipboardEventUtils$2[1];\n      if (!text) {\n        return;\n      }\n      // try the in-memory store\n      metadata = metadata || InMemoryClipboardMetadataManager.INSTANCE.get(text);\n      _this._onPaste.fire({\n        text: text,\n        metadata: metadata\n      });\n    }));\n    _this._register(_this._textArea.onFocus(function () {\n      var hadFocus = _this._hasFocus;\n      _this._setHasFocus(true);\n      if (_this._accessibilityService.isScreenReaderOptimized() && _this._browser.isSafari && !hadFocus && _this._hasFocus) {\n        // When \"tabbing into\" the textarea, immediately after dispatching the 'focus' event,\n        // Safari will always move the selection at offset 0 in the textarea\n        if (!_this._asyncFocusGainWriteScreenReaderContent.value) {\n          _this._asyncFocusGainWriteScreenReaderContent.value = new RunOnceScheduler(function () {\n            return _this.writeNativeTextAreaContent('asyncFocusGain');\n          }, 0);\n        }\n        _this._asyncFocusGainWriteScreenReaderContent.value.schedule();\n      }\n    }));\n    _this._register(_this._textArea.onBlur(function () {\n      if (_this._currentComposition) {\n        // See https://github.com/microsoft/vscode/issues/112621\n        // where compositionend is not triggered when the editor\n        // is taken off-dom during a composition\n        // Clear the flag to be able to write to the textarea\n        _this._currentComposition = null;\n        // Clear the textarea to avoid an unwanted cursor type\n        _this.writeNativeTextAreaContent('blurWithoutCompositionEnd');\n        // Fire artificial composition end\n        _this._onCompositionEnd.fire();\n      }\n      _this._setHasFocus(false);\n    }));\n    _this._register(_this._textArea.onSyntheticTap(function () {\n      if (_this._browser.isAndroid && _this._currentComposition) {\n        // on Android, tapping does not cancel the current composition, so the\n        // textarea is stuck showing the old composition\n        // Clear the flag to be able to write to the textarea\n        _this._currentComposition = null;\n        // Clear the textarea to avoid an unwanted cursor type\n        _this.writeNativeTextAreaContent('tapWithoutCompositionEnd');\n        // Fire artificial composition end\n        _this._onCompositionEnd.fire();\n      }\n    }));\n    return _this;\n  }\n  _inherits(TextAreaInput, _Disposable);\n  return _createClass(TextAreaInput, [{\n    key: \"textAreaState\",\n    get: function get() {\n      return this._textAreaState;\n    }\n  }, {\n    key: \"_installSelectionChangeListener\",\n    value: function _installSelectionChangeListener() {\n      var _this2 = this;\n      // See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256\n      // When using a Braille display, it is possible for users to reposition the\n      // system caret. This is reflected in Chrome as a `selectionchange` event.\n      //\n      // The `selectionchange` event appears to be emitted under numerous other circumstances,\n      // so it is quite a challenge to distinguish a `selectionchange` coming in from a user\n      // using a Braille display from all the other cases.\n      //\n      // The problems with the `selectionchange` event are:\n      //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\n      //  * the event is emitted when the selection is changed in the textarea programmatically -- textarea.setSelectionRange(...)\n      //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\n      //  * the event is emitted when tabbing into the textarea\n      //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\n      //  * the event sometimes comes in bursts for a single logical textarea operation\n      // `selectionchange` events often come multiple times for a single logical change\n      // so throttle multiple `selectionchange` events that burst in a short period of time.\n      var previousSelectionChangeEventTime = 0;\n      return dom.addDisposableListener(this._textArea.ownerDocument, 'selectionchange', function (e) {\n        inputLatency.onSelectionChange();\n        if (!_this2._hasFocus) {\n          return;\n        }\n        if (_this2._currentComposition) {\n          return;\n        }\n        if (!_this2._browser.isChrome) {\n          // Support only for Chrome until testing happens on other browsers\n          return;\n        }\n        var now = Date.now();\n        var delta1 = now - previousSelectionChangeEventTime;\n        previousSelectionChangeEventTime = now;\n        if (delta1 < 5) {\n          // received another `selectionchange` event within 5ms of the previous `selectionchange` event\n          // => ignore it\n          return;\n        }\n        var delta2 = now - _this2._textArea.getIgnoreSelectionChangeTime();\n        _this2._textArea.resetSelectionChangeTime();\n        if (delta2 < 100) {\n          // received a `selectionchange` event within 100ms since we touched the textarea\n          // => ignore it, since we caused it\n          return;\n        }\n        if (!_this2._textAreaState.selection) {\n          // Cannot correlate a position in the textarea with a position in the editor...\n          return;\n        }\n        var newValue = _this2._textArea.getValue();\n        if (_this2._textAreaState.value !== newValue) {\n          // Cannot correlate a position in the textarea with a position in the editor...\n          return;\n        }\n        var newSelectionStart = _this2._textArea.getSelectionStart();\n        var newSelectionEnd = _this2._textArea.getSelectionEnd();\n        if (_this2._textAreaState.selectionStart === newSelectionStart && _this2._textAreaState.selectionEnd === newSelectionEnd) {\n          // Nothing to do...\n          return;\n        }\n        var _newSelectionStartPosition = _this2._textAreaState.deduceEditorPosition(newSelectionStart);\n        var newSelectionStartPosition = _this2._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\n        var _newSelectionEndPosition = _this2._textAreaState.deduceEditorPosition(newSelectionEnd);\n        var newSelectionEndPosition = _this2._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\n        var newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);\n        _this2._onSelectionChangeRequest.fire(newSelection);\n      });\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(TextAreaInput.prototype), \"dispose\", this).call(this);\n      if (this._selectionChangeListener) {\n        this._selectionChangeListener.dispose();\n        this._selectionChangeListener = null;\n      }\n    }\n  }, {\n    key: \"focusTextArea\",\n    value: function focusTextArea() {\n      // Setting this._hasFocus and writing the screen reader content\n      // will result in a focus() and setSelectionRange() in the textarea\n      this._setHasFocus(true);\n      // If the editor is off DOM, focus cannot be really set, so let's double check that we have managed to set the focus\n      this.refreshFocusState();\n    }\n  }, {\n    key: \"isFocused\",\n    value: function isFocused() {\n      return this._hasFocus;\n    }\n  }, {\n    key: \"refreshFocusState\",\n    value: function refreshFocusState() {\n      this._setHasFocus(this._textArea.hasFocus());\n    }\n  }, {\n    key: \"_setHasFocus\",\n    value: function _setHasFocus(newHasFocus) {\n      if (this._hasFocus === newHasFocus) {\n        // no change\n        return;\n      }\n      this._hasFocus = newHasFocus;\n      if (this._selectionChangeListener) {\n        this._selectionChangeListener.dispose();\n        this._selectionChangeListener = null;\n      }\n      if (this._hasFocus) {\n        this._selectionChangeListener = this._installSelectionChangeListener();\n      }\n      if (this._hasFocus) {\n        this.writeNativeTextAreaContent('focusgain');\n      }\n      if (this._hasFocus) {\n        this._onFocus.fire();\n      } else {\n        this._onBlur.fire();\n      }\n    }\n  }, {\n    key: \"_setAndWriteTextAreaState\",\n    value: function _setAndWriteTextAreaState(reason, textAreaState) {\n      if (!this._hasFocus) {\n        textAreaState = textAreaState.collapseSelection();\n      }\n      textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\n      this._textAreaState = textAreaState;\n    }\n  }, {\n    key: \"writeNativeTextAreaContent\",\n    value: function writeNativeTextAreaContent(reason) {\n      if (!this._accessibilityService.isScreenReaderOptimized() && reason === 'render' || this._currentComposition) {\n        // Do not write to the text on render unless a screen reader is being used #192278\n        // Do not write to the text area when doing composition\n        return;\n      }\n      this._logService.trace(\"writeTextAreaState(reason: \".concat(reason, \")\"));\n      this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent());\n    }\n  }, {\n    key: \"_ensureClipboardGetsEditorSelection\",\n    value: function _ensureClipboardGetsEditorSelection(e) {\n      var dataToCopy = this._host.getDataToCopy();\n      var storedMetadata = {\n        version: 1,\n        isFromEmptySelection: dataToCopy.isFromEmptySelection,\n        multicursorText: dataToCopy.multicursorText,\n        mode: dataToCopy.mode\n      };\n      InMemoryClipboardMetadataManager.INSTANCE.set(\n      // When writing \"LINE\\r\\n\" to the clipboard and then pasting,\n      // Firefox pastes \"LINE\\n\", so let's work around this quirk\n      this._browser.isFirefox ? dataToCopy.text.replace(/\\r\\n/g, '\\n') : dataToCopy.text, storedMetadata);\n      e.preventDefault();\n      if (e.clipboardData) {\n        ClipboardEventUtils.setTextData(e.clipboardData, dataToCopy.text, dataToCopy.html, storedMetadata);\n      }\n    }\n  }]);\n}(Disposable);\nTextAreaInput = __decorate([__param(4, IAccessibilityService), __param(5, ILogService)], TextAreaInput);\nexport { TextAreaInput };\nexport var ClipboardEventUtils = {\n  getTextData: function getTextData(clipboardData) {\n    var text = clipboardData.getData(Mimes.text);\n    var metadata = null;\n    var rawmetadata = clipboardData.getData('vscode-editor-data');\n    if (typeof rawmetadata === 'string') {\n      try {\n        metadata = JSON.parse(rawmetadata);\n        if (metadata.version !== 1) {\n          metadata = null;\n        }\n      } catch (err) {\n        // no problem!\n      }\n    }\n    if (text.length === 0 && metadata === null && clipboardData.files.length > 0) {\n      // no textual data pasted, generate text from file names\n      var files = Array.prototype.slice.call(clipboardData.files, 0);\n      return [files.map(function (file) {\n        return file.name;\n      }).join('\\n'), null];\n    }\n    return [text, metadata];\n  },\n  setTextData: function setTextData(clipboardData, text, html, metadata) {\n    clipboardData.setData(Mimes.text, text);\n    if (typeof html === 'string') {\n      clipboardData.setData('text/html', html);\n    }\n    clipboardData.setData('vscode-editor-data', JSON.stringify(metadata));\n  }\n};\nexport var TextAreaWrapper = /*#__PURE__*/function (_Disposable2) {\n  function TextAreaWrapper(_actual) {\n    var _this3;\n    _classCallCheck(this, TextAreaWrapper);\n    _this3 = _callSuper(this, TextAreaWrapper);\n    _this3._actual = _actual;\n    _this3.onKeyDown = _this3._register(new DomEmitter(_this3._actual, 'keydown')).event;\n    _this3.onKeyUp = _this3._register(new DomEmitter(_this3._actual, 'keyup')).event;\n    _this3.onCompositionStart = _this3._register(new DomEmitter(_this3._actual, 'compositionstart')).event;\n    _this3.onCompositionUpdate = _this3._register(new DomEmitter(_this3._actual, 'compositionupdate')).event;\n    _this3.onCompositionEnd = _this3._register(new DomEmitter(_this3._actual, 'compositionend')).event;\n    _this3.onBeforeInput = _this3._register(new DomEmitter(_this3._actual, 'beforeinput')).event;\n    _this3.onInput = _this3._register(new DomEmitter(_this3._actual, 'input')).event;\n    _this3.onCut = _this3._register(new DomEmitter(_this3._actual, 'cut')).event;\n    _this3.onCopy = _this3._register(new DomEmitter(_this3._actual, 'copy')).event;\n    _this3.onPaste = _this3._register(new DomEmitter(_this3._actual, 'paste')).event;\n    _this3.onFocus = _this3._register(new DomEmitter(_this3._actual, 'focus')).event;\n    _this3.onBlur = _this3._register(new DomEmitter(_this3._actual, 'blur')).event;\n    _this3._onSyntheticTap = _this3._register(new Emitter());\n    _this3.onSyntheticTap = _this3._onSyntheticTap.event;\n    _this3._ignoreSelectionChangeTime = 0;\n    _this3._register(_this3.onKeyDown(function () {\n      return inputLatency.onKeyDown();\n    }));\n    _this3._register(_this3.onBeforeInput(function () {\n      return inputLatency.onBeforeInput();\n    }));\n    _this3._register(_this3.onInput(function () {\n      return inputLatency.onInput();\n    }));\n    _this3._register(_this3.onKeyUp(function () {\n      return inputLatency.onKeyUp();\n    }));\n    _this3._register(dom.addDisposableListener(_this3._actual, TextAreaSyntethicEvents.Tap, function () {\n      return _this3._onSyntheticTap.fire();\n    }));\n    return _this3;\n  }\n  _inherits(TextAreaWrapper, _Disposable2);\n  return _createClass(TextAreaWrapper, [{\n    key: \"ownerDocument\",\n    get: function get() {\n      return this._actual.ownerDocument;\n    }\n  }, {\n    key: \"hasFocus\",\n    value: function hasFocus() {\n      var shadowRoot = dom.getShadowRoot(this._actual);\n      if (shadowRoot) {\n        return shadowRoot.activeElement === this._actual;\n      } else if (this._actual.isConnected) {\n        return dom.getActiveElement() === this._actual;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"setIgnoreSelectionChangeTime\",\n    value: function setIgnoreSelectionChangeTime(reason) {\n      this._ignoreSelectionChangeTime = Date.now();\n    }\n  }, {\n    key: \"getIgnoreSelectionChangeTime\",\n    value: function getIgnoreSelectionChangeTime() {\n      return this._ignoreSelectionChangeTime;\n    }\n  }, {\n    key: \"resetSelectionChangeTime\",\n    value: function resetSelectionChangeTime() {\n      this._ignoreSelectionChangeTime = 0;\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      // console.log('current value: ' + this._textArea.value);\n      return this._actual.value;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(reason, value) {\n      var textArea = this._actual;\n      if (textArea.value === value) {\n        // No change\n        return;\n      }\n      // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\n      this.setIgnoreSelectionChangeTime('setValue');\n      textArea.value = value;\n    }\n  }, {\n    key: \"getSelectionStart\",\n    value: function getSelectionStart() {\n      return this._actual.selectionDirection === 'backward' ? this._actual.selectionEnd : this._actual.selectionStart;\n    }\n  }, {\n    key: \"getSelectionEnd\",\n    value: function getSelectionEnd() {\n      return this._actual.selectionDirection === 'backward' ? this._actual.selectionStart : this._actual.selectionEnd;\n    }\n  }, {\n    key: \"setSelectionRange\",\n    value: function setSelectionRange(reason, selectionStart, selectionEnd) {\n      var textArea = this._actual;\n      var activeElement = null;\n      var shadowRoot = dom.getShadowRoot(textArea);\n      if (shadowRoot) {\n        activeElement = shadowRoot.activeElement;\n      } else {\n        activeElement = dom.getActiveElement();\n      }\n      var activeWindow = dom.getWindow(activeElement);\n      var currentIsFocused = activeElement === textArea;\n      var currentSelectionStart = textArea.selectionStart;\n      var currentSelectionEnd = textArea.selectionEnd;\n      if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\n        // No change\n        // Firefox iframe bug https://github.com/microsoft/monaco-editor/issues/643#issuecomment-367871377\n        if (browser.isFirefox && activeWindow.parent !== activeWindow) {\n          textArea.focus();\n        }\n        return;\n      }\n      // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\n      if (currentIsFocused) {\n        // No need to focus, only need to change the selection range\n        this.setIgnoreSelectionChangeTime('setSelectionRange');\n        textArea.setSelectionRange(selectionStart, selectionEnd);\n        if (browser.isFirefox && activeWindow.parent !== activeWindow) {\n          textArea.focus();\n        }\n        return;\n      }\n      // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\n      // Here, we try to undo the browser's desperate reveal.\n      try {\n        var scrollState = dom.saveParentsScrollTop(textArea);\n        this.setIgnoreSelectionChangeTime('setSelectionRange');\n        textArea.focus();\n        textArea.setSelectionRange(selectionStart, selectionEnd);\n        dom.restoreParentsScrollTop(textArea, scrollState);\n      } catch (e) {\n        // Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\n      }\n    }\n  }]);\n}(Disposable);","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","_typeof","decorate","i","defineProperty","__param","paramIndex","decorator","browser","dom","DomEmitter","StandardKeyboardEvent","inputLatency","RunOnceScheduler","Emitter","Event","Disposable","MutableDisposable","Mimes","strings","TextAreaState","_debugComposition","Selection","IAccessibilityService","ILogService","TextAreaSyntethicEvents","Tap","CopyOptions","forceCopyWithSyntaxHighlighting","InMemoryClipboardMetadataManager","_classCallCheck","_lastState","_createClass","value","set","lastCopiedValue","data","get","pastedText","INSTANCE","CompositionContext","_lastTypeTextLength","handleCompositionUpdate","text","typeInput","replacePrevCharCnt","replaceNextCharCnt","positionDelta","TextAreaInput","_Disposable","_host","_textArea","_OS","_browser","_accessibilityService","_logService","_this","_callSuper","_onFocus","_register","onFocus","event","_onBlur","onBlur","_onKeyDown","onKeyDown","_onKeyUp","onKeyUp","_onCut","onCut","_onPaste","onPaste","_onType","onType","_onCompositionStart","onCompositionStart","_onCompositionUpdate","onCompositionUpdate","_onCompositionEnd","onCompositionEnd","_onSelectionChangeRequest","onSelectionChangeRequest","_asyncFocusGainWriteScreenReaderContent","_asyncTriggerCut","fire","_textAreaState","EMPTY","_selectionChangeListener","isScreenReaderOptimized","writeNativeTextAreaContent","runAndSubscribe","onDidChangeScreenReaderOptimized","clear","_hasFocus","_currentComposition","lastKeyDown","_e","e","keyCode","stopPropagation","equals","preventDefault","console","log","currentComposition","selectionStart","selectionEnd","substr","code","isAndroid","newState","readFromTextArea","deduceAndroidCompositionInput","onInput","setIgnoreSelectionChangeTime","deduceInput","isHighSurrogate","charCodeAt","_ensureClipboardGetsEditorSelection","schedule","onCopy","clipboardData","_ClipboardEventUtils$","ClipboardEventUtils","getTextData","_ClipboardEventUtils$2","_slicedToArray","metadata","hadFocus","_setHasFocus","isSafari","onSyntheticTap","_inherits","_installSelectionChangeListener","_this2","previousSelectionChangeEventTime","addDisposableListener","ownerDocument","onSelectionChange","isChrome","now","Date","delta1","delta2","getIgnoreSelectionChangeTime","resetSelectionChangeTime","selection","newValue","getValue","newSelectionStart","getSelectionStart","newSelectionEnd","getSelectionEnd","_newSelectionStartPosition","deduceEditorPosition","newSelectionStartPosition","deduceModelPosition","_newSelectionEndPosition","newSelectionEndPosition","newSelection","lineNumber","column","dispose","_get","_getPrototypeOf","prototype","call","focusTextArea","refreshFocusState","isFocused","hasFocus","newHasFocus","_setAndWriteTextAreaState","reason","textAreaState","collapseSelection","writeToTextArea","trace","concat","getScreenReaderContent","dataToCopy","getDataToCopy","storedMetadata","version","isFromEmptySelection","multicursorText","mode","isFirefox","replace","setTextData","html","getData","rawmetadata","JSON","parse","err","files","Array","slice","map","file","name","join","setData","stringify","TextAreaWrapper","_Disposable2","_actual","_this3","onBeforeInput","_onSyntheticTap","_ignoreSelectionChangeTime","shadowRoot","getShadowRoot","activeElement","isConnected","getActiveElement","setValue","textArea","selectionDirection","setSelectionRange","activeWindow","getWindow","currentIsFocused","currentSelectionStart","currentSelectionEnd","parent","focus","scrollState","saveParentsScrollTop","restoreParentsScrollTop"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaInput.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport * as browser from '../../../base/browser/browser.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { DomEmitter } from '../../../base/browser/event.js';\nimport { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';\nimport { inputLatency } from '../../../base/browser/performance.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { TextAreaState, _debugComposition } from './textAreaState.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { IAccessibilityService } from '../../../platform/accessibility/common/accessibility.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nexport var TextAreaSyntethicEvents;\n(function (TextAreaSyntethicEvents) {\n    TextAreaSyntethicEvents.Tap = '-monaco-textarea-synthetic-tap';\n})(TextAreaSyntethicEvents || (TextAreaSyntethicEvents = {}));\nexport const CopyOptions = {\n    forceCopyWithSyntaxHighlighting: false\n};\n/**\n * Every time we write to the clipboard, we record a bit of extra metadata here.\n * Every time we read from the cipboard, if the text matches our last written text,\n * we can fetch the previous metadata.\n */\nexport class InMemoryClipboardMetadataManager {\n    constructor() {\n        this._lastState = null;\n    }\n    set(lastCopiedValue, data) {\n        this._lastState = { lastCopiedValue, data };\n    }\n    get(pastedText) {\n        if (this._lastState && this._lastState.lastCopiedValue === pastedText) {\n            // match!\n            return this._lastState.data;\n        }\n        this._lastState = null;\n        return null;\n    }\n}\nInMemoryClipboardMetadataManager.INSTANCE = new InMemoryClipboardMetadataManager();\nclass CompositionContext {\n    constructor() {\n        this._lastTypeTextLength = 0;\n    }\n    handleCompositionUpdate(text) {\n        text = text || '';\n        const typeInput = {\n            text: text,\n            replacePrevCharCnt: this._lastTypeTextLength,\n            replaceNextCharCnt: 0,\n            positionDelta: 0\n        };\n        this._lastTypeTextLength = text.length;\n        return typeInput;\n    }\n}\n/**\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\n *  - onCut\n *  - onPaste\n *  - onType\n *\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\n */\nlet TextAreaInput = class TextAreaInput extends Disposable {\n    get textAreaState() {\n        return this._textAreaState;\n    }\n    constructor(_host, _textArea, _OS, _browser, _accessibilityService, _logService) {\n        super();\n        this._host = _host;\n        this._textArea = _textArea;\n        this._OS = _OS;\n        this._browser = _browser;\n        this._accessibilityService = _accessibilityService;\n        this._logService = _logService;\n        this._onFocus = this._register(new Emitter());\n        this.onFocus = this._onFocus.event;\n        this._onBlur = this._register(new Emitter());\n        this.onBlur = this._onBlur.event;\n        this._onKeyDown = this._register(new Emitter());\n        this.onKeyDown = this._onKeyDown.event;\n        this._onKeyUp = this._register(new Emitter());\n        this.onKeyUp = this._onKeyUp.event;\n        this._onCut = this._register(new Emitter());\n        this.onCut = this._onCut.event;\n        this._onPaste = this._register(new Emitter());\n        this.onPaste = this._onPaste.event;\n        this._onType = this._register(new Emitter());\n        this.onType = this._onType.event;\n        this._onCompositionStart = this._register(new Emitter());\n        this.onCompositionStart = this._onCompositionStart.event;\n        this._onCompositionUpdate = this._register(new Emitter());\n        this.onCompositionUpdate = this._onCompositionUpdate.event;\n        this._onCompositionEnd = this._register(new Emitter());\n        this.onCompositionEnd = this._onCompositionEnd.event;\n        this._onSelectionChangeRequest = this._register(new Emitter());\n        this.onSelectionChangeRequest = this._onSelectionChangeRequest.event;\n        this._asyncFocusGainWriteScreenReaderContent = this._register(new MutableDisposable());\n        this._asyncTriggerCut = this._register(new RunOnceScheduler(() => this._onCut.fire(), 0));\n        this._textAreaState = TextAreaState.EMPTY;\n        this._selectionChangeListener = null;\n        if (this._accessibilityService.isScreenReaderOptimized()) {\n            this.writeNativeTextAreaContent('ctor');\n        }\n        this._register(Event.runAndSubscribe(this._accessibilityService.onDidChangeScreenReaderOptimized, () => {\n            if (this._accessibilityService.isScreenReaderOptimized() && !this._asyncFocusGainWriteScreenReaderContent.value) {\n                this._asyncFocusGainWriteScreenReaderContent.value = this._register(new RunOnceScheduler(() => this.writeNativeTextAreaContent('asyncFocusGain'), 0));\n            }\n            else {\n                this._asyncFocusGainWriteScreenReaderContent.clear();\n            }\n        }));\n        this._hasFocus = false;\n        this._currentComposition = null;\n        let lastKeyDown = null;\n        this._register(this._textArea.onKeyDown((_e) => {\n            const e = new StandardKeyboardEvent(_e);\n            if (e.keyCode === 114 /* KeyCode.KEY_IN_COMPOSITION */\n                || (this._currentComposition && e.keyCode === 1 /* KeyCode.Backspace */)) {\n                // Stop propagation for keyDown events if the IME is processing key input\n                e.stopPropagation();\n            }\n            if (e.equals(9 /* KeyCode.Escape */)) {\n                // Prevent default always for `Esc`, otherwise it will generate a keypress\n                // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\n                e.preventDefault();\n            }\n            lastKeyDown = e;\n            this._onKeyDown.fire(e);\n        }));\n        this._register(this._textArea.onKeyUp((_e) => {\n            const e = new StandardKeyboardEvent(_e);\n            this._onKeyUp.fire(e);\n        }));\n        this._register(this._textArea.onCompositionStart((e) => {\n            if (_debugComposition) {\n                console.log(`[compositionstart]`, e);\n            }\n            const currentComposition = new CompositionContext();\n            if (this._currentComposition) {\n                // simply reset the composition context\n                this._currentComposition = currentComposition;\n                return;\n            }\n            this._currentComposition = currentComposition;\n            if (this._OS === 2 /* OperatingSystem.Macintosh */\n                && lastKeyDown\n                && lastKeyDown.equals(114 /* KeyCode.KEY_IN_COMPOSITION */)\n                && this._textAreaState.selectionStart === this._textAreaState.selectionEnd\n                && this._textAreaState.selectionStart > 0\n                && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === e.data\n                && (lastKeyDown.code === 'ArrowRight' || lastKeyDown.code === 'ArrowLeft')) {\n                // Handling long press case on Chromium/Safari macOS + arrow key => pretend the character was selected\n                if (_debugComposition) {\n                    console.log(`[compositionstart] Handling long press case on macOS + arrow key`, e);\n                }\n                // Pretend the previous character was composed (in order to get it removed by subsequent compositionupdate events)\n                currentComposition.handleCompositionUpdate('x');\n                this._onCompositionStart.fire({ data: e.data });\n                return;\n            }\n            if (this._browser.isAndroid) {\n                // when tapping on the editor, Android enters composition mode to edit the current word\n                // so we cannot clear the textarea on Android and we must pretend the current word was selected\n                this._onCompositionStart.fire({ data: e.data });\n                return;\n            }\n            this._onCompositionStart.fire({ data: e.data });\n        }));\n        this._register(this._textArea.onCompositionUpdate((e) => {\n            if (_debugComposition) {\n                console.log(`[compositionupdate]`, e);\n            }\n            const currentComposition = this._currentComposition;\n            if (!currentComposition) {\n                // should not be possible to receive a 'compositionupdate' without a 'compositionstart'\n                return;\n            }\n            if (this._browser.isAndroid) {\n                // On Android, the data sent with the composition update event is unusable.\n                // For example, if the cursor is in the middle of a word like Mic|osoft\n                // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n                // This is not really usable because it doesn't tell us where the edit began and where it ended.\n                const newState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n                const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n                this._textAreaState = newState;\n                this._onType.fire(typeInput);\n                this._onCompositionUpdate.fire(e);\n                return;\n            }\n            const typeInput = currentComposition.handleCompositionUpdate(e.data);\n            this._textAreaState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n            this._onType.fire(typeInput);\n            this._onCompositionUpdate.fire(e);\n        }));\n        this._register(this._textArea.onCompositionEnd((e) => {\n            if (_debugComposition) {\n                console.log(`[compositionend]`, e);\n            }\n            const currentComposition = this._currentComposition;\n            if (!currentComposition) {\n                // https://github.com/microsoft/monaco-editor/issues/1663\n                // On iOS 13.2, Chinese system IME randomly trigger an additional compositionend event with empty data\n                return;\n            }\n            this._currentComposition = null;\n            if (this._browser.isAndroid) {\n                // On Android, the data sent with the composition update event is unusable.\n                // For example, if the cursor is in the middle of a word like Mic|osoft\n                // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n                // This is not really usable because it doesn't tell us where the edit began and where it ended.\n                const newState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n                const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n                this._textAreaState = newState;\n                this._onType.fire(typeInput);\n                this._onCompositionEnd.fire();\n                return;\n            }\n            const typeInput = currentComposition.handleCompositionUpdate(e.data);\n            this._textAreaState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n            this._onType.fire(typeInput);\n            this._onCompositionEnd.fire();\n        }));\n        this._register(this._textArea.onInput((e) => {\n            if (_debugComposition) {\n                console.log(`[input]`, e);\n            }\n            // Pretend here we touched the text area, as the `input` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received input event');\n            if (this._currentComposition) {\n                return;\n            }\n            const newState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n            const typeInput = TextAreaState.deduceInput(this._textAreaState, newState, /*couldBeEmojiInput*/ this._OS === 2 /* OperatingSystem.Macintosh */);\n            if (typeInput.replacePrevCharCnt === 0 && typeInput.text.length === 1) {\n                // one character was typed\n                if (strings.isHighSurrogate(typeInput.text.charCodeAt(0))\n                    || typeInput.text.charCodeAt(0) === 0x7f /* Delete */) {\n                    // Ignore invalid input but keep it around for next time\n                    return;\n                }\n            }\n            this._textAreaState = newState;\n            if (typeInput.text !== ''\n                || typeInput.replacePrevCharCnt !== 0\n                || typeInput.replaceNextCharCnt !== 0\n                || typeInput.positionDelta !== 0) {\n                this._onType.fire(typeInput);\n            }\n        }));\n        // --- Clipboard operations\n        this._register(this._textArea.onCut((e) => {\n            // Pretend here we touched the text area, as the `cut` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received cut event');\n            this._ensureClipboardGetsEditorSelection(e);\n            this._asyncTriggerCut.schedule();\n        }));\n        this._register(this._textArea.onCopy((e) => {\n            this._ensureClipboardGetsEditorSelection(e);\n        }));\n        this._register(this._textArea.onPaste((e) => {\n            // Pretend here we touched the text area, as the `paste` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received paste event');\n            e.preventDefault();\n            if (!e.clipboardData) {\n                return;\n            }\n            let [text, metadata] = ClipboardEventUtils.getTextData(e.clipboardData);\n            if (!text) {\n                return;\n            }\n            // try the in-memory store\n            metadata = metadata || InMemoryClipboardMetadataManager.INSTANCE.get(text);\n            this._onPaste.fire({\n                text: text,\n                metadata: metadata\n            });\n        }));\n        this._register(this._textArea.onFocus(() => {\n            const hadFocus = this._hasFocus;\n            this._setHasFocus(true);\n            if (this._accessibilityService.isScreenReaderOptimized() && this._browser.isSafari && !hadFocus && this._hasFocus) {\n                // When \"tabbing into\" the textarea, immediately after dispatching the 'focus' event,\n                // Safari will always move the selection at offset 0 in the textarea\n                if (!this._asyncFocusGainWriteScreenReaderContent.value) {\n                    this._asyncFocusGainWriteScreenReaderContent.value = new RunOnceScheduler(() => this.writeNativeTextAreaContent('asyncFocusGain'), 0);\n                }\n                this._asyncFocusGainWriteScreenReaderContent.value.schedule();\n            }\n        }));\n        this._register(this._textArea.onBlur(() => {\n            if (this._currentComposition) {\n                // See https://github.com/microsoft/vscode/issues/112621\n                // where compositionend is not triggered when the editor\n                // is taken off-dom during a composition\n                // Clear the flag to be able to write to the textarea\n                this._currentComposition = null;\n                // Clear the textarea to avoid an unwanted cursor type\n                this.writeNativeTextAreaContent('blurWithoutCompositionEnd');\n                // Fire artificial composition end\n                this._onCompositionEnd.fire();\n            }\n            this._setHasFocus(false);\n        }));\n        this._register(this._textArea.onSyntheticTap(() => {\n            if (this._browser.isAndroid && this._currentComposition) {\n                // on Android, tapping does not cancel the current composition, so the\n                // textarea is stuck showing the old composition\n                // Clear the flag to be able to write to the textarea\n                this._currentComposition = null;\n                // Clear the textarea to avoid an unwanted cursor type\n                this.writeNativeTextAreaContent('tapWithoutCompositionEnd');\n                // Fire artificial composition end\n                this._onCompositionEnd.fire();\n            }\n        }));\n    }\n    _installSelectionChangeListener() {\n        // See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256\n        // When using a Braille display, it is possible for users to reposition the\n        // system caret. This is reflected in Chrome as a `selectionchange` event.\n        //\n        // The `selectionchange` event appears to be emitted under numerous other circumstances,\n        // so it is quite a challenge to distinguish a `selectionchange` coming in from a user\n        // using a Braille display from all the other cases.\n        //\n        // The problems with the `selectionchange` event are:\n        //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\n        //  * the event is emitted when the selection is changed in the textarea programmatically -- textarea.setSelectionRange(...)\n        //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\n        //  * the event is emitted when tabbing into the textarea\n        //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\n        //  * the event sometimes comes in bursts for a single logical textarea operation\n        // `selectionchange` events often come multiple times for a single logical change\n        // so throttle multiple `selectionchange` events that burst in a short period of time.\n        let previousSelectionChangeEventTime = 0;\n        return dom.addDisposableListener(this._textArea.ownerDocument, 'selectionchange', (e) => {\n            inputLatency.onSelectionChange();\n            if (!this._hasFocus) {\n                return;\n            }\n            if (this._currentComposition) {\n                return;\n            }\n            if (!this._browser.isChrome) {\n                // Support only for Chrome until testing happens on other browsers\n                return;\n            }\n            const now = Date.now();\n            const delta1 = now - previousSelectionChangeEventTime;\n            previousSelectionChangeEventTime = now;\n            if (delta1 < 5) {\n                // received another `selectionchange` event within 5ms of the previous `selectionchange` event\n                // => ignore it\n                return;\n            }\n            const delta2 = now - this._textArea.getIgnoreSelectionChangeTime();\n            this._textArea.resetSelectionChangeTime();\n            if (delta2 < 100) {\n                // received a `selectionchange` event within 100ms since we touched the textarea\n                // => ignore it, since we caused it\n                return;\n            }\n            if (!this._textAreaState.selection) {\n                // Cannot correlate a position in the textarea with a position in the editor...\n                return;\n            }\n            const newValue = this._textArea.getValue();\n            if (this._textAreaState.value !== newValue) {\n                // Cannot correlate a position in the textarea with a position in the editor...\n                return;\n            }\n            const newSelectionStart = this._textArea.getSelectionStart();\n            const newSelectionEnd = this._textArea.getSelectionEnd();\n            if (this._textAreaState.selectionStart === newSelectionStart && this._textAreaState.selectionEnd === newSelectionEnd) {\n                // Nothing to do...\n                return;\n            }\n            const _newSelectionStartPosition = this._textAreaState.deduceEditorPosition(newSelectionStart);\n            const newSelectionStartPosition = this._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\n            const _newSelectionEndPosition = this._textAreaState.deduceEditorPosition(newSelectionEnd);\n            const newSelectionEndPosition = this._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\n            const newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);\n            this._onSelectionChangeRequest.fire(newSelection);\n        });\n    }\n    dispose() {\n        super.dispose();\n        if (this._selectionChangeListener) {\n            this._selectionChangeListener.dispose();\n            this._selectionChangeListener = null;\n        }\n    }\n    focusTextArea() {\n        // Setting this._hasFocus and writing the screen reader content\n        // will result in a focus() and setSelectionRange() in the textarea\n        this._setHasFocus(true);\n        // If the editor is off DOM, focus cannot be really set, so let's double check that we have managed to set the focus\n        this.refreshFocusState();\n    }\n    isFocused() {\n        return this._hasFocus;\n    }\n    refreshFocusState() {\n        this._setHasFocus(this._textArea.hasFocus());\n    }\n    _setHasFocus(newHasFocus) {\n        if (this._hasFocus === newHasFocus) {\n            // no change\n            return;\n        }\n        this._hasFocus = newHasFocus;\n        if (this._selectionChangeListener) {\n            this._selectionChangeListener.dispose();\n            this._selectionChangeListener = null;\n        }\n        if (this._hasFocus) {\n            this._selectionChangeListener = this._installSelectionChangeListener();\n        }\n        if (this._hasFocus) {\n            this.writeNativeTextAreaContent('focusgain');\n        }\n        if (this._hasFocus) {\n            this._onFocus.fire();\n        }\n        else {\n            this._onBlur.fire();\n        }\n    }\n    _setAndWriteTextAreaState(reason, textAreaState) {\n        if (!this._hasFocus) {\n            textAreaState = textAreaState.collapseSelection();\n        }\n        textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\n        this._textAreaState = textAreaState;\n    }\n    writeNativeTextAreaContent(reason) {\n        if ((!this._accessibilityService.isScreenReaderOptimized() && reason === 'render') || this._currentComposition) {\n            // Do not write to the text on render unless a screen reader is being used #192278\n            // Do not write to the text area when doing composition\n            return;\n        }\n        this._logService.trace(`writeTextAreaState(reason: ${reason})`);\n        this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent());\n    }\n    _ensureClipboardGetsEditorSelection(e) {\n        const dataToCopy = this._host.getDataToCopy();\n        const storedMetadata = {\n            version: 1,\n            isFromEmptySelection: dataToCopy.isFromEmptySelection,\n            multicursorText: dataToCopy.multicursorText,\n            mode: dataToCopy.mode\n        };\n        InMemoryClipboardMetadataManager.INSTANCE.set(\n        // When writing \"LINE\\r\\n\" to the clipboard and then pasting,\n        // Firefox pastes \"LINE\\n\", so let's work around this quirk\n        (this._browser.isFirefox ? dataToCopy.text.replace(/\\r\\n/g, '\\n') : dataToCopy.text), storedMetadata);\n        e.preventDefault();\n        if (e.clipboardData) {\n            ClipboardEventUtils.setTextData(e.clipboardData, dataToCopy.text, dataToCopy.html, storedMetadata);\n        }\n    }\n};\nTextAreaInput = __decorate([\n    __param(4, IAccessibilityService),\n    __param(5, ILogService)\n], TextAreaInput);\nexport { TextAreaInput };\nexport const ClipboardEventUtils = {\n    getTextData(clipboardData) {\n        const text = clipboardData.getData(Mimes.text);\n        let metadata = null;\n        const rawmetadata = clipboardData.getData('vscode-editor-data');\n        if (typeof rawmetadata === 'string') {\n            try {\n                metadata = JSON.parse(rawmetadata);\n                if (metadata.version !== 1) {\n                    metadata = null;\n                }\n            }\n            catch (err) {\n                // no problem!\n            }\n        }\n        if (text.length === 0 && metadata === null && clipboardData.files.length > 0) {\n            // no textual data pasted, generate text from file names\n            const files = Array.prototype.slice.call(clipboardData.files, 0);\n            return [files.map(file => file.name).join('\\n'), null];\n        }\n        return [text, metadata];\n    },\n    setTextData(clipboardData, text, html, metadata) {\n        clipboardData.setData(Mimes.text, text);\n        if (typeof html === 'string') {\n            clipboardData.setData('text/html', html);\n        }\n        clipboardData.setData('vscode-editor-data', JSON.stringify(metadata));\n    }\n};\nexport class TextAreaWrapper extends Disposable {\n    get ownerDocument() {\n        return this._actual.ownerDocument;\n    }\n    constructor(_actual) {\n        super();\n        this._actual = _actual;\n        this.onKeyDown = this._register(new DomEmitter(this._actual, 'keydown')).event;\n        this.onKeyUp = this._register(new DomEmitter(this._actual, 'keyup')).event;\n        this.onCompositionStart = this._register(new DomEmitter(this._actual, 'compositionstart')).event;\n        this.onCompositionUpdate = this._register(new DomEmitter(this._actual, 'compositionupdate')).event;\n        this.onCompositionEnd = this._register(new DomEmitter(this._actual, 'compositionend')).event;\n        this.onBeforeInput = this._register(new DomEmitter(this._actual, 'beforeinput')).event;\n        this.onInput = this._register(new DomEmitter(this._actual, 'input')).event;\n        this.onCut = this._register(new DomEmitter(this._actual, 'cut')).event;\n        this.onCopy = this._register(new DomEmitter(this._actual, 'copy')).event;\n        this.onPaste = this._register(new DomEmitter(this._actual, 'paste')).event;\n        this.onFocus = this._register(new DomEmitter(this._actual, 'focus')).event;\n        this.onBlur = this._register(new DomEmitter(this._actual, 'blur')).event;\n        this._onSyntheticTap = this._register(new Emitter());\n        this.onSyntheticTap = this._onSyntheticTap.event;\n        this._ignoreSelectionChangeTime = 0;\n        this._register(this.onKeyDown(() => inputLatency.onKeyDown()));\n        this._register(this.onBeforeInput(() => inputLatency.onBeforeInput()));\n        this._register(this.onInput(() => inputLatency.onInput()));\n        this._register(this.onKeyUp(() => inputLatency.onKeyUp()));\n        this._register(dom.addDisposableListener(this._actual, TextAreaSyntethicEvents.Tap, () => this._onSyntheticTap.fire()));\n    }\n    hasFocus() {\n        const shadowRoot = dom.getShadowRoot(this._actual);\n        if (shadowRoot) {\n            return shadowRoot.activeElement === this._actual;\n        }\n        else if (this._actual.isConnected) {\n            return dom.getActiveElement() === this._actual;\n        }\n        else {\n            return false;\n        }\n    }\n    setIgnoreSelectionChangeTime(reason) {\n        this._ignoreSelectionChangeTime = Date.now();\n    }\n    getIgnoreSelectionChangeTime() {\n        return this._ignoreSelectionChangeTime;\n    }\n    resetSelectionChangeTime() {\n        this._ignoreSelectionChangeTime = 0;\n    }\n    getValue() {\n        // console.log('current value: ' + this._textArea.value);\n        return this._actual.value;\n    }\n    setValue(reason, value) {\n        const textArea = this._actual;\n        if (textArea.value === value) {\n            // No change\n            return;\n        }\n        // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\n        this.setIgnoreSelectionChangeTime('setValue');\n        textArea.value = value;\n    }\n    getSelectionStart() {\n        return this._actual.selectionDirection === 'backward' ? this._actual.selectionEnd : this._actual.selectionStart;\n    }\n    getSelectionEnd() {\n        return this._actual.selectionDirection === 'backward' ? this._actual.selectionStart : this._actual.selectionEnd;\n    }\n    setSelectionRange(reason, selectionStart, selectionEnd) {\n        const textArea = this._actual;\n        let activeElement = null;\n        const shadowRoot = dom.getShadowRoot(textArea);\n        if (shadowRoot) {\n            activeElement = shadowRoot.activeElement;\n        }\n        else {\n            activeElement = dom.getActiveElement();\n        }\n        const activeWindow = dom.getWindow(activeElement);\n        const currentIsFocused = (activeElement === textArea);\n        const currentSelectionStart = textArea.selectionStart;\n        const currentSelectionEnd = textArea.selectionEnd;\n        if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\n            // No change\n            // Firefox iframe bug https://github.com/microsoft/monaco-editor/issues/643#issuecomment-367871377\n            if (browser.isFirefox && activeWindow.parent !== activeWindow) {\n                textArea.focus();\n            }\n            return;\n        }\n        // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\n        if (currentIsFocused) {\n            // No need to focus, only need to change the selection range\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\n            textArea.setSelectionRange(selectionStart, selectionEnd);\n            if (browser.isFirefox && activeWindow.parent !== activeWindow) {\n                textArea.focus();\n            }\n            return;\n        }\n        // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\n        // Here, we try to undo the browser's desperate reveal.\n        try {\n            const scrollState = dom.saveParentsScrollTop(textArea);\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\n            textArea.focus();\n            textArea.setSelectionRange(selectionStart, selectionEnd);\n            dom.restoreParentsScrollTop(textArea, scrollState);\n        }\n        catch (e) {\n            // Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}