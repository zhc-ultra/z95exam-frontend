{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _typeof from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.reflect.to-string-tag.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.trim-start.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nimport * as strings from '../../../../base/common/strings.js';\nimport { ShiftCommand } from '../../../common/commands/shiftCommand.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { IndentAction } from '../../../common/languages/languageConfiguration.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport * as indentUtils from '../../indentation/common/indentUtils.js';\nimport { getGoodIndentForLine, getIndentMetadata } from '../../../common/languages/autoIndent.js';\nimport { getEnterAction } from '../../../common/languages/enterAction.js';\nvar MoveLinesCommand = /*#__PURE__*/function () {\n  function MoveLinesCommand(selection, isMovingDown, autoIndent, _languageConfigurationService) {\n    _classCallCheck(this, MoveLinesCommand);\n    this._languageConfigurationService = _languageConfigurationService;\n    this._selection = selection;\n    this._isMovingDown = isMovingDown;\n    this._autoIndent = autoIndent;\n    this._selectionId = null;\n    this._moveEndLineSelectionShrink = false;\n  }\n  return _createClass(MoveLinesCommand, [{\n    key: \"getEditOperations\",\n    value: function getEditOperations(model, builder) {\n      var modelLineCount = model.getLineCount();\n      if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {\n        this._selectionId = builder.trackSelection(this._selection);\n        return;\n      }\n      if (!this._isMovingDown && this._selection.startLineNumber === 1) {\n        this._selectionId = builder.trackSelection(this._selection);\n        return;\n      }\n      this._moveEndPositionDown = false;\n      var s = this._selection;\n      if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n        this._moveEndPositionDown = true;\n        s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n      }\n      var _model$getOptions = model.getOptions(),\n        tabSize = _model$getOptions.tabSize,\n        indentSize = _model$getOptions.indentSize,\n        insertSpaces = _model$getOptions.insertSpaces;\n      var indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);\n      var virtualModel = {\n        tokenization: {\n          getLineTokens: function getLineTokens(lineNumber) {\n            return model.tokenization.getLineTokens(lineNumber);\n          },\n          getLanguageId: function getLanguageId() {\n            return model.getLanguageId();\n          },\n          getLanguageIdAtPosition: function getLanguageIdAtPosition(lineNumber, column) {\n            return model.getLanguageIdAtPosition(lineNumber, column);\n          }\n        },\n        getLineContent: null\n      };\n      if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {\n        // Current line is empty\n        var lineNumber = s.startLineNumber;\n        var otherLineNumber = this._isMovingDown ? lineNumber + 1 : lineNumber - 1;\n        if (model.getLineMaxColumn(otherLineNumber) === 1) {\n          // Other line number is empty too, so no editing is needed\n          // Add a no-op to force running by the model\n          builder.addEditOperation(new Range(1, 1, 1, 1), null);\n        } else {\n          // Type content from other line number on line number\n          builder.addEditOperation(new Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));\n          // Remove content from other line number\n          builder.addEditOperation(new Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);\n        }\n        // Track selection at the other line number\n        s = new Selection(otherLineNumber, 1, otherLineNumber, 1);\n      } else {\n        var movingLineNumber;\n        var movingLineText;\n        if (this._isMovingDown) {\n          movingLineNumber = s.endLineNumber + 1;\n          movingLineText = model.getLineContent(movingLineNumber);\n          // Delete line that needs to be moved\n          builder.addEditOperation(new Range(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);\n          var insertingText = movingLineText;\n          if (this.shouldAutoIndent(model, s)) {\n            var movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1);\n            // if s.startLineNumber - 1 matches onEnter rule, we still honor that.\n            if (movingLineMatchResult !== null) {\n              var oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n              var newSpaceCnt = movingLineMatchResult + indentUtils.getSpaceCnt(oldIndentation, tabSize);\n              var newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n              insertingText = newIndentation + this.trimStart(movingLineText);\n            } else {\n              // no enter rule matches, let's check indentatin rules then.\n              virtualModel.getLineContent = function (lineNumber) {\n                if (lineNumber === s.startLineNumber) {\n                  return model.getLineContent(movingLineNumber);\n                } else {\n                  return model.getLineContent(lineNumber);\n                }\n              };\n              var indentOfMovingLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter, this._languageConfigurationService);\n              if (indentOfMovingLine !== null) {\n                var _oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n                var _newSpaceCnt = indentUtils.getSpaceCnt(indentOfMovingLine, tabSize);\n                var oldSpaceCnt = indentUtils.getSpaceCnt(_oldIndentation, tabSize);\n                if (_newSpaceCnt !== oldSpaceCnt) {\n                  var _newIndentation = indentUtils.generateIndent(_newSpaceCnt, tabSize, insertSpaces);\n                  insertingText = _newIndentation + this.trimStart(movingLineText);\n                }\n              }\n            }\n            // add edit operations for moving line first to make sure it's executed after we make indentation change\n            // to s.startLineNumber\n            builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n            var ret = this.matchEnterRuleMovingDown(model, indentConverter, tabSize, s.startLineNumber, movingLineNumber, insertingText);\n            // check if the line being moved before matches onEnter rules, if so let's adjust the indentation by onEnter rules.\n            if (ret !== null) {\n              if (ret !== 0) {\n                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n              }\n            } else {\n              // it doesn't match onEnter rules, let's check indentation rules then.\n              virtualModel.getLineContent = function (lineNumber) {\n                if (lineNumber === s.startLineNumber) {\n                  return insertingText;\n                } else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {\n                  return model.getLineContent(lineNumber - 1);\n                } else {\n                  return model.getLineContent(lineNumber);\n                }\n              };\n              var newIndentatOfMovingBlock = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter, this._languageConfigurationService);\n              if (newIndentatOfMovingBlock !== null) {\n                var _oldIndentation2 = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n                var _newSpaceCnt2 = indentUtils.getSpaceCnt(newIndentatOfMovingBlock, tabSize);\n                var _oldSpaceCnt = indentUtils.getSpaceCnt(_oldIndentation2, tabSize);\n                if (_newSpaceCnt2 !== _oldSpaceCnt) {\n                  var spaceCntOffset = _newSpaceCnt2 - _oldSpaceCnt;\n                  this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n                }\n              }\n            }\n          } else {\n            // Insert line that needs to be moved before\n            builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n          }\n        } else {\n          movingLineNumber = s.startLineNumber - 1;\n          movingLineText = model.getLineContent(movingLineNumber);\n          // Delete line that needs to be moved\n          builder.addEditOperation(new Range(movingLineNumber, 1, movingLineNumber + 1, 1), null);\n          // Insert line that needs to be moved after\n          builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\\n' + movingLineText);\n          if (this.shouldAutoIndent(model, s)) {\n            virtualModel.getLineContent = function (lineNumber) {\n              if (lineNumber === movingLineNumber) {\n                return model.getLineContent(s.startLineNumber);\n              } else {\n                return model.getLineContent(lineNumber);\n              }\n            };\n            var _ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2);\n            // check if s.startLineNumber - 2 matches onEnter rules, if so adjust the moving block by onEnter rules.\n            if (_ret !== null) {\n              if (_ret !== 0) {\n                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, _ret);\n              }\n            } else {\n              // it doesn't match any onEnter rule, let's check indentation rules then.\n              var indentOfFirstLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter, this._languageConfigurationService);\n              if (indentOfFirstLine !== null) {\n                // adjust the indentation of the moving block\n                var oldIndent = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n                var _newSpaceCnt3 = indentUtils.getSpaceCnt(indentOfFirstLine, tabSize);\n                var _oldSpaceCnt2 = indentUtils.getSpaceCnt(oldIndent, tabSize);\n                if (_newSpaceCnt3 !== _oldSpaceCnt2) {\n                  var _spaceCntOffset = _newSpaceCnt3 - _oldSpaceCnt2;\n                  this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, _spaceCntOffset);\n                }\n              }\n            }\n          }\n        }\n      }\n      this._selectionId = builder.trackSelection(s);\n    }\n  }, {\n    key: \"buildIndentConverter\",\n    value: function buildIndentConverter(tabSize, indentSize, insertSpaces) {\n      return {\n        shiftIndent: function shiftIndent(indentation) {\n          return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n        },\n        unshiftIndent: function unshiftIndent(indentation) {\n          return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n        }\n      };\n    }\n  }, {\n    key: \"parseEnterResult\",\n    value: function parseEnterResult(model, indentConverter, tabSize, line, enter) {\n      if (enter) {\n        var enterPrefix = enter.indentation;\n        if (enter.indentAction === IndentAction.None) {\n          enterPrefix = enter.indentation + enter.appendText;\n        } else if (enter.indentAction === IndentAction.Indent) {\n          enterPrefix = enter.indentation + enter.appendText;\n        } else if (enter.indentAction === IndentAction.IndentOutdent) {\n          enterPrefix = enter.indentation;\n        } else if (enter.indentAction === IndentAction.Outdent) {\n          enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enter.appendText;\n        }\n        var movingLineText = model.getLineContent(line);\n        if (this.trimStart(movingLineText).indexOf(this.trimStart(enterPrefix)) >= 0) {\n          var oldIndentation = strings.getLeadingWhitespace(model.getLineContent(line));\n          var newIndentation = strings.getLeadingWhitespace(enterPrefix);\n          var indentMetadataOfMovelingLine = getIndentMetadata(model, line, this._languageConfigurationService);\n          if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & 2 /* IndentConsts.DECREASE_MASK */) {\n            newIndentation = indentConverter.unshiftIndent(newIndentation);\n          }\n          var newSpaceCnt = indentUtils.getSpaceCnt(newIndentation, tabSize);\n          var oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n          return newSpaceCnt - oldSpaceCnt;\n        }\n      }\n      return null;\n    }\n    /**\n     *\n     * @param model\n     * @param indentConverter\n     * @param tabSize\n     * @param line the line moving down\n     * @param futureAboveLineNumber the line which will be at the `line` position\n     * @param futureAboveLineText\n     */\n  }, {\n    key: \"matchEnterRuleMovingDown\",\n    value: function matchEnterRuleMovingDown(model, indentConverter, tabSize, line, futureAboveLineNumber, futureAboveLineText) {\n      if (strings.lastNonWhitespaceIndex(futureAboveLineText) >= 0) {\n        // break\n        var maxColumn = model.getLineMaxColumn(futureAboveLineNumber);\n        var enter = getEnterAction(this._autoIndent, model, new Range(futureAboveLineNumber, maxColumn, futureAboveLineNumber, maxColumn), this._languageConfigurationService);\n        return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n      } else {\n        // go upwards, starting from `line - 1`\n        var validPrecedingLine = line - 1;\n        while (validPrecedingLine >= 1) {\n          var lineContent = model.getLineContent(validPrecedingLine);\n          var nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n          if (nonWhitespaceIdx >= 0) {\n            break;\n          }\n          validPrecedingLine--;\n        }\n        if (validPrecedingLine < 1 || line > model.getLineCount()) {\n          return null;\n        }\n        var _maxColumn = model.getLineMaxColumn(validPrecedingLine);\n        var _enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, _maxColumn, validPrecedingLine, _maxColumn), this._languageConfigurationService);\n        return this.parseEnterResult(model, indentConverter, tabSize, line, _enter);\n      }\n    }\n  }, {\n    key: \"matchEnterRule\",\n    value: function matchEnterRule(model, indentConverter, tabSize, line, oneLineAbove, previousLineText) {\n      var validPrecedingLine = oneLineAbove;\n      while (validPrecedingLine >= 1) {\n        // ship empty lines as empty lines just inherit indentation\n        var lineContent = void 0;\n        if (validPrecedingLine === oneLineAbove && previousLineText !== undefined) {\n          lineContent = previousLineText;\n        } else {\n          lineContent = model.getLineContent(validPrecedingLine);\n        }\n        var nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n        if (nonWhitespaceIdx >= 0) {\n          break;\n        }\n        validPrecedingLine--;\n      }\n      if (validPrecedingLine < 1 || line > model.getLineCount()) {\n        return null;\n      }\n      var maxColumn = model.getLineMaxColumn(validPrecedingLine);\n      var enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);\n      return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n    }\n  }, {\n    key: \"trimStart\",\n    value: function trimStart(str) {\n      return str.replace(/^\\s+/, '');\n    }\n  }, {\n    key: \"shouldAutoIndent\",\n    value: function shouldAutoIndent(model, selection) {\n      if (this._autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return false;\n      }\n      // if it's not easy to tokenize, we stop auto indent.\n      if (!model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n        return false;\n      }\n      var languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);\n      var languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);\n      if (languageAtSelectionStart !== languageAtSelectionEnd) {\n        return false;\n      }\n      if (this._languageConfigurationService.getLanguageConfiguration(languageAtSelectionStart).indentRulesSupport === null) {\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"getIndentEditsOfMovingBlock\",\n    value: function getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, offset) {\n      for (var i = s.startLineNumber; i <= s.endLineNumber; i++) {\n        var lineContent = model.getLineContent(i);\n        var originalIndent = strings.getLeadingWhitespace(lineContent);\n        var originalSpacesCnt = indentUtils.getSpaceCnt(originalIndent, tabSize);\n        var newSpacesCnt = originalSpacesCnt + offset;\n        var newIndent = indentUtils.generateIndent(newSpacesCnt, tabSize, insertSpaces);\n        if (newIndent !== originalIndent) {\n          builder.addEditOperation(new Range(i, 1, i, originalIndent.length + 1), newIndent);\n          if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === '') {\n            // as users select part of the original indent white spaces\n            // when we adjust the indentation of endLine, we should adjust the cursor position as well.\n            this._moveEndLineSelectionShrink = true;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"computeCursorState\",\n    value: function computeCursorState(model, helper) {\n      var result = helper.getTrackedSelection(this._selectionId);\n      if (this._moveEndPositionDown) {\n        result = result.setEndPosition(result.endLineNumber + 1, 1);\n      }\n      if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {\n        result = result.setEndPosition(result.endLineNumber, 2);\n      }\n      return result;\n    }\n  }]);\n}();\nMoveLinesCommand = __decorate([__param(3, ILanguageConfigurationService)], MoveLinesCommand);\nexport { MoveLinesCommand };","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","_typeof","decorate","i","defineProperty","__param","paramIndex","decorator","strings","ShiftCommand","Range","Selection","IndentAction","ILanguageConfigurationService","indentUtils","getGoodIndentForLine","getIndentMetadata","getEnterAction","MoveLinesCommand","selection","isMovingDown","autoIndent","_languageConfigurationService","_classCallCheck","_selection","_isMovingDown","_autoIndent","_selectionId","_moveEndLineSelectionShrink","_createClass","value","getEditOperations","model","builder","modelLineCount","getLineCount","endLineNumber","trackSelection","startLineNumber","_moveEndPositionDown","s","endColumn","setEndPosition","getLineMaxColumn","_model$getOptions","getOptions","tabSize","indentSize","insertSpaces","indentConverter","buildIndentConverter","virtualModel","tokenization","getLineTokens","lineNumber","getLanguageId","getLanguageIdAtPosition","column","getLineContent","otherLineNumber","addEditOperation","movingLineNumber","movingLineText","insertingText","shouldAutoIndent","movingLineMatchResult","matchEnterRule","oldIndentation","getLeadingWhitespace","newSpaceCnt","getSpaceCnt","newIndentation","generateIndent","trimStart","indentOfMovingLine","oldSpaceCnt","ret","matchEnterRuleMovingDown","getIndentEditsOfMovingBlock","newIndentatOfMovingBlock","spaceCntOffset","indentOfFirstLine","oldIndent","shiftIndent","indentation","unshiftIndent","parseEnterResult","line","enter","enterPrefix","indentAction","None","appendText","Indent","IndentOutdent","Outdent","indexOf","indentMetadataOfMovelingLine","futureAboveLineNumber","futureAboveLineText","lastNonWhitespaceIndex","maxColumn","validPrecedingLine","lineContent","nonWhitespaceIdx","oneLineAbove","previousLineText","undefined","str","replace","isCheapToTokenize","languageAtSelectionStart","languageAtSelectionEnd","getLanguageConfiguration","indentRulesSupport","offset","originalIndent","originalSpacesCnt","newSpacesCnt","newIndent","computeCursorState","helper","result","getTrackedSelection"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/moveLinesCommand.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport * as strings from '../../../../base/common/strings.js';\nimport { ShiftCommand } from '../../../common/commands/shiftCommand.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { IndentAction } from '../../../common/languages/languageConfiguration.js';\nimport { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';\nimport * as indentUtils from '../../indentation/common/indentUtils.js';\nimport { getGoodIndentForLine, getIndentMetadata } from '../../../common/languages/autoIndent.js';\nimport { getEnterAction } from '../../../common/languages/enterAction.js';\nlet MoveLinesCommand = class MoveLinesCommand {\n    constructor(selection, isMovingDown, autoIndent, _languageConfigurationService) {\n        this._languageConfigurationService = _languageConfigurationService;\n        this._selection = selection;\n        this._isMovingDown = isMovingDown;\n        this._autoIndent = autoIndent;\n        this._selectionId = null;\n        this._moveEndLineSelectionShrink = false;\n    }\n    getEditOperations(model, builder) {\n        const modelLineCount = model.getLineCount();\n        if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {\n            this._selectionId = builder.trackSelection(this._selection);\n            return;\n        }\n        if (!this._isMovingDown && this._selection.startLineNumber === 1) {\n            this._selectionId = builder.trackSelection(this._selection);\n            return;\n        }\n        this._moveEndPositionDown = false;\n        let s = this._selection;\n        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {\n            this._moveEndPositionDown = true;\n            s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));\n        }\n        const { tabSize, indentSize, insertSpaces } = model.getOptions();\n        const indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);\n        const virtualModel = {\n            tokenization: {\n                getLineTokens: (lineNumber) => {\n                    return model.tokenization.getLineTokens(lineNumber);\n                },\n                getLanguageId: () => {\n                    return model.getLanguageId();\n                },\n                getLanguageIdAtPosition: (lineNumber, column) => {\n                    return model.getLanguageIdAtPosition(lineNumber, column);\n                },\n            },\n            getLineContent: null,\n        };\n        if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {\n            // Current line is empty\n            const lineNumber = s.startLineNumber;\n            const otherLineNumber = (this._isMovingDown ? lineNumber + 1 : lineNumber - 1);\n            if (model.getLineMaxColumn(otherLineNumber) === 1) {\n                // Other line number is empty too, so no editing is needed\n                // Add a no-op to force running by the model\n                builder.addEditOperation(new Range(1, 1, 1, 1), null);\n            }\n            else {\n                // Type content from other line number on line number\n                builder.addEditOperation(new Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));\n                // Remove content from other line number\n                builder.addEditOperation(new Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);\n            }\n            // Track selection at the other line number\n            s = new Selection(otherLineNumber, 1, otherLineNumber, 1);\n        }\n        else {\n            let movingLineNumber;\n            let movingLineText;\n            if (this._isMovingDown) {\n                movingLineNumber = s.endLineNumber + 1;\n                movingLineText = model.getLineContent(movingLineNumber);\n                // Delete line that needs to be moved\n                builder.addEditOperation(new Range(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);\n                let insertingText = movingLineText;\n                if (this.shouldAutoIndent(model, s)) {\n                    const movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1);\n                    // if s.startLineNumber - 1 matches onEnter rule, we still honor that.\n                    if (movingLineMatchResult !== null) {\n                        const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n                        const newSpaceCnt = movingLineMatchResult + indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                        const newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n                        insertingText = newIndentation + this.trimStart(movingLineText);\n                    }\n                    else {\n                        // no enter rule matches, let's check indentatin rules then.\n                        virtualModel.getLineContent = (lineNumber) => {\n                            if (lineNumber === s.startLineNumber) {\n                                return model.getLineContent(movingLineNumber);\n                            }\n                            else {\n                                return model.getLineContent(lineNumber);\n                            }\n                        };\n                        const indentOfMovingLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter, this._languageConfigurationService);\n                        if (indentOfMovingLine !== null) {\n                            const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(movingLineNumber));\n                            const newSpaceCnt = indentUtils.getSpaceCnt(indentOfMovingLine, tabSize);\n                            const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                            if (newSpaceCnt !== oldSpaceCnt) {\n                                const newIndentation = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n                                insertingText = newIndentation + this.trimStart(movingLineText);\n                            }\n                        }\n                    }\n                    // add edit operations for moving line first to make sure it's executed after we make indentation change\n                    // to s.startLineNumber\n                    builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n                    const ret = this.matchEnterRuleMovingDown(model, indentConverter, tabSize, s.startLineNumber, movingLineNumber, insertingText);\n                    // check if the line being moved before matches onEnter rules, if so let's adjust the indentation by onEnter rules.\n                    if (ret !== null) {\n                        if (ret !== 0) {\n                            this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n                        }\n                    }\n                    else {\n                        // it doesn't match onEnter rules, let's check indentation rules then.\n                        virtualModel.getLineContent = (lineNumber) => {\n                            if (lineNumber === s.startLineNumber) {\n                                return insertingText;\n                            }\n                            else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {\n                                return model.getLineContent(lineNumber - 1);\n                            }\n                            else {\n                                return model.getLineContent(lineNumber);\n                            }\n                        };\n                        const newIndentatOfMovingBlock = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter, this._languageConfigurationService);\n                        if (newIndentatOfMovingBlock !== null) {\n                            const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n                            const newSpaceCnt = indentUtils.getSpaceCnt(newIndentatOfMovingBlock, tabSize);\n                            const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                            if (newSpaceCnt !== oldSpaceCnt) {\n                                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n                            }\n                        }\n                    }\n                }\n                else {\n                    // Insert line that needs to be moved before\n                    builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + '\\n');\n                }\n            }\n            else {\n                movingLineNumber = s.startLineNumber - 1;\n                movingLineText = model.getLineContent(movingLineNumber);\n                // Delete line that needs to be moved\n                builder.addEditOperation(new Range(movingLineNumber, 1, movingLineNumber + 1, 1), null);\n                // Insert line that needs to be moved after\n                builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\\n' + movingLineText);\n                if (this.shouldAutoIndent(model, s)) {\n                    virtualModel.getLineContent = (lineNumber) => {\n                        if (lineNumber === movingLineNumber) {\n                            return model.getLineContent(s.startLineNumber);\n                        }\n                        else {\n                            return model.getLineContent(lineNumber);\n                        }\n                    };\n                    const ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2);\n                    // check if s.startLineNumber - 2 matches onEnter rules, if so adjust the moving block by onEnter rules.\n                    if (ret !== null) {\n                        if (ret !== 0) {\n                            this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);\n                        }\n                    }\n                    else {\n                        // it doesn't match any onEnter rule, let's check indentation rules then.\n                        const indentOfFirstLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter, this._languageConfigurationService);\n                        if (indentOfFirstLine !== null) {\n                            // adjust the indentation of the moving block\n                            const oldIndent = strings.getLeadingWhitespace(model.getLineContent(s.startLineNumber));\n                            const newSpaceCnt = indentUtils.getSpaceCnt(indentOfFirstLine, tabSize);\n                            const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndent, tabSize);\n                            if (newSpaceCnt !== oldSpaceCnt) {\n                                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;\n                                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        this._selectionId = builder.trackSelection(s);\n    }\n    buildIndentConverter(tabSize, indentSize, insertSpaces) {\n        return {\n            shiftIndent: (indentation) => {\n                return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n            },\n            unshiftIndent: (indentation) => {\n                return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n            }\n        };\n    }\n    parseEnterResult(model, indentConverter, tabSize, line, enter) {\n        if (enter) {\n            let enterPrefix = enter.indentation;\n            if (enter.indentAction === IndentAction.None) {\n                enterPrefix = enter.indentation + enter.appendText;\n            }\n            else if (enter.indentAction === IndentAction.Indent) {\n                enterPrefix = enter.indentation + enter.appendText;\n            }\n            else if (enter.indentAction === IndentAction.IndentOutdent) {\n                enterPrefix = enter.indentation;\n            }\n            else if (enter.indentAction === IndentAction.Outdent) {\n                enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enter.appendText;\n            }\n            const movingLineText = model.getLineContent(line);\n            if (this.trimStart(movingLineText).indexOf(this.trimStart(enterPrefix)) >= 0) {\n                const oldIndentation = strings.getLeadingWhitespace(model.getLineContent(line));\n                let newIndentation = strings.getLeadingWhitespace(enterPrefix);\n                const indentMetadataOfMovelingLine = getIndentMetadata(model, line, this._languageConfigurationService);\n                if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & 2 /* IndentConsts.DECREASE_MASK */) {\n                    newIndentation = indentConverter.unshiftIndent(newIndentation);\n                }\n                const newSpaceCnt = indentUtils.getSpaceCnt(newIndentation, tabSize);\n                const oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                return newSpaceCnt - oldSpaceCnt;\n            }\n        }\n        return null;\n    }\n    /**\n     *\n     * @param model\n     * @param indentConverter\n     * @param tabSize\n     * @param line the line moving down\n     * @param futureAboveLineNumber the line which will be at the `line` position\n     * @param futureAboveLineText\n     */\n    matchEnterRuleMovingDown(model, indentConverter, tabSize, line, futureAboveLineNumber, futureAboveLineText) {\n        if (strings.lastNonWhitespaceIndex(futureAboveLineText) >= 0) {\n            // break\n            const maxColumn = model.getLineMaxColumn(futureAboveLineNumber);\n            const enter = getEnterAction(this._autoIndent, model, new Range(futureAboveLineNumber, maxColumn, futureAboveLineNumber, maxColumn), this._languageConfigurationService);\n            return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n        }\n        else {\n            // go upwards, starting from `line - 1`\n            let validPrecedingLine = line - 1;\n            while (validPrecedingLine >= 1) {\n                const lineContent = model.getLineContent(validPrecedingLine);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n                validPrecedingLine--;\n            }\n            if (validPrecedingLine < 1 || line > model.getLineCount()) {\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(validPrecedingLine);\n            const enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);\n            return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n        }\n    }\n    matchEnterRule(model, indentConverter, tabSize, line, oneLineAbove, previousLineText) {\n        let validPrecedingLine = oneLineAbove;\n        while (validPrecedingLine >= 1) {\n            // ship empty lines as empty lines just inherit indentation\n            let lineContent;\n            if (validPrecedingLine === oneLineAbove && previousLineText !== undefined) {\n                lineContent = previousLineText;\n            }\n            else {\n                lineContent = model.getLineContent(validPrecedingLine);\n            }\n            const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineContent);\n            if (nonWhitespaceIdx >= 0) {\n                break;\n            }\n            validPrecedingLine--;\n        }\n        if (validPrecedingLine < 1 || line > model.getLineCount()) {\n            return null;\n        }\n        const maxColumn = model.getLineMaxColumn(validPrecedingLine);\n        const enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);\n        return this.parseEnterResult(model, indentConverter, tabSize, line, enter);\n    }\n    trimStart(str) {\n        return str.replace(/^\\s+/, '');\n    }\n    shouldAutoIndent(model, selection) {\n        if (this._autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n            return false;\n        }\n        // if it's not easy to tokenize, we stop auto indent.\n        if (!model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n            return false;\n        }\n        const languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);\n        const languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);\n        if (languageAtSelectionStart !== languageAtSelectionEnd) {\n            return false;\n        }\n        if (this._languageConfigurationService.getLanguageConfiguration(languageAtSelectionStart).indentRulesSupport === null) {\n            return false;\n        }\n        return true;\n    }\n    getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, offset) {\n        for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {\n            const lineContent = model.getLineContent(i);\n            const originalIndent = strings.getLeadingWhitespace(lineContent);\n            const originalSpacesCnt = indentUtils.getSpaceCnt(originalIndent, tabSize);\n            const newSpacesCnt = originalSpacesCnt + offset;\n            const newIndent = indentUtils.generateIndent(newSpacesCnt, tabSize, insertSpaces);\n            if (newIndent !== originalIndent) {\n                builder.addEditOperation(new Range(i, 1, i, originalIndent.length + 1), newIndent);\n                if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === '') {\n                    // as users select part of the original indent white spaces\n                    // when we adjust the indentation of endLine, we should adjust the cursor position as well.\n                    this._moveEndLineSelectionShrink = true;\n                }\n            }\n        }\n    }\n    computeCursorState(model, helper) {\n        let result = helper.getTrackedSelection(this._selectionId);\n        if (this._moveEndPositionDown) {\n            result = result.setEndPosition(result.endLineNumber + 1, 1);\n        }\n        if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {\n            result = result.setEndPosition(result.endLineNumber, 2);\n        }\n        return result;\n    }\n};\nMoveLinesCommand = __decorate([\n    __param(3, ILanguageConfigurationService)\n], MoveLinesCommand);\nexport { MoveLinesCommand };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}