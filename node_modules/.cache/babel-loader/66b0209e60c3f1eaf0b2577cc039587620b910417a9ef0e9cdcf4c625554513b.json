{"ast":null,"code":"import _slicedToArray from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _get from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.date.now.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IntervalTimer, TimeoutTimer } from '../../../base/common/async.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { IME } from '../../../base/common/ime.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as nls from '../../../nls.js';\nimport { NoMatchingKb } from './keybindingResolver.js';\nvar HIGH_FREQ_COMMANDS = /^(cursor|delete|undo|redo|tab|editor\\.action\\.clipboard)/;\nexport var AbstractKeybindingService = /*#__PURE__*/function (_Disposable) {\n  function AbstractKeybindingService(_contextKeyService, _commandService, _telemetryService, _notificationService, _logService) {\n    var _this;\n    _classCallCheck(this, AbstractKeybindingService);\n    _this = _callSuper(this, AbstractKeybindingService);\n    _this._contextKeyService = _contextKeyService;\n    _this._commandService = _commandService;\n    _this._telemetryService = _telemetryService;\n    _this._notificationService = _notificationService;\n    _this._logService = _logService;\n    _this._onDidUpdateKeybindings = _this._register(new Emitter());\n    _this._currentChords = [];\n    _this._currentChordChecker = new IntervalTimer();\n    _this._currentChordStatusMessage = null;\n    _this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n    _this._currentSingleModifier = null;\n    _this._currentSingleModifierClearTimeout = new TimeoutTimer();\n    _this._currentlyDispatchingCommandId = null;\n    _this._logging = false;\n    return _this;\n  }\n  _inherits(AbstractKeybindingService, _Disposable);\n  return _createClass(AbstractKeybindingService, [{\n    key: \"onDidUpdateKeybindings\",\n    get: function get() {\n      return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Event.None; // Sinon stubbing walks properties on prototype\n    }\n  }, {\n    key: \"inChordMode\",\n    get: function get() {\n      return this._currentChords.length > 0;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(AbstractKeybindingService.prototype), \"dispose\", this).call(this);\n    }\n  }, {\n    key: \"_log\",\n    value: function _log(str) {\n      if (this._logging) {\n        this._logService.info(\"[KeybindingService]: \".concat(str));\n      }\n    }\n  }, {\n    key: \"getKeybindings\",\n    value: function getKeybindings() {\n      return this._getResolver().getKeybindings();\n    }\n  }, {\n    key: \"lookupKeybinding\",\n    value: function lookupKeybinding(commandId, context) {\n      var result = this._getResolver().lookupPrimaryKeybinding(commandId, context || this._contextKeyService);\n      if (!result) {\n        return undefined;\n      }\n      return result.resolvedKeybinding;\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(e, target) {\n      return this._dispatch(e, target);\n    }\n    // TODO@ulugbekna: update namings to align with `_doDispatch`\n    // TODO@ulugbekna: this fn doesn't seem to take into account single-modifier keybindings, eg `shift shift`\n  }, {\n    key: \"softDispatch\",\n    value: function softDispatch(e, target) {\n      this._log(\"/ Soft dispatching keyboard event\");\n      var keybinding = this.resolveKeyboardEvent(e);\n      if (keybinding.hasMultipleChords()) {\n        console.warn('keyboard event should not be mapped to multiple chords');\n        return NoMatchingKb;\n      }\n      var _keybinding$getDispat = keybinding.getDispatchChords(),\n        _keybinding$getDispat2 = _slicedToArray(_keybinding$getDispat, 1),\n        firstChord = _keybinding$getDispat2[0];\n      if (firstChord === null) {\n        // cannot be dispatched, probably only modifier keys\n        this._log(\"\\\\ Keyboard event cannot be dispatched\");\n        return NoMatchingKb;\n      }\n      var contextValue = this._contextKeyService.getContext(target);\n      var currentChords = this._currentChords.map(function (_ref) {\n        var keypress = _ref.keypress;\n        return keypress;\n      });\n      return this._getResolver().resolve(contextValue, currentChords, firstChord);\n    }\n  }, {\n    key: \"_scheduleLeaveChordMode\",\n    value: function _scheduleLeaveChordMode() {\n      var _this2 = this;\n      var chordLastInteractedTime = Date.now();\n      this._currentChordChecker.cancelAndSet(function () {\n        if (!_this2._documentHasFocus()) {\n          // Focus has been lost => leave chord mode\n          _this2._leaveChordMode();\n          return;\n        }\n        if (Date.now() - chordLastInteractedTime > 5000) {\n          // 5 seconds elapsed => leave chord mode\n          _this2._leaveChordMode();\n        }\n      }, 500);\n    }\n  }, {\n    key: \"_expectAnotherChord\",\n    value: function _expectAnotherChord(firstChord, keypressLabel) {\n      this._currentChords.push({\n        keypress: firstChord,\n        label: keypressLabel\n      });\n      switch (this._currentChords.length) {\n        case 0:\n          throw illegalState('impossible');\n        case 1:\n          // TODO@ulugbekna: revise this message and the one below (at least, fix terminology)\n          this._currentChordStatusMessage = this._notificationService.status(nls.localize('first.chord', \"({0}) was pressed. Waiting for second key of chord...\", keypressLabel));\n          break;\n        default:\n          {\n            var fullKeypressLabel = this._currentChords.map(function (_ref2) {\n              var label = _ref2.label;\n              return label;\n            }).join(', ');\n            this._currentChordStatusMessage = this._notificationService.status(nls.localize('next.chord', \"({0}) was pressed. Waiting for next key of chord...\", fullKeypressLabel));\n          }\n      }\n      this._scheduleLeaveChordMode();\n      if (IME.enabled) {\n        IME.disable();\n      }\n    }\n  }, {\n    key: \"_leaveChordMode\",\n    value: function _leaveChordMode() {\n      if (this._currentChordStatusMessage) {\n        this._currentChordStatusMessage.dispose();\n        this._currentChordStatusMessage = null;\n      }\n      this._currentChordChecker.cancel();\n      this._currentChords = [];\n      IME.enable();\n    }\n  }, {\n    key: \"_dispatch\",\n    value: function _dispatch(e, target) {\n      return this._doDispatch(this.resolveKeyboardEvent(e), target, /*isSingleModiferChord*/false);\n    }\n  }, {\n    key: \"_singleModifierDispatch\",\n    value: function _singleModifierDispatch(e, target) {\n      var _this3 = this;\n      var keybinding = this.resolveKeyboardEvent(e);\n      var _keybinding$getSingle = keybinding.getSingleModifierDispatchChords(),\n        _keybinding$getSingle2 = _slicedToArray(_keybinding$getSingle, 1),\n        singleModifier = _keybinding$getSingle2[0];\n      if (singleModifier) {\n        if (this._ignoreSingleModifiers.has(singleModifier)) {\n          this._log(\"+ Ignoring single modifier \".concat(singleModifier, \" due to it being pressed together with other keys.\"));\n          this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n          this._currentSingleModifierClearTimeout.cancel();\n          this._currentSingleModifier = null;\n          return false;\n        }\n        this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n        if (this._currentSingleModifier === null) {\n          // we have a valid `singleModifier`, store it for the next keyup, but clear it in 300ms\n          this._log(\"+ Storing single modifier for possible chord \".concat(singleModifier, \".\"));\n          this._currentSingleModifier = singleModifier;\n          this._currentSingleModifierClearTimeout.cancelAndSet(function () {\n            _this3._log(\"+ Clearing single modifier due to 300ms elapsed.\");\n            _this3._currentSingleModifier = null;\n          }, 300);\n          return false;\n        }\n        if (singleModifier === this._currentSingleModifier) {\n          // bingo!\n          this._log(\"/ Dispatching single modifier chord \".concat(singleModifier, \" \").concat(singleModifier));\n          this._currentSingleModifierClearTimeout.cancel();\n          this._currentSingleModifier = null;\n          return this._doDispatch(keybinding, target, /*isSingleModiferChord*/true);\n        }\n        this._log(\"+ Clearing single modifier due to modifier mismatch: \".concat(this._currentSingleModifier, \" \").concat(singleModifier));\n        this._currentSingleModifierClearTimeout.cancel();\n        this._currentSingleModifier = null;\n        return false;\n      }\n      // When pressing a modifier and holding it pressed with any other modifier or key combination,\n      // the pressed modifiers should no longer be considered for single modifier dispatch.\n      var _keybinding$getChords = keybinding.getChords(),\n        _keybinding$getChords2 = _slicedToArray(_keybinding$getChords, 1),\n        firstChord = _keybinding$getChords2[0];\n      this._ignoreSingleModifiers = new KeybindingModifierSet(firstChord);\n      if (this._currentSingleModifier !== null) {\n        this._log(\"+ Clearing single modifier due to other key up.\");\n      }\n      this._currentSingleModifierClearTimeout.cancel();\n      this._currentSingleModifier = null;\n      return false;\n    }\n  }, {\n    key: \"_doDispatch\",\n    value: function _doDispatch(userKeypress, target) {\n      var _this4 = this;\n      var isSingleModiferChord = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var _a;\n      var shouldPreventDefault = false;\n      if (userKeypress.hasMultipleChords()) {\n        // warn - because user can press a single chord at a time\n        console.warn('Unexpected keyboard event mapped to multiple chords');\n        return false;\n      }\n      var userPressedChord = null;\n      var currentChords = null;\n      if (isSingleModiferChord) {\n        // The keybinding is the second keypress of a single modifier chord, e.g. \"shift shift\".\n        // A single modifier can only occur when the same modifier is pressed in short sequence,\n        // hence we disregard `_currentChord` and use the same modifier instead.\n        var _userKeypress$getSing = userKeypress.getSingleModifierDispatchChords(),\n          _userKeypress$getSing2 = _slicedToArray(_userKeypress$getSing, 1),\n          dispatchKeyname = _userKeypress$getSing2[0];\n        userPressedChord = dispatchKeyname;\n        currentChords = dispatchKeyname ? [dispatchKeyname] : []; // TODO@ulugbekna: in the `else` case we assign an empty array - make sure `resolve` can handle an empty array well\n      } else {\n        var _userKeypress$getDisp = userKeypress.getDispatchChords();\n        var _userKeypress$getDisp2 = _slicedToArray(_userKeypress$getDisp, 1);\n        userPressedChord = _userKeypress$getDisp2[0];\n        currentChords = this._currentChords.map(function (_ref3) {\n          var keypress = _ref3.keypress;\n          return keypress;\n        });\n      }\n      if (userPressedChord === null) {\n        this._log(\"\\\\ Keyboard event cannot be dispatched in keydown phase.\");\n        // cannot be dispatched, probably only modifier keys\n        return shouldPreventDefault;\n      }\n      var contextValue = this._contextKeyService.getContext(target);\n      var keypressLabel = userKeypress.getLabel();\n      var resolveResult = this._getResolver().resolve(contextValue, currentChords, userPressedChord);\n      switch (resolveResult.kind) {\n        case 0 /* ResultKind.NoMatchingKb */:\n          {\n            this._logService.trace('KeybindingService#dispatch', keypressLabel, \"[ No matching keybinding ]\");\n            if (this.inChordMode) {\n              var currentChordsLabel = this._currentChords.map(function (_ref4) {\n                var label = _ref4.label;\n                return label;\n              }).join(', ');\n              this._log(\"+ Leaving multi-chord mode: Nothing bound to \\\"\".concat(currentChordsLabel, \", \").concat(keypressLabel, \"\\\".\"));\n              this._notificationService.status(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", currentChordsLabel, keypressLabel), {\n                hideAfter: 10 * 1000 /* 10s */\n              });\n              this._leaveChordMode();\n              shouldPreventDefault = true;\n            }\n            return shouldPreventDefault;\n          }\n        case 1 /* ResultKind.MoreChordsNeeded */:\n          {\n            this._logService.trace('KeybindingService#dispatch', keypressLabel, \"[ Several keybindings match - more chords needed ]\");\n            shouldPreventDefault = true;\n            this._expectAnotherChord(userPressedChord, keypressLabel);\n            this._log(this._currentChords.length === 1 ? \"+ Entering multi-chord mode...\" : \"+ Continuing multi-chord mode...\");\n            return shouldPreventDefault;\n          }\n        case 2 /* ResultKind.KbFound */:\n          {\n            this._logService.trace('KeybindingService#dispatch', keypressLabel, \"[ Will dispatch command \".concat(resolveResult.commandId, \" ]\"));\n            if (resolveResult.commandId === null || resolveResult.commandId === '') {\n              if (this.inChordMode) {\n                var _currentChordsLabel = this._currentChords.map(function (_ref5) {\n                  var label = _ref5.label;\n                  return label;\n                }).join(', ');\n                this._log(\"+ Leaving chord mode: Nothing bound to \\\"\".concat(_currentChordsLabel, \", \").concat(keypressLabel, \"\\\".\"));\n                this._notificationService.status(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", _currentChordsLabel, keypressLabel), {\n                  hideAfter: 10 * 1000 /* 10s */\n                });\n                this._leaveChordMode();\n                shouldPreventDefault = true;\n              }\n            } else {\n              if (this.inChordMode) {\n                this._leaveChordMode();\n              }\n              if (!resolveResult.isBubble) {\n                shouldPreventDefault = true;\n              }\n              this._log(\"+ Invoking command \".concat(resolveResult.commandId, \".\"));\n              this._currentlyDispatchingCommandId = resolveResult.commandId;\n              try {\n                if (typeof resolveResult.commandArgs === 'undefined') {\n                  this._commandService.executeCommand(resolveResult.commandId).then(undefined, function (err) {\n                    return _this4._notificationService.warn(err);\n                  });\n                } else {\n                  this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(undefined, function (err) {\n                    return _this4._notificationService.warn(err);\n                  });\n                }\n              } finally {\n                this._currentlyDispatchingCommandId = null;\n              }\n              if (!HIGH_FREQ_COMMANDS.test(resolveResult.commandId)) {\n                this._telemetryService.publicLog2('workbenchActionExecuted', {\n                  id: resolveResult.commandId,\n                  from: 'keybinding',\n                  detail: (_a = userKeypress.getUserSettingsLabel()) !== null && _a !== void 0 ? _a : undefined\n                });\n              }\n            }\n            return shouldPreventDefault;\n          }\n      }\n    }\n  }, {\n    key: \"mightProducePrintableCharacter\",\n    value: function mightProducePrintableCharacter(event) {\n      if (event.ctrlKey || event.metaKey) {\n        // ignore ctrl/cmd-combination but not shift/alt-combinatios\n        return false;\n      }\n      // weak check for certain ranges. this is properly implemented in a subclass\n      // with access to the KeyboardMapperFactory.\n      if (event.keyCode >= 31 /* KeyCode.KeyA */ && event.keyCode <= 56 /* KeyCode.KeyZ */ || event.keyCode >= 21 /* KeyCode.Digit0 */ && event.keyCode <= 30 /* KeyCode.Digit9 */) {\n        return true;\n      }\n      return false;\n    }\n  }]);\n}(Disposable);\nvar KeybindingModifierSet = /*#__PURE__*/function () {\n  function KeybindingModifierSet(source) {\n    _classCallCheck(this, KeybindingModifierSet);\n    this._ctrlKey = source ? source.ctrlKey : false;\n    this._shiftKey = source ? source.shiftKey : false;\n    this._altKey = source ? source.altKey : false;\n    this._metaKey = source ? source.metaKey : false;\n  }\n  return _createClass(KeybindingModifierSet, [{\n    key: \"has\",\n    value: function has(modifier) {\n      switch (modifier) {\n        case 'ctrl':\n          return this._ctrlKey;\n        case 'shift':\n          return this._shiftKey;\n        case 'alt':\n          return this._altKey;\n        case 'meta':\n          return this._metaKey;\n      }\n    }\n  }]);\n}();\nKeybindingModifierSet.EMPTY = new KeybindingModifierSet(null);","map":{"version":3,"names":["IntervalTimer","TimeoutTimer","illegalState","Emitter","Event","IME","Disposable","nls","NoMatchingKb","HIGH_FREQ_COMMANDS","AbstractKeybindingService","_Disposable","_contextKeyService","_commandService","_telemetryService","_notificationService","_logService","_this","_classCallCheck","_callSuper","_onDidUpdateKeybindings","_register","_currentChords","_currentChordChecker","_currentChordStatusMessage","_ignoreSingleModifiers","KeybindingModifierSet","EMPTY","_currentSingleModifier","_currentSingleModifierClearTimeout","_currentlyDispatchingCommandId","_logging","_inherits","_createClass","key","get","event","None","length","value","dispose","_get","_getPrototypeOf","prototype","call","_log","str","info","concat","getKeybindings","_getResolver","lookupKeybinding","commandId","context","result","lookupPrimaryKeybinding","undefined","resolvedKeybinding","dispatchEvent","e","target","_dispatch","softDispatch","keybinding","resolveKeyboardEvent","hasMultipleChords","console","warn","_keybinding$getDispat","getDispatchChords","_keybinding$getDispat2","_slicedToArray","firstChord","contextValue","getContext","currentChords","map","_ref","keypress","resolve","_scheduleLeaveChordMode","_this2","chordLastInteractedTime","Date","now","cancelAndSet","_documentHasFocus","_leaveChordMode","_expectAnotherChord","keypressLabel","push","label","status","localize","fullKeypressLabel","_ref2","join","enabled","disable","cancel","enable","_doDispatch","_singleModifierDispatch","_this3","_keybinding$getSingle","getSingleModifierDispatchChords","_keybinding$getSingle2","singleModifier","has","_keybinding$getChords","getChords","_keybinding$getChords2","userKeypress","_this4","isSingleModiferChord","arguments","_a","shouldPreventDefault","userPressedChord","_userKeypress$getSing","_userKeypress$getSing2","dispatchKeyname","_userKeypress$getDisp","_userKeypress$getDisp2","_ref3","getLabel","resolveResult","kind","trace","inChordMode","currentChordsLabel","_ref4","hideAfter","_ref5","isBubble","commandArgs","executeCommand","then","err","test","publicLog2","id","from","detail","getUserSettingsLabel","mightProducePrintableCharacter","ctrlKey","metaKey","keyCode","source","_ctrlKey","_shiftKey","shiftKey","_altKey","altKey","_metaKey","modifier"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/platform/keybinding/common/abstractKeybindingService.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IntervalTimer, TimeoutTimer } from '../../../base/common/async.js';\nimport { illegalState } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { IME } from '../../../base/common/ime.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as nls from '../../../nls.js';\nimport { NoMatchingKb } from './keybindingResolver.js';\nconst HIGH_FREQ_COMMANDS = /^(cursor|delete|undo|redo|tab|editor\\.action\\.clipboard)/;\nexport class AbstractKeybindingService extends Disposable {\n    get onDidUpdateKeybindings() {\n        return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Event.None; // Sinon stubbing walks properties on prototype\n    }\n    get inChordMode() {\n        return this._currentChords.length > 0;\n    }\n    constructor(_contextKeyService, _commandService, _telemetryService, _notificationService, _logService) {\n        super();\n        this._contextKeyService = _contextKeyService;\n        this._commandService = _commandService;\n        this._telemetryService = _telemetryService;\n        this._notificationService = _notificationService;\n        this._logService = _logService;\n        this._onDidUpdateKeybindings = this._register(new Emitter());\n        this._currentChords = [];\n        this._currentChordChecker = new IntervalTimer();\n        this._currentChordStatusMessage = null;\n        this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n        this._currentSingleModifier = null;\n        this._currentSingleModifierClearTimeout = new TimeoutTimer();\n        this._currentlyDispatchingCommandId = null;\n        this._logging = false;\n    }\n    dispose() {\n        super.dispose();\n    }\n    _log(str) {\n        if (this._logging) {\n            this._logService.info(`[KeybindingService]: ${str}`);\n        }\n    }\n    getKeybindings() {\n        return this._getResolver().getKeybindings();\n    }\n    lookupKeybinding(commandId, context) {\n        const result = this._getResolver().lookupPrimaryKeybinding(commandId, context || this._contextKeyService);\n        if (!result) {\n            return undefined;\n        }\n        return result.resolvedKeybinding;\n    }\n    dispatchEvent(e, target) {\n        return this._dispatch(e, target);\n    }\n    // TODO@ulugbekna: update namings to align with `_doDispatch`\n    // TODO@ulugbekna: this fn doesn't seem to take into account single-modifier keybindings, eg `shift shift`\n    softDispatch(e, target) {\n        this._log(`/ Soft dispatching keyboard event`);\n        const keybinding = this.resolveKeyboardEvent(e);\n        if (keybinding.hasMultipleChords()) {\n            console.warn('keyboard event should not be mapped to multiple chords');\n            return NoMatchingKb;\n        }\n        const [firstChord,] = keybinding.getDispatchChords();\n        if (firstChord === null) {\n            // cannot be dispatched, probably only modifier keys\n            this._log(`\\\\ Keyboard event cannot be dispatched`);\n            return NoMatchingKb;\n        }\n        const contextValue = this._contextKeyService.getContext(target);\n        const currentChords = this._currentChords.map((({ keypress }) => keypress));\n        return this._getResolver().resolve(contextValue, currentChords, firstChord);\n    }\n    _scheduleLeaveChordMode() {\n        const chordLastInteractedTime = Date.now();\n        this._currentChordChecker.cancelAndSet(() => {\n            if (!this._documentHasFocus()) {\n                // Focus has been lost => leave chord mode\n                this._leaveChordMode();\n                return;\n            }\n            if (Date.now() - chordLastInteractedTime > 5000) {\n                // 5 seconds elapsed => leave chord mode\n                this._leaveChordMode();\n            }\n        }, 500);\n    }\n    _expectAnotherChord(firstChord, keypressLabel) {\n        this._currentChords.push({ keypress: firstChord, label: keypressLabel });\n        switch (this._currentChords.length) {\n            case 0:\n                throw illegalState('impossible');\n            case 1:\n                // TODO@ulugbekna: revise this message and the one below (at least, fix terminology)\n                this._currentChordStatusMessage = this._notificationService.status(nls.localize('first.chord', \"({0}) was pressed. Waiting for second key of chord...\", keypressLabel));\n                break;\n            default: {\n                const fullKeypressLabel = this._currentChords.map(({ label }) => label).join(', ');\n                this._currentChordStatusMessage = this._notificationService.status(nls.localize('next.chord', \"({0}) was pressed. Waiting for next key of chord...\", fullKeypressLabel));\n            }\n        }\n        this._scheduleLeaveChordMode();\n        if (IME.enabled) {\n            IME.disable();\n        }\n    }\n    _leaveChordMode() {\n        if (this._currentChordStatusMessage) {\n            this._currentChordStatusMessage.dispose();\n            this._currentChordStatusMessage = null;\n        }\n        this._currentChordChecker.cancel();\n        this._currentChords = [];\n        IME.enable();\n    }\n    _dispatch(e, target) {\n        return this._doDispatch(this.resolveKeyboardEvent(e), target, /*isSingleModiferChord*/ false);\n    }\n    _singleModifierDispatch(e, target) {\n        const keybinding = this.resolveKeyboardEvent(e);\n        const [singleModifier,] = keybinding.getSingleModifierDispatchChords();\n        if (singleModifier) {\n            if (this._ignoreSingleModifiers.has(singleModifier)) {\n                this._log(`+ Ignoring single modifier ${singleModifier} due to it being pressed together with other keys.`);\n                this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n                this._currentSingleModifierClearTimeout.cancel();\n                this._currentSingleModifier = null;\n                return false;\n            }\n            this._ignoreSingleModifiers = KeybindingModifierSet.EMPTY;\n            if (this._currentSingleModifier === null) {\n                // we have a valid `singleModifier`, store it for the next keyup, but clear it in 300ms\n                this._log(`+ Storing single modifier for possible chord ${singleModifier}.`);\n                this._currentSingleModifier = singleModifier;\n                this._currentSingleModifierClearTimeout.cancelAndSet(() => {\n                    this._log(`+ Clearing single modifier due to 300ms elapsed.`);\n                    this._currentSingleModifier = null;\n                }, 300);\n                return false;\n            }\n            if (singleModifier === this._currentSingleModifier) {\n                // bingo!\n                this._log(`/ Dispatching single modifier chord ${singleModifier} ${singleModifier}`);\n                this._currentSingleModifierClearTimeout.cancel();\n                this._currentSingleModifier = null;\n                return this._doDispatch(keybinding, target, /*isSingleModiferChord*/ true);\n            }\n            this._log(`+ Clearing single modifier due to modifier mismatch: ${this._currentSingleModifier} ${singleModifier}`);\n            this._currentSingleModifierClearTimeout.cancel();\n            this._currentSingleModifier = null;\n            return false;\n        }\n        // When pressing a modifier and holding it pressed with any other modifier or key combination,\n        // the pressed modifiers should no longer be considered for single modifier dispatch.\n        const [firstChord,] = keybinding.getChords();\n        this._ignoreSingleModifiers = new KeybindingModifierSet(firstChord);\n        if (this._currentSingleModifier !== null) {\n            this._log(`+ Clearing single modifier due to other key up.`);\n        }\n        this._currentSingleModifierClearTimeout.cancel();\n        this._currentSingleModifier = null;\n        return false;\n    }\n    _doDispatch(userKeypress, target, isSingleModiferChord = false) {\n        var _a;\n        let shouldPreventDefault = false;\n        if (userKeypress.hasMultipleChords()) { // warn - because user can press a single chord at a time\n            console.warn('Unexpected keyboard event mapped to multiple chords');\n            return false;\n        }\n        let userPressedChord = null;\n        let currentChords = null;\n        if (isSingleModiferChord) {\n            // The keybinding is the second keypress of a single modifier chord, e.g. \"shift shift\".\n            // A single modifier can only occur when the same modifier is pressed in short sequence,\n            // hence we disregard `_currentChord` and use the same modifier instead.\n            const [dispatchKeyname,] = userKeypress.getSingleModifierDispatchChords();\n            userPressedChord = dispatchKeyname;\n            currentChords = dispatchKeyname ? [dispatchKeyname] : []; // TODO@ulugbekna: in the `else` case we assign an empty array - make sure `resolve` can handle an empty array well\n        }\n        else {\n            [userPressedChord,] = userKeypress.getDispatchChords();\n            currentChords = this._currentChords.map(({ keypress }) => keypress);\n        }\n        if (userPressedChord === null) {\n            this._log(`\\\\ Keyboard event cannot be dispatched in keydown phase.`);\n            // cannot be dispatched, probably only modifier keys\n            return shouldPreventDefault;\n        }\n        const contextValue = this._contextKeyService.getContext(target);\n        const keypressLabel = userKeypress.getLabel();\n        const resolveResult = this._getResolver().resolve(contextValue, currentChords, userPressedChord);\n        switch (resolveResult.kind) {\n            case 0 /* ResultKind.NoMatchingKb */: {\n                this._logService.trace('KeybindingService#dispatch', keypressLabel, `[ No matching keybinding ]`);\n                if (this.inChordMode) {\n                    const currentChordsLabel = this._currentChords.map(({ label }) => label).join(', ');\n                    this._log(`+ Leaving multi-chord mode: Nothing bound to \"${currentChordsLabel}, ${keypressLabel}\".`);\n                    this._notificationService.status(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", currentChordsLabel, keypressLabel), { hideAfter: 10 * 1000 /* 10s */ });\n                    this._leaveChordMode();\n                    shouldPreventDefault = true;\n                }\n                return shouldPreventDefault;\n            }\n            case 1 /* ResultKind.MoreChordsNeeded */: {\n                this._logService.trace('KeybindingService#dispatch', keypressLabel, `[ Several keybindings match - more chords needed ]`);\n                shouldPreventDefault = true;\n                this._expectAnotherChord(userPressedChord, keypressLabel);\n                this._log(this._currentChords.length === 1 ? `+ Entering multi-chord mode...` : `+ Continuing multi-chord mode...`);\n                return shouldPreventDefault;\n            }\n            case 2 /* ResultKind.KbFound */: {\n                this._logService.trace('KeybindingService#dispatch', keypressLabel, `[ Will dispatch command ${resolveResult.commandId} ]`);\n                if (resolveResult.commandId === null || resolveResult.commandId === '') {\n                    if (this.inChordMode) {\n                        const currentChordsLabel = this._currentChords.map(({ label }) => label).join(', ');\n                        this._log(`+ Leaving chord mode: Nothing bound to \"${currentChordsLabel}, ${keypressLabel}\".`);\n                        this._notificationService.status(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", currentChordsLabel, keypressLabel), { hideAfter: 10 * 1000 /* 10s */ });\n                        this._leaveChordMode();\n                        shouldPreventDefault = true;\n                    }\n                }\n                else {\n                    if (this.inChordMode) {\n                        this._leaveChordMode();\n                    }\n                    if (!resolveResult.isBubble) {\n                        shouldPreventDefault = true;\n                    }\n                    this._log(`+ Invoking command ${resolveResult.commandId}.`);\n                    this._currentlyDispatchingCommandId = resolveResult.commandId;\n                    try {\n                        if (typeof resolveResult.commandArgs === 'undefined') {\n                            this._commandService.executeCommand(resolveResult.commandId).then(undefined, err => this._notificationService.warn(err));\n                        }\n                        else {\n                            this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(undefined, err => this._notificationService.warn(err));\n                        }\n                    }\n                    finally {\n                        this._currentlyDispatchingCommandId = null;\n                    }\n                    if (!HIGH_FREQ_COMMANDS.test(resolveResult.commandId)) {\n                        this._telemetryService.publicLog2('workbenchActionExecuted', { id: resolveResult.commandId, from: 'keybinding', detail: (_a = userKeypress.getUserSettingsLabel()) !== null && _a !== void 0 ? _a : undefined });\n                    }\n                }\n                return shouldPreventDefault;\n            }\n        }\n    }\n    mightProducePrintableCharacter(event) {\n        if (event.ctrlKey || event.metaKey) {\n            // ignore ctrl/cmd-combination but not shift/alt-combinatios\n            return false;\n        }\n        // weak check for certain ranges. this is properly implemented in a subclass\n        // with access to the KeyboardMapperFactory.\n        if ((event.keyCode >= 31 /* KeyCode.KeyA */ && event.keyCode <= 56 /* KeyCode.KeyZ */)\n            || (event.keyCode >= 21 /* KeyCode.Digit0 */ && event.keyCode <= 30 /* KeyCode.Digit9 */)) {\n            return true;\n        }\n        return false;\n    }\n}\nclass KeybindingModifierSet {\n    constructor(source) {\n        this._ctrlKey = source ? source.ctrlKey : false;\n        this._shiftKey = source ? source.shiftKey : false;\n        this._altKey = source ? source.altKey : false;\n        this._metaKey = source ? source.metaKey : false;\n    }\n    has(modifier) {\n        switch (modifier) {\n            case 'ctrl': return this._ctrlKey;\n            case 'shift': return this._shiftKey;\n            case 'alt': return this._altKey;\n            case 'meta': return this._metaKey;\n        }\n    }\n}\nKeybindingModifierSet.EMPTY = new KeybindingModifierSet(null);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}