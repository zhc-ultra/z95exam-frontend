{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.splice.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nexport var LineDecoration = /*#__PURE__*/function () {\n  function LineDecoration(startColumn, endColumn, className, type) {\n    _classCallCheck(this, LineDecoration);\n    this.startColumn = startColumn;\n    this.endColumn = endColumn;\n    this.className = className;\n    this.type = type;\n    this._lineDecorationBrand = undefined;\n  }\n  return _createClass(LineDecoration, null, [{\n    key: \"_equals\",\n    value: function _equals(a, b) {\n      return a.startColumn === b.startColumn && a.endColumn === b.endColumn && a.className === b.className && a.type === b.type;\n    }\n  }, {\n    key: \"equalsArr\",\n    value: function equalsArr(a, b) {\n      var aLen = a.length;\n      var bLen = b.length;\n      if (aLen !== bLen) {\n        return false;\n      }\n      for (var i = 0; i < aLen; i++) {\n        if (!LineDecoration._equals(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"extractWrapped\",\n    value: function extractWrapped(arr, startOffset, endOffset) {\n      if (arr.length === 0) {\n        return arr;\n      }\n      var startColumn = startOffset + 1;\n      var endColumn = endOffset + 1;\n      var lineLength = endOffset - startOffset;\n      var r = [];\n      var rLength = 0;\n      var _iterator = _createForOfIteratorHelper(arr),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var dec = _step.value;\n          if (dec.endColumn <= startColumn || dec.startColumn >= endColumn) {\n            continue;\n          }\n          r[rLength++] = new LineDecoration(Math.max(1, dec.startColumn - startColumn + 1), Math.min(lineLength + 1, dec.endColumn - startColumn + 1), dec.className, dec.type);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return r;\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(lineDecorations, lineNumber, minLineColumn, maxLineColumn) {\n      if (lineDecorations.length === 0) {\n        return [];\n      }\n      var result = [];\n      var resultLen = 0;\n      for (var i = 0, len = lineDecorations.length; i < len; i++) {\n        var d = lineDecorations[i];\n        var range = d.range;\n        if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n          // Ignore decorations that sit outside this line\n          continue;\n        }\n        if (range.isEmpty() && (d.type === 0 /* InlineDecorationType.Regular */ || d.type === 3 /* InlineDecorationType.RegularAffectingLetterSpacing */)) {\n          // Ignore empty range decorations\n          continue;\n        }\n        var startColumn = range.startLineNumber === lineNumber ? range.startColumn : minLineColumn;\n        var endColumn = range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn;\n        result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n      }\n      return result;\n    }\n  }, {\n    key: \"_typeCompare\",\n    value: function _typeCompare(a, b) {\n      var ORDER = [2, 0, 1, 3];\n      return ORDER[a] - ORDER[b];\n    }\n  }, {\n    key: \"compare\",\n    value: function compare(a, b) {\n      if (a.startColumn !== b.startColumn) {\n        return a.startColumn - b.startColumn;\n      }\n      if (a.endColumn !== b.endColumn) {\n        return a.endColumn - b.endColumn;\n      }\n      var typeCmp = LineDecoration._typeCompare(a.type, b.type);\n      if (typeCmp !== 0) {\n        return typeCmp;\n      }\n      if (a.className !== b.className) {\n        return a.className < b.className ? -1 : 1;\n      }\n      return 0;\n    }\n  }]);\n}();\nexport var DecorationSegment = /*#__PURE__*/_createClass(function DecorationSegment(startOffset, endOffset, className, metadata) {\n  _classCallCheck(this, DecorationSegment);\n  this.startOffset = startOffset;\n  this.endOffset = endOffset;\n  this.className = className;\n  this.metadata = metadata;\n});\nvar Stack = /*#__PURE__*/function () {\n  function Stack() {\n    _classCallCheck(this, Stack);\n    this.stopOffsets = [];\n    this.classNames = [];\n    this.metadata = [];\n    this.count = 0;\n  }\n  return _createClass(Stack, [{\n    key: \"consumeLowerThan\",\n    value: function consumeLowerThan(maxStopOffset, nextStartOffset, result) {\n      while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n        var i = 0;\n        // Take all equal stopping offsets\n        while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n          i++;\n        }\n        // Basically we are consuming the first i + 1 elements of the stack\n        result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' '), Stack._metadata(this.metadata)));\n        nextStartOffset = this.stopOffsets[i] + 1;\n        // Consume them\n        this.stopOffsets.splice(0, i + 1);\n        this.classNames.splice(0, i + 1);\n        this.metadata.splice(0, i + 1);\n        this.count -= i + 1;\n      }\n      if (this.count > 0 && nextStartOffset < maxStopOffset) {\n        result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' '), Stack._metadata(this.metadata)));\n        nextStartOffset = maxStopOffset;\n      }\n      return nextStartOffset;\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(stopOffset, className, metadata) {\n      if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n        // Insert at the end\n        this.stopOffsets.push(stopOffset);\n        this.classNames.push(className);\n        this.metadata.push(metadata);\n      } else {\n        // Find the insertion position for `stopOffset`\n        for (var i = 0; i < this.count; i++) {\n          if (this.stopOffsets[i] >= stopOffset) {\n            this.stopOffsets.splice(i, 0, stopOffset);\n            this.classNames.splice(i, 0, className);\n            this.metadata.splice(i, 0, metadata);\n            break;\n          }\n        }\n      }\n      this.count++;\n      return;\n    }\n  }], [{\n    key: \"_metadata\",\n    value: function _metadata(metadata) {\n      var result = 0;\n      for (var i = 0, len = metadata.length; i < len; i++) {\n        result |= metadata[i];\n      }\n      return result;\n    }\n  }]);\n}();\nexport var LineDecorationsNormalizer = /*#__PURE__*/function () {\n  function LineDecorationsNormalizer() {\n    _classCallCheck(this, LineDecorationsNormalizer);\n  }\n  return _createClass(LineDecorationsNormalizer, null, [{\n    key: \"normalize\",\n    value:\n    /**\n     * Normalize line decorations. Overlapping decorations will generate multiple segments\n     */\n    function normalize(lineContent, lineDecorations) {\n      if (lineDecorations.length === 0) {\n        return [];\n      }\n      var result = [];\n      var stack = new Stack();\n      var nextStartOffset = 0;\n      for (var i = 0, len = lineDecorations.length; i < len; i++) {\n        var d = lineDecorations[i];\n        var startColumn = d.startColumn;\n        var endColumn = d.endColumn;\n        var className = d.className;\n        var metadata = d.type === 1 /* InlineDecorationType.Before */ ? 2 /* LinePartMetadata.PSEUDO_BEFORE */ : d.type === 2 /* InlineDecorationType.After */ ? 4 /* LinePartMetadata.PSEUDO_AFTER */ : 0;\n        // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n        if (startColumn > 1) {\n          var charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n          if (strings.isHighSurrogate(charCodeBefore)) {\n            startColumn--;\n          }\n        }\n        if (endColumn > 1) {\n          var _charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n          if (strings.isHighSurrogate(_charCodeBefore)) {\n            endColumn--;\n          }\n        }\n        var currentStartOffset = startColumn - 1;\n        var currentEndOffset = endColumn - 2;\n        nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n        if (stack.count === 0) {\n          nextStartOffset = currentStartOffset;\n        }\n        stack.insert(currentEndOffset, className, metadata);\n      }\n      stack.consumeLowerThan(1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, nextStartOffset, result);\n      return result;\n    }\n  }]);\n}();","map":{"version":3,"names":["strings","LineDecoration","startColumn","endColumn","className","type","_classCallCheck","_lineDecorationBrand","undefined","_createClass","key","value","_equals","a","b","equalsArr","aLen","length","bLen","i","extractWrapped","arr","startOffset","endOffset","lineLength","r","rLength","_iterator","_createForOfIteratorHelper","_step","s","n","done","dec","Math","max","min","err","e","f","filter","lineDecorations","lineNumber","minLineColumn","maxLineColumn","result","resultLen","len","d","range","endLineNumber","startLineNumber","isEmpty","inlineClassName","_typeCompare","ORDER","compare","typeCmp","DecorationSegment","metadata","Stack","stopOffsets","classNames","count","consumeLowerThan","maxStopOffset","nextStartOffset","push","join","_metadata","splice","insert","stopOffset","LineDecorationsNormalizer","normalize","lineContent","stack","charCodeBefore","charCodeAt","isHighSurrogate","currentStartOffset","currentEndOffset"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/lineDecorations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nexport class LineDecoration {\n    constructor(startColumn, endColumn, className, type) {\n        this.startColumn = startColumn;\n        this.endColumn = endColumn;\n        this.className = className;\n        this.type = type;\n        this._lineDecorationBrand = undefined;\n    }\n    static _equals(a, b) {\n        return (a.startColumn === b.startColumn\n            && a.endColumn === b.endColumn\n            && a.className === b.className\n            && a.type === b.type);\n    }\n    static equalsArr(a, b) {\n        const aLen = a.length;\n        const bLen = b.length;\n        if (aLen !== bLen) {\n            return false;\n        }\n        for (let i = 0; i < aLen; i++) {\n            if (!LineDecoration._equals(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static extractWrapped(arr, startOffset, endOffset) {\n        if (arr.length === 0) {\n            return arr;\n        }\n        const startColumn = startOffset + 1;\n        const endColumn = endOffset + 1;\n        const lineLength = endOffset - startOffset;\n        const r = [];\n        let rLength = 0;\n        for (const dec of arr) {\n            if (dec.endColumn <= startColumn || dec.startColumn >= endColumn) {\n                continue;\n            }\n            r[rLength++] = new LineDecoration(Math.max(1, dec.startColumn - startColumn + 1), Math.min(lineLength + 1, dec.endColumn - startColumn + 1), dec.className, dec.type);\n        }\n        return r;\n    }\n    static filter(lineDecorations, lineNumber, minLineColumn, maxLineColumn) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\n            const d = lineDecorations[i];\n            const range = d.range;\n            if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n                // Ignore decorations that sit outside this line\n                continue;\n            }\n            if (range.isEmpty() && (d.type === 0 /* InlineDecorationType.Regular */ || d.type === 3 /* InlineDecorationType.RegularAffectingLetterSpacing */)) {\n                // Ignore empty range decorations\n                continue;\n            }\n            const startColumn = (range.startLineNumber === lineNumber ? range.startColumn : minLineColumn);\n            const endColumn = (range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn);\n            result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n        }\n        return result;\n    }\n    static _typeCompare(a, b) {\n        const ORDER = [2, 0, 1, 3];\n        return ORDER[a] - ORDER[b];\n    }\n    static compare(a, b) {\n        if (a.startColumn !== b.startColumn) {\n            return a.startColumn - b.startColumn;\n        }\n        if (a.endColumn !== b.endColumn) {\n            return a.endColumn - b.endColumn;\n        }\n        const typeCmp = LineDecoration._typeCompare(a.type, b.type);\n        if (typeCmp !== 0) {\n            return typeCmp;\n        }\n        if (a.className !== b.className) {\n            return a.className < b.className ? -1 : 1;\n        }\n        return 0;\n    }\n}\nexport class DecorationSegment {\n    constructor(startOffset, endOffset, className, metadata) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.className = className;\n        this.metadata = metadata;\n    }\n}\nclass Stack {\n    constructor() {\n        this.stopOffsets = [];\n        this.classNames = [];\n        this.metadata = [];\n        this.count = 0;\n    }\n    static _metadata(metadata) {\n        let result = 0;\n        for (let i = 0, len = metadata.length; i < len; i++) {\n            result |= metadata[i];\n        }\n        return result;\n    }\n    consumeLowerThan(maxStopOffset, nextStartOffset, result) {\n        while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n            let i = 0;\n            // Take all equal stopping offsets\n            while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n                i++;\n            }\n            // Basically we are consuming the first i + 1 elements of the stack\n            result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' '), Stack._metadata(this.metadata)));\n            nextStartOffset = this.stopOffsets[i] + 1;\n            // Consume them\n            this.stopOffsets.splice(0, i + 1);\n            this.classNames.splice(0, i + 1);\n            this.metadata.splice(0, i + 1);\n            this.count -= (i + 1);\n        }\n        if (this.count > 0 && nextStartOffset < maxStopOffset) {\n            result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' '), Stack._metadata(this.metadata)));\n            nextStartOffset = maxStopOffset;\n        }\n        return nextStartOffset;\n    }\n    insert(stopOffset, className, metadata) {\n        if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n            // Insert at the end\n            this.stopOffsets.push(stopOffset);\n            this.classNames.push(className);\n            this.metadata.push(metadata);\n        }\n        else {\n            // Find the insertion position for `stopOffset`\n            for (let i = 0; i < this.count; i++) {\n                if (this.stopOffsets[i] >= stopOffset) {\n                    this.stopOffsets.splice(i, 0, stopOffset);\n                    this.classNames.splice(i, 0, className);\n                    this.metadata.splice(i, 0, metadata);\n                    break;\n                }\n            }\n        }\n        this.count++;\n        return;\n    }\n}\nexport class LineDecorationsNormalizer {\n    /**\n     * Normalize line decorations. Overlapping decorations will generate multiple segments\n     */\n    static normalize(lineContent, lineDecorations) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        const result = [];\n        const stack = new Stack();\n        let nextStartOffset = 0;\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\n            const d = lineDecorations[i];\n            let startColumn = d.startColumn;\n            let endColumn = d.endColumn;\n            const className = d.className;\n            const metadata = (d.type === 1 /* InlineDecorationType.Before */\n                ? 2 /* LinePartMetadata.PSEUDO_BEFORE */\n                : d.type === 2 /* InlineDecorationType.After */\n                    ? 4 /* LinePartMetadata.PSEUDO_AFTER */\n                    : 0);\n            // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n            if (startColumn > 1) {\n                const charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    startColumn--;\n                }\n            }\n            if (endColumn > 1) {\n                const charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    endColumn--;\n                }\n            }\n            const currentStartOffset = startColumn - 1;\n            const currentEndOffset = endColumn - 2;\n            nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n            if (stack.count === 0) {\n                nextStartOffset = currentStartOffset;\n            }\n            stack.insert(currentEndOffset, className, metadata);\n        }\n        stack.consumeLowerThan(1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, nextStartOffset, result);\n        return result;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}