{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.date.now.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport { LinesDiff } from './linesDiffComputer.js';\nimport { RangeMapping, DetailedLineRangeMapping } from './rangeMapping.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\nvar MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nexport var LegacyLinesDiffComputer = /*#__PURE__*/function () {\n  function LegacyLinesDiffComputer() {\n    _classCallCheck(this, LegacyLinesDiffComputer);\n  }\n  return _createClass(LegacyLinesDiffComputer, [{\n    key: \"computeDiff\",\n    value: function computeDiff(originalLines, modifiedLines, options) {\n      var _a;\n      var diffComputer = new DiffComputer(originalLines, modifiedLines, {\n        maxComputationTime: options.maxComputationTimeMs,\n        shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n        shouldComputeCharChanges: true,\n        shouldMakePrettyDiff: true,\n        shouldPostProcessCharChanges: true\n      });\n      var result = diffComputer.computeDiff();\n      var changes = [];\n      var lastChange = null;\n      var _iterator = _createForOfIteratorHelper(result.changes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var c = _step.value;\n          var originalRange = void 0;\n          if (c.originalEndLineNumber === 0) {\n            // Insertion\n            originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n          } else {\n            originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n          }\n          var modifiedRange = void 0;\n          if (c.modifiedEndLineNumber === 0) {\n            // Deletion\n            modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n          } else {\n            modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n          }\n          var change = new DetailedLineRangeMapping(originalRange, modifiedRange, (_a = c.charChanges) === null || _a === void 0 ? void 0 : _a.map(function (c) {\n            return new RangeMapping(new Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn));\n          }));\n          if (lastChange) {\n            if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {\n              // join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n              change = new DetailedLineRangeMapping(lastChange.original.join(change.original), lastChange.modified.join(change.modified), lastChange.innerChanges && change.innerChanges ? lastChange.innerChanges.concat(change.innerChanges) : undefined);\n              changes.pop();\n            }\n          }\n          changes.push(change);\n          lastChange = change;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      assertFn(function () {\n        return checkAdjacentItems(changes, function (m1, m2) {\n          return m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n          // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n          m1.original.endLineNumberExclusive < m2.original.startLineNumber && m1.modified.endLineNumberExclusive < m2.modified.startLineNumber;\n        });\n      });\n      return new LinesDiff(changes, [], result.quitEarly);\n    }\n  }]);\n}();\nfunction _computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n  var diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n  return diffAlgo.ComputeDiff(pretty);\n}\nvar LineSequence = /*#__PURE__*/function () {\n  function LineSequence(lines) {\n    _classCallCheck(this, LineSequence);\n    var startColumns = [];\n    var endColumns = [];\n    for (var i = 0, length = lines.length; i < length; i++) {\n      startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n      endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n    }\n    this.lines = lines;\n    this._startColumns = startColumns;\n    this._endColumns = endColumns;\n  }\n  return _createClass(LineSequence, [{\n    key: \"getElements\",\n    value: function getElements() {\n      var elements = [];\n      for (var i = 0, len = this.lines.length; i < len; i++) {\n        elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n      }\n      return elements;\n    }\n  }, {\n    key: \"getStrictElement\",\n    value: function getStrictElement(index) {\n      return this.lines[index];\n    }\n  }, {\n    key: \"getStartLineNumber\",\n    value: function getStartLineNumber(i) {\n      return i + 1;\n    }\n  }, {\n    key: \"getEndLineNumber\",\n    value: function getEndLineNumber(i) {\n      return i + 1;\n    }\n  }, {\n    key: \"createCharSequence\",\n    value: function createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n      var charCodes = [];\n      var lineNumbers = [];\n      var columns = [];\n      var len = 0;\n      for (var index = startIndex; index <= endIndex; index++) {\n        var lineContent = this.lines[index];\n        var startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1;\n        var endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1;\n        for (var col = startColumn; col < endColumn; col++) {\n          charCodes[len] = lineContent.charCodeAt(col - 1);\n          lineNumbers[len] = index + 1;\n          columns[len] = col;\n          len++;\n        }\n        if (!shouldIgnoreTrimWhitespace && index < endIndex) {\n          // Add \\n if trim whitespace is not ignored\n          charCodes[len] = 10 /* CharCode.LineFeed */;\n          lineNumbers[len] = index + 1;\n          columns[len] = lineContent.length + 1;\n          len++;\n        }\n      }\n      return new CharSequence(charCodes, lineNumbers, columns);\n    }\n  }]);\n}();\nvar CharSequence = /*#__PURE__*/function () {\n  function CharSequence(charCodes, lineNumbers, columns) {\n    _classCallCheck(this, CharSequence);\n    this._charCodes = charCodes;\n    this._lineNumbers = lineNumbers;\n    this._columns = columns;\n  }\n  return _createClass(CharSequence, [{\n    key: \"toString\",\n    value: function toString() {\n      var _this = this;\n      return '[' + this._charCodes.map(function (s, idx) {\n        return (s === 10 /* CharCode.LineFeed */ ? '\\\\n' : String.fromCharCode(s)) + \"-(\".concat(_this._lineNumbers[idx], \",\").concat(_this._columns[idx], \")\");\n      }).join(', ') + ']';\n    }\n  }, {\n    key: \"_assertIndex\",\n    value: function _assertIndex(index, arr) {\n      if (index < 0 || index >= arr.length) {\n        throw new Error(\"Illegal index\");\n      }\n    }\n  }, {\n    key: \"getElements\",\n    value: function getElements() {\n      return this._charCodes;\n    }\n  }, {\n    key: \"getStartLineNumber\",\n    value: function getStartLineNumber(i) {\n      if (i > 0 && i === this._lineNumbers.length) {\n        // the start line number of the element after the last element\n        // is the end line number of the last element\n        return this.getEndLineNumber(i - 1);\n      }\n      this._assertIndex(i, this._lineNumbers);\n      return this._lineNumbers[i];\n    }\n  }, {\n    key: \"getEndLineNumber\",\n    value: function getEndLineNumber(i) {\n      if (i === -1) {\n        // the end line number of the element before the first element\n        // is the start line number of the first element\n        return this.getStartLineNumber(i + 1);\n      }\n      this._assertIndex(i, this._lineNumbers);\n      if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n        return this._lineNumbers[i] + 1;\n      }\n      return this._lineNumbers[i];\n    }\n  }, {\n    key: \"getStartColumn\",\n    value: function getStartColumn(i) {\n      if (i > 0 && i === this._columns.length) {\n        // the start column of the element after the last element\n        // is the end column of the last element\n        return this.getEndColumn(i - 1);\n      }\n      this._assertIndex(i, this._columns);\n      return this._columns[i];\n    }\n  }, {\n    key: \"getEndColumn\",\n    value: function getEndColumn(i) {\n      if (i === -1) {\n        // the end column of the element before the first element\n        // is the start column of the first element\n        return this.getStartColumn(i + 1);\n      }\n      this._assertIndex(i, this._columns);\n      if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n        return 1;\n      }\n      return this._columns[i] + 1;\n    }\n  }]);\n}();\nvar CharChange = /*#__PURE__*/function () {\n  function CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n    _classCallCheck(this, CharChange);\n    this.originalStartLineNumber = originalStartLineNumber;\n    this.originalStartColumn = originalStartColumn;\n    this.originalEndLineNumber = originalEndLineNumber;\n    this.originalEndColumn = originalEndColumn;\n    this.modifiedStartLineNumber = modifiedStartLineNumber;\n    this.modifiedStartColumn = modifiedStartColumn;\n    this.modifiedEndLineNumber = modifiedEndLineNumber;\n    this.modifiedEndColumn = modifiedEndColumn;\n  }\n  return _createClass(CharChange, null, [{\n    key: \"createFromDiffChange\",\n    value: function createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n      var originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n      var originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n      var originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n      var originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n      var modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n      var modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n      var modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n      var modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n      return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n  }]);\n}();\nfunction postProcessCharChanges(rawChanges) {\n  if (rawChanges.length <= 1) {\n    return rawChanges;\n  }\n  var result = [rawChanges[0]];\n  var prevChange = result[0];\n  for (var i = 1, len = rawChanges.length; i < len; i++) {\n    var currChange = rawChanges[i];\n    var originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n    var modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n    // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n    var matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n    if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n      // Merge the current change into the previous one\n      prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;\n      prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;\n    } else {\n      // Add the current change\n      result.push(currChange);\n      prevChange = currChange;\n    }\n  }\n  return result;\n}\nvar LineChange = /*#__PURE__*/function () {\n  function LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n    _classCallCheck(this, LineChange);\n    this.originalStartLineNumber = originalStartLineNumber;\n    this.originalEndLineNumber = originalEndLineNumber;\n    this.modifiedStartLineNumber = modifiedStartLineNumber;\n    this.modifiedEndLineNumber = modifiedEndLineNumber;\n    this.charChanges = charChanges;\n  }\n  return _createClass(LineChange, null, [{\n    key: \"createFromDiffResult\",\n    value: function createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n      var originalStartLineNumber;\n      var originalEndLineNumber;\n      var modifiedStartLineNumber;\n      var modifiedEndLineNumber;\n      var charChanges = undefined;\n      if (diffChange.originalLength === 0) {\n        originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n        originalEndLineNumber = 0;\n      } else {\n        originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n        originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n      }\n      if (diffChange.modifiedLength === 0) {\n        modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n        modifiedEndLineNumber = 0;\n      } else {\n        modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n        modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n      }\n      if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n        // Compute character changes for diff chunks of at most 20 lines...\n        var originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n        var modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n          var rawChanges = _computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n          if (shouldPostProcessCharChanges) {\n            rawChanges = postProcessCharChanges(rawChanges);\n          }\n          charChanges = [];\n          for (var i = 0, length = rawChanges.length; i < length; i++) {\n            charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n          }\n        }\n      }\n      return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n  }]);\n}();\nexport var DiffComputer = /*#__PURE__*/function () {\n  function DiffComputer(originalLines, modifiedLines, opts) {\n    _classCallCheck(this, DiffComputer);\n    this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n    this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n    this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n    this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n    this.originalLines = originalLines;\n    this.modifiedLines = modifiedLines;\n    this.original = new LineSequence(originalLines);\n    this.modified = new LineSequence(modifiedLines);\n    this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n    this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n  }\n  return _createClass(DiffComputer, [{\n    key: \"computeDiff\",\n    value: function computeDiff() {\n      if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n        // empty original => fast path\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n          return {\n            quitEarly: false,\n            changes: []\n          };\n        }\n        return {\n          quitEarly: false,\n          changes: [{\n            originalStartLineNumber: 1,\n            originalEndLineNumber: 1,\n            modifiedStartLineNumber: 1,\n            modifiedEndLineNumber: this.modified.lines.length,\n            charChanges: undefined\n          }]\n        };\n      }\n      if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n        // empty modified => fast path\n        return {\n          quitEarly: false,\n          changes: [{\n            originalStartLineNumber: 1,\n            originalEndLineNumber: this.original.lines.length,\n            modifiedStartLineNumber: 1,\n            modifiedEndLineNumber: 1,\n            charChanges: undefined\n          }]\n        };\n      }\n      var diffResult = _computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n      var rawChanges = diffResult.changes;\n      var quitEarly = diffResult.quitEarly;\n      // The diff is always computed with ignoring trim whitespace\n      // This ensures we get the prettiest diff\n      if (this.shouldIgnoreTrimWhitespace) {\n        var lineChanges = [];\n        for (var i = 0, length = rawChanges.length; i < length; i++) {\n          lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n        }\n        return {\n          quitEarly: quitEarly,\n          changes: lineChanges\n        };\n      }\n      // Need to post-process and introduce changes where the trim whitespace is different\n      // Note that we are looping starting at -1 to also cover the lines before the first change\n      var result = [];\n      var originalLineIndex = 0;\n      var modifiedLineIndex = 0;\n      for (var _i = -1 /* !!!! */, len = rawChanges.length; _i < len; _i++) {\n        var nextChange = _i + 1 < len ? rawChanges[_i + 1] : null;\n        var originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;\n        var modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;\n        while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n          var originalLine = this.originalLines[originalLineIndex];\n          var modifiedLine = this.modifiedLines[modifiedLineIndex];\n          if (originalLine !== modifiedLine) {\n            // These lines differ only in trim whitespace\n            // Check the leading whitespace\n            {\n              var originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n              var modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n              while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                var originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                var modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                if (originalChar !== modifiedChar) {\n                  break;\n                }\n                originalStartColumn--;\n                modifiedStartColumn--;\n              }\n              if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n              }\n            }\n            // Check the trailing whitespace\n            {\n              var originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n              var modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n              var originalMaxColumn = originalLine.length + 1;\n              var modifiedMaxColumn = modifiedLine.length + 1;\n              while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                var _originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                var _modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                if (_originalChar !== _modifiedChar) {\n                  break;\n                }\n                originalEndColumn++;\n                modifiedEndColumn++;\n              }\n              if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n              }\n            }\n          }\n          originalLineIndex++;\n          modifiedLineIndex++;\n        }\n        if (nextChange) {\n          // Emit the actual change\n          result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n          originalLineIndex += nextChange.originalLength;\n          modifiedLineIndex += nextChange.modifiedLength;\n        }\n      }\n      return {\n        quitEarly: quitEarly,\n        changes: result\n      };\n    }\n  }, {\n    key: \"_pushTrimWhitespaceCharChange\",\n    value: function _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n      if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n        // Merged into previous\n        return;\n      }\n      var charChanges = undefined;\n      if (this.shouldComputeCharChanges) {\n        charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n      }\n      result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n  }, {\n    key: \"_mergeTrimWhitespaceCharChange\",\n    value: function _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n      var len = result.length;\n      if (len === 0) {\n        return false;\n      }\n      var prevChange = result[len - 1];\n      if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n        // Don't merge with inserts/deletes\n        return false;\n      }\n      if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n        if (this.shouldComputeCharChanges && prevChange.charChanges) {\n          prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n        }\n        return true;\n      }\n      if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n        prevChange.originalEndLineNumber = originalLineNumber;\n        prevChange.modifiedEndLineNumber = modifiedLineNumber;\n        if (this.shouldComputeCharChanges && prevChange.charChanges) {\n          prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n        }\n        return true;\n      }\n      return false;\n    }\n  }]);\n}();\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n  var r = strings.firstNonWhitespaceIndex(txt);\n  if (r === -1) {\n    return defaultValue;\n  }\n  return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n  var r = strings.lastNonWhitespaceIndex(txt);\n  if (r === -1) {\n    return defaultValue;\n  }\n  return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n  if (maximumRuntime === 0) {\n    return function () {\n      return true;\n    };\n  }\n  var startTime = Date.now();\n  return function () {\n    return Date.now() - startTime < maximumRuntime;\n  };\n}","map":{"version":3,"names":["LcsDiff","LinesDiff","RangeMapping","DetailedLineRangeMapping","strings","Range","assertFn","checkAdjacentItems","LineRange","MINIMUM_MATCHING_CHARACTER_LENGTH","LegacyLinesDiffComputer","_classCallCheck","_createClass","key","value","computeDiff","originalLines","modifiedLines","options","_a","diffComputer","DiffComputer","maxComputationTime","maxComputationTimeMs","shouldIgnoreTrimWhitespace","ignoreTrimWhitespace","shouldComputeCharChanges","shouldMakePrettyDiff","shouldPostProcessCharChanges","result","changes","lastChange","_iterator","_createForOfIteratorHelper","_step","s","n","done","c","originalRange","originalEndLineNumber","originalStartLineNumber","modifiedRange","modifiedEndLineNumber","modifiedStartLineNumber","change","charChanges","map","originalStartColumn","originalEndColumn","modifiedStartColumn","modifiedEndColumn","modified","endLineNumberExclusive","startLineNumber","original","join","innerChanges","concat","undefined","pop","push","err","e","f","m1","m2","quitEarly","originalSequence","modifiedSequence","continueProcessingPredicate","pretty","diffAlgo","ComputeDiff","LineSequence","lines","startColumns","endColumns","i","length","getFirstNonBlankColumn","getLastNonBlankColumn","_startColumns","_endColumns","getElements","elements","len","substring","getStrictElement","index","getStartLineNumber","getEndLineNumber","createCharSequence","startIndex","endIndex","charCodes","lineNumbers","columns","lineContent","startColumn","endColumn","col","charCodeAt","CharSequence","_charCodes","_lineNumbers","_columns","toString","_this","idx","String","fromCharCode","_assertIndex","arr","Error","getStartColumn","getEndColumn","CharChange","createFromDiffChange","diffChange","originalCharSequence","modifiedCharSequence","originalStart","originalLength","modifiedStart","modifiedLength","postProcessCharChanges","rawChanges","prevChange","currChange","originalMatchingLength","modifiedMatchingLength","matchingLength","Math","min","LineChange","createFromDiffResult","originalLineSequence","modifiedLineSequence","continueCharDiff","opts","continueLineDiff","createContinueProcessingPredicate","diffResult","lineChanges","originalLineIndex","modifiedLineIndex","nextChange","originalStop","modifiedStop","originalLine","modifiedLine","originalChar","modifiedChar","_pushTrimWhitespaceCharChange","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","_mergeTrimWhitespaceCharChange","txt","defaultValue","r","firstNonWhitespaceIndex","lastNonWhitespaceIndex","maximumRuntime","startTime","Date","now"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport { LinesDiff } from './linesDiffComputer.js';\nimport { RangeMapping, DetailedLineRangeMapping } from './rangeMapping.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nexport class LegacyLinesDiffComputer {\n    computeDiff(originalLines, modifiedLines, options) {\n        var _a;\n        const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n            maxComputationTime: options.maxComputationTimeMs,\n            shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n            shouldComputeCharChanges: true,\n            shouldMakePrettyDiff: true,\n            shouldPostProcessCharChanges: true,\n        });\n        const result = diffComputer.computeDiff();\n        const changes = [];\n        let lastChange = null;\n        for (const c of result.changes) {\n            let originalRange;\n            if (c.originalEndLineNumber === 0) {\n                // Insertion\n                originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n            }\n            else {\n                originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n            }\n            let modifiedRange;\n            if (c.modifiedEndLineNumber === 0) {\n                // Deletion\n                modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n            }\n            else {\n                modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n            }\n            let change = new DetailedLineRangeMapping(originalRange, modifiedRange, (_a = c.charChanges) === null || _a === void 0 ? void 0 : _a.map(c => new RangeMapping(new Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn))));\n            if (lastChange) {\n                if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber\n                    || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {\n                    // join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n                    change = new DetailedLineRangeMapping(lastChange.original.join(change.original), lastChange.modified.join(change.modified), lastChange.innerChanges && change.innerChanges ?\n                        lastChange.innerChanges.concat(change.innerChanges) : undefined);\n                    changes.pop();\n                }\n            }\n            changes.push(change);\n            lastChange = change;\n        }\n        assertFn(() => {\n            return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n                // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n                m1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n                m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);\n        });\n        return new LinesDiff(changes, [], result.quitEarly);\n    }\n}\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n            if (!shouldIgnoreTrimWhitespace && index < endIndex) {\n                // Add \\n if trim whitespace is not ignored\n                charCodes[len] = 10 /* CharCode.LineFeed */;\n                lineNumbers[len] = index + 1;\n                columns[len] = lineContent.length + 1;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    toString() {\n        return ('[' + this._charCodes.map((s, idx) => (s === 10 /* CharCode.LineFeed */ ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']');\n    }\n    _assertIndex(index, arr) {\n        if (index < 0 || index >= arr.length) {\n            throw new Error(`Illegal index`);\n        }\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        if (i > 0 && i === this._lineNumbers.length) {\n            // the start line number of the element after the last element\n            // is the end line number of the last element\n            return this.getEndLineNumber(i - 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        return this._lineNumbers[i];\n    }\n    getEndLineNumber(i) {\n        if (i === -1) {\n            // the end line number of the element before the first element\n            // is the start line number of the first element\n            return this.getStartLineNumber(i + 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return this._lineNumbers[i] + 1;\n        }\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        if (i > 0 && i === this._columns.length) {\n            // the start column of the element after the last element\n            // is the end column of the last element\n            return this.getEndColumn(i - 1);\n        }\n        this._assertIndex(i, this._columns);\n        return this._columns[i];\n    }\n    getEndColumn(i) {\n        if (i === -1) {\n            // the end column of the element before the first element\n            // is the start column of the first element\n            return this.getStartColumn(i + 1);\n        }\n        this._assertIndex(i, this._columns);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return 1;\n        }\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n                let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n                if (shouldPostProcessCharChanges) {\n                    rawChanges = postProcessCharChanges(rawChanges);\n                }\n                charChanges = [];\n                for (let i = 0, length = rawChanges.length; i < length; i++) {\n                    charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n                }\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nexport class DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = strings.firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = strings.lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}