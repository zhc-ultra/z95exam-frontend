{"ast":null,"code":"/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.48.0(0037b13fb5d186fdf1e7df51a9416a2de2b8c670)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\n// src/basic-languages/elixir/elixir.ts\nvar conf = {\n  comments: {\n    lineComment: \"#\"\n  },\n  brackets: [[\"{\", \"}\"], [\"[\", \"]\"], [\"(\", \")\"]],\n  surroundingPairs: [{\n    open: \"{\",\n    close: \"}\"\n  }, {\n    open: \"[\",\n    close: \"]\"\n  }, {\n    open: \"(\",\n    close: \")\"\n  }, {\n    open: \"'\",\n    close: \"'\"\n  }, {\n    open: '\"',\n    close: '\"'\n  }],\n  autoClosingPairs: [{\n    open: \"'\",\n    close: \"'\",\n    notIn: [\"string\", \"comment\"]\n  }, {\n    open: '\"',\n    close: '\"',\n    notIn: [\"comment\"]\n  }, {\n    open: '\"\"\"',\n    close: '\"\"\"'\n  }, {\n    open: \"`\",\n    close: \"`\",\n    notIn: [\"string\", \"comment\"]\n  }, {\n    open: \"(\",\n    close: \")\"\n  }, {\n    open: \"{\",\n    close: \"}\"\n  }, {\n    open: \"[\",\n    close: \"]\"\n  }, {\n    open: \"<<\",\n    close: \">>\"\n  }],\n  indentationRules: {\n    increaseIndentPattern: /^\\s*(after|else|catch|rescue|fn|[^#]*(do|<\\-|\\->|\\{|\\[|\\=))\\s*$/,\n    decreaseIndentPattern: /^\\s*((\\}|\\])\\s*$|(after|else|catch|rescue|end)\\b)/\n  }\n};\nvar language = {\n  defaultToken: \"source\",\n  tokenPostfix: \".elixir\",\n  brackets: [{\n    open: \"[\",\n    close: \"]\",\n    token: \"delimiter.square\"\n  }, {\n    open: \"(\",\n    close: \")\",\n    token: \"delimiter.parenthesis\"\n  }, {\n    open: \"{\",\n    close: \"}\",\n    token: \"delimiter.curly\"\n  }, {\n    open: \"<<\",\n    close: \">>\",\n    token: \"delimiter.angle.special\"\n  }],\n  // Below are lists/regexps to which we reference later.\n  declarationKeywords: [\"def\", \"defp\", \"defn\", \"defnp\", \"defguard\", \"defguardp\", \"defmacro\", \"defmacrop\", \"defdelegate\", \"defcallback\", \"defmacrocallback\", \"defmodule\", \"defprotocol\", \"defexception\", \"defimpl\", \"defstruct\"],\n  operatorKeywords: [\"and\", \"in\", \"not\", \"or\", \"when\"],\n  namespaceKeywords: [\"alias\", \"import\", \"require\", \"use\"],\n  otherKeywords: [\"after\", \"case\", \"catch\", \"cond\", \"do\", \"else\", \"end\", \"fn\", \"for\", \"if\", \"quote\", \"raise\", \"receive\", \"rescue\", \"super\", \"throw\", \"try\", \"unless\", \"unquote_splicing\", \"unquote\", \"with\"],\n  constants: [\"true\", \"false\", \"nil\"],\n  nameBuiltin: [\"__MODULE__\", \"__DIR__\", \"__ENV__\", \"__CALLER__\", \"__STACKTRACE__\"],\n  // Matches any of the operator names:\n  // <<< >>> ||| &&& ^^^ ~~~ === !== ~>> <~> |~> <|> == != <= >= && || \\\\ <> ++ -- |> =~ -> <- ~> <~ :: .. = < > + - * / | . ^ & !\n  operator: /-[->]?|!={0,2}|\\*{1,2}|\\/|\\\\\\\\|&{1,3}|\\.\\.?|\\^(?:\\^\\^)?|\\+\\+?|<(?:-|<<|=|>|\\|>|~>?)?|=~|={1,3}|>(?:=|>>)?|\\|~>|\\|>|\\|{1,3}|~>>?|~~~|::/,\n  // See https://hexdocs.pm/elixir/syntax-reference.html#variables\n  variableName: /[a-z_][a-zA-Z0-9_]*[?!]?/,\n  // See https://hexdocs.pm/elixir/syntax-reference.html#atoms\n  atomName: /[a-zA-Z_][a-zA-Z0-9_@]*[?!]?|@specialAtomName|@operator/,\n  specialAtomName: /\\.\\.\\.|<<>>|%\\{\\}|%|\\{\\}/,\n  aliasPart: /[A-Z][a-zA-Z0-9_]*/,\n  moduleName: /@aliasPart(?:\\.@aliasPart)*/,\n  // Sigil pairs are: \"\"\" \"\"\", ''' ''', \" \", ' ', / /, | |, < >, { }, [ ], ( )\n  sigilSymmetricDelimiter: /\"\"\"|'''|\"|'|\\/|\\|/,\n  sigilStartDelimiter: /@sigilSymmetricDelimiter|<|\\{|\\[|\\(/,\n  sigilEndDelimiter: /@sigilSymmetricDelimiter|>|\\}|\\]|\\)/,\n  sigilModifiers: /[a-zA-Z0-9]*/,\n  decimal: /\\d(?:_?\\d)*/,\n  hex: /[0-9a-fA-F](_?[0-9a-fA-F])*/,\n  octal: /[0-7](_?[0-7])*/,\n  binary: /[01](_?[01])*/,\n  // See https://hexdocs.pm/elixir/master/String.html#module-escape-characters\n  escape: /\\\\u[0-9a-fA-F]{4}|\\\\x[0-9a-fA-F]{2}|\\\\./,\n  // The keys below correspond to tokenizer states.\n  // We start from the root state and match against its rules\n  // until we explicitly transition into another state.\n  // The `include` simply brings in all operations from the given state\n  // and is useful for improving readability.\n  tokenizer: {\n    root: [{\n      include: \"@whitespace\"\n    }, {\n      include: \"@comments\"\n    },\n    // Keywords start as either an identifier or a string,\n    // but end with a : so it's important to match this first.\n    {\n      include: \"@keywordsShorthand\"\n    }, {\n      include: \"@numbers\"\n    }, {\n      include: \"@identifiers\"\n    }, {\n      include: \"@strings\"\n    }, {\n      include: \"@atoms\"\n    }, {\n      include: \"@sigils\"\n    }, {\n      include: \"@attributes\"\n    }, {\n      include: \"@symbols\"\n    }],\n    // Whitespace\n    whitespace: [[/\\s+/, \"white\"]],\n    // Comments\n    comments: [[/(#)(.*)/, [\"comment.punctuation\", \"comment\"]]],\n    // Keyword list shorthand\n    keywordsShorthand: [[/(@atomName)(:)(\\s+)/, [\"constant\", \"constant.punctuation\", \"white\"]],\n    // Use positive look-ahead to ensure the string is followed by :\n    // and should be considered a keyword.\n    [/\"(?=([^\"]|#\\{.*?\\}|\\\\\")*\":)/, {\n      token: \"constant.delimiter\",\n      next: \"@doubleQuotedStringKeyword\"\n    }], [/'(?=([^']|#\\{.*?\\}|\\\\')*':)/, {\n      token: \"constant.delimiter\",\n      next: \"@singleQuotedStringKeyword\"\n    }]],\n    doubleQuotedStringKeyword: [[/\":/, {\n      token: \"constant.delimiter\",\n      next: \"@pop\"\n    }], {\n      include: \"@stringConstantContentInterpol\"\n    }],\n    singleQuotedStringKeyword: [[/':/, {\n      token: \"constant.delimiter\",\n      next: \"@pop\"\n    }], {\n      include: \"@stringConstantContentInterpol\"\n    }],\n    // Numbers\n    numbers: [[/0b@binary/, \"number.binary\"], [/0o@octal/, \"number.octal\"], [/0x@hex/, \"number.hex\"], [/@decimal\\.@decimal([eE]-?@decimal)?/, \"number.float\"], [/@decimal/, \"number\"]],\n    // Identifiers\n    identifiers: [\n    // Tokenize identifier name in function-like definitions.\n    // Note: given `def a + b, do: nil`, `a` is not a function name,\n    // so we use negative look-ahead to ensure there's no operator.\n    [/\\b(defp?|defnp?|defmacrop?|defguardp?|defdelegate)(\\s+)(@variableName)(?!\\s+@operator)/, [\"keyword.declaration\", \"white\", {\n      cases: {\n        unquote: \"keyword\",\n        \"@default\": \"function\"\n      }\n    }]],\n    // Tokenize function calls\n    [\n    // In-scope call - an identifier followed by ( or .(\n    /(@variableName)(?=\\s*\\.?\\s*\\()/, {\n      cases: {\n        // Tokenize as keyword in cases like `if(..., do: ..., else: ...)`\n        \"@declarationKeywords\": \"keyword.declaration\",\n        \"@namespaceKeywords\": \"keyword\",\n        \"@otherKeywords\": \"keyword\",\n        \"@default\": \"function.call\"\n      }\n    }], [\n    // Referencing function in a module\n    /(@moduleName)(\\s*)(\\.)(\\s*)(@variableName)/, [\"type.identifier\", \"white\", \"operator\", \"white\", \"function.call\"]], [\n    // Referencing function in an Erlang module\n    /(:)(@atomName)(\\s*)(\\.)(\\s*)(@variableName)/, [\"constant.punctuation\", \"constant\", \"white\", \"operator\", \"white\", \"function.call\"]], [\n    // Piping into a function (tokenized separately as it may not have parentheses)\n    /(\\|>)(\\s*)(@variableName)/, [\"operator\", \"white\", {\n      cases: {\n        \"@otherKeywords\": \"keyword\",\n        \"@default\": \"function.call\"\n      }\n    }]], [\n    // Function reference passed to another function\n    /(&)(\\s*)(@variableName)/, [\"operator\", \"white\", \"function.call\"]],\n    // Language keywords, builtins, constants and variables\n    [/@variableName/, {\n      cases: {\n        \"@declarationKeywords\": \"keyword.declaration\",\n        \"@operatorKeywords\": \"keyword.operator\",\n        \"@namespaceKeywords\": \"keyword\",\n        \"@otherKeywords\": \"keyword\",\n        \"@constants\": \"constant.language\",\n        \"@nameBuiltin\": \"variable.language\",\n        \"_.*\": \"comment.unused\",\n        \"@default\": \"identifier\"\n      }\n    }],\n    // Module names\n    [/@moduleName/, \"type.identifier\"]],\n    // Strings\n    strings: [[/\"\"\"/, {\n      token: \"string.delimiter\",\n      next: \"@doubleQuotedHeredoc\"\n    }], [/'''/, {\n      token: \"string.delimiter\",\n      next: \"@singleQuotedHeredoc\"\n    }], [/\"/, {\n      token: \"string.delimiter\",\n      next: \"@doubleQuotedString\"\n    }], [/'/, {\n      token: \"string.delimiter\",\n      next: \"@singleQuotedString\"\n    }]],\n    doubleQuotedHeredoc: [[/\"\"\"/, {\n      token: \"string.delimiter\",\n      next: \"@pop\"\n    }], {\n      include: \"@stringContentInterpol\"\n    }],\n    singleQuotedHeredoc: [[/'''/, {\n      token: \"string.delimiter\",\n      next: \"@pop\"\n    }], {\n      include: \"@stringContentInterpol\"\n    }],\n    doubleQuotedString: [[/\"/, {\n      token: \"string.delimiter\",\n      next: \"@pop\"\n    }], {\n      include: \"@stringContentInterpol\"\n    }],\n    singleQuotedString: [[/'/, {\n      token: \"string.delimiter\",\n      next: \"@pop\"\n    }], {\n      include: \"@stringContentInterpol\"\n    }],\n    // Atoms\n    atoms: [[/(:)(@atomName)/, [\"constant.punctuation\", \"constant\"]], [/:\"/, {\n      token: \"constant.delimiter\",\n      next: \"@doubleQuotedStringAtom\"\n    }], [/:'/, {\n      token: \"constant.delimiter\",\n      next: \"@singleQuotedStringAtom\"\n    }]],\n    doubleQuotedStringAtom: [[/\"/, {\n      token: \"constant.delimiter\",\n      next: \"@pop\"\n    }], {\n      include: \"@stringConstantContentInterpol\"\n    }],\n    singleQuotedStringAtom: [[/'/, {\n      token: \"constant.delimiter\",\n      next: \"@pop\"\n    }], {\n      include: \"@stringConstantContentInterpol\"\n    }],\n    // Sigils\n    // See https://elixir-lang.org/getting-started/sigils.html\n    // Sigils allow for typing values using their textual representation.\n    // All sigils start with ~ followed by a letter or\n    // multi-letter uppercase starting at Elixir v1.15.0, indicating sigil type\n    // and then a delimiter pair enclosing the textual representation.\n    // Optional modifiers are allowed after the closing delimiter.\n    // For instance a regular expressions can be written as:\n    // ~r/foo|bar/ ~r{foo|bar} ~r/foo|bar/g\n    //\n    // In general lowercase sigils allow for interpolation\n    // and escaped characters, whereas uppercase sigils don't\n    //\n    // During tokenization we want to distinguish some\n    // specific sigil types, namely string and regexp,\n    // so that they cen be themed separately.\n    //\n    // To reasonably handle all those combinations we leverage\n    // dot-separated states, so if we transition to @sigilStart.interpol.s.{.}\n    // then \"sigilStart.interpol.s\" state will match and also all\n    // the individual dot-separated parameters can be accessed.\n    sigils: [[/~[a-z]@sigilStartDelimiter/, {\n      token: \"@rematch\",\n      next: \"@sigil.interpol\"\n    }], [/~([A-Z]+)@sigilStartDelimiter/, {\n      token: \"@rematch\",\n      next: \"@sigil.noInterpol\"\n    }]],\n    sigil: [[/~([a-z]|[A-Z]+)\\{/, {\n      token: \"@rematch\",\n      switchTo: \"@sigilStart.$S2.$1.{.}\"\n    }], [/~([a-z]|[A-Z]+)\\[/, {\n      token: \"@rematch\",\n      switchTo: \"@sigilStart.$S2.$1.[.]\"\n    }], [/~([a-z]|[A-Z]+)\\(/, {\n      token: \"@rematch\",\n      switchTo: \"@sigilStart.$S2.$1.(.)\"\n    }], [/~([a-z]|[A-Z]+)\\</, {\n      token: \"@rematch\",\n      switchTo: \"@sigilStart.$S2.$1.<.>\"\n    }], [/~([a-z]|[A-Z]+)(@sigilSymmetricDelimiter)/, {\n      token: \"@rematch\",\n      switchTo: \"@sigilStart.$S2.$1.$2.$2\"\n    }]],\n    // The definitions below expect states to be of the form:\n    //\n    // sigilStart.<interpol-or-noInterpol>.<sigil-letter>.<start-delimiter>.<end-delimiter>\n    // sigilContinue.<interpol-or-noInterpol>.<sigil-letter>.<start-delimiter>.<end-delimiter>\n    //\n    // The sigilStart state is used only to properly classify the token (as string/regex/sigil)\n    // and immediately switches to the sigilContinue sate, which handles the actual content\n    // and waits for the corresponding end delimiter.\n    \"sigilStart.interpol.s\": [[/~s@sigilStartDelimiter/, {\n      token: \"string.delimiter\",\n      switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n    }]],\n    \"sigilContinue.interpol.s\": [[/(@sigilEndDelimiter)@sigilModifiers/, {\n      cases: {\n        \"$1==$S5\": {\n          token: \"string.delimiter\",\n          next: \"@pop\"\n        },\n        \"@default\": \"string\"\n      }\n    }], {\n      include: \"@stringContentInterpol\"\n    }],\n    \"sigilStart.noInterpol.S\": [[/~S@sigilStartDelimiter/, {\n      token: \"string.delimiter\",\n      switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n    }]],\n    \"sigilContinue.noInterpol.S\": [\n    // Ignore escaped sigil end\n    [/(^|[^\\\\])\\\\@sigilEndDelimiter/, \"string\"], [/(@sigilEndDelimiter)@sigilModifiers/, {\n      cases: {\n        \"$1==$S5\": {\n          token: \"string.delimiter\",\n          next: \"@pop\"\n        },\n        \"@default\": \"string\"\n      }\n    }], {\n      include: \"@stringContent\"\n    }],\n    \"sigilStart.interpol.r\": [[/~r@sigilStartDelimiter/, {\n      token: \"regexp.delimiter\",\n      switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n    }]],\n    \"sigilContinue.interpol.r\": [[/(@sigilEndDelimiter)@sigilModifiers/, {\n      cases: {\n        \"$1==$S5\": {\n          token: \"regexp.delimiter\",\n          next: \"@pop\"\n        },\n        \"@default\": \"regexp\"\n      }\n    }], {\n      include: \"@regexpContentInterpol\"\n    }],\n    \"sigilStart.noInterpol.R\": [[/~R@sigilStartDelimiter/, {\n      token: \"regexp.delimiter\",\n      switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n    }]],\n    \"sigilContinue.noInterpol.R\": [\n    // Ignore escaped sigil end\n    [/(^|[^\\\\])\\\\@sigilEndDelimiter/, \"regexp\"], [/(@sigilEndDelimiter)@sigilModifiers/, {\n      cases: {\n        \"$1==$S5\": {\n          token: \"regexp.delimiter\",\n          next: \"@pop\"\n        },\n        \"@default\": \"regexp\"\n      }\n    }], {\n      include: \"@regexpContent\"\n    }],\n    // Fallback to the generic sigil by default\n    \"sigilStart.interpol\": [[/~([a-z]|[A-Z]+)@sigilStartDelimiter/, {\n      token: \"sigil.delimiter\",\n      switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n    }]],\n    \"sigilContinue.interpol\": [[/(@sigilEndDelimiter)@sigilModifiers/, {\n      cases: {\n        \"$1==$S5\": {\n          token: \"sigil.delimiter\",\n          next: \"@pop\"\n        },\n        \"@default\": \"sigil\"\n      }\n    }], {\n      include: \"@sigilContentInterpol\"\n    }],\n    \"sigilStart.noInterpol\": [[/~([a-z]|[A-Z]+)@sigilStartDelimiter/, {\n      token: \"sigil.delimiter\",\n      switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n    }]],\n    \"sigilContinue.noInterpol\": [\n    // Ignore escaped sigil end\n    [/(^|[^\\\\])\\\\@sigilEndDelimiter/, \"sigil\"], [/(@sigilEndDelimiter)@sigilModifiers/, {\n      cases: {\n        \"$1==$S5\": {\n          token: \"sigil.delimiter\",\n          next: \"@pop\"\n        },\n        \"@default\": \"sigil\"\n      }\n    }], {\n      include: \"@sigilContent\"\n    }],\n    // Attributes\n    attributes: [\n    // Module @doc* attributes - tokenized as comments\n    [/\\@(module|type)?doc (~[sS])?\"\"\"/, {\n      token: \"comment.block.documentation\",\n      next: \"@doubleQuotedHeredocDocstring\"\n    }], [/\\@(module|type)?doc (~[sS])?'''/, {\n      token: \"comment.block.documentation\",\n      next: \"@singleQuotedHeredocDocstring\"\n    }], [/\\@(module|type)?doc (~[sS])?\"/, {\n      token: \"comment.block.documentation\",\n      next: \"@doubleQuotedStringDocstring\"\n    }], [/\\@(module|type)?doc (~[sS])?'/, {\n      token: \"comment.block.documentation\",\n      next: \"@singleQuotedStringDocstring\"\n    }], [/\\@(module|type)?doc false/, \"comment.block.documentation\"],\n    // Module attributes\n    [/\\@(@variableName)/, \"variable\"]],\n    doubleQuotedHeredocDocstring: [[/\"\"\"/, {\n      token: \"comment.block.documentation\",\n      next: \"@pop\"\n    }], {\n      include: \"@docstringContent\"\n    }],\n    singleQuotedHeredocDocstring: [[/'''/, {\n      token: \"comment.block.documentation\",\n      next: \"@pop\"\n    }], {\n      include: \"@docstringContent\"\n    }],\n    doubleQuotedStringDocstring: [[/\"/, {\n      token: \"comment.block.documentation\",\n      next: \"@pop\"\n    }], {\n      include: \"@docstringContent\"\n    }],\n    singleQuotedStringDocstring: [[/'/, {\n      token: \"comment.block.documentation\",\n      next: \"@pop\"\n    }], {\n      include: \"@docstringContent\"\n    }],\n    // Operators, punctuation, brackets\n    symbols: [\n    // Code point operator (either with regular character ?a or an escaped one ?\\n)\n    [/\\?(\\\\.|[^\\\\\\s])/, \"number.constant\"],\n    // Anonymous function arguments\n    [/&\\d+/, \"operator\"],\n    // Bitshift operators (must go before delimiters, so that << >> don't match first)\n    [/<<<|>>>/, \"operator\"],\n    // Delimiter pairs\n    [/[()\\[\\]\\{\\}]|<<|>>/, \"@brackets\"],\n    // Triple dot is a valid name (must go before operators, so that .. doesn't match instead)\n    [/\\.\\.\\./, \"identifier\"],\n    // Punctuation => (must go before operators, so it's not tokenized as = then >)\n    [/=>/, \"punctuation\"],\n    // Operators\n    [/@operator/, \"operator\"],\n    // Punctuation\n    [/[:;,.%]/, \"punctuation\"]],\n    // Generic helpers\n    stringContentInterpol: [{\n      include: \"@interpolation\"\n    }, {\n      include: \"@escapeChar\"\n    }, {\n      include: \"@stringContent\"\n    }],\n    stringContent: [[/./, \"string\"]],\n    stringConstantContentInterpol: [{\n      include: \"@interpolation\"\n    }, {\n      include: \"@escapeChar\"\n    }, {\n      include: \"@stringConstantContent\"\n    }],\n    stringConstantContent: [[/./, \"constant\"]],\n    regexpContentInterpol: [{\n      include: \"@interpolation\"\n    }, {\n      include: \"@escapeChar\"\n    }, {\n      include: \"@regexpContent\"\n    }],\n    regexpContent: [\n    // # may be a regular regexp char, so we use a heuristic\n    // assuming a # surrounded by whitespace is actually a comment.\n    [/(\\s)(#)(\\s.*)$/, [\"white\", \"comment.punctuation\", \"comment\"]], [/./, \"regexp\"]],\n    sigilContentInterpol: [{\n      include: \"@interpolation\"\n    }, {\n      include: \"@escapeChar\"\n    }, {\n      include: \"@sigilContent\"\n    }],\n    sigilContent: [[/./, \"sigil\"]],\n    docstringContent: [[/./, \"comment.block.documentation\"]],\n    escapeChar: [[/@escape/, \"constant.character.escape\"]],\n    interpolation: [[/#{/, {\n      token: \"delimiter.bracket.embed\",\n      next: \"@interpolationContinue\"\n    }]],\n    interpolationContinue: [[/}/, {\n      token: \"delimiter.bracket.embed\",\n      next: \"@pop\"\n    }],\n    // Interpolation brackets may contain arbitrary code,\n    // so we simply match against all the root rules,\n    // until we reach interpolation end (the above matches).\n    {\n      include: \"@root\"\n    }]\n  }\n};\nexport { conf, language };","map":{"version":3,"names":["conf","comments","lineComment","brackets","surroundingPairs","open","close","autoClosingPairs","notIn","indentationRules","increaseIndentPattern","decreaseIndentPattern","language","defaultToken","tokenPostfix","token","declarationKeywords","operatorKeywords","namespaceKeywords","otherKeywords","constants","nameBuiltin","operator","variableName","atomName","specialAtomName","aliasPart","moduleName","sigilSymmetricDelimiter","sigilStartDelimiter","sigilEndDelimiter","sigilModifiers","decimal","hex","octal","binary","escape","tokenizer","root","include","whitespace","keywordsShorthand","next","doubleQuotedStringKeyword","singleQuotedStringKeyword","numbers","identifiers","cases","unquote","strings","doubleQuotedHeredoc","singleQuotedHeredoc","doubleQuotedString","singleQuotedString","atoms","doubleQuotedStringAtom","singleQuotedStringAtom","sigils","sigil","switchTo","attributes","doubleQuotedHeredocDocstring","singleQuotedHeredocDocstring","doubleQuotedStringDocstring","singleQuotedStringDocstring","symbols","stringContentInterpol","stringContent","stringConstantContentInterpol","stringConstantContent","regexpContentInterpol","regexpContent","sigilContentInterpol","sigilContent","docstringContent","escapeChar","interpolation","interpolationContinue"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.js"],"sourcesContent":["/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.48.0(0037b13fb5d186fdf1e7df51a9416a2de2b8c670)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\n\n// src/basic-languages/elixir/elixir.ts\nvar conf = {\n  comments: {\n    lineComment: \"#\"\n  },\n  brackets: [\n    [\"{\", \"}\"],\n    [\"[\", \"]\"],\n    [\"(\", \")\"]\n  ],\n  surroundingPairs: [\n    { open: \"{\", close: \"}\" },\n    { open: \"[\", close: \"]\" },\n    { open: \"(\", close: \")\" },\n    { open: \"'\", close: \"'\" },\n    { open: '\"', close: '\"' }\n  ],\n  autoClosingPairs: [\n    { open: \"'\", close: \"'\", notIn: [\"string\", \"comment\"] },\n    { open: '\"', close: '\"', notIn: [\"comment\"] },\n    { open: '\"\"\"', close: '\"\"\"' },\n    { open: \"`\", close: \"`\", notIn: [\"string\", \"comment\"] },\n    { open: \"(\", close: \")\" },\n    { open: \"{\", close: \"}\" },\n    { open: \"[\", close: \"]\" },\n    { open: \"<<\", close: \">>\" }\n  ],\n  indentationRules: {\n    increaseIndentPattern: /^\\s*(after|else|catch|rescue|fn|[^#]*(do|<\\-|\\->|\\{|\\[|\\=))\\s*$/,\n    decreaseIndentPattern: /^\\s*((\\}|\\])\\s*$|(after|else|catch|rescue|end)\\b)/\n  }\n};\nvar language = {\n  defaultToken: \"source\",\n  tokenPostfix: \".elixir\",\n  brackets: [\n    { open: \"[\", close: \"]\", token: \"delimiter.square\" },\n    { open: \"(\", close: \")\", token: \"delimiter.parenthesis\" },\n    { open: \"{\", close: \"}\", token: \"delimiter.curly\" },\n    { open: \"<<\", close: \">>\", token: \"delimiter.angle.special\" }\n  ],\n  // Below are lists/regexps to which we reference later.\n  declarationKeywords: [\n    \"def\",\n    \"defp\",\n    \"defn\",\n    \"defnp\",\n    \"defguard\",\n    \"defguardp\",\n    \"defmacro\",\n    \"defmacrop\",\n    \"defdelegate\",\n    \"defcallback\",\n    \"defmacrocallback\",\n    \"defmodule\",\n    \"defprotocol\",\n    \"defexception\",\n    \"defimpl\",\n    \"defstruct\"\n  ],\n  operatorKeywords: [\"and\", \"in\", \"not\", \"or\", \"when\"],\n  namespaceKeywords: [\"alias\", \"import\", \"require\", \"use\"],\n  otherKeywords: [\n    \"after\",\n    \"case\",\n    \"catch\",\n    \"cond\",\n    \"do\",\n    \"else\",\n    \"end\",\n    \"fn\",\n    \"for\",\n    \"if\",\n    \"quote\",\n    \"raise\",\n    \"receive\",\n    \"rescue\",\n    \"super\",\n    \"throw\",\n    \"try\",\n    \"unless\",\n    \"unquote_splicing\",\n    \"unquote\",\n    \"with\"\n  ],\n  constants: [\"true\", \"false\", \"nil\"],\n  nameBuiltin: [\"__MODULE__\", \"__DIR__\", \"__ENV__\", \"__CALLER__\", \"__STACKTRACE__\"],\n  // Matches any of the operator names:\n  // <<< >>> ||| &&& ^^^ ~~~ === !== ~>> <~> |~> <|> == != <= >= && || \\\\ <> ++ -- |> =~ -> <- ~> <~ :: .. = < > + - * / | . ^ & !\n  operator: /-[->]?|!={0,2}|\\*{1,2}|\\/|\\\\\\\\|&{1,3}|\\.\\.?|\\^(?:\\^\\^)?|\\+\\+?|<(?:-|<<|=|>|\\|>|~>?)?|=~|={1,3}|>(?:=|>>)?|\\|~>|\\|>|\\|{1,3}|~>>?|~~~|::/,\n  // See https://hexdocs.pm/elixir/syntax-reference.html#variables\n  variableName: /[a-z_][a-zA-Z0-9_]*[?!]?/,\n  // See https://hexdocs.pm/elixir/syntax-reference.html#atoms\n  atomName: /[a-zA-Z_][a-zA-Z0-9_@]*[?!]?|@specialAtomName|@operator/,\n  specialAtomName: /\\.\\.\\.|<<>>|%\\{\\}|%|\\{\\}/,\n  aliasPart: /[A-Z][a-zA-Z0-9_]*/,\n  moduleName: /@aliasPart(?:\\.@aliasPart)*/,\n  // Sigil pairs are: \"\"\" \"\"\", ''' ''', \" \", ' ', / /, | |, < >, { }, [ ], ( )\n  sigilSymmetricDelimiter: /\"\"\"|'''|\"|'|\\/|\\|/,\n  sigilStartDelimiter: /@sigilSymmetricDelimiter|<|\\{|\\[|\\(/,\n  sigilEndDelimiter: /@sigilSymmetricDelimiter|>|\\}|\\]|\\)/,\n  sigilModifiers: /[a-zA-Z0-9]*/,\n  decimal: /\\d(?:_?\\d)*/,\n  hex: /[0-9a-fA-F](_?[0-9a-fA-F])*/,\n  octal: /[0-7](_?[0-7])*/,\n  binary: /[01](_?[01])*/,\n  // See https://hexdocs.pm/elixir/master/String.html#module-escape-characters\n  escape: /\\\\u[0-9a-fA-F]{4}|\\\\x[0-9a-fA-F]{2}|\\\\./,\n  // The keys below correspond to tokenizer states.\n  // We start from the root state and match against its rules\n  // until we explicitly transition into another state.\n  // The `include` simply brings in all operations from the given state\n  // and is useful for improving readability.\n  tokenizer: {\n    root: [\n      { include: \"@whitespace\" },\n      { include: \"@comments\" },\n      // Keywords start as either an identifier or a string,\n      // but end with a : so it's important to match this first.\n      { include: \"@keywordsShorthand\" },\n      { include: \"@numbers\" },\n      { include: \"@identifiers\" },\n      { include: \"@strings\" },\n      { include: \"@atoms\" },\n      { include: \"@sigils\" },\n      { include: \"@attributes\" },\n      { include: \"@symbols\" }\n    ],\n    // Whitespace\n    whitespace: [[/\\s+/, \"white\"]],\n    // Comments\n    comments: [[/(#)(.*)/, [\"comment.punctuation\", \"comment\"]]],\n    // Keyword list shorthand\n    keywordsShorthand: [\n      [/(@atomName)(:)(\\s+)/, [\"constant\", \"constant.punctuation\", \"white\"]],\n      // Use positive look-ahead to ensure the string is followed by :\n      // and should be considered a keyword.\n      [\n        /\"(?=([^\"]|#\\{.*?\\}|\\\\\")*\":)/,\n        { token: \"constant.delimiter\", next: \"@doubleQuotedStringKeyword\" }\n      ],\n      [\n        /'(?=([^']|#\\{.*?\\}|\\\\')*':)/,\n        { token: \"constant.delimiter\", next: \"@singleQuotedStringKeyword\" }\n      ]\n    ],\n    doubleQuotedStringKeyword: [\n      [/\":/, { token: \"constant.delimiter\", next: \"@pop\" }],\n      { include: \"@stringConstantContentInterpol\" }\n    ],\n    singleQuotedStringKeyword: [\n      [/':/, { token: \"constant.delimiter\", next: \"@pop\" }],\n      { include: \"@stringConstantContentInterpol\" }\n    ],\n    // Numbers\n    numbers: [\n      [/0b@binary/, \"number.binary\"],\n      [/0o@octal/, \"number.octal\"],\n      [/0x@hex/, \"number.hex\"],\n      [/@decimal\\.@decimal([eE]-?@decimal)?/, \"number.float\"],\n      [/@decimal/, \"number\"]\n    ],\n    // Identifiers\n    identifiers: [\n      // Tokenize identifier name in function-like definitions.\n      // Note: given `def a + b, do: nil`, `a` is not a function name,\n      // so we use negative look-ahead to ensure there's no operator.\n      [\n        /\\b(defp?|defnp?|defmacrop?|defguardp?|defdelegate)(\\s+)(@variableName)(?!\\s+@operator)/,\n        [\n          \"keyword.declaration\",\n          \"white\",\n          {\n            cases: {\n              unquote: \"keyword\",\n              \"@default\": \"function\"\n            }\n          }\n        ]\n      ],\n      // Tokenize function calls\n      [\n        // In-scope call - an identifier followed by ( or .(\n        /(@variableName)(?=\\s*\\.?\\s*\\()/,\n        {\n          cases: {\n            // Tokenize as keyword in cases like `if(..., do: ..., else: ...)`\n            \"@declarationKeywords\": \"keyword.declaration\",\n            \"@namespaceKeywords\": \"keyword\",\n            \"@otherKeywords\": \"keyword\",\n            \"@default\": \"function.call\"\n          }\n        }\n      ],\n      [\n        // Referencing function in a module\n        /(@moduleName)(\\s*)(\\.)(\\s*)(@variableName)/,\n        [\"type.identifier\", \"white\", \"operator\", \"white\", \"function.call\"]\n      ],\n      [\n        // Referencing function in an Erlang module\n        /(:)(@atomName)(\\s*)(\\.)(\\s*)(@variableName)/,\n        [\"constant.punctuation\", \"constant\", \"white\", \"operator\", \"white\", \"function.call\"]\n      ],\n      [\n        // Piping into a function (tokenized separately as it may not have parentheses)\n        /(\\|>)(\\s*)(@variableName)/,\n        [\n          \"operator\",\n          \"white\",\n          {\n            cases: {\n              \"@otherKeywords\": \"keyword\",\n              \"@default\": \"function.call\"\n            }\n          }\n        ]\n      ],\n      [\n        // Function reference passed to another function\n        /(&)(\\s*)(@variableName)/,\n        [\"operator\", \"white\", \"function.call\"]\n      ],\n      // Language keywords, builtins, constants and variables\n      [\n        /@variableName/,\n        {\n          cases: {\n            \"@declarationKeywords\": \"keyword.declaration\",\n            \"@operatorKeywords\": \"keyword.operator\",\n            \"@namespaceKeywords\": \"keyword\",\n            \"@otherKeywords\": \"keyword\",\n            \"@constants\": \"constant.language\",\n            \"@nameBuiltin\": \"variable.language\",\n            \"_.*\": \"comment.unused\",\n            \"@default\": \"identifier\"\n          }\n        }\n      ],\n      // Module names\n      [/@moduleName/, \"type.identifier\"]\n    ],\n    // Strings\n    strings: [\n      [/\"\"\"/, { token: \"string.delimiter\", next: \"@doubleQuotedHeredoc\" }],\n      [/'''/, { token: \"string.delimiter\", next: \"@singleQuotedHeredoc\" }],\n      [/\"/, { token: \"string.delimiter\", next: \"@doubleQuotedString\" }],\n      [/'/, { token: \"string.delimiter\", next: \"@singleQuotedString\" }]\n    ],\n    doubleQuotedHeredoc: [\n      [/\"\"\"/, { token: \"string.delimiter\", next: \"@pop\" }],\n      { include: \"@stringContentInterpol\" }\n    ],\n    singleQuotedHeredoc: [\n      [/'''/, { token: \"string.delimiter\", next: \"@pop\" }],\n      { include: \"@stringContentInterpol\" }\n    ],\n    doubleQuotedString: [\n      [/\"/, { token: \"string.delimiter\", next: \"@pop\" }],\n      { include: \"@stringContentInterpol\" }\n    ],\n    singleQuotedString: [\n      [/'/, { token: \"string.delimiter\", next: \"@pop\" }],\n      { include: \"@stringContentInterpol\" }\n    ],\n    // Atoms\n    atoms: [\n      [/(:)(@atomName)/, [\"constant.punctuation\", \"constant\"]],\n      [/:\"/, { token: \"constant.delimiter\", next: \"@doubleQuotedStringAtom\" }],\n      [/:'/, { token: \"constant.delimiter\", next: \"@singleQuotedStringAtom\" }]\n    ],\n    doubleQuotedStringAtom: [\n      [/\"/, { token: \"constant.delimiter\", next: \"@pop\" }],\n      { include: \"@stringConstantContentInterpol\" }\n    ],\n    singleQuotedStringAtom: [\n      [/'/, { token: \"constant.delimiter\", next: \"@pop\" }],\n      { include: \"@stringConstantContentInterpol\" }\n    ],\n    // Sigils\n    // See https://elixir-lang.org/getting-started/sigils.html\n    // Sigils allow for typing values using their textual representation.\n    // All sigils start with ~ followed by a letter or\n    // multi-letter uppercase starting at Elixir v1.15.0, indicating sigil type\n    // and then a delimiter pair enclosing the textual representation.\n    // Optional modifiers are allowed after the closing delimiter.\n    // For instance a regular expressions can be written as:\n    // ~r/foo|bar/ ~r{foo|bar} ~r/foo|bar/g\n    //\n    // In general lowercase sigils allow for interpolation\n    // and escaped characters, whereas uppercase sigils don't\n    //\n    // During tokenization we want to distinguish some\n    // specific sigil types, namely string and regexp,\n    // so that they cen be themed separately.\n    //\n    // To reasonably handle all those combinations we leverage\n    // dot-separated states, so if we transition to @sigilStart.interpol.s.{.}\n    // then \"sigilStart.interpol.s\" state will match and also all\n    // the individual dot-separated parameters can be accessed.\n    sigils: [\n      [/~[a-z]@sigilStartDelimiter/, { token: \"@rematch\", next: \"@sigil.interpol\" }],\n      [/~([A-Z]+)@sigilStartDelimiter/, { token: \"@rematch\", next: \"@sigil.noInterpol\" }]\n    ],\n    sigil: [\n      [/~([a-z]|[A-Z]+)\\{/, { token: \"@rematch\", switchTo: \"@sigilStart.$S2.$1.{.}\" }],\n      [/~([a-z]|[A-Z]+)\\[/, { token: \"@rematch\", switchTo: \"@sigilStart.$S2.$1.[.]\" }],\n      [/~([a-z]|[A-Z]+)\\(/, { token: \"@rematch\", switchTo: \"@sigilStart.$S2.$1.(.)\" }],\n      [/~([a-z]|[A-Z]+)\\</, { token: \"@rematch\", switchTo: \"@sigilStart.$S2.$1.<.>\" }],\n      [\n        /~([a-z]|[A-Z]+)(@sigilSymmetricDelimiter)/,\n        { token: \"@rematch\", switchTo: \"@sigilStart.$S2.$1.$2.$2\" }\n      ]\n    ],\n    // The definitions below expect states to be of the form:\n    //\n    // sigilStart.<interpol-or-noInterpol>.<sigil-letter>.<start-delimiter>.<end-delimiter>\n    // sigilContinue.<interpol-or-noInterpol>.<sigil-letter>.<start-delimiter>.<end-delimiter>\n    //\n    // The sigilStart state is used only to properly classify the token (as string/regex/sigil)\n    // and immediately switches to the sigilContinue sate, which handles the actual content\n    // and waits for the corresponding end delimiter.\n    \"sigilStart.interpol.s\": [\n      [\n        /~s@sigilStartDelimiter/,\n        {\n          token: \"string.delimiter\",\n          switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n        }\n      ]\n    ],\n    \"sigilContinue.interpol.s\": [\n      [\n        /(@sigilEndDelimiter)@sigilModifiers/,\n        {\n          cases: {\n            \"$1==$S5\": { token: \"string.delimiter\", next: \"@pop\" },\n            \"@default\": \"string\"\n          }\n        }\n      ],\n      { include: \"@stringContentInterpol\" }\n    ],\n    \"sigilStart.noInterpol.S\": [\n      [\n        /~S@sigilStartDelimiter/,\n        {\n          token: \"string.delimiter\",\n          switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n        }\n      ]\n    ],\n    \"sigilContinue.noInterpol.S\": [\n      // Ignore escaped sigil end\n      [/(^|[^\\\\])\\\\@sigilEndDelimiter/, \"string\"],\n      [\n        /(@sigilEndDelimiter)@sigilModifiers/,\n        {\n          cases: {\n            \"$1==$S5\": { token: \"string.delimiter\", next: \"@pop\" },\n            \"@default\": \"string\"\n          }\n        }\n      ],\n      { include: \"@stringContent\" }\n    ],\n    \"sigilStart.interpol.r\": [\n      [\n        /~r@sigilStartDelimiter/,\n        {\n          token: \"regexp.delimiter\",\n          switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n        }\n      ]\n    ],\n    \"sigilContinue.interpol.r\": [\n      [\n        /(@sigilEndDelimiter)@sigilModifiers/,\n        {\n          cases: {\n            \"$1==$S5\": { token: \"regexp.delimiter\", next: \"@pop\" },\n            \"@default\": \"regexp\"\n          }\n        }\n      ],\n      { include: \"@regexpContentInterpol\" }\n    ],\n    \"sigilStart.noInterpol.R\": [\n      [\n        /~R@sigilStartDelimiter/,\n        {\n          token: \"regexp.delimiter\",\n          switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n        }\n      ]\n    ],\n    \"sigilContinue.noInterpol.R\": [\n      // Ignore escaped sigil end\n      [/(^|[^\\\\])\\\\@sigilEndDelimiter/, \"regexp\"],\n      [\n        /(@sigilEndDelimiter)@sigilModifiers/,\n        {\n          cases: {\n            \"$1==$S5\": { token: \"regexp.delimiter\", next: \"@pop\" },\n            \"@default\": \"regexp\"\n          }\n        }\n      ],\n      { include: \"@regexpContent\" }\n    ],\n    // Fallback to the generic sigil by default\n    \"sigilStart.interpol\": [\n      [\n        /~([a-z]|[A-Z]+)@sigilStartDelimiter/,\n        {\n          token: \"sigil.delimiter\",\n          switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n        }\n      ]\n    ],\n    \"sigilContinue.interpol\": [\n      [\n        /(@sigilEndDelimiter)@sigilModifiers/,\n        {\n          cases: {\n            \"$1==$S5\": { token: \"sigil.delimiter\", next: \"@pop\" },\n            \"@default\": \"sigil\"\n          }\n        }\n      ],\n      { include: \"@sigilContentInterpol\" }\n    ],\n    \"sigilStart.noInterpol\": [\n      [\n        /~([a-z]|[A-Z]+)@sigilStartDelimiter/,\n        {\n          token: \"sigil.delimiter\",\n          switchTo: \"@sigilContinue.$S2.$S3.$S4.$S5\"\n        }\n      ]\n    ],\n    \"sigilContinue.noInterpol\": [\n      // Ignore escaped sigil end\n      [/(^|[^\\\\])\\\\@sigilEndDelimiter/, \"sigil\"],\n      [\n        /(@sigilEndDelimiter)@sigilModifiers/,\n        {\n          cases: {\n            \"$1==$S5\": { token: \"sigil.delimiter\", next: \"@pop\" },\n            \"@default\": \"sigil\"\n          }\n        }\n      ],\n      { include: \"@sigilContent\" }\n    ],\n    // Attributes\n    attributes: [\n      // Module @doc* attributes - tokenized as comments\n      [\n        /\\@(module|type)?doc (~[sS])?\"\"\"/,\n        {\n          token: \"comment.block.documentation\",\n          next: \"@doubleQuotedHeredocDocstring\"\n        }\n      ],\n      [\n        /\\@(module|type)?doc (~[sS])?'''/,\n        {\n          token: \"comment.block.documentation\",\n          next: \"@singleQuotedHeredocDocstring\"\n        }\n      ],\n      [\n        /\\@(module|type)?doc (~[sS])?\"/,\n        {\n          token: \"comment.block.documentation\",\n          next: \"@doubleQuotedStringDocstring\"\n        }\n      ],\n      [\n        /\\@(module|type)?doc (~[sS])?'/,\n        {\n          token: \"comment.block.documentation\",\n          next: \"@singleQuotedStringDocstring\"\n        }\n      ],\n      [/\\@(module|type)?doc false/, \"comment.block.documentation\"],\n      // Module attributes\n      [/\\@(@variableName)/, \"variable\"]\n    ],\n    doubleQuotedHeredocDocstring: [\n      [/\"\"\"/, { token: \"comment.block.documentation\", next: \"@pop\" }],\n      { include: \"@docstringContent\" }\n    ],\n    singleQuotedHeredocDocstring: [\n      [/'''/, { token: \"comment.block.documentation\", next: \"@pop\" }],\n      { include: \"@docstringContent\" }\n    ],\n    doubleQuotedStringDocstring: [\n      [/\"/, { token: \"comment.block.documentation\", next: \"@pop\" }],\n      { include: \"@docstringContent\" }\n    ],\n    singleQuotedStringDocstring: [\n      [/'/, { token: \"comment.block.documentation\", next: \"@pop\" }],\n      { include: \"@docstringContent\" }\n    ],\n    // Operators, punctuation, brackets\n    symbols: [\n      // Code point operator (either with regular character ?a or an escaped one ?\\n)\n      [/\\?(\\\\.|[^\\\\\\s])/, \"number.constant\"],\n      // Anonymous function arguments\n      [/&\\d+/, \"operator\"],\n      // Bitshift operators (must go before delimiters, so that << >> don't match first)\n      [/<<<|>>>/, \"operator\"],\n      // Delimiter pairs\n      [/[()\\[\\]\\{\\}]|<<|>>/, \"@brackets\"],\n      // Triple dot is a valid name (must go before operators, so that .. doesn't match instead)\n      [/\\.\\.\\./, \"identifier\"],\n      // Punctuation => (must go before operators, so it's not tokenized as = then >)\n      [/=>/, \"punctuation\"],\n      // Operators\n      [/@operator/, \"operator\"],\n      // Punctuation\n      [/[:;,.%]/, \"punctuation\"]\n    ],\n    // Generic helpers\n    stringContentInterpol: [\n      { include: \"@interpolation\" },\n      { include: \"@escapeChar\" },\n      { include: \"@stringContent\" }\n    ],\n    stringContent: [[/./, \"string\"]],\n    stringConstantContentInterpol: [\n      { include: \"@interpolation\" },\n      { include: \"@escapeChar\" },\n      { include: \"@stringConstantContent\" }\n    ],\n    stringConstantContent: [[/./, \"constant\"]],\n    regexpContentInterpol: [\n      { include: \"@interpolation\" },\n      { include: \"@escapeChar\" },\n      { include: \"@regexpContent\" }\n    ],\n    regexpContent: [\n      // # may be a regular regexp char, so we use a heuristic\n      // assuming a # surrounded by whitespace is actually a comment.\n      [/(\\s)(#)(\\s.*)$/, [\"white\", \"comment.punctuation\", \"comment\"]],\n      [/./, \"regexp\"]\n    ],\n    sigilContentInterpol: [\n      { include: \"@interpolation\" },\n      { include: \"@escapeChar\" },\n      { include: \"@sigilContent\" }\n    ],\n    sigilContent: [[/./, \"sigil\"]],\n    docstringContent: [[/./, \"comment.block.documentation\"]],\n    escapeChar: [[/@escape/, \"constant.character.escape\"]],\n    interpolation: [[/#{/, { token: \"delimiter.bracket.embed\", next: \"@interpolationContinue\" }]],\n    interpolationContinue: [\n      [/}/, { token: \"delimiter.bracket.embed\", next: \"@pop\" }],\n      // Interpolation brackets may contain arbitrary code,\n      // so we simply match against all the root rules,\n      // until we reach interpolation end (the above matches).\n      { include: \"@root\" }\n    ]\n  }\n};\nexport {\n  conf,\n  language\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}