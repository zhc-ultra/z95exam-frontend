{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint8-clamped-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { MinimapCharRenderer } from './minimapCharRenderer.js';\nimport { allCharCodes } from './minimapCharSheet.js';\nimport { prebakedMiniMaps } from './minimapPreBaked.js';\nimport { toUint8 } from '../../../../base/common/uint.js';\n/**\n * Creates character renderers. It takes a 'scale' that determines how large\n * characters should be drawn. Using this, it draws data into a canvas and\n * then downsamples the characters as necessary for the current display.\n * This makes rendering more efficient, rather than drawing a full (tiny)\n * font, or downsampling in real-time.\n */\nexport var MinimapCharRendererFactory = /*#__PURE__*/function () {\n  function MinimapCharRendererFactory() {\n    _classCallCheck(this, MinimapCharRendererFactory);\n  }\n  return _createClass(MinimapCharRendererFactory, null, [{\n    key: \"create\",\n    value:\n    /**\n     * Creates a new character renderer factory with the given scale.\n     */\n    function create(scale, fontFamily) {\n      // renderers are immutable. By default we'll 'create' a new minimap\n      // character renderer whenever we switch editors, no need to do extra work.\n      if (this.lastCreated && scale === this.lastCreated.scale && fontFamily === this.lastFontFamily) {\n        return this.lastCreated;\n      }\n      var factory;\n      if (prebakedMiniMaps[scale]) {\n        factory = new MinimapCharRenderer(prebakedMiniMaps[scale](), scale);\n      } else {\n        factory = MinimapCharRendererFactory.createFromSampleData(MinimapCharRendererFactory.createSampleData(fontFamily).data, scale);\n      }\n      this.lastFontFamily = fontFamily;\n      this.lastCreated = factory;\n      return factory;\n    }\n    /**\n     * Creates the font sample data, writing to a canvas.\n     */\n  }, {\n    key: \"createSampleData\",\n    value: function createSampleData(fontFamily) {\n      var canvas = document.createElement('canvas');\n      var ctx = canvas.getContext('2d');\n      canvas.style.height = \"\".concat(16 /* Constants.SAMPLED_CHAR_HEIGHT */, \"px\");\n      canvas.height = 16 /* Constants.SAMPLED_CHAR_HEIGHT */;\n      canvas.width = 96 /* Constants.CHAR_COUNT */ * 10 /* Constants.SAMPLED_CHAR_WIDTH */;\n      canvas.style.width = 96 /* Constants.CHAR_COUNT */ * 10 /* Constants.SAMPLED_CHAR_WIDTH */ + 'px';\n      ctx.fillStyle = '#ffffff';\n      ctx.font = \"bold \".concat(16 /* Constants.SAMPLED_CHAR_HEIGHT */, \"px \", fontFamily);\n      ctx.textBaseline = 'middle';\n      var x = 0;\n      var _iterator = _createForOfIteratorHelper(allCharCodes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var code = _step.value;\n          ctx.fillText(String.fromCharCode(code), x, 16 /* Constants.SAMPLED_CHAR_HEIGHT */ / 2);\n          x += 10 /* Constants.SAMPLED_CHAR_WIDTH */;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return ctx.getImageData(0, 0, 96 /* Constants.CHAR_COUNT */ * 10 /* Constants.SAMPLED_CHAR_WIDTH */, 16 /* Constants.SAMPLED_CHAR_HEIGHT */);\n    }\n    /**\n     * Creates a character renderer from the canvas sample data.\n     */\n  }, {\n    key: \"createFromSampleData\",\n    value: function createFromSampleData(source, scale) {\n      var expectedLength = 16 /* Constants.SAMPLED_CHAR_HEIGHT */ * 10 /* Constants.SAMPLED_CHAR_WIDTH */ * 4 /* Constants.RGBA_CHANNELS_CNT */ * 96 /* Constants.CHAR_COUNT */;\n      if (source.length !== expectedLength) {\n        throw new Error('Unexpected source in MinimapCharRenderer');\n      }\n      var charData = MinimapCharRendererFactory._downsample(source, scale);\n      return new MinimapCharRenderer(charData, scale);\n    }\n  }, {\n    key: \"_downsampleChar\",\n    value: function _downsampleChar(source, sourceOffset, dest, destOffset, scale) {\n      var width = 1 /* Constants.BASE_CHAR_WIDTH */ * scale;\n      var height = 2 /* Constants.BASE_CHAR_HEIGHT */ * scale;\n      var targetIndex = destOffset;\n      var brightest = 0;\n      // This is essentially an ad-hoc rescaling algorithm. Standard approaches\n      // like bicubic interpolation are awesome for scaling between image sizes,\n      // but don't work so well when scaling to very small pixel values, we end\n      // up with blurry, indistinct forms.\n      //\n      // The approach taken here is simply mapping each source pixel to the target\n      // pixels, and taking the weighted values for all pixels in each, and then\n      // averaging them out. Finally we apply an intensity boost in _downsample,\n      // since when scaling to the smallest pixel sizes there's more black space\n      // which causes characters to be much less distinct.\n      for (var y = 0; y < height; y++) {\n        // 1. For this destination pixel, get the source pixels we're sampling\n        // from (x1, y1) to the next pixel (x2, y2)\n        var sourceY1 = y / height * 16 /* Constants.SAMPLED_CHAR_HEIGHT */;\n        var sourceY2 = (y + 1) / height * 16 /* Constants.SAMPLED_CHAR_HEIGHT */;\n        for (var x = 0; x < width; x++) {\n          var sourceX1 = x / width * 10 /* Constants.SAMPLED_CHAR_WIDTH */;\n          var sourceX2 = (x + 1) / width * 10 /* Constants.SAMPLED_CHAR_WIDTH */;\n          // 2. Sample all of them, summing them up and weighting them. Similar\n          // to bilinear interpolation.\n          var value = 0;\n          var samples = 0;\n          for (var sy = sourceY1; sy < sourceY2; sy++) {\n            var sourceRow = sourceOffset + Math.floor(sy) * 3840 /* Constants.RGBA_SAMPLED_ROW_WIDTH */;\n            var yBalance = 1 - (sy - Math.floor(sy));\n            for (var sx = sourceX1; sx < sourceX2; sx++) {\n              var xBalance = 1 - (sx - Math.floor(sx));\n              var sourceIndex = sourceRow + Math.floor(sx) * 4 /* Constants.RGBA_CHANNELS_CNT */;\n              var weight = xBalance * yBalance;\n              samples += weight;\n              value += source[sourceIndex] * source[sourceIndex + 3] / 255 * weight;\n            }\n          }\n          var _final = value / samples;\n          brightest = Math.max(brightest, _final);\n          dest[targetIndex++] = toUint8(_final);\n        }\n      }\n      return brightest;\n    }\n  }, {\n    key: \"_downsample\",\n    value: function _downsample(data, scale) {\n      var pixelsPerCharacter = 2 /* Constants.BASE_CHAR_HEIGHT */ * scale * 1 /* Constants.BASE_CHAR_WIDTH */ * scale;\n      var resultLen = pixelsPerCharacter * 96 /* Constants.CHAR_COUNT */;\n      var result = new Uint8ClampedArray(resultLen);\n      var resultOffset = 0;\n      var sourceOffset = 0;\n      var brightest = 0;\n      for (var charIndex = 0; charIndex < 96 /* Constants.CHAR_COUNT */; charIndex++) {\n        brightest = Math.max(brightest, this._downsampleChar(data, sourceOffset, result, resultOffset, scale));\n        resultOffset += pixelsPerCharacter;\n        sourceOffset += 10 /* Constants.SAMPLED_CHAR_WIDTH */ * 4 /* Constants.RGBA_CHANNELS_CNT */;\n      }\n      if (brightest > 0) {\n        var adjust = 255 / brightest;\n        for (var i = 0; i < resultLen; i++) {\n          result[i] *= adjust;\n        }\n      }\n      return result;\n    }\n  }]);\n}();","map":{"version":3,"names":["MinimapCharRenderer","allCharCodes","prebakedMiniMaps","toUint8","MinimapCharRendererFactory","_classCallCheck","_createClass","key","value","create","scale","fontFamily","lastCreated","lastFontFamily","factory","createFromSampleData","createSampleData","data","canvas","document","createElement","ctx","getContext","style","height","concat","width","fillStyle","font","textBaseline","x","_iterator","_createForOfIteratorHelper","_step","s","n","done","code","fillText","String","fromCharCode","err","e","f","getImageData","source","expectedLength","length","Error","charData","_downsample","_downsampleChar","sourceOffset","dest","destOffset","targetIndex","brightest","y","sourceY1","sourceY2","sourceX1","sourceX2","samples","sy","sourceRow","Math","floor","yBalance","sx","xBalance","sourceIndex","weight","final","max","pixelsPerCharacter","resultLen","result","Uint8ClampedArray","resultOffset","charIndex","adjust","i"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimapCharRendererFactory.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { MinimapCharRenderer } from './minimapCharRenderer.js';\nimport { allCharCodes } from './minimapCharSheet.js';\nimport { prebakedMiniMaps } from './minimapPreBaked.js';\nimport { toUint8 } from '../../../../base/common/uint.js';\n/**\n * Creates character renderers. It takes a 'scale' that determines how large\n * characters should be drawn. Using this, it draws data into a canvas and\n * then downsamples the characters as necessary for the current display.\n * This makes rendering more efficient, rather than drawing a full (tiny)\n * font, or downsampling in real-time.\n */\nexport class MinimapCharRendererFactory {\n    /**\n     * Creates a new character renderer factory with the given scale.\n     */\n    static create(scale, fontFamily) {\n        // renderers are immutable. By default we'll 'create' a new minimap\n        // character renderer whenever we switch editors, no need to do extra work.\n        if (this.lastCreated && scale === this.lastCreated.scale && fontFamily === this.lastFontFamily) {\n            return this.lastCreated;\n        }\n        let factory;\n        if (prebakedMiniMaps[scale]) {\n            factory = new MinimapCharRenderer(prebakedMiniMaps[scale](), scale);\n        }\n        else {\n            factory = MinimapCharRendererFactory.createFromSampleData(MinimapCharRendererFactory.createSampleData(fontFamily).data, scale);\n        }\n        this.lastFontFamily = fontFamily;\n        this.lastCreated = factory;\n        return factory;\n    }\n    /**\n     * Creates the font sample data, writing to a canvas.\n     */\n    static createSampleData(fontFamily) {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        canvas.style.height = `${16 /* Constants.SAMPLED_CHAR_HEIGHT */}px`;\n        canvas.height = 16 /* Constants.SAMPLED_CHAR_HEIGHT */;\n        canvas.width = 96 /* Constants.CHAR_COUNT */ * 10 /* Constants.SAMPLED_CHAR_WIDTH */;\n        canvas.style.width = 96 /* Constants.CHAR_COUNT */ * 10 /* Constants.SAMPLED_CHAR_WIDTH */ + 'px';\n        ctx.fillStyle = '#ffffff';\n        ctx.font = `bold ${16 /* Constants.SAMPLED_CHAR_HEIGHT */}px ${fontFamily}`;\n        ctx.textBaseline = 'middle';\n        let x = 0;\n        for (const code of allCharCodes) {\n            ctx.fillText(String.fromCharCode(code), x, 16 /* Constants.SAMPLED_CHAR_HEIGHT */ / 2);\n            x += 10 /* Constants.SAMPLED_CHAR_WIDTH */;\n        }\n        return ctx.getImageData(0, 0, 96 /* Constants.CHAR_COUNT */ * 10 /* Constants.SAMPLED_CHAR_WIDTH */, 16 /* Constants.SAMPLED_CHAR_HEIGHT */);\n    }\n    /**\n     * Creates a character renderer from the canvas sample data.\n     */\n    static createFromSampleData(source, scale) {\n        const expectedLength = 16 /* Constants.SAMPLED_CHAR_HEIGHT */ * 10 /* Constants.SAMPLED_CHAR_WIDTH */ * 4 /* Constants.RGBA_CHANNELS_CNT */ * 96 /* Constants.CHAR_COUNT */;\n        if (source.length !== expectedLength) {\n            throw new Error('Unexpected source in MinimapCharRenderer');\n        }\n        const charData = MinimapCharRendererFactory._downsample(source, scale);\n        return new MinimapCharRenderer(charData, scale);\n    }\n    static _downsampleChar(source, sourceOffset, dest, destOffset, scale) {\n        const width = 1 /* Constants.BASE_CHAR_WIDTH */ * scale;\n        const height = 2 /* Constants.BASE_CHAR_HEIGHT */ * scale;\n        let targetIndex = destOffset;\n        let brightest = 0;\n        // This is essentially an ad-hoc rescaling algorithm. Standard approaches\n        // like bicubic interpolation are awesome for scaling between image sizes,\n        // but don't work so well when scaling to very small pixel values, we end\n        // up with blurry, indistinct forms.\n        //\n        // The approach taken here is simply mapping each source pixel to the target\n        // pixels, and taking the weighted values for all pixels in each, and then\n        // averaging them out. Finally we apply an intensity boost in _downsample,\n        // since when scaling to the smallest pixel sizes there's more black space\n        // which causes characters to be much less distinct.\n        for (let y = 0; y < height; y++) {\n            // 1. For this destination pixel, get the source pixels we're sampling\n            // from (x1, y1) to the next pixel (x2, y2)\n            const sourceY1 = (y / height) * 16 /* Constants.SAMPLED_CHAR_HEIGHT */;\n            const sourceY2 = ((y + 1) / height) * 16 /* Constants.SAMPLED_CHAR_HEIGHT */;\n            for (let x = 0; x < width; x++) {\n                const sourceX1 = (x / width) * 10 /* Constants.SAMPLED_CHAR_WIDTH */;\n                const sourceX2 = ((x + 1) / width) * 10 /* Constants.SAMPLED_CHAR_WIDTH */;\n                // 2. Sample all of them, summing them up and weighting them. Similar\n                // to bilinear interpolation.\n                let value = 0;\n                let samples = 0;\n                for (let sy = sourceY1; sy < sourceY2; sy++) {\n                    const sourceRow = sourceOffset + Math.floor(sy) * 3840 /* Constants.RGBA_SAMPLED_ROW_WIDTH */;\n                    const yBalance = 1 - (sy - Math.floor(sy));\n                    for (let sx = sourceX1; sx < sourceX2; sx++) {\n                        const xBalance = 1 - (sx - Math.floor(sx));\n                        const sourceIndex = sourceRow + Math.floor(sx) * 4 /* Constants.RGBA_CHANNELS_CNT */;\n                        const weight = xBalance * yBalance;\n                        samples += weight;\n                        value += ((source[sourceIndex] * source[sourceIndex + 3]) / 255) * weight;\n                    }\n                }\n                const final = value / samples;\n                brightest = Math.max(brightest, final);\n                dest[targetIndex++] = toUint8(final);\n            }\n        }\n        return brightest;\n    }\n    static _downsample(data, scale) {\n        const pixelsPerCharacter = 2 /* Constants.BASE_CHAR_HEIGHT */ * scale * 1 /* Constants.BASE_CHAR_WIDTH */ * scale;\n        const resultLen = pixelsPerCharacter * 96 /* Constants.CHAR_COUNT */;\n        const result = new Uint8ClampedArray(resultLen);\n        let resultOffset = 0;\n        let sourceOffset = 0;\n        let brightest = 0;\n        for (let charIndex = 0; charIndex < 96 /* Constants.CHAR_COUNT */; charIndex++) {\n            brightest = Math.max(brightest, this._downsampleChar(data, sourceOffset, result, resultOffset, scale));\n            resultOffset += pixelsPerCharacter;\n            sourceOffset += 10 /* Constants.SAMPLED_CHAR_WIDTH */ * 4 /* Constants.RGBA_CHANNELS_CNT */;\n        }\n        if (brightest > 0) {\n            const adjust = 255 / brightest;\n            for (let i = 0; i < resultLen; i++) {\n                result[i] *= adjust;\n            }\n        }\n        return result;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}