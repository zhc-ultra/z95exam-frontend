{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nvar PendingChanges = /*#__PURE__*/function () {\n  function PendingChanges() {\n    _classCallCheck(this, PendingChanges);\n    this._hasPending = false;\n    this._inserts = [];\n    this._changes = [];\n    this._removes = [];\n  }\n  return _createClass(PendingChanges, [{\n    key: \"insert\",\n    value: function insert(x) {\n      this._hasPending = true;\n      this._inserts.push(x);\n    }\n  }, {\n    key: \"change\",\n    value: function change(x) {\n      this._hasPending = true;\n      this._changes.push(x);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(x) {\n      this._hasPending = true;\n      this._removes.push(x);\n    }\n  }, {\n    key: \"mustCommit\",\n    value: function mustCommit() {\n      return this._hasPending;\n    }\n  }, {\n    key: \"commit\",\n    value: function commit(linesLayout) {\n      if (!this._hasPending) {\n        return;\n      }\n      var inserts = this._inserts;\n      var changes = this._changes;\n      var removes = this._removes;\n      this._hasPending = false;\n      this._inserts = [];\n      this._changes = [];\n      this._removes = [];\n      linesLayout._commitPendingChanges(inserts, changes, removes);\n    }\n  }]);\n}();\nexport var EditorWhitespace = /*#__PURE__*/_createClass(function EditorWhitespace(id, afterLineNumber, ordinal, height, minWidth) {\n  _classCallCheck(this, EditorWhitespace);\n  this.id = id;\n  this.afterLineNumber = afterLineNumber;\n  this.ordinal = ordinal;\n  this.height = height;\n  this.minWidth = minWidth;\n  this.prefixSum = 0;\n});\n/**\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\n *\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\n */\nexport var LinesLayout = /*#__PURE__*/function () {\n  function LinesLayout(lineCount, lineHeight, paddingTop, paddingBottom) {\n    _classCallCheck(this, LinesLayout);\n    this._instanceId = strings.singleLetterHash(++LinesLayout.INSTANCE_COUNT);\n    this._pendingChanges = new PendingChanges();\n    this._lastWhitespaceId = 0;\n    this._arr = [];\n    this._prefixSumValidIndex = -1;\n    this._minWidth = -1; /* marker for not being computed */\n    this._lineCount = lineCount;\n    this._lineHeight = lineHeight;\n    this._paddingTop = paddingTop;\n    this._paddingBottom = paddingBottom;\n  }\n  /**\n   * Find the insertion index for a new value inside a sorted array of values.\n   * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n   */\n  return _createClass(LinesLayout, [{\n    key: \"setLineHeight\",\n    value:\n    /**\n     * Change the height of a line in pixels.\n     */\n    function setLineHeight(lineHeight) {\n      this._checkPendingChanges();\n      this._lineHeight = lineHeight;\n    }\n    /**\n     * Changes the padding used to calculate vertical offsets.\n     */\n  }, {\n    key: \"setPadding\",\n    value: function setPadding(paddingTop, paddingBottom) {\n      this._paddingTop = paddingTop;\n      this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Set the number of lines.\n     *\n     * @param lineCount New number of lines.\n     */\n  }, {\n    key: \"onFlushed\",\n    value: function onFlushed(lineCount) {\n      this._checkPendingChanges();\n      this._lineCount = lineCount;\n    }\n  }, {\n    key: \"changeWhitespace\",\n    value: function changeWhitespace(callback) {\n      var _this = this;\n      var hadAChange = false;\n      try {\n        var accessor = {\n          insertWhitespace: function insertWhitespace(afterLineNumber, ordinal, heightInPx, minWidth) {\n            hadAChange = true;\n            afterLineNumber = afterLineNumber | 0;\n            ordinal = ordinal | 0;\n            heightInPx = heightInPx | 0;\n            minWidth = minWidth | 0;\n            var id = _this._instanceId + ++_this._lastWhitespaceId;\n            _this._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber, ordinal, heightInPx, minWidth));\n            return id;\n          },\n          changeOneWhitespace: function changeOneWhitespace(id, newAfterLineNumber, newHeight) {\n            hadAChange = true;\n            newAfterLineNumber = newAfterLineNumber | 0;\n            newHeight = newHeight | 0;\n            _this._pendingChanges.change({\n              id: id,\n              newAfterLineNumber: newAfterLineNumber,\n              newHeight: newHeight\n            });\n          },\n          removeWhitespace: function removeWhitespace(id) {\n            hadAChange = true;\n            _this._pendingChanges.remove({\n              id: id\n            });\n          }\n        };\n        callback(accessor);\n      } finally {\n        this._pendingChanges.commit(this);\n      }\n      return hadAChange;\n    }\n  }, {\n    key: \"_commitPendingChanges\",\n    value: function _commitPendingChanges(inserts, changes, removes) {\n      if (inserts.length > 0 || removes.length > 0) {\n        this._minWidth = -1; /* marker for not being computed */\n      }\n      if (inserts.length + changes.length + removes.length <= 1) {\n        // when only one thing happened, handle it \"delicately\"\n        var _iterator = _createForOfIteratorHelper(inserts),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var insert = _step.value;\n            this._insertWhitespace(insert);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        var _iterator2 = _createForOfIteratorHelper(changes),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var change = _step2.value;\n            this._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        var _iterator3 = _createForOfIteratorHelper(removes),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var remove = _step3.value;\n            var index = this._findWhitespaceIndex(remove.id);\n            if (index === -1) {\n              continue;\n            }\n            this._removeWhitespace(index);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        return;\n      }\n      // simply rebuild the entire datastructure\n      var toRemove = new Set();\n      var _iterator4 = _createForOfIteratorHelper(removes),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _remove = _step4.value;\n          toRemove.add(_remove.id);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      var toChange = new Map();\n      var _iterator5 = _createForOfIteratorHelper(changes),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _change2 = _step5.value;\n          toChange.set(_change2.id, _change2);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      var applyRemoveAndChange = function applyRemoveAndChange(whitespaces) {\n        var result = [];\n        var _iterator6 = _createForOfIteratorHelper(whitespaces),\n          _step6;\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var whitespace = _step6.value;\n            if (toRemove.has(whitespace.id)) {\n              continue;\n            }\n            if (toChange.has(whitespace.id)) {\n              var _change = toChange.get(whitespace.id);\n              whitespace.afterLineNumber = _change.newAfterLineNumber;\n              whitespace.height = _change.newHeight;\n            }\n            result.push(whitespace);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n        return result;\n      };\n      var result = applyRemoveAndChange(this._arr).concat(applyRemoveAndChange(inserts));\n      result.sort(function (a, b) {\n        if (a.afterLineNumber === b.afterLineNumber) {\n          return a.ordinal - b.ordinal;\n        }\n        return a.afterLineNumber - b.afterLineNumber;\n      });\n      this._arr = result;\n      this._prefixSumValidIndex = -1;\n    }\n  }, {\n    key: \"_checkPendingChanges\",\n    value: function _checkPendingChanges() {\n      if (this._pendingChanges.mustCommit()) {\n        this._pendingChanges.commit(this);\n      }\n    }\n  }, {\n    key: \"_insertWhitespace\",\n    value: function _insertWhitespace(whitespace) {\n      var insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);\n      this._arr.splice(insertIndex, 0, whitespace);\n      this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n    }\n  }, {\n    key: \"_findWhitespaceIndex\",\n    value: function _findWhitespaceIndex(id) {\n      var arr = this._arr;\n      for (var i = 0, len = arr.length; i < len; i++) {\n        if (arr[i].id === id) {\n          return i;\n        }\n      }\n      return -1;\n    }\n  }, {\n    key: \"_changeOneWhitespace\",\n    value: function _changeOneWhitespace(id, newAfterLineNumber, newHeight) {\n      var index = this._findWhitespaceIndex(id);\n      if (index === -1) {\n        return;\n      }\n      if (this._arr[index].height !== newHeight) {\n        this._arr[index].height = newHeight;\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n      }\n      if (this._arr[index].afterLineNumber !== newAfterLineNumber) {\n        // `afterLineNumber` changed for this whitespace\n        // Record old whitespace\n        var whitespace = this._arr[index];\n        // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n        this._removeWhitespace(index);\n        whitespace.afterLineNumber = newAfterLineNumber;\n        // And add it again\n        this._insertWhitespace(whitespace);\n      }\n    }\n  }, {\n    key: \"_removeWhitespace\",\n    value: function _removeWhitespace(removeIndex) {\n      this._arr.splice(removeIndex, 1);\n      this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n    }\n    /**\n     * Notify the layouter that lines have been deleted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the deletion started, inclusive\n     * @param toLineNumber The line number at which the deletion ended, inclusive\n     */\n  }, {\n    key: \"onLinesDeleted\",\n    value: function onLinesDeleted(fromLineNumber, toLineNumber) {\n      this._checkPendingChanges();\n      fromLineNumber = fromLineNumber | 0;\n      toLineNumber = toLineNumber | 0;\n      this._lineCount -= toLineNumber - fromLineNumber + 1;\n      for (var i = 0, len = this._arr.length; i < len; i++) {\n        var afterLineNumber = this._arr[i].afterLineNumber;\n        if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n          // The line this whitespace was after has been deleted\n          //  => move whitespace to before first deleted line\n          this._arr[i].afterLineNumber = fromLineNumber - 1;\n        } else if (afterLineNumber > toLineNumber) {\n          // The line this whitespace was after has been moved up\n          //  => move whitespace up\n          this._arr[i].afterLineNumber -= toLineNumber - fromLineNumber + 1;\n        }\n      }\n    }\n    /**\n     * Notify the layouter that lines have been inserted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the insertion started, inclusive\n     * @param toLineNumber The line number at which the insertion ended, inclusive.\n     */\n  }, {\n    key: \"onLinesInserted\",\n    value: function onLinesInserted(fromLineNumber, toLineNumber) {\n      this._checkPendingChanges();\n      fromLineNumber = fromLineNumber | 0;\n      toLineNumber = toLineNumber | 0;\n      this._lineCount += toLineNumber - fromLineNumber + 1;\n      for (var i = 0, len = this._arr.length; i < len; i++) {\n        var afterLineNumber = this._arr[i].afterLineNumber;\n        if (fromLineNumber <= afterLineNumber) {\n          this._arr[i].afterLineNumber += toLineNumber - fromLineNumber + 1;\n        }\n      }\n    }\n    /**\n     * Get the sum of all the whitespaces.\n     */\n  }, {\n    key: \"getWhitespacesTotalHeight\",\n    value: function getWhitespacesTotalHeight() {\n      this._checkPendingChanges();\n      if (this._arr.length === 0) {\n        return 0;\n      }\n      return this.getWhitespacesAccumulatedHeight(this._arr.length - 1);\n    }\n    /**\n     * Return the sum of the heights of the whitespaces at [0..index].\n     * This includes the whitespace at `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n     */\n  }, {\n    key: \"getWhitespacesAccumulatedHeight\",\n    value: function getWhitespacesAccumulatedHeight(index) {\n      this._checkPendingChanges();\n      index = index | 0;\n      var startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n      if (startIndex === 0) {\n        this._arr[0].prefixSum = this._arr[0].height;\n        startIndex++;\n      }\n      for (var i = startIndex; i <= index; i++) {\n        this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;\n      }\n      this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n      return this._arr[index].prefixSum;\n    }\n    /**\n     * Get the sum of heights for all objects.\n     *\n     * @return The sum of heights for all objects.\n     */\n  }, {\n    key: \"getLinesTotalHeight\",\n    value: function getLinesTotalHeight() {\n      this._checkPendingChanges();\n      var linesHeight = this._lineHeight * this._lineCount;\n      var whitespacesHeight = this.getWhitespacesTotalHeight();\n      return linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;\n    }\n    /**\n     * Returns the accumulated height of whitespaces before the given line number.\n     *\n     * @param lineNumber The line number\n     */\n  }, {\n    key: \"getWhitespaceAccumulatedHeightBeforeLineNumber\",\n    value: function getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber) {\n      this._checkPendingChanges();\n      lineNumber = lineNumber | 0;\n      var lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n      if (lastWhitespaceBeforeLineNumber === -1) {\n        return 0;\n      }\n      return this.getWhitespacesAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n    }\n  }, {\n    key: \"_findLastWhitespaceBeforeLineNumber\",\n    value: function _findLastWhitespaceBeforeLineNumber(lineNumber) {\n      lineNumber = lineNumber | 0;\n      // Find the whitespace before line number\n      var arr = this._arr;\n      var low = 0;\n      var high = arr.length - 1;\n      while (low <= high) {\n        var delta = high - low | 0;\n        var halfDelta = delta / 2 | 0;\n        var mid = low + halfDelta | 0;\n        if (arr[mid].afterLineNumber < lineNumber) {\n          if (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {\n            return mid;\n          } else {\n            low = mid + 1 | 0;\n          }\n        } else {\n          high = mid - 1 | 0;\n        }\n      }\n      return -1;\n    }\n  }, {\n    key: \"_findFirstWhitespaceAfterLineNumber\",\n    value: function _findFirstWhitespaceAfterLineNumber(lineNumber) {\n      lineNumber = lineNumber | 0;\n      var lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n      var firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n      if (firstWhitespaceAfterLineNumber < this._arr.length) {\n        return firstWhitespaceAfterLineNumber;\n      }\n      return -1;\n    }\n    /**\n     * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n     * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n     */\n  }, {\n    key: \"getFirstWhitespaceIndexAfterLineNumber\",\n    value: function getFirstWhitespaceIndexAfterLineNumber(lineNumber) {\n      this._checkPendingChanges();\n      lineNumber = lineNumber | 0;\n      return this._findFirstWhitespaceAfterLineNumber(lineNumber);\n    }\n    /**\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n     *\n     * @param lineNumber The line number\n     * @return The sum of heights for all objects above `lineNumber`.\n     */\n  }, {\n    key: \"getVerticalOffsetForLineNumber\",\n    value: function getVerticalOffsetForLineNumber(lineNumber) {\n      var includeViewZones = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this._checkPendingChanges();\n      lineNumber = lineNumber | 0;\n      var previousLinesHeight;\n      if (lineNumber > 1) {\n        previousLinesHeight = this._lineHeight * (lineNumber - 1);\n      } else {\n        previousLinesHeight = 0;\n      }\n      var previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber - (includeViewZones ? 1 : 0));\n      return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    /**\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n     *\n     * @param lineNumber The line number\n     * @return The sum of heights for all objects above `lineNumber`.\n     */\n  }, {\n    key: \"getVerticalOffsetAfterLineNumber\",\n    value: function getVerticalOffsetAfterLineNumber(lineNumber) {\n      var includeViewZones = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this._checkPendingChanges();\n      lineNumber = lineNumber | 0;\n      var previousLinesHeight = this._lineHeight * lineNumber;\n      var previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber + (includeViewZones ? 1 : 0));\n      return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    /**\n     * The maximum min width for all whitespaces.\n     */\n  }, {\n    key: \"getWhitespaceMinWidth\",\n    value: function getWhitespaceMinWidth() {\n      this._checkPendingChanges();\n      if (this._minWidth === -1) {\n        var minWidth = 0;\n        for (var i = 0, len = this._arr.length; i < len; i++) {\n          minWidth = Math.max(minWidth, this._arr[i].minWidth);\n        }\n        this._minWidth = minWidth;\n      }\n      return this._minWidth;\n    }\n    /**\n     * Check if `verticalOffset` is below all lines.\n     */\n  }, {\n    key: \"isAfterLines\",\n    value: function isAfterLines(verticalOffset) {\n      this._checkPendingChanges();\n      var totalHeight = this.getLinesTotalHeight();\n      return verticalOffset > totalHeight;\n    }\n  }, {\n    key: \"isInTopPadding\",\n    value: function isInTopPadding(verticalOffset) {\n      if (this._paddingTop === 0) {\n        return false;\n      }\n      this._checkPendingChanges();\n      return verticalOffset < this._paddingTop;\n    }\n  }, {\n    key: \"isInBottomPadding\",\n    value: function isInBottomPadding(verticalOffset) {\n      if (this._paddingBottom === 0) {\n        return false;\n      }\n      this._checkPendingChanges();\n      var totalHeight = this.getLinesTotalHeight();\n      return verticalOffset >= totalHeight - this._paddingBottom;\n    }\n    /**\n     * Find the first line number that is at or after vertical offset `verticalOffset`.\n     * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\n     * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\n     *\n     * @param verticalOffset The vertical offset to search at.\n     * @return The line number at or after vertical offset `verticalOffset`.\n     */\n  }, {\n    key: \"getLineNumberAtOrAfterVerticalOffset\",\n    value: function getLineNumberAtOrAfterVerticalOffset(verticalOffset) {\n      this._checkPendingChanges();\n      verticalOffset = verticalOffset | 0;\n      if (verticalOffset < 0) {\n        return 1;\n      }\n      var linesCount = this._lineCount | 0;\n      var lineHeight = this._lineHeight;\n      var minLineNumber = 1;\n      var maxLineNumber = linesCount;\n      while (minLineNumber < maxLineNumber) {\n        var midLineNumber = (minLineNumber + maxLineNumber) / 2 | 0;\n        var midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n        if (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n          // vertical offset is after mid line number\n          minLineNumber = midLineNumber + 1;\n        } else if (verticalOffset >= midLineNumberVerticalOffset) {\n          // Hit\n          return midLineNumber;\n        } else {\n          // vertical offset is before mid line number, but mid line number could still be what we're searching for\n          maxLineNumber = midLineNumber;\n        }\n      }\n      if (minLineNumber > linesCount) {\n        return linesCount;\n      }\n      return minLineNumber;\n    }\n    /**\n     * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\n     */\n  }, {\n    key: \"getLinesViewportData\",\n    value: function getLinesViewportData(verticalOffset1, verticalOffset2) {\n      this._checkPendingChanges();\n      verticalOffset1 = verticalOffset1 | 0;\n      verticalOffset2 = verticalOffset2 | 0;\n      var lineHeight = this._lineHeight;\n      // Find first line number\n      // We don't live in a perfect world, so the line number might start before or after verticalOffset1\n      var startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n      var startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n      var endLineNumber = this._lineCount | 0;\n      // Also keep track of what whitespace we've got\n      var whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n      var whitespaceCount = this.getWhitespacesCount() | 0;\n      var currentWhitespaceHeight;\n      var currentWhitespaceAfterLineNumber;\n      if (whitespaceIndex === -1) {\n        whitespaceIndex = whitespaceCount;\n        currentWhitespaceAfterLineNumber = endLineNumber + 1;\n        currentWhitespaceHeight = 0;\n      } else {\n        currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n        currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n      }\n      var currentVerticalOffset = startLineNumberVerticalOffset;\n      var currentLineRelativeOffset = currentVerticalOffset;\n      // IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n      var STEP_SIZE = 500000;\n      var bigNumbersDelta = 0;\n      if (startLineNumberVerticalOffset >= STEP_SIZE) {\n        // Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n        bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n        bigNumbersDelta = Math.floor(bigNumbersDelta / lineHeight) * lineHeight;\n        currentLineRelativeOffset -= bigNumbersDelta;\n      }\n      var linesOffsets = [];\n      var verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n      var centeredLineNumber = -1;\n      // Figure out how far the lines go\n      for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n        if (centeredLineNumber === -1) {\n          var currentLineTop = currentVerticalOffset;\n          var currentLineBottom = currentVerticalOffset + lineHeight;\n          if (currentLineTop <= verticalCenter && verticalCenter < currentLineBottom || currentLineTop > verticalCenter) {\n            centeredLineNumber = lineNumber;\n          }\n        }\n        // Count current line height in the vertical offsets\n        currentVerticalOffset += lineHeight;\n        linesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;\n        // Next line starts immediately after this one\n        currentLineRelativeOffset += lineHeight;\n        while (currentWhitespaceAfterLineNumber === lineNumber) {\n          // Push down next line with the height of the current whitespace\n          currentLineRelativeOffset += currentWhitespaceHeight;\n          // Count current whitespace in the vertical offsets\n          currentVerticalOffset += currentWhitespaceHeight;\n          whitespaceIndex++;\n          if (whitespaceIndex >= whitespaceCount) {\n            currentWhitespaceAfterLineNumber = endLineNumber + 1;\n          } else {\n            currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n            currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n          }\n        }\n        if (currentVerticalOffset >= verticalOffset2) {\n          // We have covered the entire viewport area, time to stop\n          endLineNumber = lineNumber;\n          break;\n        }\n      }\n      if (centeredLineNumber === -1) {\n        centeredLineNumber = endLineNumber;\n      }\n      var endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n      var completelyVisibleStartLineNumber = startLineNumber;\n      var completelyVisibleEndLineNumber = endLineNumber;\n      if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n        if (startLineNumberVerticalOffset < verticalOffset1) {\n          completelyVisibleStartLineNumber++;\n        }\n      }\n      if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n        if (endLineNumberVerticalOffset + lineHeight > verticalOffset2) {\n          completelyVisibleEndLineNumber--;\n        }\n      }\n      return {\n        bigNumbersDelta: bigNumbersDelta,\n        startLineNumber: startLineNumber,\n        endLineNumber: endLineNumber,\n        relativeVerticalOffset: linesOffsets,\n        centeredLineNumber: centeredLineNumber,\n        completelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n        completelyVisibleEndLineNumber: completelyVisibleEndLineNumber,\n        lineHeight: this._lineHeight\n      };\n    }\n  }, {\n    key: \"getVerticalOffsetForWhitespaceIndex\",\n    value: function getVerticalOffsetForWhitespaceIndex(whitespaceIndex) {\n      this._checkPendingChanges();\n      whitespaceIndex = whitespaceIndex | 0;\n      var afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n      var previousLinesHeight;\n      if (afterLineNumber >= 1) {\n        previousLinesHeight = this._lineHeight * afterLineNumber;\n      } else {\n        previousLinesHeight = 0;\n      }\n      var previousWhitespacesHeight;\n      if (whitespaceIndex > 0) {\n        previousWhitespacesHeight = this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1);\n      } else {\n        previousWhitespacesHeight = 0;\n      }\n      return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n  }, {\n    key: \"getWhitespaceIndexAtOrAfterVerticallOffset\",\n    value: function getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset) {\n      this._checkPendingChanges();\n      verticalOffset = verticalOffset | 0;\n      var minWhitespaceIndex = 0;\n      var maxWhitespaceIndex = this.getWhitespacesCount() - 1;\n      if (maxWhitespaceIndex < 0) {\n        return -1;\n      }\n      // Special case: nothing to be found\n      var maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n      var maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n      if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n        return -1;\n      }\n      while (minWhitespaceIndex < maxWhitespaceIndex) {\n        var midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n        var midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n        var midWhitespaceHeight = this.getHeightForWhitespaceIndex(midWhitespaceIndex);\n        if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n          // vertical offset is after whitespace\n          minWhitespaceIndex = midWhitespaceIndex + 1;\n        } else if (verticalOffset >= midWhitespaceVerticalOffset) {\n          // Hit\n          return midWhitespaceIndex;\n        } else {\n          // vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n          maxWhitespaceIndex = midWhitespaceIndex;\n        }\n      }\n      return minWhitespaceIndex;\n    }\n    /**\n     * Get exactly the whitespace that is layouted at `verticalOffset`.\n     *\n     * @param verticalOffset The vertical offset.\n     * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\n     */\n  }, {\n    key: \"getWhitespaceAtVerticalOffset\",\n    value: function getWhitespaceAtVerticalOffset(verticalOffset) {\n      this._checkPendingChanges();\n      verticalOffset = verticalOffset | 0;\n      var candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n      if (candidateIndex < 0) {\n        return null;\n      }\n      if (candidateIndex >= this.getWhitespacesCount()) {\n        return null;\n      }\n      var candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n      if (candidateTop > verticalOffset) {\n        return null;\n      }\n      var candidateHeight = this.getHeightForWhitespaceIndex(candidateIndex);\n      var candidateId = this.getIdForWhitespaceIndex(candidateIndex);\n      var candidateAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n      return {\n        id: candidateId,\n        afterLineNumber: candidateAfterLineNumber,\n        verticalOffset: candidateTop,\n        height: candidateHeight\n      };\n    }\n    /**\n     * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\n     */\n  }, {\n    key: \"getWhitespaceViewportData\",\n    value: function getWhitespaceViewportData(verticalOffset1, verticalOffset2) {\n      this._checkPendingChanges();\n      verticalOffset1 = verticalOffset1 | 0;\n      verticalOffset2 = verticalOffset2 | 0;\n      var startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n      var endIndex = this.getWhitespacesCount() - 1;\n      if (startIndex < 0) {\n        return [];\n      }\n      var result = [];\n      for (var i = startIndex; i <= endIndex; i++) {\n        var top = this.getVerticalOffsetForWhitespaceIndex(i);\n        var height = this.getHeightForWhitespaceIndex(i);\n        if (top >= verticalOffset2) {\n          break;\n        }\n        result.push({\n          id: this.getIdForWhitespaceIndex(i),\n          afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(i),\n          verticalOffset: top,\n          height: height\n        });\n      }\n      return result;\n    }\n    /**\n     * Get all whitespaces.\n     */\n  }, {\n    key: \"getWhitespaces\",\n    value: function getWhitespaces() {\n      this._checkPendingChanges();\n      return this._arr.slice(0);\n    }\n    /**\n     * The number of whitespaces.\n     */\n  }, {\n    key: \"getWhitespacesCount\",\n    value: function getWhitespacesCount() {\n      this._checkPendingChanges();\n      return this._arr.length;\n    }\n    /**\n     * Get the `id` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `id` of whitespace at `index`.\n     */\n  }, {\n    key: \"getIdForWhitespaceIndex\",\n    value: function getIdForWhitespaceIndex(index) {\n      this._checkPendingChanges();\n      index = index | 0;\n      return this._arr[index].id;\n    }\n    /**\n     * Get the `afterLineNumber` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `afterLineNumber` of whitespace at `index`.\n     */\n  }, {\n    key: \"getAfterLineNumberForWhitespaceIndex\",\n    value: function getAfterLineNumberForWhitespaceIndex(index) {\n      this._checkPendingChanges();\n      index = index | 0;\n      return this._arr[index].afterLineNumber;\n    }\n    /**\n     * Get the `height` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `height` of whitespace at `index`.\n     */\n  }, {\n    key: \"getHeightForWhitespaceIndex\",\n    value: function getHeightForWhitespaceIndex(index) {\n      this._checkPendingChanges();\n      index = index | 0;\n      return this._arr[index].height;\n    }\n  }], [{\n    key: \"findInsertionIndex\",\n    value: function findInsertionIndex(arr, afterLineNumber, ordinal) {\n      var low = 0;\n      var high = arr.length;\n      while (low < high) {\n        var mid = low + high >>> 1;\n        if (afterLineNumber === arr[mid].afterLineNumber) {\n          if (ordinal < arr[mid].ordinal) {\n            high = mid;\n          } else {\n            low = mid + 1;\n          }\n        } else if (afterLineNumber < arr[mid].afterLineNumber) {\n          high = mid;\n        } else {\n          low = mid + 1;\n        }\n      }\n      return low;\n    }\n  }]);\n}();\nLinesLayout.INSTANCE_COUNT = 0;","map":{"version":3,"names":["strings","PendingChanges","_classCallCheck","_hasPending","_inserts","_changes","_removes","_createClass","key","value","insert","x","push","change","remove","mustCommit","commit","linesLayout","inserts","changes","removes","_commitPendingChanges","EditorWhitespace","id","afterLineNumber","ordinal","height","minWidth","prefixSum","LinesLayout","lineCount","lineHeight","paddingTop","paddingBottom","_instanceId","singleLetterHash","INSTANCE_COUNT","_pendingChanges","_lastWhitespaceId","_arr","_prefixSumValidIndex","_minWidth","_lineCount","_lineHeight","_paddingTop","_paddingBottom","setLineHeight","_checkPendingChanges","setPadding","onFlushed","changeWhitespace","callback","_this","hadAChange","accessor","insertWhitespace","heightInPx","changeOneWhitespace","newAfterLineNumber","newHeight","removeWhitespace","length","_iterator","_createForOfIteratorHelper","_step","s","n","done","_insertWhitespace","err","e","f","_iterator2","_step2","_changeOneWhitespace","_iterator3","_step3","index","_findWhitespaceIndex","_removeWhitespace","toRemove","Set","_iterator4","_step4","add","toChange","Map","_iterator5","_step5","set","applyRemoveAndChange","whitespaces","result","_iterator6","_step6","whitespace","has","get","concat","sort","a","b","insertIndex","findInsertionIndex","splice","Math","min","arr","i","len","removeIndex","onLinesDeleted","fromLineNumber","toLineNumber","onLinesInserted","getWhitespacesTotalHeight","getWhitespacesAccumulatedHeight","startIndex","max","getLinesTotalHeight","linesHeight","whitespacesHeight","getWhitespaceAccumulatedHeightBeforeLineNumber","lineNumber","lastWhitespaceBeforeLineNumber","_findLastWhitespaceBeforeLineNumber","low","high","delta","halfDelta","mid","_findFirstWhitespaceAfterLineNumber","firstWhitespaceAfterLineNumber","getFirstWhitespaceIndexAfterLineNumber","getVerticalOffsetForLineNumber","includeViewZones","arguments","undefined","previousLinesHeight","previousWhitespacesHeight","getVerticalOffsetAfterLineNumber","getWhitespaceMinWidth","isAfterLines","verticalOffset","totalHeight","isInTopPadding","isInBottomPadding","getLineNumberAtOrAfterVerticalOffset","linesCount","minLineNumber","maxLineNumber","midLineNumber","midLineNumberVerticalOffset","getLinesViewportData","verticalOffset1","verticalOffset2","startLineNumber","startLineNumberVerticalOffset","endLineNumber","whitespaceIndex","whitespaceCount","getWhitespacesCount","currentWhitespaceHeight","currentWhitespaceAfterLineNumber","getAfterLineNumberForWhitespaceIndex","getHeightForWhitespaceIndex","currentVerticalOffset","currentLineRelativeOffset","STEP_SIZE","bigNumbersDelta","floor","linesOffsets","verticalCenter","centeredLineNumber","currentLineTop","currentLineBottom","endLineNumberVerticalOffset","completelyVisibleStartLineNumber","completelyVisibleEndLineNumber","relativeVerticalOffset","getVerticalOffsetForWhitespaceIndex","getWhitespaceIndexAtOrAfterVerticallOffset","minWhitespaceIndex","maxWhitespaceIndex","maxWhitespaceVerticalOffset","maxWhitespaceHeight","midWhitespaceIndex","midWhitespaceVerticalOffset","midWhitespaceHeight","getWhitespaceAtVerticalOffset","candidateIndex","candidateTop","candidateHeight","candidateId","getIdForWhitespaceIndex","candidateAfterLineNumber","getWhitespaceViewportData","endIndex","top","getWhitespaces","slice"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/linesLayout.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nclass PendingChanges {\n    constructor() {\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n    }\n    insert(x) {\n        this._hasPending = true;\n        this._inserts.push(x);\n    }\n    change(x) {\n        this._hasPending = true;\n        this._changes.push(x);\n    }\n    remove(x) {\n        this._hasPending = true;\n        this._removes.push(x);\n    }\n    mustCommit() {\n        return this._hasPending;\n    }\n    commit(linesLayout) {\n        if (!this._hasPending) {\n            return;\n        }\n        const inserts = this._inserts;\n        const changes = this._changes;\n        const removes = this._removes;\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n        linesLayout._commitPendingChanges(inserts, changes, removes);\n    }\n}\nexport class EditorWhitespace {\n    constructor(id, afterLineNumber, ordinal, height, minWidth) {\n        this.id = id;\n        this.afterLineNumber = afterLineNumber;\n        this.ordinal = ordinal;\n        this.height = height;\n        this.minWidth = minWidth;\n        this.prefixSum = 0;\n    }\n}\n/**\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\n *\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\n */\nexport class LinesLayout {\n    constructor(lineCount, lineHeight, paddingTop, paddingBottom) {\n        this._instanceId = strings.singleLetterHash(++LinesLayout.INSTANCE_COUNT);\n        this._pendingChanges = new PendingChanges();\n        this._lastWhitespaceId = 0;\n        this._arr = [];\n        this._prefixSumValidIndex = -1;\n        this._minWidth = -1; /* marker for not being computed */\n        this._lineCount = lineCount;\n        this._lineHeight = lineHeight;\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Find the insertion index for a new value inside a sorted array of values.\n     * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n     */\n    static findInsertionIndex(arr, afterLineNumber, ordinal) {\n        let low = 0;\n        let high = arr.length;\n        while (low < high) {\n            const mid = ((low + high) >>> 1);\n            if (afterLineNumber === arr[mid].afterLineNumber) {\n                if (ordinal < arr[mid].ordinal) {\n                    high = mid;\n                }\n                else {\n                    low = mid + 1;\n                }\n            }\n            else if (afterLineNumber < arr[mid].afterLineNumber) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n    /**\n     * Change the height of a line in pixels.\n     */\n    setLineHeight(lineHeight) {\n        this._checkPendingChanges();\n        this._lineHeight = lineHeight;\n    }\n    /**\n     * Changes the padding used to calculate vertical offsets.\n     */\n    setPadding(paddingTop, paddingBottom) {\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Set the number of lines.\n     *\n     * @param lineCount New number of lines.\n     */\n    onFlushed(lineCount) {\n        this._checkPendingChanges();\n        this._lineCount = lineCount;\n    }\n    changeWhitespace(callback) {\n        let hadAChange = false;\n        try {\n            const accessor = {\n                insertWhitespace: (afterLineNumber, ordinal, heightInPx, minWidth) => {\n                    hadAChange = true;\n                    afterLineNumber = afterLineNumber | 0;\n                    ordinal = ordinal | 0;\n                    heightInPx = heightInPx | 0;\n                    minWidth = minWidth | 0;\n                    const id = this._instanceId + (++this._lastWhitespaceId);\n                    this._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber, ordinal, heightInPx, minWidth));\n                    return id;\n                },\n                changeOneWhitespace: (id, newAfterLineNumber, newHeight) => {\n                    hadAChange = true;\n                    newAfterLineNumber = newAfterLineNumber | 0;\n                    newHeight = newHeight | 0;\n                    this._pendingChanges.change({ id, newAfterLineNumber, newHeight });\n                },\n                removeWhitespace: (id) => {\n                    hadAChange = true;\n                    this._pendingChanges.remove({ id });\n                }\n            };\n            callback(accessor);\n        }\n        finally {\n            this._pendingChanges.commit(this);\n        }\n        return hadAChange;\n    }\n    _commitPendingChanges(inserts, changes, removes) {\n        if (inserts.length > 0 || removes.length > 0) {\n            this._minWidth = -1; /* marker for not being computed */\n        }\n        if (inserts.length + changes.length + removes.length <= 1) {\n            // when only one thing happened, handle it \"delicately\"\n            for (const insert of inserts) {\n                this._insertWhitespace(insert);\n            }\n            for (const change of changes) {\n                this._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);\n            }\n            for (const remove of removes) {\n                const index = this._findWhitespaceIndex(remove.id);\n                if (index === -1) {\n                    continue;\n                }\n                this._removeWhitespace(index);\n            }\n            return;\n        }\n        // simply rebuild the entire datastructure\n        const toRemove = new Set();\n        for (const remove of removes) {\n            toRemove.add(remove.id);\n        }\n        const toChange = new Map();\n        for (const change of changes) {\n            toChange.set(change.id, change);\n        }\n        const applyRemoveAndChange = (whitespaces) => {\n            const result = [];\n            for (const whitespace of whitespaces) {\n                if (toRemove.has(whitespace.id)) {\n                    continue;\n                }\n                if (toChange.has(whitespace.id)) {\n                    const change = toChange.get(whitespace.id);\n                    whitespace.afterLineNumber = change.newAfterLineNumber;\n                    whitespace.height = change.newHeight;\n                }\n                result.push(whitespace);\n            }\n            return result;\n        };\n        const result = applyRemoveAndChange(this._arr).concat(applyRemoveAndChange(inserts));\n        result.sort((a, b) => {\n            if (a.afterLineNumber === b.afterLineNumber) {\n                return a.ordinal - b.ordinal;\n            }\n            return a.afterLineNumber - b.afterLineNumber;\n        });\n        this._arr = result;\n        this._prefixSumValidIndex = -1;\n    }\n    _checkPendingChanges() {\n        if (this._pendingChanges.mustCommit()) {\n            this._pendingChanges.commit(this);\n        }\n    }\n    _insertWhitespace(whitespace) {\n        const insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);\n        this._arr.splice(insertIndex, 0, whitespace);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n    }\n    _findWhitespaceIndex(id) {\n        const arr = this._arr;\n        for (let i = 0, len = arr.length; i < len; i++) {\n            if (arr[i].id === id) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    _changeOneWhitespace(id, newAfterLineNumber, newHeight) {\n        const index = this._findWhitespaceIndex(id);\n        if (index === -1) {\n            return;\n        }\n        if (this._arr[index].height !== newHeight) {\n            this._arr[index].height = newHeight;\n            this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n        }\n        if (this._arr[index].afterLineNumber !== newAfterLineNumber) {\n            // `afterLineNumber` changed for this whitespace\n            // Record old whitespace\n            const whitespace = this._arr[index];\n            // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n            this._removeWhitespace(index);\n            whitespace.afterLineNumber = newAfterLineNumber;\n            // And add it again\n            this._insertWhitespace(whitespace);\n        }\n    }\n    _removeWhitespace(removeIndex) {\n        this._arr.splice(removeIndex, 1);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n    }\n    /**\n     * Notify the layouter that lines have been deleted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the deletion started, inclusive\n     * @param toLineNumber The line number at which the deletion ended, inclusive\n     */\n    onLinesDeleted(fromLineNumber, toLineNumber) {\n        this._checkPendingChanges();\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount -= (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n                // The line this whitespace was after has been deleted\n                //  => move whitespace to before first deleted line\n                this._arr[i].afterLineNumber = fromLineNumber - 1;\n            }\n            else if (afterLineNumber > toLineNumber) {\n                // The line this whitespace was after has been moved up\n                //  => move whitespace up\n                this._arr[i].afterLineNumber -= (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    }\n    /**\n     * Notify the layouter that lines have been inserted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the insertion started, inclusive\n     * @param toLineNumber The line number at which the insertion ended, inclusive.\n     */\n    onLinesInserted(fromLineNumber, toLineNumber) {\n        this._checkPendingChanges();\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount += (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber) {\n                this._arr[i].afterLineNumber += (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    }\n    /**\n     * Get the sum of all the whitespaces.\n     */\n    getWhitespacesTotalHeight() {\n        this._checkPendingChanges();\n        if (this._arr.length === 0) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(this._arr.length - 1);\n    }\n    /**\n     * Return the sum of the heights of the whitespaces at [0..index].\n     * This includes the whitespace at `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n     */\n    getWhitespacesAccumulatedHeight(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        let startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n        if (startIndex === 0) {\n            this._arr[0].prefixSum = this._arr[0].height;\n            startIndex++;\n        }\n        for (let i = startIndex; i <= index; i++) {\n            this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;\n        }\n        this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n        return this._arr[index].prefixSum;\n    }\n    /**\n     * Get the sum of heights for all objects.\n     *\n     * @return The sum of heights for all objects.\n     */\n    getLinesTotalHeight() {\n        this._checkPendingChanges();\n        const linesHeight = this._lineHeight * this._lineCount;\n        const whitespacesHeight = this.getWhitespacesTotalHeight();\n        return linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;\n    }\n    /**\n     * Returns the accumulated height of whitespaces before the given line number.\n     *\n     * @param lineNumber The line number\n     */\n    getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        if (lastWhitespaceBeforeLineNumber === -1) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n    }\n    _findLastWhitespaceBeforeLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        // Find the whitespace before line number\n        const arr = this._arr;\n        let low = 0;\n        let high = arr.length - 1;\n        while (low <= high) {\n            const delta = (high - low) | 0;\n            const halfDelta = (delta / 2) | 0;\n            const mid = (low + halfDelta) | 0;\n            if (arr[mid].afterLineNumber < lineNumber) {\n                if (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {\n                    return mid;\n                }\n                else {\n                    low = (mid + 1) | 0;\n                }\n            }\n            else {\n                high = (mid - 1) | 0;\n            }\n        }\n        return -1;\n    }\n    _findFirstWhitespaceAfterLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        const firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n        if (firstWhitespaceAfterLineNumber < this._arr.length) {\n            return firstWhitespaceAfterLineNumber;\n        }\n        return -1;\n    }\n    /**\n     * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n     * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n     */\n    getFirstWhitespaceIndexAfterLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        return this._findFirstWhitespaceAfterLineNumber(lineNumber);\n    }\n    /**\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n     *\n     * @param lineNumber The line number\n     * @return The sum of heights for all objects above `lineNumber`.\n     */\n    getVerticalOffsetForLineNumber(lineNumber, includeViewZones = false) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        let previousLinesHeight;\n        if (lineNumber > 1) {\n            previousLinesHeight = this._lineHeight * (lineNumber - 1);\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber - (includeViewZones ? 1 : 0));\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    /**\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n     *\n     * @param lineNumber The line number\n     * @return The sum of heights for all objects above `lineNumber`.\n     */\n    getVerticalOffsetAfterLineNumber(lineNumber, includeViewZones = false) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        const previousLinesHeight = this._lineHeight * lineNumber;\n        const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber + (includeViewZones ? 1 : 0));\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    /**\n     * The maximum min width for all whitespaces.\n     */\n    getWhitespaceMinWidth() {\n        this._checkPendingChanges();\n        if (this._minWidth === -1) {\n            let minWidth = 0;\n            for (let i = 0, len = this._arr.length; i < len; i++) {\n                minWidth = Math.max(minWidth, this._arr[i].minWidth);\n            }\n            this._minWidth = minWidth;\n        }\n        return this._minWidth;\n    }\n    /**\n     * Check if `verticalOffset` is below all lines.\n     */\n    isAfterLines(verticalOffset) {\n        this._checkPendingChanges();\n        const totalHeight = this.getLinesTotalHeight();\n        return verticalOffset > totalHeight;\n    }\n    isInTopPadding(verticalOffset) {\n        if (this._paddingTop === 0) {\n            return false;\n        }\n        this._checkPendingChanges();\n        return (verticalOffset < this._paddingTop);\n    }\n    isInBottomPadding(verticalOffset) {\n        if (this._paddingBottom === 0) {\n            return false;\n        }\n        this._checkPendingChanges();\n        const totalHeight = this.getLinesTotalHeight();\n        return (verticalOffset >= totalHeight - this._paddingBottom);\n    }\n    /**\n     * Find the first line number that is at or after vertical offset `verticalOffset`.\n     * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\n     * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\n     *\n     * @param verticalOffset The vertical offset to search at.\n     * @return The line number at or after vertical offset `verticalOffset`.\n     */\n    getLineNumberAtOrAfterVerticalOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        if (verticalOffset < 0) {\n            return 1;\n        }\n        const linesCount = this._lineCount | 0;\n        const lineHeight = this._lineHeight;\n        let minLineNumber = 1;\n        let maxLineNumber = linesCount;\n        while (minLineNumber < maxLineNumber) {\n            const midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;\n            const midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n            if (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n                // vertical offset is after mid line number\n                minLineNumber = midLineNumber + 1;\n            }\n            else if (verticalOffset >= midLineNumberVerticalOffset) {\n                // Hit\n                return midLineNumber;\n            }\n            else {\n                // vertical offset is before mid line number, but mid line number could still be what we're searching for\n                maxLineNumber = midLineNumber;\n            }\n        }\n        if (minLineNumber > linesCount) {\n            return linesCount;\n        }\n        return minLineNumber;\n    }\n    /**\n     * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\n     */\n    getLinesViewportData(verticalOffset1, verticalOffset2) {\n        this._checkPendingChanges();\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        const lineHeight = this._lineHeight;\n        // Find first line number\n        // We don't live in a perfect world, so the line number might start before or after verticalOffset1\n        const startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n        const startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n        let endLineNumber = this._lineCount | 0;\n        // Also keep track of what whitespace we've got\n        let whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n        const whitespaceCount = this.getWhitespacesCount() | 0;\n        let currentWhitespaceHeight;\n        let currentWhitespaceAfterLineNumber;\n        if (whitespaceIndex === -1) {\n            whitespaceIndex = whitespaceCount;\n            currentWhitespaceAfterLineNumber = endLineNumber + 1;\n            currentWhitespaceHeight = 0;\n        }\n        else {\n            currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n            currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n        }\n        let currentVerticalOffset = startLineNumberVerticalOffset;\n        let currentLineRelativeOffset = currentVerticalOffset;\n        // IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n        const STEP_SIZE = 500000;\n        let bigNumbersDelta = 0;\n        if (startLineNumberVerticalOffset >= STEP_SIZE) {\n            // Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n            bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n            bigNumbersDelta = Math.floor(bigNumbersDelta / lineHeight) * lineHeight;\n            currentLineRelativeOffset -= bigNumbersDelta;\n        }\n        const linesOffsets = [];\n        const verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n        let centeredLineNumber = -1;\n        // Figure out how far the lines go\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            if (centeredLineNumber === -1) {\n                const currentLineTop = currentVerticalOffset;\n                const currentLineBottom = currentVerticalOffset + lineHeight;\n                if ((currentLineTop <= verticalCenter && verticalCenter < currentLineBottom) || currentLineTop > verticalCenter) {\n                    centeredLineNumber = lineNumber;\n                }\n            }\n            // Count current line height in the vertical offsets\n            currentVerticalOffset += lineHeight;\n            linesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;\n            // Next line starts immediately after this one\n            currentLineRelativeOffset += lineHeight;\n            while (currentWhitespaceAfterLineNumber === lineNumber) {\n                // Push down next line with the height of the current whitespace\n                currentLineRelativeOffset += currentWhitespaceHeight;\n                // Count current whitespace in the vertical offsets\n                currentVerticalOffset += currentWhitespaceHeight;\n                whitespaceIndex++;\n                if (whitespaceIndex >= whitespaceCount) {\n                    currentWhitespaceAfterLineNumber = endLineNumber + 1;\n                }\n                else {\n                    currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n                    currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n                }\n            }\n            if (currentVerticalOffset >= verticalOffset2) {\n                // We have covered the entire viewport area, time to stop\n                endLineNumber = lineNumber;\n                break;\n            }\n        }\n        if (centeredLineNumber === -1) {\n            centeredLineNumber = endLineNumber;\n        }\n        const endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n        let completelyVisibleStartLineNumber = startLineNumber;\n        let completelyVisibleEndLineNumber = endLineNumber;\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (startLineNumberVerticalOffset < verticalOffset1) {\n                completelyVisibleStartLineNumber++;\n            }\n        }\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (endLineNumberVerticalOffset + lineHeight > verticalOffset2) {\n                completelyVisibleEndLineNumber--;\n            }\n        }\n        return {\n            bigNumbersDelta: bigNumbersDelta,\n            startLineNumber: startLineNumber,\n            endLineNumber: endLineNumber,\n            relativeVerticalOffset: linesOffsets,\n            centeredLineNumber: centeredLineNumber,\n            completelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n            completelyVisibleEndLineNumber: completelyVisibleEndLineNumber,\n            lineHeight: this._lineHeight,\n        };\n    }\n    getVerticalOffsetForWhitespaceIndex(whitespaceIndex) {\n        this._checkPendingChanges();\n        whitespaceIndex = whitespaceIndex | 0;\n        const afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n        let previousLinesHeight;\n        if (afterLineNumber >= 1) {\n            previousLinesHeight = this._lineHeight * afterLineNumber;\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        let previousWhitespacesHeight;\n        if (whitespaceIndex > 0) {\n            previousWhitespacesHeight = this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1);\n        }\n        else {\n            previousWhitespacesHeight = 0;\n        }\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        let minWhitespaceIndex = 0;\n        let maxWhitespaceIndex = this.getWhitespacesCount() - 1;\n        if (maxWhitespaceIndex < 0) {\n            return -1;\n        }\n        // Special case: nothing to be found\n        const maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n        const maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n        if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n            return -1;\n        }\n        while (minWhitespaceIndex < maxWhitespaceIndex) {\n            const midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n            const midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n            const midWhitespaceHeight = this.getHeightForWhitespaceIndex(midWhitespaceIndex);\n            if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n                // vertical offset is after whitespace\n                minWhitespaceIndex = midWhitespaceIndex + 1;\n            }\n            else if (verticalOffset >= midWhitespaceVerticalOffset) {\n                // Hit\n                return midWhitespaceIndex;\n            }\n            else {\n                // vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n                maxWhitespaceIndex = midWhitespaceIndex;\n            }\n        }\n        return minWhitespaceIndex;\n    }\n    /**\n     * Get exactly the whitespace that is layouted at `verticalOffset`.\n     *\n     * @param verticalOffset The vertical offset.\n     * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\n     */\n    getWhitespaceAtVerticalOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        const candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n        if (candidateIndex < 0) {\n            return null;\n        }\n        if (candidateIndex >= this.getWhitespacesCount()) {\n            return null;\n        }\n        const candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n        if (candidateTop > verticalOffset) {\n            return null;\n        }\n        const candidateHeight = this.getHeightForWhitespaceIndex(candidateIndex);\n        const candidateId = this.getIdForWhitespaceIndex(candidateIndex);\n        const candidateAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n        return {\n            id: candidateId,\n            afterLineNumber: candidateAfterLineNumber,\n            verticalOffset: candidateTop,\n            height: candidateHeight\n        };\n    }\n    /**\n     * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\n     */\n    getWhitespaceViewportData(verticalOffset1, verticalOffset2) {\n        this._checkPendingChanges();\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        const startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n        const endIndex = this.getWhitespacesCount() - 1;\n        if (startIndex < 0) {\n            return [];\n        }\n        const result = [];\n        for (let i = startIndex; i <= endIndex; i++) {\n            const top = this.getVerticalOffsetForWhitespaceIndex(i);\n            const height = this.getHeightForWhitespaceIndex(i);\n            if (top >= verticalOffset2) {\n                break;\n            }\n            result.push({\n                id: this.getIdForWhitespaceIndex(i),\n                afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(i),\n                verticalOffset: top,\n                height: height\n            });\n        }\n        return result;\n    }\n    /**\n     * Get all whitespaces.\n     */\n    getWhitespaces() {\n        this._checkPendingChanges();\n        return this._arr.slice(0);\n    }\n    /**\n     * The number of whitespaces.\n     */\n    getWhitespacesCount() {\n        this._checkPendingChanges();\n        return this._arr.length;\n    }\n    /**\n     * Get the `id` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `id` of whitespace at `index`.\n     */\n    getIdForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].id;\n    }\n    /**\n     * Get the `afterLineNumber` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `afterLineNumber` of whitespace at `index`.\n     */\n    getAfterLineNumberForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].afterLineNumber;\n    }\n    /**\n     * Get the `height` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `height` of whitespace at `index`.\n     */\n    getHeightForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].height;\n    }\n}\nLinesLayout.INSTANCE_COUNT = 0;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}