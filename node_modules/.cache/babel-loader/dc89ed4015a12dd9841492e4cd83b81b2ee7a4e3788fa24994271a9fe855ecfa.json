{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.object.to-string.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLast } from '../../../base/common/arraysFind.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nexport var GuidesTextModelPart = /*#__PURE__*/function (_TextModelPart) {\n  function GuidesTextModelPart(textModel, languageConfigurationService) {\n    var _this;\n    _classCallCheck(this, GuidesTextModelPart);\n    _this = _callSuper(this, GuidesTextModelPart);\n    _this.textModel = textModel;\n    _this.languageConfigurationService = languageConfigurationService;\n    return _this;\n  }\n  _inherits(GuidesTextModelPart, _TextModelPart);\n  return _createClass(GuidesTextModelPart, [{\n    key: \"getLanguageConfiguration\",\n    value: function getLanguageConfiguration(languageId) {\n      return this.languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n  }, {\n    key: \"_computeIndentLevel\",\n    value: function _computeIndentLevel(lineIndex) {\n      return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n    }\n  }, {\n    key: \"getActiveIndentGuide\",\n    value: function getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n      var _this2 = this;\n      this.assertNotDisposed();\n      var lineCount = this.textModel.getLineCount();\n      if (lineNumber < 1 || lineNumber > lineCount) {\n        throw new BugIndicatingError('Illegal value for lineNumber');\n      }\n      var foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n      var offSide = Boolean(foldingRules && foldingRules.offSide);\n      var up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n      var up_aboveContentLineIndent = -1;\n      var up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n      var up_belowContentLineIndent = -1;\n      var up_resolveIndents = function up_resolveIndents(lineNumber) {\n        if (up_aboveContentLineIndex !== -1 && (up_aboveContentLineIndex === -2 || up_aboveContentLineIndex > lineNumber - 1)) {\n          up_aboveContentLineIndex = -1;\n          up_aboveContentLineIndent = -1;\n          // must find previous line with content\n          for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n            var _indent = _this2._computeIndentLevel(lineIndex);\n            if (_indent >= 0) {\n              up_aboveContentLineIndex = lineIndex;\n              up_aboveContentLineIndent = _indent;\n              break;\n            }\n          }\n        }\n        if (up_belowContentLineIndex === -2) {\n          up_belowContentLineIndex = -1;\n          up_belowContentLineIndent = -1;\n          // must find next line with content\n          for (var _lineIndex = lineNumber; _lineIndex < lineCount; _lineIndex++) {\n            var _indent2 = _this2._computeIndentLevel(_lineIndex);\n            if (_indent2 >= 0) {\n              up_belowContentLineIndex = _lineIndex;\n              up_belowContentLineIndent = _indent2;\n              break;\n            }\n          }\n        }\n      };\n      var down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n      var down_aboveContentLineIndent = -1;\n      var down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n      var down_belowContentLineIndent = -1;\n      var down_resolveIndents = function down_resolveIndents(lineNumber) {\n        if (down_aboveContentLineIndex === -2) {\n          down_aboveContentLineIndex = -1;\n          down_aboveContentLineIndent = -1;\n          // must find previous line with content\n          for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n            var _indent3 = _this2._computeIndentLevel(lineIndex);\n            if (_indent3 >= 0) {\n              down_aboveContentLineIndex = lineIndex;\n              down_aboveContentLineIndent = _indent3;\n              break;\n            }\n          }\n        }\n        if (down_belowContentLineIndex !== -1 && (down_belowContentLineIndex === -2 || down_belowContentLineIndex < lineNumber - 1)) {\n          down_belowContentLineIndex = -1;\n          down_belowContentLineIndent = -1;\n          // must find next line with content\n          for (var _lineIndex2 = lineNumber; _lineIndex2 < lineCount; _lineIndex2++) {\n            var _indent4 = _this2._computeIndentLevel(_lineIndex2);\n            if (_indent4 >= 0) {\n              down_belowContentLineIndex = _lineIndex2;\n              down_belowContentLineIndent = _indent4;\n              break;\n            }\n          }\n        }\n      };\n      var startLineNumber = 0;\n      var goUp = true;\n      var endLineNumber = 0;\n      var goDown = true;\n      var indent = 0;\n      var initialIndent = 0;\n      for (var distance = 0; goUp || goDown; distance++) {\n        var upLineNumber = lineNumber - distance;\n        var downLineNumber = lineNumber + distance;\n        if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n          goUp = false;\n        }\n        if (distance > 1 && (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n          goDown = false;\n        }\n        if (distance > 50000) {\n          // stop processing\n          goUp = false;\n          goDown = false;\n        }\n        var upLineIndentLevel = -1;\n        if (goUp && upLineNumber >= 1) {\n          // compute indent level going up\n          var currentIndent = this._computeIndentLevel(upLineNumber - 1);\n          if (currentIndent >= 0) {\n            // This line has content (besides whitespace)\n            // Use the line's indent\n            up_belowContentLineIndex = upLineNumber - 1;\n            up_belowContentLineIndent = currentIndent;\n            upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n          } else {\n            up_resolveIndents(upLineNumber);\n            upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n          }\n        }\n        var downLineIndentLevel = -1;\n        if (goDown && downLineNumber <= lineCount) {\n          // compute indent level going down\n          var _currentIndent = this._computeIndentLevel(downLineNumber - 1);\n          if (_currentIndent >= 0) {\n            // This line has content (besides whitespace)\n            // Use the line's indent\n            down_aboveContentLineIndex = downLineNumber - 1;\n            down_aboveContentLineIndent = _currentIndent;\n            downLineIndentLevel = Math.ceil(_currentIndent / this.textModel.getOptions().indentSize);\n          } else {\n            down_resolveIndents(downLineNumber);\n            downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n          }\n        }\n        if (distance === 0) {\n          initialIndent = upLineIndentLevel;\n          continue;\n        }\n        if (distance === 1) {\n          if (downLineNumber <= lineCount && downLineIndentLevel >= 0 && initialIndent + 1 === downLineIndentLevel) {\n            // This is the beginning of a scope, we have special handling here, since we want the\n            // child scope indent to be active, not the parent scope\n            goUp = false;\n            startLineNumber = downLineNumber;\n            endLineNumber = downLineNumber;\n            indent = downLineIndentLevel;\n            continue;\n          }\n          if (upLineNumber >= 1 && upLineIndentLevel >= 0 && upLineIndentLevel - 1 === initialIndent) {\n            // This is the end of a scope, just like above\n            goDown = false;\n            startLineNumber = upLineNumber;\n            endLineNumber = upLineNumber;\n            indent = upLineIndentLevel;\n            continue;\n          }\n          startLineNumber = lineNumber;\n          endLineNumber = lineNumber;\n          indent = initialIndent;\n          if (indent === 0) {\n            // No need to continue\n            return {\n              startLineNumber: startLineNumber,\n              endLineNumber: endLineNumber,\n              indent: indent\n            };\n          }\n        }\n        if (goUp) {\n          if (upLineIndentLevel >= indent) {\n            startLineNumber = upLineNumber;\n          } else {\n            goUp = false;\n          }\n        }\n        if (goDown) {\n          if (downLineIndentLevel >= indent) {\n            endLineNumber = downLineNumber;\n          } else {\n            goDown = false;\n          }\n        }\n      }\n      return {\n        startLineNumber: startLineNumber,\n        endLineNumber: endLineNumber,\n        indent: indent\n      };\n    }\n  }, {\n    key: \"getLinesBracketGuides\",\n    value: function getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n      var _a;\n      var result = [];\n      for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n        result.push([]);\n      }\n      // If requested, this could be made configurable.\n      var includeSingleLinePairs = true;\n      var bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber))).toArray();\n      var activeBracketPairRange = undefined;\n      if (activePosition && bracketPairs.length > 0) {\n        var bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber && activePosition.lineNumber <= endLineNumber\n        // We don't need to query the brackets again if the cursor is in the viewport\n        ? bracketPairs : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition)).toArray()).filter(function (bp) {\n          return Range.strictContainsPosition(bp.range, activePosition);\n        });\n        activeBracketPairRange = (_a = findLast(bracketsContainingActivePosition, function (i) {\n          return includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber;\n        })) === null || _a === void 0 ? void 0 : _a.range;\n      }\n      var independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;\n      var colorProvider = new BracketPairGuidesClassNames();\n      var _iterator = _createForOfIteratorHelper(bracketPairs),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var pair = _step.value;\n          /*\n                    {\n                  |\n                  }\n                   {\n                  |\n                  ----}\n               ____{\n              |test\n              ----}\n               renderHorizontalEndLineAtTheBottom:\n                  {\n                  |\n                  |x}\n                  --\n              renderHorizontalEndLineAtTheBottom:\n              ____{\n              |test\n              | x }\n              ----\n          */\n          if (!pair.closingBracketRange) {\n            continue;\n          }\n          var isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);\n          if (!isActive && !options.includeInactive) {\n            continue;\n          }\n          var className = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) + (options.highlightActive && isActive ? ' ' + colorProvider.activeClassName : '');\n          var start = pair.openingBracketRange.getStartPosition();\n          var end = pair.closingBracketRange.getStartPosition();\n          var horizontalGuides = options.horizontalGuides === HorizontalGuidesState.Enabled || options.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive;\n          if (pair.range.startLineNumber === pair.range.endLineNumber) {\n            if (includeSingleLinePairs && horizontalGuides) {\n              result[pair.range.startLineNumber - startLineNumber].push(new IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, className, new IndentGuideHorizontalLine(false, end.column), -1, -1));\n            }\n            continue;\n          }\n          var endVisibleColumn = this.getVisibleColumnFromPosition(end);\n          var startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition());\n          var guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);\n          var renderHorizontalEndLineAtTheBottom = false;\n          var firstNonWsIndex = strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n          var hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;\n          if (hasTextBeforeClosingBracket) {\n            renderHorizontalEndLineAtTheBottom = true;\n          }\n          var visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);\n          var visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);\n          var offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;\n          for (var l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {\n            result[l - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, null, l === start.lineNumber ? start.column : -1, l === end.lineNumber ? end.column : -1));\n          }\n          if (horizontalGuides) {\n            if (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {\n              result[start.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(false, start.column), -1, -1));\n            }\n            if (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {\n              result[end.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1));\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      for (var _i = 0, _result = result; _i < _result.length; _i++) {\n        var guides = _result[_i];\n        guides.sort(function (a, b) {\n          return a.visibleColumn - b.visibleColumn;\n        });\n      }\n      return result;\n    }\n  }, {\n    key: \"getVisibleColumnFromPosition\",\n    value: function getVisibleColumnFromPosition(position) {\n      return CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1;\n    }\n  }, {\n    key: \"getLinesIndentGuides\",\n    value: function getLinesIndentGuides(startLineNumber, endLineNumber) {\n      this.assertNotDisposed();\n      var lineCount = this.textModel.getLineCount();\n      if (startLineNumber < 1 || startLineNumber > lineCount) {\n        throw new Error('Illegal value for startLineNumber');\n      }\n      if (endLineNumber < 1 || endLineNumber > lineCount) {\n        throw new Error('Illegal value for endLineNumber');\n      }\n      var options = this.textModel.getOptions();\n      var foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n      var offSide = Boolean(foldingRules && foldingRules.offSide);\n      var result = new Array(endLineNumber - startLineNumber + 1);\n      var aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n      var aboveContentLineIndent = -1;\n      var belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n      var belowContentLineIndent = -1;\n      for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n        var resultIndex = lineNumber - startLineNumber;\n        var currentIndent = this._computeIndentLevel(lineNumber - 1);\n        if (currentIndent >= 0) {\n          // This line has content (besides whitespace)\n          // Use the line's indent\n          aboveContentLineIndex = lineNumber - 1;\n          aboveContentLineIndent = currentIndent;\n          result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n          continue;\n        }\n        if (aboveContentLineIndex === -2) {\n          aboveContentLineIndex = -1;\n          aboveContentLineIndent = -1;\n          // must find previous line with content\n          for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n            var indent = this._computeIndentLevel(lineIndex);\n            if (indent >= 0) {\n              aboveContentLineIndex = lineIndex;\n              aboveContentLineIndent = indent;\n              break;\n            }\n          }\n        }\n        if (belowContentLineIndex !== -1 && (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n          belowContentLineIndex = -1;\n          belowContentLineIndent = -1;\n          // must find next line with content\n          for (var _lineIndex3 = lineNumber; _lineIndex3 < lineCount; _lineIndex3++) {\n            var _indent5 = this._computeIndentLevel(_lineIndex3);\n            if (_indent5 >= 0) {\n              belowContentLineIndex = _lineIndex3;\n              belowContentLineIndent = _indent5;\n              break;\n            }\n          }\n        }\n        result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n      }\n      return result;\n    }\n  }, {\n    key: \"_getIndentLevelForWhitespaceLine\",\n    value: function _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n      var options = this.textModel.getOptions();\n      if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n        // At the top or bottom of the file\n        return 0;\n      } else if (aboveContentLineIndent < belowContentLineIndent) {\n        // we are inside the region above\n        return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n      } else if (aboveContentLineIndent === belowContentLineIndent) {\n        // we are in between two regions\n        return Math.ceil(belowContentLineIndent / options.indentSize);\n      } else {\n        if (offSide) {\n          // same level as region below\n          return Math.ceil(belowContentLineIndent / options.indentSize);\n        } else {\n          // we are inside the region that ends below\n          return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n        }\n      }\n    }\n  }]);\n}(TextModelPart);\nexport var BracketPairGuidesClassNames = /*#__PURE__*/function () {\n  function BracketPairGuidesClassNames() {\n    _classCallCheck(this, BracketPairGuidesClassNames);\n    this.activeClassName = 'indent-active';\n  }\n  return _createClass(BracketPairGuidesClassNames, [{\n    key: \"getInlineClassName\",\n    value: function getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {\n      return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);\n    }\n  }, {\n    key: \"getInlineClassNameOfLevel\",\n    value: function getInlineClassNameOfLevel(level) {\n      // To support a dynamic amount of colors up to 6 colors,\n      // we use a number that is a lcm of all numbers from 1 to 6.\n      return \"bracket-indent-guide lvl-\".concat(level % 30);\n    }\n  }]);\n}();","map":{"version":3,"names":["findLast","strings","CursorColumns","Range","TextModelPart","computeIndentLevel","HorizontalGuidesState","IndentGuide","IndentGuideHorizontalLine","BugIndicatingError","GuidesTextModelPart","_TextModelPart","textModel","languageConfigurationService","_this","_classCallCheck","_callSuper","_inherits","_createClass","key","value","getLanguageConfiguration","languageId","_computeIndentLevel","lineIndex","getLineContent","getOptions","tabSize","getActiveIndentGuide","lineNumber","minLineNumber","maxLineNumber","_this2","assertNotDisposed","lineCount","getLineCount","foldingRules","getLanguageId","offSide","Boolean","up_aboveContentLineIndex","up_aboveContentLineIndent","up_belowContentLineIndex","up_belowContentLineIndent","up_resolveIndents","indent","down_aboveContentLineIndex","down_aboveContentLineIndent","down_belowContentLineIndex","down_belowContentLineIndent","down_resolveIndents","startLineNumber","goUp","endLineNumber","goDown","initialIndent","distance","upLineNumber","downLineNumber","upLineIndentLevel","currentIndent","Math","ceil","indentSize","_getIndentLevelForWhitespaceLine","downLineIndentLevel","getLinesBracketGuides","activePosition","options","_a","result","push","includeSingleLinePairs","bracketPairs","getBracketPairsInRangeWithMinIndentation","getLineMaxColumn","toArray","activeBracketPairRange","undefined","length","bracketsContainingActivePosition","getBracketPairsInRange","fromPositions","filter","bp","strictContainsPosition","range","i","independentColorPoolPerBracketType","bracketPairColorizationOptions","colorProvider","BracketPairGuidesClassNames","_iterator","_createForOfIteratorHelper","_step","s","n","done","pair","closingBracketRange","isActive","equalsRange","includeInactive","className","getInlineClassName","nestingLevel","nestingLevelOfEqualBracketType","highlightActive","activeClassName","start","openingBracketRange","getStartPosition","end","horizontalGuides","Enabled","EnabledForActive","getEndPosition","column","endVisibleColumn","getVisibleColumnFromPosition","startVisibleColumn","guideVisibleColumn","min","minVisibleColumnIndentation","renderHorizontalEndLineAtTheBottom","firstNonWsIndex","firstNonWhitespaceIndex","hasTextBeforeClosingBracket","startColumn","visibleGuideStartLineNumber","max","visibleGuideEndLineNumber","offset","l","err","e","f","_i","_result","guides","sort","a","b","visibleColumn","position","visibleColumnFromColumn","getLinesIndentGuides","Error","Array","aboveContentLineIndex","aboveContentLineIndent","belowContentLineIndex","belowContentLineIndent","resultIndex","floor","getInlineClassNameOfLevel","level","concat"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLast } from '../../../base/common/arraysFind.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nexport class GuidesTextModelPart extends TextModelPart {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n    }\n    getLanguageConfiguration(languageId) {\n        return this.languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    _computeIndentLevel(lineIndex) {\n        return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_aboveContentLineIndent = -1;\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_belowContentLineIndent = -1;\n        const up_resolveIndents = (lineNumber) => {\n            if (up_aboveContentLineIndex !== -1 &&\n                (up_aboveContentLineIndex === -2 ||\n                    up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_aboveContentLineIndent = -1;\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_belowContentLineIndent = -1;\n        const down_resolveIndents = (lineNumber) => {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 &&\n                (down_belowContentLineIndex === -2 ||\n                    down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let startLineNumber = 0;\n        let goUp = true;\n        let endLineNumber = 0;\n        let goDown = true;\n        let indent = 0;\n        let initialIndent = 0;\n        for (let distance = 0; goUp || goDown; distance++) {\n            const upLineNumber = lineNumber - distance;\n            const downLineNumber = lineNumber + distance;\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance > 1 &&\n                (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            let upLineIndentLevel = -1;\n            if (goUp && upLineNumber >= 1) {\n                // compute indent level going up\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n            }\n            let downLineIndentLevel = -1;\n            if (goDown && downLineNumber <= lineCount) {\n                // compute indent level going down\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n            }\n            if (distance === 0) {\n                initialIndent = upLineIndentLevel;\n                continue;\n            }\n            if (distance === 1) {\n                if (downLineNumber <= lineCount &&\n                    downLineIndentLevel >= 0 &&\n                    initialIndent + 1 === downLineIndentLevel) {\n                    // This is the beginning of a scope, we have special handling here, since we want the\n                    // child scope indent to be active, not the parent scope\n                    goUp = false;\n                    startLineNumber = downLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = downLineIndentLevel;\n                    continue;\n                }\n                if (upLineNumber >= 1 &&\n                    upLineIndentLevel >= 0 &&\n                    upLineIndentLevel - 1 === initialIndent) {\n                    // This is the end of a scope, just like above\n                    goDown = false;\n                    startLineNumber = upLineNumber;\n                    endLineNumber = upLineNumber;\n                    indent = upLineIndentLevel;\n                    continue;\n                }\n                startLineNumber = lineNumber;\n                endLineNumber = lineNumber;\n                indent = initialIndent;\n                if (indent === 0) {\n                    // No need to continue\n                    return { startLineNumber, endLineNumber, indent };\n                }\n            }\n            if (goUp) {\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber, endLineNumber, indent };\n    }\n    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n        var _a;\n        const result = [];\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            result.push([]);\n        }\n        // If requested, this could be made configurable.\n        const includeSingleLinePairs = true;\n        const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber))).toArray();\n        let activeBracketPairRange = undefined;\n        if (activePosition && bracketPairs.length > 0) {\n            const bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber &&\n                activePosition.lineNumber <= endLineNumber\n                // We don't need to query the brackets again if the cursor is in the viewport\n                ? bracketPairs\n                : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition)).toArray()).filter((bp) => Range.strictContainsPosition(bp.range, activePosition));\n            activeBracketPairRange = (_a = findLast(bracketsContainingActivePosition, (i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber)) === null || _a === void 0 ? void 0 : _a.range;\n        }\n        const independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;\n        const colorProvider = new BracketPairGuidesClassNames();\n        for (const pair of bracketPairs) {\n            /*\n\n\n                    {\n                    |\n                    }\n\n                    {\n                    |\n                    ----}\n\n                ____{\n                |test\n                ----}\n\n                renderHorizontalEndLineAtTheBottom:\n                    {\n                    |\n                    |x}\n                    --\n                renderHorizontalEndLineAtTheBottom:\n                ____{\n                |test\n                | x }\n                ----\n            */\n            if (!pair.closingBracketRange) {\n                continue;\n            }\n            const isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);\n            if (!isActive && !options.includeInactive) {\n                continue;\n            }\n            const className = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) +\n                (options.highlightActive && isActive\n                    ? ' ' + colorProvider.activeClassName\n                    : '');\n            const start = pair.openingBracketRange.getStartPosition();\n            const end = pair.closingBracketRange.getStartPosition();\n            const horizontalGuides = options.horizontalGuides === HorizontalGuidesState.Enabled || (options.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive);\n            if (pair.range.startLineNumber === pair.range.endLineNumber) {\n                if (includeSingleLinePairs && horizontalGuides) {\n                    result[pair.range.startLineNumber - startLineNumber].push(new IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, className, new IndentGuideHorizontalLine(false, end.column), -1, -1));\n                }\n                continue;\n            }\n            const endVisibleColumn = this.getVisibleColumnFromPosition(end);\n            const startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition());\n            const guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);\n            let renderHorizontalEndLineAtTheBottom = false;\n            const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n            const hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;\n            if (hasTextBeforeClosingBracket) {\n                renderHorizontalEndLineAtTheBottom = true;\n            }\n            const visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);\n            const visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);\n            const offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;\n            for (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {\n                result[l - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, null, l === start.lineNumber ? start.column : -1, l === end.lineNumber ? end.column : -1));\n            }\n            if (horizontalGuides) {\n                if (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {\n                    result[start.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(false, start.column), -1, -1));\n                }\n                if (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {\n                    result[end.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1));\n                }\n            }\n        }\n        for (const guides of result) {\n            guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n        }\n        return result;\n    }\n    getVisibleColumnFromPosition(position) {\n        return (CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        const options = this.textModel.getOptions();\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        const result = new Array(endLineNumber - startLineNumber + 1);\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let aboveContentLineIndent = -1;\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let belowContentLineIndent = -1;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const resultIndex = lineNumber - startLineNumber;\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 &&\n                (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    }\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n        const options = this.textModel.getOptions();\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n            }\n        }\n    }\n}\nexport class BracketPairGuidesClassNames {\n    constructor() {\n        this.activeClassName = 'indent-active';\n    }\n    getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-indent-guide lvl-${level % 30}`;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}