{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.fill.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.object.to-string.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { createModelLineProjection } from './modelLineProjection.js';\nimport { ConstantTimePrefixSumComputer } from '../model/prefixSumComputer.js';\nimport { ViewLineData } from '../viewModel.js';\nexport var ViewModelLinesFromProjectedModel = /*#__PURE__*/function () {\n  function ViewModelLinesFromProjectedModel(editorId, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent, wordBreak) {\n    _classCallCheck(this, ViewModelLinesFromProjectedModel);\n    this._editorId = editorId;\n    this.model = model;\n    this._validModelVersionId = -1;\n    this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n    this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n    this.fontInfo = fontInfo;\n    this.tabSize = tabSize;\n    this.wrappingStrategy = wrappingStrategy;\n    this.wrappingColumn = wrappingColumn;\n    this.wrappingIndent = wrappingIndent;\n    this.wordBreak = wordBreak;\n    this._constructLines( /*resetHiddenAreas*/true, null);\n  }\n  return _createClass(ViewModelLinesFromProjectedModel, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n    }\n  }, {\n    key: \"createCoordinatesConverter\",\n    value: function createCoordinatesConverter() {\n      return new CoordinatesConverter(this);\n    }\n  }, {\n    key: \"_constructLines\",\n    value: function _constructLines(resetHiddenAreas, previousLineBreaks) {\n      var _this = this;\n      this.modelLineProjections = [];\n      if (resetHiddenAreas) {\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n      }\n      var linesContent = this.model.getLinesContent();\n      var injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n      var lineCount = linesContent.length;\n      var lineBreaksComputer = this.createLineBreaksComputer();\n      var injectedTextQueue = new arrays.ArrayQueue(LineInjectedText.fromDecorations(injectedTextDecorations));\n      var _loop = function _loop(i) {\n        var lineInjectedText = injectedTextQueue.takeWhile(function (t) {\n          return t.lineNumber === i + 1;\n        });\n        lineBreaksComputer.addRequest(linesContent[i], lineInjectedText, previousLineBreaks ? previousLineBreaks[i] : null);\n      };\n      for (var i = 0; i < lineCount; i++) {\n        _loop(i);\n      }\n      var linesBreaks = lineBreaksComputer.finalize();\n      var values = [];\n      var hiddenAreas = this.hiddenAreasDecorationIds.map(function (areaId) {\n        return _this.model.getDecorationRange(areaId);\n      }).sort(Range.compareRangesUsingStarts);\n      var hiddenAreaStart = 1,\n        hiddenAreaEnd = 0;\n      var hiddenAreaIdx = -1;\n      var nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : lineCount + 2;\n      for (var _i = 0; _i < lineCount; _i++) {\n        var lineNumber = _i + 1;\n        if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n          hiddenAreaIdx++;\n          hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n          hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n          nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : lineCount + 2;\n        }\n        var isInHiddenArea = lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd;\n        var line = createModelLineProjection(linesBreaks[_i], !isInHiddenArea);\n        values[_i] = line.getViewLineCount();\n        this.modelLineProjections[_i] = line;\n      }\n      this._validModelVersionId = this.model.getVersionId();\n      this.projectedModelLineLineCounts = new ConstantTimePrefixSumComputer(values);\n    }\n  }, {\n    key: \"getHiddenAreas\",\n    value: function getHiddenAreas() {\n      var _this2 = this;\n      return this.hiddenAreasDecorationIds.map(function (decId) {\n        return _this2.model.getDecorationRange(decId);\n      });\n    }\n  }, {\n    key: \"setHiddenAreas\",\n    value: function setHiddenAreas(_ranges) {\n      var _this3 = this;\n      var validatedRanges = _ranges.map(function (r) {\n        return _this3.model.validateRange(r);\n      });\n      var newRanges = normalizeLineRanges(validatedRanges);\n      // TODO@Martin: Please stop calling this method on each model change!\n      // This checks if there really was a change\n      var oldRanges = this.hiddenAreasDecorationIds.map(function (areaId) {\n        return _this3.model.getDecorationRange(areaId);\n      }).sort(Range.compareRangesUsingStarts);\n      if (newRanges.length === oldRanges.length) {\n        var hasDifference = false;\n        for (var i = 0; i < newRanges.length; i++) {\n          if (!newRanges[i].equalsRange(oldRanges[i])) {\n            hasDifference = true;\n            break;\n          }\n        }\n        if (!hasDifference) {\n          return false;\n        }\n      }\n      var newDecorations = newRanges.map(function (r) {\n        return {\n          range: r,\n          options: ModelDecorationOptions.EMPTY\n        };\n      });\n      this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, newDecorations);\n      var hiddenAreas = newRanges;\n      var hiddenAreaStart = 1,\n        hiddenAreaEnd = 0;\n      var hiddenAreaIdx = -1;\n      var nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n      var hasVisibleLine = false;\n      for (var _i2 = 0; _i2 < this.modelLineProjections.length; _i2++) {\n        var lineNumber = _i2 + 1;\n        if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n          hiddenAreaIdx++;\n          hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n          hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n          nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n        }\n        var lineChanged = false;\n        if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n          // Line should be hidden\n          if (this.modelLineProjections[_i2].isVisible()) {\n            this.modelLineProjections[_i2] = this.modelLineProjections[_i2].setVisible(false);\n            lineChanged = true;\n          }\n        } else {\n          hasVisibleLine = true;\n          // Line should be visible\n          if (!this.modelLineProjections[_i2].isVisible()) {\n            this.modelLineProjections[_i2] = this.modelLineProjections[_i2].setVisible(true);\n            lineChanged = true;\n          }\n        }\n        if (lineChanged) {\n          var newOutputLineCount = this.modelLineProjections[_i2].getViewLineCount();\n          this.projectedModelLineLineCounts.setValue(_i2, newOutputLineCount);\n        }\n      }\n      if (!hasVisibleLine) {\n        // Cannot have everything be hidden => reveal everything!\n        this.setHiddenAreas([]);\n      }\n      return true;\n    }\n  }, {\n    key: \"modelPositionIsVisible\",\n    value: function modelPositionIsVisible(modelLineNumber, _modelColumn) {\n      if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n        // invalid arguments\n        return false;\n      }\n      return this.modelLineProjections[modelLineNumber - 1].isVisible();\n    }\n  }, {\n    key: \"getModelLineViewLineCount\",\n    value: function getModelLineViewLineCount(modelLineNumber) {\n      if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n        // invalid arguments\n        return 1;\n      }\n      return this.modelLineProjections[modelLineNumber - 1].getViewLineCount();\n    }\n  }, {\n    key: \"setTabSize\",\n    value: function setTabSize(newTabSize) {\n      if (this.tabSize === newTabSize) {\n        return false;\n      }\n      this.tabSize = newTabSize;\n      this._constructLines( /*resetHiddenAreas*/false, null);\n      return true;\n    }\n  }, {\n    key: \"setWrappingSettings\",\n    value: function setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent, wordBreak) {\n      var equalFontInfo = this.fontInfo.equals(fontInfo);\n      var equalWrappingStrategy = this.wrappingStrategy === wrappingStrategy;\n      var equalWrappingColumn = this.wrappingColumn === wrappingColumn;\n      var equalWrappingIndent = this.wrappingIndent === wrappingIndent;\n      var equalWordBreak = this.wordBreak === wordBreak;\n      if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent && equalWordBreak) {\n        return false;\n      }\n      var onlyWrappingColumnChanged = equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent && equalWordBreak;\n      this.fontInfo = fontInfo;\n      this.wrappingStrategy = wrappingStrategy;\n      this.wrappingColumn = wrappingColumn;\n      this.wrappingIndent = wrappingIndent;\n      this.wordBreak = wordBreak;\n      var previousLineBreaks = null;\n      if (onlyWrappingColumnChanged) {\n        previousLineBreaks = [];\n        for (var i = 0, len = this.modelLineProjections.length; i < len; i++) {\n          previousLineBreaks[i] = this.modelLineProjections[i].getProjectionData();\n        }\n      }\n      this._constructLines( /*resetHiddenAreas*/false, previousLineBreaks);\n      return true;\n    }\n  }, {\n    key: \"createLineBreaksComputer\",\n    value: function createLineBreaksComputer() {\n      var lineBreaksComputerFactory = this.wrappingStrategy === 'advanced' ? this._domLineBreaksComputerFactory : this._monospaceLineBreaksComputerFactory;\n      return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent, this.wordBreak);\n    }\n  }, {\n    key: \"onModelFlushed\",\n    value: function onModelFlushed() {\n      this._constructLines( /*resetHiddenAreas*/true, null);\n    }\n  }, {\n    key: \"onModelLinesDeleted\",\n    value: function onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\n      if (!versionId || versionId <= this._validModelVersionId) {\n        // Here we check for versionId in case the lines were reconstructed in the meantime.\n        // We don't want to apply stale change events on top of a newer read model state.\n        return null;\n      }\n      var outputFromLineNumber = fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1;\n      var outputToLineNumber = this.projectedModelLineLineCounts.getPrefixSum(toLineNumber);\n      this.modelLineProjections.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n      this.projectedModelLineLineCounts.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n      return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n    }\n  }, {\n    key: \"onModelLinesInserted\",\n    value: function onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\n      if (!versionId || versionId <= this._validModelVersionId) {\n        // Here we check for versionId in case the lines were reconstructed in the meantime.\n        // We don't want to apply stale change events on top of a newer read model state.\n        return null;\n      }\n      // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n      var isInHiddenArea = fromLineNumber > 2 && !this.modelLineProjections[fromLineNumber - 2].isVisible();\n      var outputFromLineNumber = fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1;\n      var totalOutputLineCount = 0;\n      var insertLines = [];\n      var insertPrefixSumValues = [];\n      for (var i = 0, len = lineBreaks.length; i < len; i++) {\n        var line = createModelLineProjection(lineBreaks[i], !isInHiddenArea);\n        insertLines.push(line);\n        var outputLineCount = line.getViewLineCount();\n        totalOutputLineCount += outputLineCount;\n        insertPrefixSumValues[i] = outputLineCount;\n      }\n      // TODO@Alex: use arrays.arrayInsert\n      this.modelLineProjections = this.modelLineProjections.slice(0, fromLineNumber - 1).concat(insertLines).concat(this.modelLineProjections.slice(fromLineNumber - 1));\n      this.projectedModelLineLineCounts.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n      return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n    }\n  }, {\n    key: \"onModelLineChanged\",\n    value: function onModelLineChanged(versionId, lineNumber, lineBreakData) {\n      if (versionId !== null && versionId <= this._validModelVersionId) {\n        // Here we check for versionId in case the lines were reconstructed in the meantime.\n        // We don't want to apply stale change events on top of a newer read model state.\n        return [false, null, null, null];\n      }\n      var lineIndex = lineNumber - 1;\n      var oldOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n      var isVisible = this.modelLineProjections[lineIndex].isVisible();\n      var line = createModelLineProjection(lineBreakData, isVisible);\n      this.modelLineProjections[lineIndex] = line;\n      var newOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n      var lineMappingChanged = false;\n      var changeFrom = 0;\n      var changeTo = -1;\n      var insertFrom = 0;\n      var insertTo = -1;\n      var deleteFrom = 0;\n      var deleteTo = -1;\n      if (oldOutputLineCount > newOutputLineCount) {\n        changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n        changeTo = changeFrom + newOutputLineCount - 1;\n        deleteFrom = changeTo + 1;\n        deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n        lineMappingChanged = true;\n      } else if (oldOutputLineCount < newOutputLineCount) {\n        changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n        changeTo = changeFrom + oldOutputLineCount - 1;\n        insertFrom = changeTo + 1;\n        insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n        lineMappingChanged = true;\n      } else {\n        changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n        changeTo = changeFrom + newOutputLineCount - 1;\n      }\n      this.projectedModelLineLineCounts.setValue(lineIndex, newOutputLineCount);\n      var viewLinesChangedEvent = changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo - changeFrom + 1) : null;\n      var viewLinesInsertedEvent = insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null;\n      var viewLinesDeletedEvent = deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null;\n      return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n    }\n  }, {\n    key: \"acceptVersionId\",\n    value: function acceptVersionId(versionId) {\n      this._validModelVersionId = versionId;\n      if (this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible()) {\n        // At least one line must be visible => reset hidden areas\n        this.setHiddenAreas([]);\n      }\n    }\n  }, {\n    key: \"getViewLineCount\",\n    value: function getViewLineCount() {\n      return this.projectedModelLineLineCounts.getTotalSum();\n    }\n  }, {\n    key: \"_toValidViewLineNumber\",\n    value: function _toValidViewLineNumber(viewLineNumber) {\n      if (viewLineNumber < 1) {\n        return 1;\n      }\n      var viewLineCount = this.getViewLineCount();\n      if (viewLineNumber > viewLineCount) {\n        return viewLineCount;\n      }\n      return viewLineNumber | 0;\n    }\n  }, {\n    key: \"getActiveIndentGuide\",\n    value: function getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\n      viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n      minLineNumber = this._toValidViewLineNumber(minLineNumber);\n      maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n      var modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n      var modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n      var modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n      var result = this.model.guides.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n      var viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n      var viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n      return {\n        startLineNumber: viewStartPosition.lineNumber,\n        endLineNumber: viewEndPosition.lineNumber,\n        indent: result.indent\n      };\n    }\n    // #region ViewLineInfo\n  }, {\n    key: \"getViewLineInfo\",\n    value: function getViewLineInfo(viewLineNumber) {\n      viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n      var r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n      var lineIndex = r.index;\n      var remainder = r.remainder;\n      return new ViewLineInfo(lineIndex + 1, remainder);\n    }\n  }, {\n    key: \"getMinColumnOfViewLine\",\n    value: function getMinColumnOfViewLine(viewLineInfo) {\n      return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n  }, {\n    key: \"getMaxColumnOfViewLine\",\n    value: function getMaxColumnOfViewLine(viewLineInfo) {\n      return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n  }, {\n    key: \"getModelStartPositionOfViewLine\",\n    value: function getModelStartPositionOfViewLine(viewLineInfo) {\n      var line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n      var minViewColumn = line.getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n      var column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, minViewColumn);\n      return new Position(viewLineInfo.modelLineNumber, column);\n    }\n  }, {\n    key: \"getModelEndPositionOfViewLine\",\n    value: function getModelEndPositionOfViewLine(viewLineInfo) {\n      var line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n      var maxViewColumn = line.getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n      var column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, maxViewColumn);\n      return new Position(viewLineInfo.modelLineNumber, column);\n    }\n  }, {\n    key: \"getViewLineInfosGroupedByModelRanges\",\n    value: function getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber) {\n      var startViewLine = this.getViewLineInfo(viewStartLineNumber);\n      var endViewLine = this.getViewLineInfo(viewEndLineNumber);\n      var result = new Array();\n      var lastVisibleModelPos = this.getModelStartPositionOfViewLine(startViewLine);\n      var viewLines = new Array();\n      for (var curModelLine = startViewLine.modelLineNumber; curModelLine <= endViewLine.modelLineNumber; curModelLine++) {\n        var line = this.modelLineProjections[curModelLine - 1];\n        if (line.isVisible()) {\n          var startOffset = curModelLine === startViewLine.modelLineNumber ? startViewLine.modelLineWrappedLineIdx : 0;\n          var endOffset = curModelLine === endViewLine.modelLineNumber ? endViewLine.modelLineWrappedLineIdx + 1 : line.getViewLineCount();\n          for (var i = startOffset; i < endOffset; i++) {\n            viewLines.push(new ViewLineInfo(curModelLine, i));\n          }\n        }\n        if (!line.isVisible() && lastVisibleModelPos) {\n          var lastVisibleModelPos2 = new Position(curModelLine - 1, this.model.getLineMaxColumn(curModelLine - 1) + 1);\n          var modelRange = Range.fromPositions(lastVisibleModelPos, lastVisibleModelPos2);\n          result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n          viewLines = [];\n          lastVisibleModelPos = null;\n        } else if (line.isVisible() && !lastVisibleModelPos) {\n          lastVisibleModelPos = new Position(curModelLine, 1);\n        }\n      }\n      if (lastVisibleModelPos) {\n        var _modelRange = Range.fromPositions(lastVisibleModelPos, this.getModelEndPositionOfViewLine(endViewLine));\n        result.push(new ViewLineInfoGroupedByModelRange(_modelRange, viewLines));\n      }\n      return result;\n    }\n    // #endregion\n  }, {\n    key: \"getViewLinesBracketGuides\",\n    value: function getViewLinesBracketGuides(viewStartLineNumber, viewEndLineNumber, activeViewPosition, options) {\n      var _this4 = this;\n      var modelActivePosition = activeViewPosition ? this.convertViewPositionToModelPosition(activeViewPosition.lineNumber, activeViewPosition.column) : null;\n      var resultPerViewLine = [];\n      var _iterator = _createForOfIteratorHelper(this.getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber)),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var group = _step.value;\n          var modelRangeStartLineNumber = group.modelRange.startLineNumber;\n          var bracketGuidesPerModelLine = this.model.guides.getLinesBracketGuides(modelRangeStartLineNumber, group.modelRange.endLineNumber, modelActivePosition, options);\n          var _iterator2 = _createForOfIteratorHelper(group.viewLines),\n            _step2;\n          try {\n            var _loop2 = function _loop2() {\n              var viewLineInfo = _step2.value;\n              var bracketGuides = bracketGuidesPerModelLine[viewLineInfo.modelLineNumber - modelRangeStartLineNumber];\n              // visibleColumns stay as they are (this is a bug and needs to be fixed, but it is not a regression)\n              // model-columns must be converted to view-model columns.\n              var result = bracketGuides.map(function (g) {\n                if (g.forWrappedLinesAfterColumn !== -1) {\n                  var _p = _this4.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesAfterColumn);\n                  if (_p.lineNumber >= viewLineInfo.modelLineWrappedLineIdx) {\n                    return undefined;\n                  }\n                }\n                if (g.forWrappedLinesBeforeOrAtColumn !== -1) {\n                  var _p2 = _this4.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesBeforeOrAtColumn);\n                  if (_p2.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                    return undefined;\n                  }\n                }\n                if (!g.horizontalLine) {\n                  return g;\n                }\n                var column = -1;\n                if (g.column !== -1) {\n                  var _p3 = _this4.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.column);\n                  if (_p3.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n                    column = _p3.column;\n                  } else if (_p3.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                    column = _this4.getMinColumnOfViewLine(viewLineInfo);\n                  } else if (_p3.lineNumber > viewLineInfo.modelLineWrappedLineIdx) {\n                    return undefined;\n                  }\n                }\n                var viewPosition = _this4.convertModelPositionToViewPosition(viewLineInfo.modelLineNumber, g.horizontalLine.endColumn);\n                var p = _this4.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.horizontalLine.endColumn);\n                if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n                  return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, viewPosition.column), -1, -1);\n                } else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                  return undefined;\n                } else {\n                  if (g.visibleColumn !== -1) {\n                    // Don't repeat horizontal lines that use visibleColumn for unrelated lines.\n                    return undefined;\n                  }\n                  return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, _this4.getMaxColumnOfViewLine(viewLineInfo)), -1, -1);\n                }\n              });\n              resultPerViewLine.push(result.filter(function (r) {\n                return !!r;\n              }));\n            };\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              _loop2();\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return resultPerViewLine;\n    }\n  }, {\n    key: \"getViewLinesIndentGuides\",\n    value: function getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n      // TODO: Use the same code as in `getViewLinesBracketGuides`.\n      // Future TODO: Merge with `getViewLinesBracketGuides`.\n      // However, this requires more refactoring of indent guides.\n      viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n      viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n      var modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n      var modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n      var result = [];\n      var resultRepeatCount = [];\n      var resultRepeatOption = [];\n      var modelStartLineIndex = modelStart.lineNumber - 1;\n      var modelEndLineIndex = modelEnd.lineNumber - 1;\n      var reqStart = null;\n      for (var modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n        var line = this.modelLineProjections[modelLineIndex];\n        if (line.isVisible()) {\n          var viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n          var viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n          var count = viewLineEndIndex - viewLineStartIndex + 1;\n          var option = 0 /* IndentGuideRepeatOption.BlockNone */;\n          if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n            // wrapped lines should block indent guides\n            option = viewLineStartIndex === 0 ? 1 /* IndentGuideRepeatOption.BlockSubsequent */ : 2 /* IndentGuideRepeatOption.BlockAll */;\n          }\n          resultRepeatCount.push(count);\n          resultRepeatOption.push(option);\n          // merge into previous request\n          if (reqStart === null) {\n            reqStart = new Position(modelLineIndex + 1, 0);\n          }\n        } else {\n          // hit invisible line => flush request\n          if (reqStart !== null) {\n            result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n            reqStart = null;\n          }\n        }\n      }\n      if (reqStart !== null) {\n        result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n        reqStart = null;\n      }\n      var viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n      var viewIndents = new Array(viewLineCount);\n      var currIndex = 0;\n      for (var i = 0, len = result.length; i < len; i++) {\n        var value = result[i];\n        var _count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n        var _option = resultRepeatOption[i];\n        var blockAtIndex = void 0;\n        if (_option === 2 /* IndentGuideRepeatOption.BlockAll */) {\n          blockAtIndex = 0;\n        } else if (_option === 1 /* IndentGuideRepeatOption.BlockSubsequent */) {\n          blockAtIndex = 1;\n        } else {\n          blockAtIndex = _count;\n        }\n        for (var j = 0; j < _count; j++) {\n          if (j === blockAtIndex) {\n            value = 0;\n          }\n          viewIndents[currIndex++] = value;\n        }\n      }\n      return viewIndents;\n    }\n  }, {\n    key: \"getViewLineContent\",\n    value: function getViewLineContent(viewLineNumber) {\n      var info = this.getViewLineInfo(viewLineNumber);\n      return this.modelLineProjections[info.modelLineNumber - 1].getViewLineContent(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n  }, {\n    key: \"getViewLineLength\",\n    value: function getViewLineLength(viewLineNumber) {\n      var info = this.getViewLineInfo(viewLineNumber);\n      return this.modelLineProjections[info.modelLineNumber - 1].getViewLineLength(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n  }, {\n    key: \"getViewLineMinColumn\",\n    value: function getViewLineMinColumn(viewLineNumber) {\n      var info = this.getViewLineInfo(viewLineNumber);\n      return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMinColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n  }, {\n    key: \"getViewLineMaxColumn\",\n    value: function getViewLineMaxColumn(viewLineNumber) {\n      var info = this.getViewLineInfo(viewLineNumber);\n      return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMaxColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n  }, {\n    key: \"getViewLineData\",\n    value: function getViewLineData(viewLineNumber) {\n      var info = this.getViewLineInfo(viewLineNumber);\n      return this.modelLineProjections[info.modelLineNumber - 1].getViewLineData(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n  }, {\n    key: \"getViewLinesData\",\n    value: function getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n      viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n      viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n      var start = this.projectedModelLineLineCounts.getIndexOf(viewStartLineNumber - 1);\n      var viewLineNumber = viewStartLineNumber;\n      var startModelLineIndex = start.index;\n      var startRemainder = start.remainder;\n      var result = [];\n      for (var modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n        var line = this.modelLineProjections[modelLineIndex];\n        if (!line.isVisible()) {\n          continue;\n        }\n        var fromViewLineIndex = modelLineIndex === startModelLineIndex ? startRemainder : 0;\n        var remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n        var lastLine = false;\n        if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n          lastLine = true;\n          remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n        }\n        line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, remainingViewLineCount, viewLineNumber - viewStartLineNumber, needed, result);\n        viewLineNumber += remainingViewLineCount;\n        if (lastLine) {\n          break;\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"validateViewPosition\",\n    value: function validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\n      viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n      var r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n      var lineIndex = r.index;\n      var remainder = r.remainder;\n      var line = this.modelLineProjections[lineIndex];\n      var minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n      var maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n      if (viewColumn < minColumn) {\n        viewColumn = minColumn;\n      }\n      if (viewColumn > maxColumn) {\n        viewColumn = maxColumn;\n      }\n      var computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n      var computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n      if (computedModelPosition.equals(expectedModelPosition)) {\n        return new Position(viewLineNumber, viewColumn);\n      }\n      return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n    }\n  }, {\n    key: \"validateViewRange\",\n    value: function validateViewRange(viewRange, expectedModelRange) {\n      var validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n      var validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n      return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n    }\n  }, {\n    key: \"convertViewPositionToModelPosition\",\n    value: function convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\n      var info = this.getViewLineInfo(viewLineNumber);\n      var inputColumn = this.modelLineProjections[info.modelLineNumber - 1].getModelColumnOfViewPosition(info.modelLineWrappedLineIdx, viewColumn);\n      // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n      return this.model.validatePosition(new Position(info.modelLineNumber, inputColumn));\n    }\n  }, {\n    key: \"convertViewRangeToModelRange\",\n    value: function convertViewRangeToModelRange(viewRange) {\n      var start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n      var end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n      return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n  }, {\n    key: \"convertModelPositionToViewPosition\",\n    value: function convertModelPositionToViewPosition(_modelLineNumber, _modelColumn) {\n      var affinity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n      var allowZeroLineNumber = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var belowHiddenRanges = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n      var inputLineNumber = validPosition.lineNumber;\n      var inputColumn = validPosition.column;\n      var lineIndex = inputLineNumber - 1,\n        lineIndexChanged = false;\n      if (belowHiddenRanges) {\n        while (lineIndex < this.modelLineProjections.length && !this.modelLineProjections[lineIndex].isVisible()) {\n          lineIndex++;\n          lineIndexChanged = true;\n        }\n      } else {\n        while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n          lineIndex--;\n          lineIndexChanged = true;\n        }\n      }\n      if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n        // Could not reach a real line\n        // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n        // TODO@alexdima@hediet this isn't soo pretty\n        return new Position(allowZeroLineNumber ? 0 : 1, 1);\n      }\n      var deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n      var r;\n      if (lineIndexChanged) {\n        if (belowHiddenRanges) {\n          r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, 1, affinity);\n        } else {\n          r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1), affinity);\n        }\n      } else {\n        r = this.modelLineProjections[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity);\n      }\n      // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n      return r;\n    }\n    /**\n     * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.\n    */\n  }, {\n    key: \"convertModelRangeToViewRange\",\n    value: function convertModelRangeToViewRange(modelRange) {\n      var affinity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      if (modelRange.isEmpty()) {\n        var start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, affinity);\n        return Range.fromPositions(start);\n      } else {\n        var _start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, 1 /* PositionAffinity.Right */);\n        var end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn, 0 /* PositionAffinity.Left */);\n        return new Range(_start.lineNumber, _start.column, end.lineNumber, end.column);\n      }\n    }\n  }, {\n    key: \"getViewLineNumberOfModelPosition\",\n    value: function getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n      var lineIndex = modelLineNumber - 1;\n      if (this.modelLineProjections[lineIndex].isVisible()) {\n        // this model line is visible\n        var _deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(_deltaLineNumber, modelColumn);\n      }\n      // this model line is not visible\n      while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n        lineIndex--;\n      }\n      if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n        // Could not reach a real line\n        return 1;\n      }\n      var deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n      return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n    }\n  }, {\n    key: \"getDecorationsInRange\",\n    value: function getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations) {\n      var modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n      var modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n      if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n        // most likely there are no hidden lines => fast path\n        // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n        return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations);\n      }\n      var result = [];\n      var modelStartLineIndex = modelStart.lineNumber - 1;\n      var modelEndLineIndex = modelEnd.lineNumber - 1;\n      var reqStart = null;\n      for (var modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n        var line = this.modelLineProjections[modelLineIndex];\n        if (line.isVisible()) {\n          // merge into previous request\n          if (reqStart === null) {\n            reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n          }\n        } else {\n          // hit invisible line => flush request\n          if (reqStart !== null) {\n            var maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n            result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation, onlyMinimapDecorations));\n            reqStart = null;\n          }\n        }\n      }\n      if (reqStart !== null) {\n        result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, onlyMinimapDecorations));\n        reqStart = null;\n      }\n      result.sort(function (a, b) {\n        var res = Range.compareRangesUsingStarts(a.range, b.range);\n        if (res === 0) {\n          if (a.id < b.id) {\n            return -1;\n          }\n          if (a.id > b.id) {\n            return 1;\n          }\n          return 0;\n        }\n        return res;\n      });\n      // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n      var finalResult = [];\n      var finalResultLen = 0;\n      var prevDecId = null;\n      var _iterator3 = _createForOfIteratorHelper(result),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var dec = _step3.value;\n          var decId = dec.id;\n          if (prevDecId === decId) {\n            // skip\n            continue;\n          }\n          prevDecId = decId;\n          finalResult[finalResultLen++] = dec;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return finalResult;\n    }\n  }, {\n    key: \"getInjectedTextAt\",\n    value: function getInjectedTextAt(position) {\n      var info = this.getViewLineInfo(position.lineNumber);\n      return this.modelLineProjections[info.modelLineNumber - 1].getInjectedTextAt(info.modelLineWrappedLineIdx, position.column);\n    }\n  }, {\n    key: \"normalizePosition\",\n    value: function normalizePosition(position, affinity) {\n      var info = this.getViewLineInfo(position.lineNumber);\n      return this.modelLineProjections[info.modelLineNumber - 1].normalizePosition(info.modelLineWrappedLineIdx, position, affinity);\n    }\n  }, {\n    key: \"getLineIndentColumn\",\n    value: function getLineIndentColumn(lineNumber) {\n      var info = this.getViewLineInfo(lineNumber);\n      if (info.modelLineWrappedLineIdx === 0) {\n        return this.model.getLineIndentColumn(info.modelLineNumber);\n      }\n      // wrapped lines have no indentation.\n      // We deliberately don't handle the case that indentation is wrapped\n      // to avoid two view lines reporting indentation for the very same model line.\n      return 0;\n    }\n  }]);\n}();\n/**\n * Overlapping unsorted ranges:\n * [   )      [ )       [  )\n *    [    )      [       )\n * ->\n * Non overlapping sorted ranges:\n * [       )  [ ) [        )\n *\n * Note: This function only considers line information! Columns are ignored.\n*/\nfunction normalizeLineRanges(ranges) {\n  if (ranges.length === 0) {\n    return [];\n  }\n  var sortedRanges = ranges.slice();\n  sortedRanges.sort(Range.compareRangesUsingStarts);\n  var result = [];\n  var currentRangeStart = sortedRanges[0].startLineNumber;\n  var currentRangeEnd = sortedRanges[0].endLineNumber;\n  for (var i = 1, len = sortedRanges.length; i < len; i++) {\n    var range = sortedRanges[i];\n    if (range.startLineNumber > currentRangeEnd + 1) {\n      result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n      currentRangeStart = range.startLineNumber;\n      currentRangeEnd = range.endLineNumber;\n    } else if (range.endLineNumber > currentRangeEnd) {\n      currentRangeEnd = range.endLineNumber;\n    }\n  }\n  result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n  return result;\n}\n/**\n * Represents a view line. Can be used to efficiently query more information about it.\n */\nvar ViewLineInfo = /*#__PURE__*/_createClass(function ViewLineInfo(modelLineNumber, modelLineWrappedLineIdx) {\n  _classCallCheck(this, ViewLineInfo);\n  this.modelLineNumber = modelLineNumber;\n  this.modelLineWrappedLineIdx = modelLineWrappedLineIdx;\n});\n/**\n * A list of view lines that have a contiguous span in the model.\n*/\nvar ViewLineInfoGroupedByModelRange = /*#__PURE__*/_createClass(function ViewLineInfoGroupedByModelRange(modelRange, viewLines) {\n  _classCallCheck(this, ViewLineInfoGroupedByModelRange);\n  this.modelRange = modelRange;\n  this.viewLines = viewLines;\n});\nvar CoordinatesConverter = /*#__PURE__*/function () {\n  function CoordinatesConverter(lines) {\n    _classCallCheck(this, CoordinatesConverter);\n    this._lines = lines;\n  }\n  // View -> Model conversion and related methods\n  return _createClass(CoordinatesConverter, [{\n    key: \"convertViewPositionToModelPosition\",\n    value: function convertViewPositionToModelPosition(viewPosition) {\n      return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n    }\n  }, {\n    key: \"convertViewRangeToModelRange\",\n    value: function convertViewRangeToModelRange(viewRange) {\n      return this._lines.convertViewRangeToModelRange(viewRange);\n    }\n  }, {\n    key: \"validateViewPosition\",\n    value: function validateViewPosition(viewPosition, expectedModelPosition) {\n      return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n    }\n  }, {\n    key: \"validateViewRange\",\n    value: function validateViewRange(viewRange, expectedModelRange) {\n      return this._lines.validateViewRange(viewRange, expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n  }, {\n    key: \"convertModelPositionToViewPosition\",\n    value: function convertModelPositionToViewPosition(modelPosition, affinity, allowZero, belowHiddenRanges) {\n      return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column, affinity, allowZero, belowHiddenRanges);\n    }\n  }, {\n    key: \"convertModelRangeToViewRange\",\n    value: function convertModelRangeToViewRange(modelRange, affinity) {\n      return this._lines.convertModelRangeToViewRange(modelRange, affinity);\n    }\n  }, {\n    key: \"modelPositionIsVisible\",\n    value: function modelPositionIsVisible(modelPosition) {\n      return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n    }\n  }, {\n    key: \"getModelLineViewLineCount\",\n    value: function getModelLineViewLineCount(modelLineNumber) {\n      return this._lines.getModelLineViewLineCount(modelLineNumber);\n    }\n  }, {\n    key: \"getViewLineNumberOfModelPosition\",\n    value: function getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n      return this._lines.getViewLineNumberOfModelPosition(modelLineNumber, modelColumn);\n    }\n  }]);\n}();\nexport var ViewModelLinesFromModelAsIs = /*#__PURE__*/function () {\n  function ViewModelLinesFromModelAsIs(model) {\n    _classCallCheck(this, ViewModelLinesFromModelAsIs);\n    this.model = model;\n  }\n  return _createClass(ViewModelLinesFromModelAsIs, [{\n    key: \"dispose\",\n    value: function dispose() {}\n  }, {\n    key: \"createCoordinatesConverter\",\n    value: function createCoordinatesConverter() {\n      return new IdentityCoordinatesConverter(this);\n    }\n  }, {\n    key: \"getHiddenAreas\",\n    value: function getHiddenAreas() {\n      return [];\n    }\n  }, {\n    key: \"setHiddenAreas\",\n    value: function setHiddenAreas(_ranges) {\n      return false;\n    }\n  }, {\n    key: \"setTabSize\",\n    value: function setTabSize(_newTabSize) {\n      return false;\n    }\n  }, {\n    key: \"setWrappingSettings\",\n    value: function setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\n      return false;\n    }\n  }, {\n    key: \"createLineBreaksComputer\",\n    value: function createLineBreaksComputer() {\n      var result = [];\n      return {\n        addRequest: function addRequest(lineText, injectedText, previousLineBreakData) {\n          result.push(null);\n        },\n        finalize: function finalize() {\n          return result;\n        }\n      };\n    }\n  }, {\n    key: \"onModelFlushed\",\n    value: function onModelFlushed() {}\n  }, {\n    key: \"onModelLinesDeleted\",\n    value: function onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\n      return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n    }\n  }, {\n    key: \"onModelLinesInserted\",\n    value: function onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\n      return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n    }\n  }, {\n    key: \"onModelLineChanged\",\n    value: function onModelLineChanged(_versionId, lineNumber, lineBreakData) {\n      return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, 1), null, null];\n    }\n  }, {\n    key: \"acceptVersionId\",\n    value: function acceptVersionId(_versionId) {}\n  }, {\n    key: \"getViewLineCount\",\n    value: function getViewLineCount() {\n      return this.model.getLineCount();\n    }\n  }, {\n    key: \"getActiveIndentGuide\",\n    value: function getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\n      return {\n        startLineNumber: viewLineNumber,\n        endLineNumber: viewLineNumber,\n        indent: 0\n      };\n    }\n  }, {\n    key: \"getViewLinesBracketGuides\",\n    value: function getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition) {\n      return new Array(endLineNumber - startLineNumber + 1).fill([]);\n    }\n  }, {\n    key: \"getViewLinesIndentGuides\",\n    value: function getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n      var viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n      var result = new Array(viewLineCount);\n      for (var i = 0; i < viewLineCount; i++) {\n        result[i] = 0;\n      }\n      return result;\n    }\n  }, {\n    key: \"getViewLineContent\",\n    value: function getViewLineContent(viewLineNumber) {\n      return this.model.getLineContent(viewLineNumber);\n    }\n  }, {\n    key: \"getViewLineLength\",\n    value: function getViewLineLength(viewLineNumber) {\n      return this.model.getLineLength(viewLineNumber);\n    }\n  }, {\n    key: \"getViewLineMinColumn\",\n    value: function getViewLineMinColumn(viewLineNumber) {\n      return this.model.getLineMinColumn(viewLineNumber);\n    }\n  }, {\n    key: \"getViewLineMaxColumn\",\n    value: function getViewLineMaxColumn(viewLineNumber) {\n      return this.model.getLineMaxColumn(viewLineNumber);\n    }\n  }, {\n    key: \"getViewLineData\",\n    value: function getViewLineData(viewLineNumber) {\n      var lineTokens = this.model.tokenization.getLineTokens(viewLineNumber);\n      var lineContent = lineTokens.getLineContent();\n      return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n  }, {\n    key: \"getViewLinesData\",\n    value: function getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n      var lineCount = this.model.getLineCount();\n      viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n      viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n      var result = [];\n      for (var lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n        var idx = lineNumber - viewStartLineNumber;\n        result[idx] = needed[idx] ? this.getViewLineData(lineNumber) : null;\n      }\n      return result;\n    }\n  }, {\n    key: \"getDecorationsInRange\",\n    value: function getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations) {\n      return this.model.getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations);\n    }\n  }, {\n    key: \"normalizePosition\",\n    value: function normalizePosition(position, affinity) {\n      return this.model.normalizePosition(position, affinity);\n    }\n  }, {\n    key: \"getLineIndentColumn\",\n    value: function getLineIndentColumn(lineNumber) {\n      return this.model.getLineIndentColumn(lineNumber);\n    }\n  }, {\n    key: \"getInjectedTextAt\",\n    value: function getInjectedTextAt(position) {\n      // Identity lines collection does not support injected text.\n      return null;\n    }\n  }]);\n}();\nvar IdentityCoordinatesConverter = /*#__PURE__*/function () {\n  function IdentityCoordinatesConverter(lines) {\n    _classCallCheck(this, IdentityCoordinatesConverter);\n    this._lines = lines;\n  }\n  return _createClass(IdentityCoordinatesConverter, [{\n    key: \"_validPosition\",\n    value: function _validPosition(pos) {\n      return this._lines.model.validatePosition(pos);\n    }\n  }, {\n    key: \"_validRange\",\n    value: function _validRange(range) {\n      return this._lines.model.validateRange(range);\n    }\n    // View -> Model conversion and related methods\n  }, {\n    key: \"convertViewPositionToModelPosition\",\n    value: function convertViewPositionToModelPosition(viewPosition) {\n      return this._validPosition(viewPosition);\n    }\n  }, {\n    key: \"convertViewRangeToModelRange\",\n    value: function convertViewRangeToModelRange(viewRange) {\n      return this._validRange(viewRange);\n    }\n  }, {\n    key: \"validateViewPosition\",\n    value: function validateViewPosition(_viewPosition, expectedModelPosition) {\n      return this._validPosition(expectedModelPosition);\n    }\n  }, {\n    key: \"validateViewRange\",\n    value: function validateViewRange(_viewRange, expectedModelRange) {\n      return this._validRange(expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n  }, {\n    key: \"convertModelPositionToViewPosition\",\n    value: function convertModelPositionToViewPosition(modelPosition) {\n      return this._validPosition(modelPosition);\n    }\n  }, {\n    key: \"convertModelRangeToViewRange\",\n    value: function convertModelRangeToViewRange(modelRange) {\n      return this._validRange(modelRange);\n    }\n  }, {\n    key: \"modelPositionIsVisible\",\n    value: function modelPositionIsVisible(modelPosition) {\n      var lineCount = this._lines.model.getLineCount();\n      if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n        // invalid arguments\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"getModelLineViewLineCount\",\n    value: function getModelLineViewLineCount(modelLineNumber) {\n      return 1;\n    }\n  }, {\n    key: \"getViewLineNumberOfModelPosition\",\n    value: function getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n      return modelLineNumber;\n    }\n  }]);\n}();","map":{"version":3,"names":["arrays","Position","Range","IndentGuide","IndentGuideHorizontalLine","ModelDecorationOptions","LineInjectedText","viewEvents","createModelLineProjection","ConstantTimePrefixSumComputer","ViewLineData","ViewModelLinesFromProjectedModel","editorId","model","domLineBreaksComputerFactory","monospaceLineBreaksComputerFactory","fontInfo","tabSize","wrappingStrategy","wrappingColumn","wrappingIndent","wordBreak","_classCallCheck","_editorId","_validModelVersionId","_domLineBreaksComputerFactory","_monospaceLineBreaksComputerFactory","_constructLines","_createClass","key","value","dispose","hiddenAreasDecorationIds","deltaDecorations","createCoordinatesConverter","CoordinatesConverter","resetHiddenAreas","previousLineBreaks","_this","modelLineProjections","linesContent","getLinesContent","injectedTextDecorations","getInjectedTextDecorations","lineCount","length","lineBreaksComputer","createLineBreaksComputer","injectedTextQueue","ArrayQueue","fromDecorations","_loop","i","lineInjectedText","takeWhile","t","lineNumber","addRequest","linesBreaks","finalize","values","hiddenAreas","map","areaId","getDecorationRange","sort","compareRangesUsingStarts","hiddenAreaStart","hiddenAreaEnd","hiddenAreaIdx","nextLineNumberToUpdateHiddenArea","startLineNumber","endLineNumber","isInHiddenArea","line","getViewLineCount","getVersionId","projectedModelLineLineCounts","getHiddenAreas","_this2","decId","setHiddenAreas","_ranges","_this3","validatedRanges","r","validateRange","newRanges","normalizeLineRanges","oldRanges","hasDifference","equalsRange","newDecorations","range","options","EMPTY","hasVisibleLine","lineChanged","isVisible","setVisible","newOutputLineCount","setValue","modelPositionIsVisible","modelLineNumber","_modelColumn","getModelLineViewLineCount","setTabSize","newTabSize","setWrappingSettings","equalFontInfo","equals","equalWrappingStrategy","equalWrappingColumn","equalWrappingIndent","equalWordBreak","onlyWrappingColumnChanged","len","getProjectionData","lineBreaksComputerFactory","onModelFlushed","onModelLinesDeleted","versionId","fromLineNumber","toLineNumber","outputFromLineNumber","getPrefixSum","outputToLineNumber","splice","removeValues","ViewLinesDeletedEvent","onModelLinesInserted","_toLineNumber","lineBreaks","totalOutputLineCount","insertLines","insertPrefixSumValues","push","outputLineCount","slice","concat","insertValues","ViewLinesInsertedEvent","onModelLineChanged","lineBreakData","lineIndex","oldOutputLineCount","lineMappingChanged","changeFrom","changeTo","insertFrom","insertTo","deleteFrom","deleteTo","viewLinesChangedEvent","ViewLinesChangedEvent","viewLinesInsertedEvent","viewLinesDeletedEvent","acceptVersionId","getTotalSum","_toValidViewLineNumber","viewLineNumber","viewLineCount","getActiveIndentGuide","minLineNumber","maxLineNumber","modelPosition","convertViewPositionToModelPosition","getViewLineMinColumn","modelMinPosition","modelMaxPosition","result","guides","viewStartPosition","convertModelPositionToViewPosition","viewEndPosition","getLineMaxColumn","indent","getViewLineInfo","getIndexOf","index","remainder","ViewLineInfo","getMinColumnOfViewLine","viewLineInfo","modelLineWrappedLineIdx","getMaxColumnOfViewLine","getViewLineMaxColumn","getModelStartPositionOfViewLine","minViewColumn","column","getModelColumnOfViewPosition","getModelEndPositionOfViewLine","maxViewColumn","getViewLineInfosGroupedByModelRanges","viewStartLineNumber","viewEndLineNumber","startViewLine","endViewLine","Array","lastVisibleModelPos","viewLines","curModelLine","startOffset","endOffset","lastVisibleModelPos2","modelRange","fromPositions","ViewLineInfoGroupedByModelRange","getViewLinesBracketGuides","activeViewPosition","_this4","modelActivePosition","resultPerViewLine","_iterator","_createForOfIteratorHelper","_step","s","n","done","group","modelRangeStartLineNumber","bracketGuidesPerModelLine","getLinesBracketGuides","_iterator2","_step2","_loop2","bracketGuides","g","forWrappedLinesAfterColumn","p","getViewPositionOfModelPosition","undefined","forWrappedLinesBeforeOrAtColumn","horizontalLine","viewPosition","endColumn","visibleColumn","className","top","filter","err","e","f","getViewLinesIndentGuides","modelStart","modelEnd","resultRepeatCount","resultRepeatOption","modelStartLineIndex","modelEndLineIndex","reqStart","modelLineIndex","viewLineStartIndex","getViewLineNumberOfModelPosition","viewLineEndIndex","count","option","getLinesIndentGuides","viewIndents","currIndex","Math","min","blockAtIndex","j","getViewLineContent","info","getViewLineLength","getViewLineData","getViewLinesData","needed","start","startModelLineIndex","startRemainder","getLineCount","fromViewLineIndex","remainingViewLineCount","lastLine","validateViewPosition","viewColumn","expectedModelPosition","minColumn","maxColumn","computedModelColumn","computedModelPosition","validatePosition","validateViewRange","viewRange","expectedModelRange","validViewStart","startColumn","getStartPosition","validViewEnd","getEndPosition","inputColumn","convertViewRangeToModelRange","end","_modelLineNumber","affinity","arguments","allowZeroLineNumber","belowHiddenRanges","validPosition","inputLineNumber","lineIndexChanged","deltaLineNumber","convertModelRangeToViewRange","isEmpty","modelColumn","getDecorationsInRange","ownerId","filterOutValidation","onlyMinimapDecorations","onlyMarginDecorations","maxLineColumn","a","b","res","id","finalResult","finalResultLen","prevDecId","_iterator3","_step3","dec","getInjectedTextAt","position","normalizePosition","getLineIndentColumn","ranges","sortedRanges","currentRangeStart","currentRangeEnd","lines","_lines","allowZero","ViewModelLinesFromModelAsIs","IdentityCoordinatesConverter","_newTabSize","_fontInfo","_wrappingStrategy","_wrappingColumn","_wrappingIndent","lineText","injectedText","previousLineBreakData","_versionId","_minLineNumber","_maxLineNumber","activePosition","fill","getLineContent","getLineLength","getLineMinColumn","lineTokens","tokenization","getLineTokens","lineContent","inflate","max","idx","_validPosition","pos","_validRange","_viewPosition","_viewRange"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelLines.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { createModelLineProjection } from './modelLineProjection.js';\nimport { ConstantTimePrefixSumComputer } from '../model/prefixSumComputer.js';\nimport { ViewLineData } from '../viewModel.js';\nexport class ViewModelLinesFromProjectedModel {\n    constructor(editorId, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent, wordBreak) {\n        this._editorId = editorId;\n        this.model = model;\n        this._validModelVersionId = -1;\n        this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n        this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n        this.fontInfo = fontInfo;\n        this.tabSize = tabSize;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        this.wordBreak = wordBreak;\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    dispose() {\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n    }\n    createCoordinatesConverter() {\n        return new CoordinatesConverter(this);\n    }\n    _constructLines(resetHiddenAreas, previousLineBreaks) {\n        this.modelLineProjections = [];\n        if (resetHiddenAreas) {\n            this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n        }\n        const linesContent = this.model.getLinesContent();\n        const injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n        const lineCount = linesContent.length;\n        const lineBreaksComputer = this.createLineBreaksComputer();\n        const injectedTextQueue = new arrays.ArrayQueue(LineInjectedText.fromDecorations(injectedTextDecorations));\n        for (let i = 0; i < lineCount; i++) {\n            const lineInjectedText = injectedTextQueue.takeWhile(t => t.lineNumber === i + 1);\n            lineBreaksComputer.addRequest(linesContent[i], lineInjectedText, previousLineBreaks ? previousLineBreaks[i] : null);\n        }\n        const linesBreaks = lineBreaksComputer.finalize();\n        const values = [];\n        const hiddenAreas = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n            }\n            const isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);\n            const line = createModelLineProjection(linesBreaks[i], !isInHiddenArea);\n            values[i] = line.getViewLineCount();\n            this.modelLineProjections[i] = line;\n        }\n        this._validModelVersionId = this.model.getVersionId();\n        this.projectedModelLineLineCounts = new ConstantTimePrefixSumComputer(values);\n    }\n    getHiddenAreas() {\n        return this.hiddenAreasDecorationIds.map((decId) => this.model.getDecorationRange(decId));\n    }\n    setHiddenAreas(_ranges) {\n        const validatedRanges = _ranges.map(r => this.model.validateRange(r));\n        const newRanges = normalizeLineRanges(validatedRanges);\n        // TODO@Martin: Please stop calling this method on each model change!\n        // This checks if there really was a change\n        const oldRanges = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        if (newRanges.length === oldRanges.length) {\n            let hasDifference = false;\n            for (let i = 0; i < newRanges.length; i++) {\n                if (!newRanges[i].equalsRange(oldRanges[i])) {\n                    hasDifference = true;\n                    break;\n                }\n            }\n            if (!hasDifference) {\n                return false;\n            }\n        }\n        const newDecorations = newRanges.map((r) => ({\n            range: r,\n            options: ModelDecorationOptions.EMPTY,\n        }));\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, newDecorations);\n        const hiddenAreas = newRanges;\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n        let hasVisibleLine = false;\n        for (let i = 0; i < this.modelLineProjections.length; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n            }\n            let lineChanged = false;\n            if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n                // Line should be hidden\n                if (this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(false);\n                    lineChanged = true;\n                }\n            }\n            else {\n                hasVisibleLine = true;\n                // Line should be visible\n                if (!this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(true);\n                    lineChanged = true;\n                }\n            }\n            if (lineChanged) {\n                const newOutputLineCount = this.modelLineProjections[i].getViewLineCount();\n                this.projectedModelLineLineCounts.setValue(i, newOutputLineCount);\n            }\n        }\n        if (!hasVisibleLine) {\n            // Cannot have everything be hidden => reveal everything!\n            this.setHiddenAreas([]);\n        }\n        return true;\n    }\n    modelPositionIsVisible(modelLineNumber, _modelColumn) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return false;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].isVisible();\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return 1;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].getViewLineCount();\n    }\n    setTabSize(newTabSize) {\n        if (this.tabSize === newTabSize) {\n            return false;\n        }\n        this.tabSize = newTabSize;\n        this._constructLines(/*resetHiddenAreas*/ false, null);\n        return true;\n    }\n    setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent, wordBreak) {\n        const equalFontInfo = this.fontInfo.equals(fontInfo);\n        const equalWrappingStrategy = (this.wrappingStrategy === wrappingStrategy);\n        const equalWrappingColumn = (this.wrappingColumn === wrappingColumn);\n        const equalWrappingIndent = (this.wrappingIndent === wrappingIndent);\n        const equalWordBreak = (this.wordBreak === wordBreak);\n        if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent && equalWordBreak) {\n            return false;\n        }\n        const onlyWrappingColumnChanged = (equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent && equalWordBreak);\n        this.fontInfo = fontInfo;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        this.wordBreak = wordBreak;\n        let previousLineBreaks = null;\n        if (onlyWrappingColumnChanged) {\n            previousLineBreaks = [];\n            for (let i = 0, len = this.modelLineProjections.length; i < len; i++) {\n                previousLineBreaks[i] = this.modelLineProjections[i].getProjectionData();\n            }\n        }\n        this._constructLines(/*resetHiddenAreas*/ false, previousLineBreaks);\n        return true;\n    }\n    createLineBreaksComputer() {\n        const lineBreaksComputerFactory = (this.wrappingStrategy === 'advanced'\n            ? this._domLineBreaksComputerFactory\n            : this._monospaceLineBreaksComputerFactory);\n        return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent, this.wordBreak);\n    }\n    onModelFlushed() {\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        const outputToLineNumber = this.projectedModelLineLineCounts.getPrefixSum(toLineNumber);\n        this.modelLineProjections.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        this.projectedModelLineLineCounts.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n    }\n    onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n        const isInHiddenArea = (fromLineNumber > 2 && !this.modelLineProjections[fromLineNumber - 2].isVisible());\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        let totalOutputLineCount = 0;\n        const insertLines = [];\n        const insertPrefixSumValues = [];\n        for (let i = 0, len = lineBreaks.length; i < len; i++) {\n            const line = createModelLineProjection(lineBreaks[i], !isInHiddenArea);\n            insertLines.push(line);\n            const outputLineCount = line.getViewLineCount();\n            totalOutputLineCount += outputLineCount;\n            insertPrefixSumValues[i] = outputLineCount;\n        }\n        // TODO@Alex: use arrays.arrayInsert\n        this.modelLineProjections =\n            this.modelLineProjections.slice(0, fromLineNumber - 1)\n                .concat(insertLines)\n                .concat(this.modelLineProjections.slice(fromLineNumber - 1));\n        this.projectedModelLineLineCounts.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n        return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n    }\n    onModelLineChanged(versionId, lineNumber, lineBreakData) {\n        if (versionId !== null && versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return [false, null, null, null];\n        }\n        const lineIndex = lineNumber - 1;\n        const oldOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        const isVisible = this.modelLineProjections[lineIndex].isVisible();\n        const line = createModelLineProjection(lineBreakData, isVisible);\n        this.modelLineProjections[lineIndex] = line;\n        const newOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        let lineMappingChanged = false;\n        let changeFrom = 0;\n        let changeTo = -1;\n        let insertFrom = 0;\n        let insertTo = -1;\n        let deleteFrom = 0;\n        let deleteTo = -1;\n        if (oldOutputLineCount > newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n            deleteFrom = changeTo + 1;\n            deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else if (oldOutputLineCount < newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + oldOutputLineCount - 1;\n            insertFrom = changeTo + 1;\n            insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n        }\n        this.projectedModelLineLineCounts.setValue(lineIndex, newOutputLineCount);\n        const viewLinesChangedEvent = (changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo - changeFrom + 1) : null);\n        const viewLinesInsertedEvent = (insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null);\n        const viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);\n        return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n    }\n    acceptVersionId(versionId) {\n        this._validModelVersionId = versionId;\n        if (this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible()) {\n            // At least one line must be visible => reset hidden areas\n            this.setHiddenAreas([]);\n        }\n    }\n    getViewLineCount() {\n        return this.projectedModelLineLineCounts.getTotalSum();\n    }\n    _toValidViewLineNumber(viewLineNumber) {\n        if (viewLineNumber < 1) {\n            return 1;\n        }\n        const viewLineCount = this.getViewLineCount();\n        if (viewLineNumber > viewLineCount) {\n            return viewLineCount;\n        }\n        return viewLineNumber | 0;\n    }\n    getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        minLineNumber = this._toValidViewLineNumber(minLineNumber);\n        maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n        const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n        const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n        const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n        const result = this.model.guides.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n        const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n        const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n        return {\n            startLineNumber: viewStartPosition.lineNumber,\n            endLineNumber: viewEndPosition.lineNumber,\n            indent: result.indent\n        };\n    }\n    // #region ViewLineInfo\n    getViewLineInfo(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        return new ViewLineInfo(lineIndex + 1, remainder);\n    }\n    getMinColumnOfViewLine(viewLineInfo) {\n        return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n    getMaxColumnOfViewLine(viewLineInfo) {\n        return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n    getModelStartPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const minViewColumn = line.getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, minViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getModelEndPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const maxViewColumn = line.getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, maxViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber) {\n        const startViewLine = this.getViewLineInfo(viewStartLineNumber);\n        const endViewLine = this.getViewLineInfo(viewEndLineNumber);\n        const result = new Array();\n        let lastVisibleModelPos = this.getModelStartPositionOfViewLine(startViewLine);\n        let viewLines = new Array();\n        for (let curModelLine = startViewLine.modelLineNumber; curModelLine <= endViewLine.modelLineNumber; curModelLine++) {\n            const line = this.modelLineProjections[curModelLine - 1];\n            if (line.isVisible()) {\n                const startOffset = curModelLine === startViewLine.modelLineNumber\n                    ? startViewLine.modelLineWrappedLineIdx\n                    : 0;\n                const endOffset = curModelLine === endViewLine.modelLineNumber\n                    ? endViewLine.modelLineWrappedLineIdx + 1\n                    : line.getViewLineCount();\n                for (let i = startOffset; i < endOffset; i++) {\n                    viewLines.push(new ViewLineInfo(curModelLine, i));\n                }\n            }\n            if (!line.isVisible() && lastVisibleModelPos) {\n                const lastVisibleModelPos2 = new Position(curModelLine - 1, this.model.getLineMaxColumn(curModelLine - 1) + 1);\n                const modelRange = Range.fromPositions(lastVisibleModelPos, lastVisibleModelPos2);\n                result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n                viewLines = [];\n                lastVisibleModelPos = null;\n            }\n            else if (line.isVisible() && !lastVisibleModelPos) {\n                lastVisibleModelPos = new Position(curModelLine, 1);\n            }\n        }\n        if (lastVisibleModelPos) {\n            const modelRange = Range.fromPositions(lastVisibleModelPos, this.getModelEndPositionOfViewLine(endViewLine));\n            result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n        }\n        return result;\n    }\n    // #endregion\n    getViewLinesBracketGuides(viewStartLineNumber, viewEndLineNumber, activeViewPosition, options) {\n        const modelActivePosition = activeViewPosition ? this.convertViewPositionToModelPosition(activeViewPosition.lineNumber, activeViewPosition.column) : null;\n        const resultPerViewLine = [];\n        for (const group of this.getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber)) {\n            const modelRangeStartLineNumber = group.modelRange.startLineNumber;\n            const bracketGuidesPerModelLine = this.model.guides.getLinesBracketGuides(modelRangeStartLineNumber, group.modelRange.endLineNumber, modelActivePosition, options);\n            for (const viewLineInfo of group.viewLines) {\n                const bracketGuides = bracketGuidesPerModelLine[viewLineInfo.modelLineNumber - modelRangeStartLineNumber];\n                // visibleColumns stay as they are (this is a bug and needs to be fixed, but it is not a regression)\n                // model-columns must be converted to view-model columns.\n                const result = bracketGuides.map(g => {\n                    if (g.forWrappedLinesAfterColumn !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesAfterColumn);\n                        if (p.lineNumber >= viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    if (g.forWrappedLinesBeforeOrAtColumn !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesBeforeOrAtColumn);\n                        if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    if (!g.horizontalLine) {\n                        return g;\n                    }\n                    let column = -1;\n                    if (g.column !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.column);\n                        if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n                            column = p.column;\n                        }\n                        else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                            column = this.getMinColumnOfViewLine(viewLineInfo);\n                        }\n                        else if (p.lineNumber > viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    const viewPosition = this.convertModelPositionToViewPosition(viewLineInfo.modelLineNumber, g.horizontalLine.endColumn);\n                    const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.horizontalLine.endColumn);\n                    if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n                        return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, viewPosition.column), -1, -1);\n                    }\n                    else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                        return undefined;\n                    }\n                    else {\n                        if (g.visibleColumn !== -1) {\n                            // Don't repeat horizontal lines that use visibleColumn for unrelated lines.\n                            return undefined;\n                        }\n                        return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, this.getMaxColumnOfViewLine(viewLineInfo)), -1, -1);\n                    }\n                });\n                resultPerViewLine.push(result.filter((r) => !!r));\n            }\n        }\n        return resultPerViewLine;\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        // TODO: Use the same code as in `getViewLinesBracketGuides`.\n        // Future TODO: Merge with `getViewLinesBracketGuides`.\n        // However, this requires more refactoring of indent guides.\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n        const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n        let result = [];\n        const resultRepeatCount = [];\n        const resultRepeatOption = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                const viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                const viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n                const count = viewLineEndIndex - viewLineStartIndex + 1;\n                let option = 0 /* IndentGuideRepeatOption.BlockNone */;\n                if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n                    // wrapped lines should block indent guides\n                    option = (viewLineStartIndex === 0 ? 1 /* IndentGuideRepeatOption.BlockSubsequent */ : 2 /* IndentGuideRepeatOption.BlockAll */);\n                }\n                resultRepeatCount.push(count);\n                resultRepeatOption.push(option);\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, 0);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n            reqStart = null;\n        }\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const viewIndents = new Array(viewLineCount);\n        let currIndex = 0;\n        for (let i = 0, len = result.length; i < len; i++) {\n            let value = result[i];\n            const count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n            const option = resultRepeatOption[i];\n            let blockAtIndex;\n            if (option === 2 /* IndentGuideRepeatOption.BlockAll */) {\n                blockAtIndex = 0;\n            }\n            else if (option === 1 /* IndentGuideRepeatOption.BlockSubsequent */) {\n                blockAtIndex = 1;\n            }\n            else {\n                blockAtIndex = count;\n            }\n            for (let j = 0; j < count; j++) {\n                if (j === blockAtIndex) {\n                    value = 0;\n                }\n                viewIndents[currIndex++] = value;\n            }\n        }\n        return viewIndents;\n    }\n    getViewLineContent(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineContent(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineLength(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineLength(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMinColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMaxColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineData(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineData(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const start = this.projectedModelLineLineCounts.getIndexOf(viewStartLineNumber - 1);\n        let viewLineNumber = viewStartLineNumber;\n        const startModelLineIndex = start.index;\n        const startRemainder = start.remainder;\n        const result = [];\n        for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (!line.isVisible()) {\n                continue;\n            }\n            const fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);\n            let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n            let lastLine = false;\n            if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n                lastLine = true;\n                remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n            }\n            line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, remainingViewLineCount, viewLineNumber - viewStartLineNumber, needed, result);\n            viewLineNumber += remainingViewLineCount;\n            if (lastLine) {\n                break;\n            }\n        }\n        return result;\n    }\n    validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        const line = this.modelLineProjections[lineIndex];\n        const minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n        const maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n        if (viewColumn < minColumn) {\n            viewColumn = minColumn;\n        }\n        if (viewColumn > maxColumn) {\n            viewColumn = maxColumn;\n        }\n        const computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n        const computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n        if (computedModelPosition.equals(expectedModelPosition)) {\n            return new Position(viewLineNumber, viewColumn);\n        }\n        return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n        const validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n        return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n    }\n    convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        const inputColumn = this.modelLineProjections[info.modelLineNumber - 1].getModelColumnOfViewPosition(info.modelLineWrappedLineIdx, viewColumn);\n        // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n        return this.model.validatePosition(new Position(info.modelLineNumber, inputColumn));\n    }\n    convertViewRangeToModelRange(viewRange) {\n        const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n        const end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    convertModelPositionToViewPosition(_modelLineNumber, _modelColumn, affinity = 2 /* PositionAffinity.None */, allowZeroLineNumber = false, belowHiddenRanges = false) {\n        const validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n        const inputLineNumber = validPosition.lineNumber;\n        const inputColumn = validPosition.column;\n        let lineIndex = inputLineNumber - 1, lineIndexChanged = false;\n        if (belowHiddenRanges) {\n            while (lineIndex < this.modelLineProjections.length && !this.modelLineProjections[lineIndex].isVisible()) {\n                lineIndex++;\n                lineIndexChanged = true;\n            }\n        }\n        else {\n            while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n                lineIndex--;\n                lineIndexChanged = true;\n            }\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n            // TODO@alexdima@hediet this isn't soo pretty\n            return new Position(allowZeroLineNumber ? 0 : 1, 1);\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        let r;\n        if (lineIndexChanged) {\n            if (belowHiddenRanges) {\n                r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, 1, affinity);\n            }\n            else {\n                r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1), affinity);\n            }\n        }\n        else {\n            r = this.modelLineProjections[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity);\n        }\n        // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n        return r;\n    }\n    /**\n     * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.\n    */\n    convertModelRangeToViewRange(modelRange, affinity = 0 /* PositionAffinity.Left */) {\n        if (modelRange.isEmpty()) {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, affinity);\n            return Range.fromPositions(start);\n        }\n        else {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, 1 /* PositionAffinity.Right */);\n            const end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn, 0 /* PositionAffinity.Left */);\n            return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n        }\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        let lineIndex = modelLineNumber - 1;\n        if (this.modelLineProjections[lineIndex].isVisible()) {\n            // this model line is visible\n            const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n            return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, modelColumn);\n        }\n        // this model line is not visible\n        while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            lineIndex--;\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            return 1;\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations) {\n        const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n        const modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n        if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n            // most likely there are no hidden lines => fast path\n            // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n            return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations);\n        }\n        let result = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n                    result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation, onlyMinimapDecorations));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation, onlyMinimapDecorations));\n            reqStart = null;\n        }\n        result.sort((a, b) => {\n            const res = Range.compareRangesUsingStarts(a.range, b.range);\n            if (res === 0) {\n                if (a.id < b.id) {\n                    return -1;\n                }\n                if (a.id > b.id) {\n                    return 1;\n                }\n                return 0;\n            }\n            return res;\n        });\n        // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n        const finalResult = [];\n        let finalResultLen = 0;\n        let prevDecId = null;\n        for (const dec of result) {\n            const decId = dec.id;\n            if (prevDecId === decId) {\n                // skip\n                continue;\n            }\n            prevDecId = decId;\n            finalResult[finalResultLen++] = dec;\n        }\n        return finalResult;\n    }\n    getInjectedTextAt(position) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getInjectedTextAt(info.modelLineWrappedLineIdx, position.column);\n    }\n    normalizePosition(position, affinity) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].normalizePosition(info.modelLineWrappedLineIdx, position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        const info = this.getViewLineInfo(lineNumber);\n        if (info.modelLineWrappedLineIdx === 0) {\n            return this.model.getLineIndentColumn(info.modelLineNumber);\n        }\n        // wrapped lines have no indentation.\n        // We deliberately don't handle the case that indentation is wrapped\n        // to avoid two view lines reporting indentation for the very same model line.\n        return 0;\n    }\n}\n/**\n * Overlapping unsorted ranges:\n * [   )      [ )       [  )\n *    [    )      [       )\n * ->\n * Non overlapping sorted ranges:\n * [       )  [ ) [        )\n *\n * Note: This function only considers line information! Columns are ignored.\n*/\nfunction normalizeLineRanges(ranges) {\n    if (ranges.length === 0) {\n        return [];\n    }\n    const sortedRanges = ranges.slice();\n    sortedRanges.sort(Range.compareRangesUsingStarts);\n    const result = [];\n    let currentRangeStart = sortedRanges[0].startLineNumber;\n    let currentRangeEnd = sortedRanges[0].endLineNumber;\n    for (let i = 1, len = sortedRanges.length; i < len; i++) {\n        const range = sortedRanges[i];\n        if (range.startLineNumber > currentRangeEnd + 1) {\n            result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n            currentRangeStart = range.startLineNumber;\n            currentRangeEnd = range.endLineNumber;\n        }\n        else if (range.endLineNumber > currentRangeEnd) {\n            currentRangeEnd = range.endLineNumber;\n        }\n    }\n    result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n    return result;\n}\n/**\n * Represents a view line. Can be used to efficiently query more information about it.\n */\nclass ViewLineInfo {\n    constructor(modelLineNumber, modelLineWrappedLineIdx) {\n        this.modelLineNumber = modelLineNumber;\n        this.modelLineWrappedLineIdx = modelLineWrappedLineIdx;\n    }\n}\n/**\n * A list of view lines that have a contiguous span in the model.\n*/\nclass ViewLineInfoGroupedByModelRange {\n    constructor(modelRange, viewLines) {\n        this.modelRange = modelRange;\n        this.viewLines = viewLines;\n    }\n}\nclass CoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._lines.convertViewRangeToModelRange(viewRange);\n    }\n    validateViewPosition(viewPosition, expectedModelPosition) {\n        return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        return this._lines.validateViewRange(viewRange, expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition, affinity, allowZero, belowHiddenRanges) {\n        return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column, affinity, allowZero, belowHiddenRanges);\n    }\n    convertModelRangeToViewRange(modelRange, affinity) {\n        return this._lines.convertModelRangeToViewRange(modelRange, affinity);\n    }\n    modelPositionIsVisible(modelPosition) {\n        return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return this._lines.getModelLineViewLineCount(modelLineNumber);\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return this._lines.getViewLineNumberOfModelPosition(modelLineNumber, modelColumn);\n    }\n}\nexport class ViewModelLinesFromModelAsIs {\n    constructor(model) {\n        this.model = model;\n    }\n    dispose() {\n    }\n    createCoordinatesConverter() {\n        return new IdentityCoordinatesConverter(this);\n    }\n    getHiddenAreas() {\n        return [];\n    }\n    setHiddenAreas(_ranges) {\n        return false;\n    }\n    setTabSize(_newTabSize) {\n        return false;\n    }\n    setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\n        return false;\n    }\n    createLineBreaksComputer() {\n        const result = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                result.push(null);\n            },\n            finalize: () => {\n                return result;\n            }\n        };\n    }\n    onModelFlushed() {\n    }\n    onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\n        return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\n        return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLineChanged(_versionId, lineNumber, lineBreakData) {\n        return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, 1), null, null];\n    }\n    acceptVersionId(_versionId) {\n    }\n    getViewLineCount() {\n        return this.model.getLineCount();\n    }\n    getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\n        return {\n            startLineNumber: viewLineNumber,\n            endLineNumber: viewLineNumber,\n            indent: 0\n        };\n    }\n    getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition) {\n        return new Array(endLineNumber - startLineNumber + 1).fill([]);\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const result = new Array(viewLineCount);\n        for (let i = 0; i < viewLineCount; i++) {\n            result[i] = 0;\n        }\n        return result;\n    }\n    getViewLineContent(viewLineNumber) {\n        return this.model.getLineContent(viewLineNumber);\n    }\n    getViewLineLength(viewLineNumber) {\n        return this.model.getLineLength(viewLineNumber);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        return this.model.getLineMinColumn(viewLineNumber);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        return this.model.getLineMaxColumn(viewLineNumber);\n    }\n    getViewLineData(viewLineNumber) {\n        const lineTokens = this.model.tokenization.getLineTokens(viewLineNumber);\n        const lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        const lineCount = this.model.getLineCount();\n        viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n        viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n        const result = [];\n        for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n            const idx = lineNumber - viewStartLineNumber;\n            result[idx] = needed[idx] ? this.getViewLineData(lineNumber) : null;\n        }\n        return result;\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations) {\n        return this.model.getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations, onlyMarginDecorations);\n    }\n    normalizePosition(position, affinity) {\n        return this.model.normalizePosition(position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        return this.model.getLineIndentColumn(lineNumber);\n    }\n    getInjectedTextAt(position) {\n        // Identity lines collection does not support injected text.\n        return null;\n    }\n}\nclass IdentityCoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    _validPosition(pos) {\n        return this._lines.model.validatePosition(pos);\n    }\n    _validRange(range) {\n        return this._lines.model.validateRange(range);\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._validPosition(viewPosition);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._validRange(viewRange);\n    }\n    validateViewPosition(_viewPosition, expectedModelPosition) {\n        return this._validPosition(expectedModelPosition);\n    }\n    validateViewRange(_viewRange, expectedModelRange) {\n        return this._validRange(expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition) {\n        return this._validPosition(modelPosition);\n    }\n    convertModelRangeToViewRange(modelRange) {\n        return this._validRange(modelRange);\n    }\n    modelPositionIsVisible(modelPosition) {\n        const lineCount = this._lines.model.getLineCount();\n        if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n            // invalid arguments\n            return false;\n        }\n        return true;\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return 1;\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return modelLineNumber;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}