{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _callSuper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.date.to-json.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.typed-array.uint8-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { PageCoordinates } from '../editorDom.js';\nimport { PartFingerprints } from '../view/viewPart.js';\nimport { ViewLine } from '../viewParts/lines/viewLine.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range as EditorRange } from '../../common/core/range.js';\nimport { CursorColumns } from '../../common/core/cursorColumns.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { AtomicTabMoveOperations } from '../../common/cursor/cursorAtomicMoveOperations.js';\nimport { Lazy } from '../../../base/common/lazy.js';\nvar UnknownHitTestResult = /*#__PURE__*/_createClass(function UnknownHitTestResult() {\n  var hitTarget = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  _classCallCheck(this, UnknownHitTestResult);\n  this.hitTarget = hitTarget;\n  this.type = 0 /* HitTestResultType.Unknown */;\n});\nvar ContentHitTestResult = /*#__PURE__*/function () {\n  function ContentHitTestResult(position, spanNode, injectedText) {\n    _classCallCheck(this, ContentHitTestResult);\n    this.position = position;\n    this.spanNode = spanNode;\n    this.injectedText = injectedText;\n    this.type = 1 /* HitTestResultType.Content */;\n  }\n  return _createClass(ContentHitTestResult, [{\n    key: \"hitTarget\",\n    get: function get() {\n      return this.spanNode;\n    }\n  }]);\n}();\nvar HitTestResult;\n(function (HitTestResult) {\n  function createFromDOMInfo(ctx, spanNode, offset) {\n    var position = ctx.getPositionFromDOMInfo(spanNode, offset);\n    if (position) {\n      return new ContentHitTestResult(position, spanNode, null);\n    }\n    return new UnknownHitTestResult(spanNode);\n  }\n  HitTestResult.createFromDOMInfo = createFromDOMInfo;\n})(HitTestResult || (HitTestResult = {}));\nexport var PointerHandlerLastRenderData = /*#__PURE__*/_createClass(function PointerHandlerLastRenderData(lastViewCursorsRenderData, lastTextareaPosition) {\n  _classCallCheck(this, PointerHandlerLastRenderData);\n  this.lastViewCursorsRenderData = lastViewCursorsRenderData;\n  this.lastTextareaPosition = lastTextareaPosition;\n});\nexport var MouseTarget = /*#__PURE__*/function () {\n  function MouseTarget() {\n    _classCallCheck(this, MouseTarget);\n  }\n  return _createClass(MouseTarget, null, [{\n    key: \"_deduceRage\",\n    value: function _deduceRage(position) {\n      var range = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      if (!range && position) {\n        return new EditorRange(position.lineNumber, position.column, position.lineNumber, position.column);\n      }\n      return range !== null && range !== void 0 ? range : null;\n    }\n  }, {\n    key: \"createUnknown\",\n    value: function createUnknown(element, mouseColumn, position) {\n      return {\n        type: 0 /* MouseTargetType.UNKNOWN */,\n        element: element,\n        mouseColumn: mouseColumn,\n        position: position,\n        range: this._deduceRage(position)\n      };\n    }\n  }, {\n    key: \"createTextarea\",\n    value: function createTextarea(element, mouseColumn) {\n      return {\n        type: 1 /* MouseTargetType.TEXTAREA */,\n        element: element,\n        mouseColumn: mouseColumn,\n        position: null,\n        range: null\n      };\n    }\n  }, {\n    key: \"createMargin\",\n    value: function createMargin(type, element, mouseColumn, position, range, detail) {\n      return {\n        type: type,\n        element: element,\n        mouseColumn: mouseColumn,\n        position: position,\n        range: range,\n        detail: detail\n      };\n    }\n  }, {\n    key: \"createViewZone\",\n    value: function createViewZone(type, element, mouseColumn, position, detail) {\n      return {\n        type: type,\n        element: element,\n        mouseColumn: mouseColumn,\n        position: position,\n        range: this._deduceRage(position),\n        detail: detail\n      };\n    }\n  }, {\n    key: \"createContentText\",\n    value: function createContentText(element, mouseColumn, position, range, detail) {\n      return {\n        type: 6 /* MouseTargetType.CONTENT_TEXT */,\n        element: element,\n        mouseColumn: mouseColumn,\n        position: position,\n        range: this._deduceRage(position, range),\n        detail: detail\n      };\n    }\n  }, {\n    key: \"createContentEmpty\",\n    value: function createContentEmpty(element, mouseColumn, position, detail) {\n      return {\n        type: 7 /* MouseTargetType.CONTENT_EMPTY */,\n        element: element,\n        mouseColumn: mouseColumn,\n        position: position,\n        range: this._deduceRage(position),\n        detail: detail\n      };\n    }\n  }, {\n    key: \"createContentWidget\",\n    value: function createContentWidget(element, mouseColumn, detail) {\n      return {\n        type: 9 /* MouseTargetType.CONTENT_WIDGET */,\n        element: element,\n        mouseColumn: mouseColumn,\n        position: null,\n        range: null,\n        detail: detail\n      };\n    }\n  }, {\n    key: \"createScrollbar\",\n    value: function createScrollbar(element, mouseColumn, position) {\n      return {\n        type: 11 /* MouseTargetType.SCROLLBAR */,\n        element: element,\n        mouseColumn: mouseColumn,\n        position: position,\n        range: this._deduceRage(position)\n      };\n    }\n  }, {\n    key: \"createOverlayWidget\",\n    value: function createOverlayWidget(element, mouseColumn, detail) {\n      return {\n        type: 12 /* MouseTargetType.OVERLAY_WIDGET */,\n        element: element,\n        mouseColumn: mouseColumn,\n        position: null,\n        range: null,\n        detail: detail\n      };\n    }\n  }, {\n    key: \"createOutsideEditor\",\n    value: function createOutsideEditor(mouseColumn, position, outsidePosition, outsideDistance) {\n      return {\n        type: 13 /* MouseTargetType.OUTSIDE_EDITOR */,\n        element: null,\n        mouseColumn: mouseColumn,\n        position: position,\n        range: this._deduceRage(position),\n        outsidePosition: outsidePosition,\n        outsideDistance: outsideDistance\n      };\n    }\n  }, {\n    key: \"_typeToString\",\n    value: function _typeToString(type) {\n      if (type === 1 /* MouseTargetType.TEXTAREA */) {\n        return 'TEXTAREA';\n      }\n      if (type === 2 /* MouseTargetType.GUTTER_GLYPH_MARGIN */) {\n        return 'GUTTER_GLYPH_MARGIN';\n      }\n      if (type === 3 /* MouseTargetType.GUTTER_LINE_NUMBERS */) {\n        return 'GUTTER_LINE_NUMBERS';\n      }\n      if (type === 4 /* MouseTargetType.GUTTER_LINE_DECORATIONS */) {\n        return 'GUTTER_LINE_DECORATIONS';\n      }\n      if (type === 5 /* MouseTargetType.GUTTER_VIEW_ZONE */) {\n        return 'GUTTER_VIEW_ZONE';\n      }\n      if (type === 6 /* MouseTargetType.CONTENT_TEXT */) {\n        return 'CONTENT_TEXT';\n      }\n      if (type === 7 /* MouseTargetType.CONTENT_EMPTY */) {\n        return 'CONTENT_EMPTY';\n      }\n      if (type === 8 /* MouseTargetType.CONTENT_VIEW_ZONE */) {\n        return 'CONTENT_VIEW_ZONE';\n      }\n      if (type === 9 /* MouseTargetType.CONTENT_WIDGET */) {\n        return 'CONTENT_WIDGET';\n      }\n      if (type === 10 /* MouseTargetType.OVERVIEW_RULER */) {\n        return 'OVERVIEW_RULER';\n      }\n      if (type === 11 /* MouseTargetType.SCROLLBAR */) {\n        return 'SCROLLBAR';\n      }\n      if (type === 12 /* MouseTargetType.OVERLAY_WIDGET */) {\n        return 'OVERLAY_WIDGET';\n      }\n      return 'UNKNOWN';\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(target) {\n      return this._typeToString(target.type) + ': ' + target.position + ' - ' + target.range + ' - ' + JSON.stringify(target.detail);\n    }\n  }]);\n}();\nvar ElementPath = /*#__PURE__*/function () {\n  function ElementPath() {\n    _classCallCheck(this, ElementPath);\n  }\n  return _createClass(ElementPath, null, [{\n    key: \"isTextArea\",\n    value: function isTextArea(path) {\n      return path.length === 2 && path[0] === 3 /* PartFingerprint.OverflowGuard */ && path[1] === 7 /* PartFingerprint.TextArea */;\n    }\n  }, {\n    key: \"isChildOfViewLines\",\n    value: function isChildOfViewLines(path) {\n      return path.length >= 4 && path[0] === 3 /* PartFingerprint.OverflowGuard */ && path[3] === 8 /* PartFingerprint.ViewLines */;\n    }\n  }, {\n    key: \"isStrictChildOfViewLines\",\n    value: function isStrictChildOfViewLines(path) {\n      return path.length > 4 && path[0] === 3 /* PartFingerprint.OverflowGuard */ && path[3] === 8 /* PartFingerprint.ViewLines */;\n    }\n  }, {\n    key: \"isChildOfScrollableElement\",\n    value: function isChildOfScrollableElement(path) {\n      return path.length >= 2 && path[0] === 3 /* PartFingerprint.OverflowGuard */ && path[1] === 6 /* PartFingerprint.ScrollableElement */;\n    }\n  }, {\n    key: \"isChildOfMinimap\",\n    value: function isChildOfMinimap(path) {\n      return path.length >= 2 && path[0] === 3 /* PartFingerprint.OverflowGuard */ && path[1] === 9 /* PartFingerprint.Minimap */;\n    }\n  }, {\n    key: \"isChildOfContentWidgets\",\n    value: function isChildOfContentWidgets(path) {\n      return path.length >= 4 && path[0] === 3 /* PartFingerprint.OverflowGuard */ && path[3] === 1 /* PartFingerprint.ContentWidgets */;\n    }\n  }, {\n    key: \"isChildOfOverflowGuard\",\n    value: function isChildOfOverflowGuard(path) {\n      return path.length >= 1 && path[0] === 3 /* PartFingerprint.OverflowGuard */;\n    }\n  }, {\n    key: \"isChildOfOverflowingContentWidgets\",\n    value: function isChildOfOverflowingContentWidgets(path) {\n      return path.length >= 1 && path[0] === 2 /* PartFingerprint.OverflowingContentWidgets */;\n    }\n  }, {\n    key: \"isChildOfOverlayWidgets\",\n    value: function isChildOfOverlayWidgets(path) {\n      return path.length >= 2 && path[0] === 3 /* PartFingerprint.OverflowGuard */ && path[1] === 4 /* PartFingerprint.OverlayWidgets */;\n    }\n  }, {\n    key: \"isChildOfOverflowingOverlayWidgets\",\n    value: function isChildOfOverflowingOverlayWidgets(path) {\n      return path.length >= 1 && path[0] === 5 /* PartFingerprint.OverflowingOverlayWidgets */;\n    }\n  }]);\n}();\nexport var HitTestContext = /*#__PURE__*/function () {\n  function HitTestContext(context, viewHelper, lastRenderData) {\n    _classCallCheck(this, HitTestContext);\n    this.viewModel = context.viewModel;\n    var options = context.configuration.options;\n    this.layoutInfo = options.get(145 /* EditorOption.layoutInfo */);\n    this.viewDomNode = viewHelper.viewDomNode;\n    this.lineHeight = options.get(67 /* EditorOption.lineHeight */);\n    this.stickyTabStops = options.get(116 /* EditorOption.stickyTabStops */);\n    this.typicalHalfwidthCharacterWidth = options.get(50 /* EditorOption.fontInfo */).typicalHalfwidthCharacterWidth;\n    this.lastRenderData = lastRenderData;\n    this._context = context;\n    this._viewHelper = viewHelper;\n  }\n  return _createClass(HitTestContext, [{\n    key: \"getZoneAtCoord\",\n    value: function getZoneAtCoord(mouseVerticalOffset) {\n      return HitTestContext.getZoneAtCoord(this._context, mouseVerticalOffset);\n    }\n  }, {\n    key: \"getFullLineRangeAtCoord\",\n    value: function getFullLineRangeAtCoord(mouseVerticalOffset) {\n      if (this._context.viewLayout.isAfterLines(mouseVerticalOffset)) {\n        // Below the last line\n        var _lineNumber = this._context.viewModel.getLineCount();\n        var _maxLineColumn = this._context.viewModel.getLineMaxColumn(_lineNumber);\n        return {\n          range: new EditorRange(_lineNumber, _maxLineColumn, _lineNumber, _maxLineColumn),\n          isAfterLines: true\n        };\n      }\n      var lineNumber = this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n      var maxLineColumn = this._context.viewModel.getLineMaxColumn(lineNumber);\n      return {\n        range: new EditorRange(lineNumber, 1, lineNumber, maxLineColumn),\n        isAfterLines: false\n      };\n    }\n  }, {\n    key: \"getLineNumberAtVerticalOffset\",\n    value: function getLineNumberAtVerticalOffset(mouseVerticalOffset) {\n      return this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n    }\n  }, {\n    key: \"isAfterLines\",\n    value: function isAfterLines(mouseVerticalOffset) {\n      return this._context.viewLayout.isAfterLines(mouseVerticalOffset);\n    }\n  }, {\n    key: \"isInTopPadding\",\n    value: function isInTopPadding(mouseVerticalOffset) {\n      return this._context.viewLayout.isInTopPadding(mouseVerticalOffset);\n    }\n  }, {\n    key: \"isInBottomPadding\",\n    value: function isInBottomPadding(mouseVerticalOffset) {\n      return this._context.viewLayout.isInBottomPadding(mouseVerticalOffset);\n    }\n  }, {\n    key: \"getVerticalOffsetForLineNumber\",\n    value: function getVerticalOffsetForLineNumber(lineNumber) {\n      return this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber);\n    }\n  }, {\n    key: \"findAttribute\",\n    value: function findAttribute(element, attr) {\n      return HitTestContext._findAttribute(element, attr, this._viewHelper.viewDomNode);\n    }\n  }, {\n    key: \"getLineWidth\",\n    value: function getLineWidth(lineNumber) {\n      return this._viewHelper.getLineWidth(lineNumber);\n    }\n  }, {\n    key: \"visibleRangeForPosition\",\n    value: function visibleRangeForPosition(lineNumber, column) {\n      return this._viewHelper.visibleRangeForPosition(lineNumber, column);\n    }\n  }, {\n    key: \"getPositionFromDOMInfo\",\n    value: function getPositionFromDOMInfo(spanNode, offset) {\n      return this._viewHelper.getPositionFromDOMInfo(spanNode, offset);\n    }\n  }, {\n    key: \"getCurrentScrollTop\",\n    value: function getCurrentScrollTop() {\n      return this._context.viewLayout.getCurrentScrollTop();\n    }\n  }, {\n    key: \"getCurrentScrollLeft\",\n    value: function getCurrentScrollLeft() {\n      return this._context.viewLayout.getCurrentScrollLeft();\n    }\n  }], [{\n    key: \"getZoneAtCoord\",\n    value: function getZoneAtCoord(context, mouseVerticalOffset) {\n      // The target is either a view zone or the empty space after the last view-line\n      var viewZoneWhitespace = context.viewLayout.getWhitespaceAtVerticalOffset(mouseVerticalOffset);\n      if (viewZoneWhitespace) {\n        var viewZoneMiddle = viewZoneWhitespace.verticalOffset + viewZoneWhitespace.height / 2;\n        var lineCount = context.viewModel.getLineCount();\n        var positionBefore = null;\n        var position;\n        var positionAfter = null;\n        if (viewZoneWhitespace.afterLineNumber !== lineCount) {\n          // There are more lines after this view zone\n          positionAfter = new Position(viewZoneWhitespace.afterLineNumber + 1, 1);\n        }\n        if (viewZoneWhitespace.afterLineNumber > 0) {\n          // There are more lines above this view zone\n          positionBefore = new Position(viewZoneWhitespace.afterLineNumber, context.viewModel.getLineMaxColumn(viewZoneWhitespace.afterLineNumber));\n        }\n        if (positionAfter === null) {\n          position = positionBefore;\n        } else if (positionBefore === null) {\n          position = positionAfter;\n        } else if (mouseVerticalOffset < viewZoneMiddle) {\n          position = positionBefore;\n        } else {\n          position = positionAfter;\n        }\n        return {\n          viewZoneId: viewZoneWhitespace.id,\n          afterLineNumber: viewZoneWhitespace.afterLineNumber,\n          positionBefore: positionBefore,\n          positionAfter: positionAfter,\n          position: position\n        };\n      }\n      return null;\n    }\n  }, {\n    key: \"_findAttribute\",\n    value: function _findAttribute(element, attr, stopAt) {\n      while (element && element !== element.ownerDocument.body) {\n        if (element.hasAttribute && element.hasAttribute(attr)) {\n          return element.getAttribute(attr);\n        }\n        if (element === stopAt) {\n          return null;\n        }\n        element = element.parentNode;\n      }\n      return null;\n    }\n  }]);\n}();\nvar BareHitTestRequest = /*#__PURE__*/_createClass(function BareHitTestRequest(ctx, editorPos, pos, relativePos) {\n  _classCallCheck(this, BareHitTestRequest);\n  this.editorPos = editorPos;\n  this.pos = pos;\n  this.relativePos = relativePos;\n  this.mouseVerticalOffset = Math.max(0, ctx.getCurrentScrollTop() + this.relativePos.y);\n  this.mouseContentHorizontalOffset = ctx.getCurrentScrollLeft() + this.relativePos.x - ctx.layoutInfo.contentLeft;\n  this.isInMarginArea = this.relativePos.x < ctx.layoutInfo.contentLeft && this.relativePos.x >= ctx.layoutInfo.glyphMarginLeft;\n  this.isInContentArea = !this.isInMarginArea;\n  this.mouseColumn = Math.max(0, MouseTargetFactory._getMouseColumn(this.mouseContentHorizontalOffset, ctx.typicalHalfwidthCharacterWidth));\n});\nvar HitTestRequest = /*#__PURE__*/function (_BareHitTestRequest) {\n  function HitTestRequest(ctx, editorPos, pos, relativePos, eventTarget) {\n    var _this;\n    _classCallCheck(this, HitTestRequest);\n    _this = _callSuper(this, HitTestRequest, [ctx, editorPos, pos, relativePos]);\n    _this.hitTestResult = new Lazy(function () {\n      return MouseTargetFactory.doHitTest(_this._ctx, _this);\n    });\n    _this._targetPathCacheElement = null;\n    _this._targetPathCacheValue = new Uint8Array(0);\n    _this._ctx = ctx;\n    _this._eventTarget = eventTarget;\n    // If no event target is passed in, we will use the hit test target\n    var hasEventTarget = Boolean(_this._eventTarget);\n    _this._useHitTestTarget = !hasEventTarget;\n    return _this;\n  }\n  _inherits(HitTestRequest, _BareHitTestRequest);\n  return _createClass(HitTestRequest, [{\n    key: \"target\",\n    get: function get() {\n      if (this._useHitTestTarget) {\n        return this.hitTestResult.value.hitTarget;\n      }\n      return this._eventTarget;\n    }\n  }, {\n    key: \"targetPath\",\n    get: function get() {\n      if (this._targetPathCacheElement !== this.target) {\n        this._targetPathCacheElement = this.target;\n        this._targetPathCacheValue = PartFingerprints.collect(this.target, this._ctx.viewDomNode);\n      }\n      return this._targetPathCacheValue;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"pos(\".concat(this.pos.x, \",\").concat(this.pos.y, \"), editorPos(\").concat(this.editorPos.x, \",\").concat(this.editorPos.y, \"), relativePos(\").concat(this.relativePos.x, \",\").concat(this.relativePos.y, \"), mouseVerticalOffset: \").concat(this.mouseVerticalOffset, \", mouseContentHorizontalOffset: \").concat(this.mouseContentHorizontalOffset, \"\\n\\ttarget: \").concat(this.target ? this.target.outerHTML : null);\n    }\n  }, {\n    key: \"wouldBenefitFromHitTestTargetSwitch\",\n    get: function get() {\n      return !this._useHitTestTarget && this.hitTestResult.value.hitTarget !== null && this.target !== this.hitTestResult.value.hitTarget;\n    }\n  }, {\n    key: \"switchToHitTestTarget\",\n    value: function switchToHitTestTarget() {\n      this._useHitTestTarget = true;\n    }\n  }, {\n    key: \"_getMouseColumn\",\n    value: function _getMouseColumn() {\n      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      if (position && position.column < this._ctx.viewModel.getLineMaxColumn(position.lineNumber)) {\n        // Most likely, the line contains foreign decorations...\n        return CursorColumns.visibleColumnFromColumn(this._ctx.viewModel.getLineContent(position.lineNumber), position.column, this._ctx.viewModel.model.getOptions().tabSize) + 1;\n      }\n      return this.mouseColumn;\n    }\n  }, {\n    key: \"fulfillUnknown\",\n    value: function fulfillUnknown() {\n      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      return MouseTarget.createUnknown(this.target, this._getMouseColumn(position), position);\n    }\n  }, {\n    key: \"fulfillTextarea\",\n    value: function fulfillTextarea() {\n      return MouseTarget.createTextarea(this.target, this._getMouseColumn());\n    }\n  }, {\n    key: \"fulfillMargin\",\n    value: function fulfillMargin(type, position, range, detail) {\n      return MouseTarget.createMargin(type, this.target, this._getMouseColumn(position), position, range, detail);\n    }\n  }, {\n    key: \"fulfillViewZone\",\n    value: function fulfillViewZone(type, position, detail) {\n      return MouseTarget.createViewZone(type, this.target, this._getMouseColumn(position), position, detail);\n    }\n  }, {\n    key: \"fulfillContentText\",\n    value: function fulfillContentText(position, range, detail) {\n      return MouseTarget.createContentText(this.target, this._getMouseColumn(position), position, range, detail);\n    }\n  }, {\n    key: \"fulfillContentEmpty\",\n    value: function fulfillContentEmpty(position, detail) {\n      return MouseTarget.createContentEmpty(this.target, this._getMouseColumn(position), position, detail);\n    }\n  }, {\n    key: \"fulfillContentWidget\",\n    value: function fulfillContentWidget(detail) {\n      return MouseTarget.createContentWidget(this.target, this._getMouseColumn(), detail);\n    }\n  }, {\n    key: \"fulfillScrollbar\",\n    value: function fulfillScrollbar(position) {\n      return MouseTarget.createScrollbar(this.target, this._getMouseColumn(position), position);\n    }\n  }, {\n    key: \"fulfillOverlayWidget\",\n    value: function fulfillOverlayWidget(detail) {\n      return MouseTarget.createOverlayWidget(this.target, this._getMouseColumn(), detail);\n    }\n  }]);\n}(BareHitTestRequest);\nvar EMPTY_CONTENT_AFTER_LINES = {\n  isAfterLines: true\n};\nfunction createEmptyContentDataInLines(horizontalDistanceToText) {\n  return {\n    isAfterLines: false,\n    horizontalDistanceToText: horizontalDistanceToText\n  };\n}\nexport var MouseTargetFactory = /*#__PURE__*/function () {\n  function MouseTargetFactory(context, viewHelper) {\n    _classCallCheck(this, MouseTargetFactory);\n    this._context = context;\n    this._viewHelper = viewHelper;\n  }\n  return _createClass(MouseTargetFactory, [{\n    key: \"mouseTargetIsWidget\",\n    value: function mouseTargetIsWidget(e) {\n      var t = e.target;\n      var path = PartFingerprints.collect(t, this._viewHelper.viewDomNode);\n      // Is it a content widget?\n      if (ElementPath.isChildOfContentWidgets(path) || ElementPath.isChildOfOverflowingContentWidgets(path)) {\n        return true;\n      }\n      // Is it an overlay widget?\n      if (ElementPath.isChildOfOverlayWidgets(path) || ElementPath.isChildOfOverflowingOverlayWidgets(path)) {\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"createMouseTarget\",\n    value: function createMouseTarget(lastRenderData, editorPos, pos, relativePos, target) {\n      var ctx = new HitTestContext(this._context, this._viewHelper, lastRenderData);\n      var request = new HitTestRequest(ctx, editorPos, pos, relativePos, target);\n      try {\n        var r = MouseTargetFactory._createMouseTarget(ctx, request);\n        if (r.type === 6 /* MouseTargetType.CONTENT_TEXT */) {\n          // Snap to the nearest soft tab boundary if atomic soft tabs are enabled.\n          if (ctx.stickyTabStops && r.position !== null) {\n            var position = MouseTargetFactory._snapToSoftTabBoundary(r.position, ctx.viewModel);\n            var range = EditorRange.fromPositions(position, position).plusRange(r.range);\n            return request.fulfillContentText(position, range, r.detail);\n          }\n        }\n        // console.log(MouseTarget.toString(r));\n        return r;\n      } catch (err) {\n        // console.log(err);\n        return request.fulfillUnknown();\n      }\n    }\n  }, {\n    key: \"getMouseColumn\",\n    value: function getMouseColumn(relativePos) {\n      var options = this._context.configuration.options;\n      var layoutInfo = options.get(145 /* EditorOption.layoutInfo */);\n      var mouseContentHorizontalOffset = this._context.viewLayout.getCurrentScrollLeft() + relativePos.x - layoutInfo.contentLeft;\n      return MouseTargetFactory._getMouseColumn(mouseContentHorizontalOffset, options.get(50 /* EditorOption.fontInfo */).typicalHalfwidthCharacterWidth);\n    }\n  }], [{\n    key: \"_createMouseTarget\",\n    value: function _createMouseTarget(ctx, request) {\n      // console.log(`${domHitTestExecuted ? '=>' : ''}CAME IN REQUEST: ${request}`);\n      if (request.target === null) {\n        // No target\n        return request.fulfillUnknown();\n      }\n      // we know for a fact that request.target is not null\n      var resolvedRequest = request;\n      var result = null;\n      if (!ElementPath.isChildOfOverflowGuard(request.targetPath) && !ElementPath.isChildOfOverflowingContentWidgets(request.targetPath) && !ElementPath.isChildOfOverflowingOverlayWidgets(request.targetPath)) {\n        // We only render dom nodes inside the overflow guard or in the overflowing content widgets\n        result = result || request.fulfillUnknown();\n      }\n      result = result || MouseTargetFactory._hitTestContentWidget(ctx, resolvedRequest);\n      result = result || MouseTargetFactory._hitTestOverlayWidget(ctx, resolvedRequest);\n      result = result || MouseTargetFactory._hitTestMinimap(ctx, resolvedRequest);\n      result = result || MouseTargetFactory._hitTestScrollbarSlider(ctx, resolvedRequest);\n      result = result || MouseTargetFactory._hitTestViewZone(ctx, resolvedRequest);\n      result = result || MouseTargetFactory._hitTestMargin(ctx, resolvedRequest);\n      result = result || MouseTargetFactory._hitTestViewCursor(ctx, resolvedRequest);\n      result = result || MouseTargetFactory._hitTestTextArea(ctx, resolvedRequest);\n      result = result || MouseTargetFactory._hitTestViewLines(ctx, resolvedRequest);\n      result = result || MouseTargetFactory._hitTestScrollbar(ctx, resolvedRequest);\n      return result || request.fulfillUnknown();\n    }\n  }, {\n    key: \"_hitTestContentWidget\",\n    value: function _hitTestContentWidget(ctx, request) {\n      // Is it a content widget?\n      if (ElementPath.isChildOfContentWidgets(request.targetPath) || ElementPath.isChildOfOverflowingContentWidgets(request.targetPath)) {\n        var widgetId = ctx.findAttribute(request.target, 'widgetId');\n        if (widgetId) {\n          return request.fulfillContentWidget(widgetId);\n        } else {\n          return request.fulfillUnknown();\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_hitTestOverlayWidget\",\n    value: function _hitTestOverlayWidget(ctx, request) {\n      // Is it an overlay widget?\n      if (ElementPath.isChildOfOverlayWidgets(request.targetPath) || ElementPath.isChildOfOverflowingOverlayWidgets(request.targetPath)) {\n        var widgetId = ctx.findAttribute(request.target, 'widgetId');\n        if (widgetId) {\n          return request.fulfillOverlayWidget(widgetId);\n        } else {\n          return request.fulfillUnknown();\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_hitTestViewCursor\",\n    value: function _hitTestViewCursor(ctx, request) {\n      if (request.target) {\n        // Check if we've hit a painted cursor\n        var lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n        var _iterator = _createForOfIteratorHelper(lastViewCursorsRenderData),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var d = _step.value;\n            if (request.target === d.domNode) {\n              return request.fulfillContentText(d.position, null, {\n                mightBeForeignElement: false,\n                injectedText: null\n              });\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      if (request.isInContentArea) {\n        // Edge has a bug when hit-testing the exact position of a cursor,\n        // instead of returning the correct dom node, it returns the\n        // first or last rendered view line dom node, therefore help it out\n        // and first check if we are on top of a cursor\n        var _lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n        var mouseContentHorizontalOffset = request.mouseContentHorizontalOffset;\n        var mouseVerticalOffset = request.mouseVerticalOffset;\n        var _iterator2 = _createForOfIteratorHelper(_lastViewCursorsRenderData),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _d = _step2.value;\n            if (mouseContentHorizontalOffset < _d.contentLeft) {\n              // mouse position is to the left of the cursor\n              continue;\n            }\n            if (mouseContentHorizontalOffset > _d.contentLeft + _d.width) {\n              // mouse position is to the right of the cursor\n              continue;\n            }\n            var cursorVerticalOffset = ctx.getVerticalOffsetForLineNumber(_d.position.lineNumber);\n            if (cursorVerticalOffset <= mouseVerticalOffset && mouseVerticalOffset <= cursorVerticalOffset + _d.height) {\n              return request.fulfillContentText(_d.position, null, {\n                mightBeForeignElement: false,\n                injectedText: null\n              });\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_hitTestViewZone\",\n    value: function _hitTestViewZone(ctx, request) {\n      var viewZoneData = ctx.getZoneAtCoord(request.mouseVerticalOffset);\n      if (viewZoneData) {\n        var mouseTargetType = request.isInContentArea ? 8 /* MouseTargetType.CONTENT_VIEW_ZONE */ : 5 /* MouseTargetType.GUTTER_VIEW_ZONE */;\n        return request.fulfillViewZone(mouseTargetType, viewZoneData.position, viewZoneData);\n      }\n      return null;\n    }\n  }, {\n    key: \"_hitTestTextArea\",\n    value: function _hitTestTextArea(ctx, request) {\n      // Is it the textarea?\n      if (ElementPath.isTextArea(request.targetPath)) {\n        if (ctx.lastRenderData.lastTextareaPosition) {\n          return request.fulfillContentText(ctx.lastRenderData.lastTextareaPosition, null, {\n            mightBeForeignElement: false,\n            injectedText: null\n          });\n        }\n        return request.fulfillTextarea();\n      }\n      return null;\n    }\n  }, {\n    key: \"_hitTestMargin\",\n    value: function _hitTestMargin(ctx, request) {\n      if (request.isInMarginArea) {\n        var res = ctx.getFullLineRangeAtCoord(request.mouseVerticalOffset);\n        var pos = res.range.getStartPosition();\n        var offset = Math.abs(request.relativePos.x);\n        var detail = {\n          isAfterLines: res.isAfterLines,\n          glyphMarginLeft: ctx.layoutInfo.glyphMarginLeft,\n          glyphMarginWidth: ctx.layoutInfo.glyphMarginWidth,\n          lineNumbersWidth: ctx.layoutInfo.lineNumbersWidth,\n          offsetX: offset\n        };\n        offset -= ctx.layoutInfo.glyphMarginLeft;\n        if (offset <= ctx.layoutInfo.glyphMarginWidth) {\n          // On the glyph margin\n          var modelCoordinate = ctx.viewModel.coordinatesConverter.convertViewPositionToModelPosition(res.range.getStartPosition());\n          var lanes = ctx.viewModel.glyphLanes.getLanesAtLine(modelCoordinate.lineNumber);\n          detail.glyphMarginLane = lanes[Math.floor(offset / ctx.lineHeight)];\n          return request.fulfillMargin(2 /* MouseTargetType.GUTTER_GLYPH_MARGIN */, pos, res.range, detail);\n        }\n        offset -= ctx.layoutInfo.glyphMarginWidth;\n        if (offset <= ctx.layoutInfo.lineNumbersWidth) {\n          // On the line numbers\n          return request.fulfillMargin(3 /* MouseTargetType.GUTTER_LINE_NUMBERS */, pos, res.range, detail);\n        }\n        offset -= ctx.layoutInfo.lineNumbersWidth;\n        // On the line decorations\n        return request.fulfillMargin(4 /* MouseTargetType.GUTTER_LINE_DECORATIONS */, pos, res.range, detail);\n      }\n      return null;\n    }\n  }, {\n    key: \"_hitTestViewLines\",\n    value: function _hitTestViewLines(ctx, request) {\n      if (!ElementPath.isChildOfViewLines(request.targetPath)) {\n        return null;\n      }\n      if (ctx.isInTopPadding(request.mouseVerticalOffset)) {\n        return request.fulfillContentEmpty(new Position(1, 1), EMPTY_CONTENT_AFTER_LINES);\n      }\n      // Check if it is below any lines and any view zones\n      if (ctx.isAfterLines(request.mouseVerticalOffset) || ctx.isInBottomPadding(request.mouseVerticalOffset)) {\n        // This most likely indicates it happened after the last view-line\n        var lineCount = ctx.viewModel.getLineCount();\n        var maxLineColumn = ctx.viewModel.getLineMaxColumn(lineCount);\n        return request.fulfillContentEmpty(new Position(lineCount, maxLineColumn), EMPTY_CONTENT_AFTER_LINES);\n      }\n      // Check if we are hitting a view-line (can happen in the case of inline decorations on empty lines)\n      // See https://github.com/microsoft/vscode/issues/46942\n      if (ElementPath.isStrictChildOfViewLines(request.targetPath)) {\n        var lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n        if (ctx.viewModel.getLineLength(lineNumber) === 0) {\n          var _lineWidth = ctx.getLineWidth(lineNumber);\n          var detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - _lineWidth);\n          return request.fulfillContentEmpty(new Position(lineNumber, 1), detail);\n        }\n        var lineWidth = ctx.getLineWidth(lineNumber);\n        if (request.mouseContentHorizontalOffset >= lineWidth) {\n          // TODO: This is wrong for RTL\n          var _detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n          var pos = new Position(lineNumber, ctx.viewModel.getLineMaxColumn(lineNumber));\n          return request.fulfillContentEmpty(pos, _detail);\n        }\n      }\n      // Do the hit test (if not already done)\n      var hitTestResult = request.hitTestResult.value;\n      if (hitTestResult.type === 1 /* HitTestResultType.Content */) {\n        return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.spanNode, hitTestResult.position, hitTestResult.injectedText);\n      }\n      // We didn't hit content...\n      if (request.wouldBenefitFromHitTestTargetSwitch) {\n        // We actually hit something different... Give it one last change by trying again with this new target\n        request.switchToHitTestTarget();\n        return this._createMouseTarget(ctx, request);\n      }\n      // We have tried everything...\n      return request.fulfillUnknown();\n    }\n  }, {\n    key: \"_hitTestMinimap\",\n    value: function _hitTestMinimap(ctx, request) {\n      if (ElementPath.isChildOfMinimap(request.targetPath)) {\n        var possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n        var maxColumn = ctx.viewModel.getLineMaxColumn(possibleLineNumber);\n        return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n      }\n      return null;\n    }\n  }, {\n    key: \"_hitTestScrollbarSlider\",\n    value: function _hitTestScrollbarSlider(ctx, request) {\n      if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n        if (request.target && request.target.nodeType === 1) {\n          var className = request.target.className;\n          if (className && /\\b(slider|scrollbar)\\b/.test(className)) {\n            var possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n            var maxColumn = ctx.viewModel.getLineMaxColumn(possibleLineNumber);\n            return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n          }\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_hitTestScrollbar\",\n    value: function _hitTestScrollbar(ctx, request) {\n      // Is it the overview ruler?\n      // Is it a child of the scrollable element?\n      if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n        var possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n        var maxColumn = ctx.viewModel.getLineMaxColumn(possibleLineNumber);\n        return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n      }\n      return null;\n    }\n  }, {\n    key: \"_getMouseColumn\",\n    value: function _getMouseColumn(mouseContentHorizontalOffset, typicalHalfwidthCharacterWidth) {\n      if (mouseContentHorizontalOffset < 0) {\n        return 1;\n      }\n      var chars = Math.round(mouseContentHorizontalOffset / typicalHalfwidthCharacterWidth);\n      return chars + 1;\n    }\n  }, {\n    key: \"createMouseTargetFromHitTestPosition\",\n    value: function createMouseTargetFromHitTestPosition(ctx, request, spanNode, pos, injectedText) {\n      var lineNumber = pos.lineNumber;\n      var column = pos.column;\n      var lineWidth = ctx.getLineWidth(lineNumber);\n      if (request.mouseContentHorizontalOffset > lineWidth) {\n        var detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n        return request.fulfillContentEmpty(pos, detail);\n      }\n      var visibleRange = ctx.visibleRangeForPosition(lineNumber, column);\n      if (!visibleRange) {\n        return request.fulfillUnknown(pos);\n      }\n      var columnHorizontalOffset = visibleRange.left;\n      if (Math.abs(request.mouseContentHorizontalOffset - columnHorizontalOffset) < 1) {\n        return request.fulfillContentText(pos, null, {\n          mightBeForeignElement: !!injectedText,\n          injectedText: injectedText\n        });\n      }\n      var points = [];\n      points.push({\n        offset: visibleRange.left,\n        column: column\n      });\n      if (column > 1) {\n        var _visibleRange = ctx.visibleRangeForPosition(lineNumber, column - 1);\n        if (_visibleRange) {\n          points.push({\n            offset: _visibleRange.left,\n            column: column - 1\n          });\n        }\n      }\n      var lineMaxColumn = ctx.viewModel.getLineMaxColumn(lineNumber);\n      if (column < lineMaxColumn) {\n        var _visibleRange2 = ctx.visibleRangeForPosition(lineNumber, column + 1);\n        if (_visibleRange2) {\n          points.push({\n            offset: _visibleRange2.left,\n            column: column + 1\n          });\n        }\n      }\n      points.sort(function (a, b) {\n        return a.offset - b.offset;\n      });\n      var mouseCoordinates = request.pos.toClientCoordinates(dom.getWindow(ctx.viewDomNode));\n      var spanNodeClientRect = spanNode.getBoundingClientRect();\n      var mouseIsOverSpanNode = spanNodeClientRect.left <= mouseCoordinates.clientX && mouseCoordinates.clientX <= spanNodeClientRect.right;\n      var rng = null;\n      for (var i = 1; i < points.length; i++) {\n        var prev = points[i - 1];\n        var curr = points[i];\n        if (prev.offset <= request.mouseContentHorizontalOffset && request.mouseContentHorizontalOffset <= curr.offset) {\n          rng = new EditorRange(lineNumber, prev.column, lineNumber, curr.column);\n          // See https://github.com/microsoft/vscode/issues/152819\n          // Due to the use of zwj, the browser's hit test result is skewed towards the left\n          // Here we try to correct that if the mouse horizontal offset is closer to the right than the left\n          var prevDelta = Math.abs(prev.offset - request.mouseContentHorizontalOffset);\n          var nextDelta = Math.abs(curr.offset - request.mouseContentHorizontalOffset);\n          pos = prevDelta < nextDelta ? new Position(lineNumber, prev.column) : new Position(lineNumber, curr.column);\n          break;\n        }\n      }\n      return request.fulfillContentText(pos, rng, {\n        mightBeForeignElement: !mouseIsOverSpanNode || !!injectedText,\n        injectedText: injectedText\n      });\n    }\n    /**\n     * Most probably WebKit browsers and Edge\n     */\n  }, {\n    key: \"_doHitTestWithCaretRangeFromPoint\",\n    value: function _doHitTestWithCaretRangeFromPoint(ctx, request) {\n      // In Chrome, especially on Linux it is possible to click between lines,\n      // so try to adjust the `hity` below so that it lands in the center of a line\n      var lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n      var lineStartVerticalOffset = ctx.getVerticalOffsetForLineNumber(lineNumber);\n      var lineEndVerticalOffset = lineStartVerticalOffset + ctx.lineHeight;\n      var isBelowLastLine = lineNumber === ctx.viewModel.getLineCount() && request.mouseVerticalOffset > lineEndVerticalOffset;\n      if (!isBelowLastLine) {\n        var lineCenteredVerticalOffset = Math.floor((lineStartVerticalOffset + lineEndVerticalOffset) / 2);\n        var adjustedPageY = request.pos.y + (lineCenteredVerticalOffset - request.mouseVerticalOffset);\n        if (adjustedPageY <= request.editorPos.y) {\n          adjustedPageY = request.editorPos.y + 1;\n        }\n        if (adjustedPageY >= request.editorPos.y + request.editorPos.height) {\n          adjustedPageY = request.editorPos.y + request.editorPos.height - 1;\n        }\n        var adjustedPage = new PageCoordinates(request.pos.x, adjustedPageY);\n        var r = this._actualDoHitTestWithCaretRangeFromPoint(ctx, adjustedPage.toClientCoordinates(dom.getWindow(ctx.viewDomNode)));\n        if (r.type === 1 /* HitTestResultType.Content */) {\n          return r;\n        }\n      }\n      // Also try to hit test without the adjustment (for the edge cases that we are near the top or bottom)\n      return this._actualDoHitTestWithCaretRangeFromPoint(ctx, request.pos.toClientCoordinates(dom.getWindow(ctx.viewDomNode)));\n    }\n  }, {\n    key: \"_actualDoHitTestWithCaretRangeFromPoint\",\n    value: function _actualDoHitTestWithCaretRangeFromPoint(ctx, coords) {\n      var shadowRoot = dom.getShadowRoot(ctx.viewDomNode);\n      var range;\n      if (shadowRoot) {\n        if (typeof shadowRoot.caretRangeFromPoint === 'undefined') {\n          range = shadowCaretRangeFromPoint(shadowRoot, coords.clientX, coords.clientY);\n        } else {\n          range = shadowRoot.caretRangeFromPoint(coords.clientX, coords.clientY);\n        }\n      } else {\n        range = ctx.viewDomNode.ownerDocument.caretRangeFromPoint(coords.clientX, coords.clientY);\n      }\n      if (!range || !range.startContainer) {\n        return new UnknownHitTestResult();\n      }\n      // Chrome always hits a TEXT_NODE, while Edge sometimes hits a token span\n      var startContainer = range.startContainer;\n      if (startContainer.nodeType === startContainer.TEXT_NODE) {\n        // startContainer is expected to be the token text\n        var parent1 = startContainer.parentNode; // expected to be the token span\n        var parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n        var parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n        var parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n        if (parent3ClassName === ViewLine.CLASS_NAME) {\n          return HitTestResult.createFromDOMInfo(ctx, parent1, range.startOffset);\n        } else {\n          return new UnknownHitTestResult(startContainer.parentNode);\n        }\n      } else if (startContainer.nodeType === startContainer.ELEMENT_NODE) {\n        // startContainer is expected to be the token span\n        var _parent = startContainer.parentNode; // expected to be the view line container span\n        var _parent2 = _parent ? _parent.parentNode : null; // expected to be the view line div\n        var parent2ClassName = _parent2 && _parent2.nodeType === _parent2.ELEMENT_NODE ? _parent2.className : null;\n        if (parent2ClassName === ViewLine.CLASS_NAME) {\n          return HitTestResult.createFromDOMInfo(ctx, startContainer, startContainer.textContent.length);\n        } else {\n          return new UnknownHitTestResult(startContainer);\n        }\n      }\n      return new UnknownHitTestResult();\n    }\n    /**\n     * Most probably Gecko\n     */\n  }, {\n    key: \"_doHitTestWithCaretPositionFromPoint\",\n    value: function _doHitTestWithCaretPositionFromPoint(ctx, coords) {\n      var hitResult = ctx.viewDomNode.ownerDocument.caretPositionFromPoint(coords.clientX, coords.clientY);\n      if (hitResult.offsetNode.nodeType === hitResult.offsetNode.TEXT_NODE) {\n        // offsetNode is expected to be the token text\n        var parent1 = hitResult.offsetNode.parentNode; // expected to be the token span\n        var parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n        var parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n        var parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n        if (parent3ClassName === ViewLine.CLASS_NAME) {\n          return HitTestResult.createFromDOMInfo(ctx, hitResult.offsetNode.parentNode, hitResult.offset);\n        } else {\n          return new UnknownHitTestResult(hitResult.offsetNode.parentNode);\n        }\n      }\n      // For inline decorations, Gecko sometimes returns the `<span>` of the line and the offset is the `<span>` with the inline decoration\n      // Some other times, it returns the `<span>` with the inline decoration\n      if (hitResult.offsetNode.nodeType === hitResult.offsetNode.ELEMENT_NODE) {\n        var _parent3 = hitResult.offsetNode.parentNode;\n        var parent1ClassName = _parent3 && _parent3.nodeType === _parent3.ELEMENT_NODE ? _parent3.className : null;\n        var _parent4 = _parent3 ? _parent3.parentNode : null;\n        var parent2ClassName = _parent4 && _parent4.nodeType === _parent4.ELEMENT_NODE ? _parent4.className : null;\n        if (parent1ClassName === ViewLine.CLASS_NAME) {\n          // it returned the `<span>` of the line and the offset is the `<span>` with the inline decoration\n          var tokenSpan = hitResult.offsetNode.childNodes[Math.min(hitResult.offset, hitResult.offsetNode.childNodes.length - 1)];\n          if (tokenSpan) {\n            return HitTestResult.createFromDOMInfo(ctx, tokenSpan, 0);\n          }\n        } else if (parent2ClassName === ViewLine.CLASS_NAME) {\n          // it returned the `<span>` with the inline decoration\n          return HitTestResult.createFromDOMInfo(ctx, hitResult.offsetNode, 0);\n        }\n      }\n      return new UnknownHitTestResult(hitResult.offsetNode);\n    }\n  }, {\n    key: \"_snapToSoftTabBoundary\",\n    value: function _snapToSoftTabBoundary(position, viewModel) {\n      var lineContent = viewModel.getLineContent(position.lineNumber);\n      var _viewModel$model$getO = viewModel.model.getOptions(),\n        tabSize = _viewModel$model$getO.tabSize;\n      var newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 2 /* Direction.Nearest */);\n      if (newPosition !== -1) {\n        return new Position(position.lineNumber, newPosition + 1);\n      }\n      return position;\n    }\n  }, {\n    key: \"doHitTest\",\n    value: function doHitTest(ctx, request) {\n      var result = new UnknownHitTestResult();\n      if (typeof ctx.viewDomNode.ownerDocument.caretRangeFromPoint === 'function') {\n        result = this._doHitTestWithCaretRangeFromPoint(ctx, request);\n      } else if (ctx.viewDomNode.ownerDocument.caretPositionFromPoint) {\n        result = this._doHitTestWithCaretPositionFromPoint(ctx, request.pos.toClientCoordinates(dom.getWindow(ctx.viewDomNode)));\n      }\n      if (result.type === 1 /* HitTestResultType.Content */) {\n        var injectedText = ctx.viewModel.getInjectedTextAt(result.position);\n        var normalizedPosition = ctx.viewModel.normalizePosition(result.position, 2 /* PositionAffinity.None */);\n        if (injectedText || !normalizedPosition.equals(result.position)) {\n          result = new ContentHitTestResult(normalizedPosition, result.spanNode, injectedText);\n        }\n      }\n      return result;\n    }\n  }]);\n}();\nfunction shadowCaretRangeFromPoint(shadowRoot, x, y) {\n  var range = document.createRange();\n  // Get the element under the point\n  var el = shadowRoot.elementFromPoint(x, y);\n  if (el !== null) {\n    // Get the last child of the element until its firstChild is a text node\n    // This assumes that the pointer is on the right of the line, out of the tokens\n    // and that we want to get the offset of the last token of the line\n    while (el && el.firstChild && el.firstChild.nodeType !== el.firstChild.TEXT_NODE && el.lastChild && el.lastChild.firstChild) {\n      el = el.lastChild;\n    }\n    // Grab its rect\n    var rect = el.getBoundingClientRect();\n    // And its font (the computed shorthand font property might be empty, see #3217)\n    var elWindow = dom.getWindow(el);\n    var fontStyle = elWindow.getComputedStyle(el, null).getPropertyValue('font-style');\n    var fontVariant = elWindow.getComputedStyle(el, null).getPropertyValue('font-variant');\n    var fontWeight = elWindow.getComputedStyle(el, null).getPropertyValue('font-weight');\n    var fontSize = elWindow.getComputedStyle(el, null).getPropertyValue('font-size');\n    var lineHeight = elWindow.getComputedStyle(el, null).getPropertyValue('line-height');\n    var fontFamily = elWindow.getComputedStyle(el, null).getPropertyValue('font-family');\n    var font = \"\".concat(fontStyle, \" \").concat(fontVariant, \" \").concat(fontWeight, \" \").concat(fontSize, \"/\").concat(lineHeight, \" \").concat(fontFamily);\n    // And also its txt content\n    var text = el.innerText;\n    // Position the pixel cursor at the left of the element\n    var pixelCursor = rect.left;\n    var offset = 0;\n    var step;\n    // If the point is on the right of the box put the cursor after the last character\n    if (x > rect.left + rect.width) {\n      offset = text.length;\n    } else {\n      var charWidthReader = CharWidthReader.getInstance();\n      // Goes through all the characters of the innerText, and checks if the x of the point\n      // belongs to the character.\n      for (var i = 0; i < text.length + 1; i++) {\n        // The step is half the width of the character\n        step = charWidthReader.getCharWidth(text.charAt(i), font) / 2;\n        // Move to the center of the character\n        pixelCursor += step;\n        // If the x of the point is smaller that the position of the cursor, the point is over that character\n        if (x < pixelCursor) {\n          offset = i;\n          break;\n        }\n        // Move between the current character and the next\n        pixelCursor += step;\n      }\n    }\n    // Creates a range with the text node of the element and set the offset found\n    range.setStart(el.firstChild, offset);\n    range.setEnd(el.firstChild, offset);\n  }\n  return range;\n}\nvar CharWidthReader = /*#__PURE__*/function () {\n  function CharWidthReader() {\n    _classCallCheck(this, CharWidthReader);\n    this._cache = {};\n    this._canvas = document.createElement('canvas');\n  }\n  return _createClass(CharWidthReader, [{\n    key: \"getCharWidth\",\n    value: function getCharWidth(_char, font) {\n      var cacheKey = _char + font;\n      if (this._cache[cacheKey]) {\n        return this._cache[cacheKey];\n      }\n      var context = this._canvas.getContext('2d');\n      context.font = font;\n      var metrics = context.measureText(_char);\n      var width = metrics.width;\n      this._cache[cacheKey] = width;\n      return width;\n    }\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      if (!CharWidthReader._INSTANCE) {\n        CharWidthReader._INSTANCE = new CharWidthReader();\n      }\n      return CharWidthReader._INSTANCE;\n    }\n  }]);\n}();\nCharWidthReader._INSTANCE = null;","map":{"version":3,"names":["PageCoordinates","PartFingerprints","ViewLine","Position","Range","EditorRange","CursorColumns","dom","AtomicTabMoveOperations","Lazy","UnknownHitTestResult","_createClass","hitTarget","arguments","length","undefined","_classCallCheck","type","ContentHitTestResult","position","spanNode","injectedText","key","get","HitTestResult","createFromDOMInfo","ctx","offset","getPositionFromDOMInfo","PointerHandlerLastRenderData","lastViewCursorsRenderData","lastTextareaPosition","MouseTarget","value","_deduceRage","range","lineNumber","column","createUnknown","element","mouseColumn","createTextarea","createMargin","detail","createViewZone","createContentText","createContentEmpty","createContentWidget","createScrollbar","createOverlayWidget","createOutsideEditor","outsidePosition","outsideDistance","_typeToString","toString","target","JSON","stringify","ElementPath","isTextArea","path","isChildOfViewLines","isStrictChildOfViewLines","isChildOfScrollableElement","isChildOfMinimap","isChildOfContentWidgets","isChildOfOverflowGuard","isChildOfOverflowingContentWidgets","isChildOfOverlayWidgets","isChildOfOverflowingOverlayWidgets","HitTestContext","context","viewHelper","lastRenderData","viewModel","options","configuration","layoutInfo","viewDomNode","lineHeight","stickyTabStops","typicalHalfwidthCharacterWidth","_context","_viewHelper","getZoneAtCoord","mouseVerticalOffset","getFullLineRangeAtCoord","viewLayout","isAfterLines","getLineCount","maxLineColumn","getLineMaxColumn","getLineNumberAtVerticalOffset","isInTopPadding","isInBottomPadding","getVerticalOffsetForLineNumber","findAttribute","attr","_findAttribute","getLineWidth","visibleRangeForPosition","getCurrentScrollTop","getCurrentScrollLeft","viewZoneWhitespace","getWhitespaceAtVerticalOffset","viewZoneMiddle","verticalOffset","height","lineCount","positionBefore","positionAfter","afterLineNumber","viewZoneId","id","stopAt","ownerDocument","body","hasAttribute","getAttribute","parentNode","BareHitTestRequest","editorPos","pos","relativePos","Math","max","y","mouseContentHorizontalOffset","x","contentLeft","isInMarginArea","glyphMarginLeft","isInContentArea","MouseTargetFactory","_getMouseColumn","HitTestRequest","_BareHitTestRequest","eventTarget","_this","_callSuper","hitTestResult","doHitTest","_ctx","_targetPathCacheElement","_targetPathCacheValue","Uint8Array","_eventTarget","hasEventTarget","Boolean","_useHitTestTarget","_inherits","collect","concat","outerHTML","switchToHitTestTarget","visibleColumnFromColumn","getLineContent","model","getOptions","tabSize","fulfillUnknown","fulfillTextarea","fulfillMargin","fulfillViewZone","fulfillContentText","fulfillContentEmpty","fulfillContentWidget","fulfillScrollbar","fulfillOverlayWidget","EMPTY_CONTENT_AFTER_LINES","createEmptyContentDataInLines","horizontalDistanceToText","mouseTargetIsWidget","e","t","createMouseTarget","request","r","_createMouseTarget","_snapToSoftTabBoundary","fromPositions","plusRange","err","getMouseColumn","resolvedRequest","result","targetPath","_hitTestContentWidget","_hitTestOverlayWidget","_hitTestMinimap","_hitTestScrollbarSlider","_hitTestViewZone","_hitTestMargin","_hitTestViewCursor","_hitTestTextArea","_hitTestViewLines","_hitTestScrollbar","widgetId","_iterator","_createForOfIteratorHelper","_step","s","n","done","d","domNode","mightBeForeignElement","f","_iterator2","_step2","width","cursorVerticalOffset","viewZoneData","mouseTargetType","res","getStartPosition","abs","glyphMarginWidth","lineNumbersWidth","offsetX","modelCoordinate","coordinatesConverter","convertViewPositionToModelPosition","lanes","glyphLanes","getLanesAtLine","glyphMarginLane","floor","getLineLength","lineWidth","createMouseTargetFromHitTestPosition","wouldBenefitFromHitTestTargetSwitch","possibleLineNumber","maxColumn","nodeType","className","test","chars","round","visibleRange","columnHorizontalOffset","left","points","push","lineMaxColumn","sort","a","b","mouseCoordinates","toClientCoordinates","getWindow","spanNodeClientRect","getBoundingClientRect","mouseIsOverSpanNode","clientX","right","rng","i","prev","curr","prevDelta","nextDelta","_doHitTestWithCaretRangeFromPoint","lineStartVerticalOffset","lineEndVerticalOffset","isBelowLastLine","lineCenteredVerticalOffset","adjustedPageY","adjustedPage","_actualDoHitTestWithCaretRangeFromPoint","coords","shadowRoot","getShadowRoot","caretRangeFromPoint","shadowCaretRangeFromPoint","clientY","startContainer","TEXT_NODE","parent1","parent2","parent3","parent3ClassName","ELEMENT_NODE","CLASS_NAME","startOffset","parent2ClassName","textContent","_doHitTestWithCaretPositionFromPoint","hitResult","caretPositionFromPoint","offsetNode","parent1ClassName","tokenSpan","childNodes","min","lineContent","_viewModel$model$getO","newPosition","atomicPosition","getInjectedTextAt","normalizedPosition","normalizePosition","equals","document","createRange","el","elementFromPoint","firstChild","lastChild","rect","elWindow","fontStyle","getComputedStyle","getPropertyValue","fontVariant","fontWeight","fontSize","fontFamily","font","text","innerText","pixelCursor","step","charWidthReader","CharWidthReader","getInstance","getCharWidth","charAt","setStart","setEnd","_cache","_canvas","createElement","char","cacheKey","getContext","metrics","measureText","_INSTANCE"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/browser/controller/mouseTarget.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { PageCoordinates } from '../editorDom.js';\nimport { PartFingerprints } from '../view/viewPart.js';\nimport { ViewLine } from '../viewParts/lines/viewLine.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range as EditorRange } from '../../common/core/range.js';\nimport { CursorColumns } from '../../common/core/cursorColumns.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { AtomicTabMoveOperations } from '../../common/cursor/cursorAtomicMoveOperations.js';\nimport { Lazy } from '../../../base/common/lazy.js';\nclass UnknownHitTestResult {\n    constructor(hitTarget = null) {\n        this.hitTarget = hitTarget;\n        this.type = 0 /* HitTestResultType.Unknown */;\n    }\n}\nclass ContentHitTestResult {\n    get hitTarget() { return this.spanNode; }\n    constructor(position, spanNode, injectedText) {\n        this.position = position;\n        this.spanNode = spanNode;\n        this.injectedText = injectedText;\n        this.type = 1 /* HitTestResultType.Content */;\n    }\n}\nvar HitTestResult;\n(function (HitTestResult) {\n    function createFromDOMInfo(ctx, spanNode, offset) {\n        const position = ctx.getPositionFromDOMInfo(spanNode, offset);\n        if (position) {\n            return new ContentHitTestResult(position, spanNode, null);\n        }\n        return new UnknownHitTestResult(spanNode);\n    }\n    HitTestResult.createFromDOMInfo = createFromDOMInfo;\n})(HitTestResult || (HitTestResult = {}));\nexport class PointerHandlerLastRenderData {\n    constructor(lastViewCursorsRenderData, lastTextareaPosition) {\n        this.lastViewCursorsRenderData = lastViewCursorsRenderData;\n        this.lastTextareaPosition = lastTextareaPosition;\n    }\n}\nexport class MouseTarget {\n    static _deduceRage(position, range = null) {\n        if (!range && position) {\n            return new EditorRange(position.lineNumber, position.column, position.lineNumber, position.column);\n        }\n        return range !== null && range !== void 0 ? range : null;\n    }\n    static createUnknown(element, mouseColumn, position) {\n        return { type: 0 /* MouseTargetType.UNKNOWN */, element, mouseColumn, position, range: this._deduceRage(position) };\n    }\n    static createTextarea(element, mouseColumn) {\n        return { type: 1 /* MouseTargetType.TEXTAREA */, element, mouseColumn, position: null, range: null };\n    }\n    static createMargin(type, element, mouseColumn, position, range, detail) {\n        return { type, element, mouseColumn, position, range, detail };\n    }\n    static createViewZone(type, element, mouseColumn, position, detail) {\n        return { type, element, mouseColumn, position, range: this._deduceRage(position), detail };\n    }\n    static createContentText(element, mouseColumn, position, range, detail) {\n        return { type: 6 /* MouseTargetType.CONTENT_TEXT */, element, mouseColumn, position, range: this._deduceRage(position, range), detail };\n    }\n    static createContentEmpty(element, mouseColumn, position, detail) {\n        return { type: 7 /* MouseTargetType.CONTENT_EMPTY */, element, mouseColumn, position, range: this._deduceRage(position), detail };\n    }\n    static createContentWidget(element, mouseColumn, detail) {\n        return { type: 9 /* MouseTargetType.CONTENT_WIDGET */, element, mouseColumn, position: null, range: null, detail };\n    }\n    static createScrollbar(element, mouseColumn, position) {\n        return { type: 11 /* MouseTargetType.SCROLLBAR */, element, mouseColumn, position, range: this._deduceRage(position) };\n    }\n    static createOverlayWidget(element, mouseColumn, detail) {\n        return { type: 12 /* MouseTargetType.OVERLAY_WIDGET */, element, mouseColumn, position: null, range: null, detail };\n    }\n    static createOutsideEditor(mouseColumn, position, outsidePosition, outsideDistance) {\n        return { type: 13 /* MouseTargetType.OUTSIDE_EDITOR */, element: null, mouseColumn, position, range: this._deduceRage(position), outsidePosition, outsideDistance };\n    }\n    static _typeToString(type) {\n        if (type === 1 /* MouseTargetType.TEXTAREA */) {\n            return 'TEXTAREA';\n        }\n        if (type === 2 /* MouseTargetType.GUTTER_GLYPH_MARGIN */) {\n            return 'GUTTER_GLYPH_MARGIN';\n        }\n        if (type === 3 /* MouseTargetType.GUTTER_LINE_NUMBERS */) {\n            return 'GUTTER_LINE_NUMBERS';\n        }\n        if (type === 4 /* MouseTargetType.GUTTER_LINE_DECORATIONS */) {\n            return 'GUTTER_LINE_DECORATIONS';\n        }\n        if (type === 5 /* MouseTargetType.GUTTER_VIEW_ZONE */) {\n            return 'GUTTER_VIEW_ZONE';\n        }\n        if (type === 6 /* MouseTargetType.CONTENT_TEXT */) {\n            return 'CONTENT_TEXT';\n        }\n        if (type === 7 /* MouseTargetType.CONTENT_EMPTY */) {\n            return 'CONTENT_EMPTY';\n        }\n        if (type === 8 /* MouseTargetType.CONTENT_VIEW_ZONE */) {\n            return 'CONTENT_VIEW_ZONE';\n        }\n        if (type === 9 /* MouseTargetType.CONTENT_WIDGET */) {\n            return 'CONTENT_WIDGET';\n        }\n        if (type === 10 /* MouseTargetType.OVERVIEW_RULER */) {\n            return 'OVERVIEW_RULER';\n        }\n        if (type === 11 /* MouseTargetType.SCROLLBAR */) {\n            return 'SCROLLBAR';\n        }\n        if (type === 12 /* MouseTargetType.OVERLAY_WIDGET */) {\n            return 'OVERLAY_WIDGET';\n        }\n        return 'UNKNOWN';\n    }\n    static toString(target) {\n        return this._typeToString(target.type) + ': ' + target.position + ' - ' + target.range + ' - ' + JSON.stringify(target.detail);\n    }\n}\nclass ElementPath {\n    static isTextArea(path) {\n        return (path.length === 2\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[1] === 7 /* PartFingerprint.TextArea */);\n    }\n    static isChildOfViewLines(path) {\n        return (path.length >= 4\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[3] === 8 /* PartFingerprint.ViewLines */);\n    }\n    static isStrictChildOfViewLines(path) {\n        return (path.length > 4\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[3] === 8 /* PartFingerprint.ViewLines */);\n    }\n    static isChildOfScrollableElement(path) {\n        return (path.length >= 2\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[1] === 6 /* PartFingerprint.ScrollableElement */);\n    }\n    static isChildOfMinimap(path) {\n        return (path.length >= 2\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[1] === 9 /* PartFingerprint.Minimap */);\n    }\n    static isChildOfContentWidgets(path) {\n        return (path.length >= 4\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[3] === 1 /* PartFingerprint.ContentWidgets */);\n    }\n    static isChildOfOverflowGuard(path) {\n        return (path.length >= 1\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */);\n    }\n    static isChildOfOverflowingContentWidgets(path) {\n        return (path.length >= 1\n            && path[0] === 2 /* PartFingerprint.OverflowingContentWidgets */);\n    }\n    static isChildOfOverlayWidgets(path) {\n        return (path.length >= 2\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[1] === 4 /* PartFingerprint.OverlayWidgets */);\n    }\n    static isChildOfOverflowingOverlayWidgets(path) {\n        return (path.length >= 1\n            && path[0] === 5 /* PartFingerprint.OverflowingOverlayWidgets */);\n    }\n}\nexport class HitTestContext {\n    constructor(context, viewHelper, lastRenderData) {\n        this.viewModel = context.viewModel;\n        const options = context.configuration.options;\n        this.layoutInfo = options.get(145 /* EditorOption.layoutInfo */);\n        this.viewDomNode = viewHelper.viewDomNode;\n        this.lineHeight = options.get(67 /* EditorOption.lineHeight */);\n        this.stickyTabStops = options.get(116 /* EditorOption.stickyTabStops */);\n        this.typicalHalfwidthCharacterWidth = options.get(50 /* EditorOption.fontInfo */).typicalHalfwidthCharacterWidth;\n        this.lastRenderData = lastRenderData;\n        this._context = context;\n        this._viewHelper = viewHelper;\n    }\n    getZoneAtCoord(mouseVerticalOffset) {\n        return HitTestContext.getZoneAtCoord(this._context, mouseVerticalOffset);\n    }\n    static getZoneAtCoord(context, mouseVerticalOffset) {\n        // The target is either a view zone or the empty space after the last view-line\n        const viewZoneWhitespace = context.viewLayout.getWhitespaceAtVerticalOffset(mouseVerticalOffset);\n        if (viewZoneWhitespace) {\n            const viewZoneMiddle = viewZoneWhitespace.verticalOffset + viewZoneWhitespace.height / 2;\n            const lineCount = context.viewModel.getLineCount();\n            let positionBefore = null;\n            let position;\n            let positionAfter = null;\n            if (viewZoneWhitespace.afterLineNumber !== lineCount) {\n                // There are more lines after this view zone\n                positionAfter = new Position(viewZoneWhitespace.afterLineNumber + 1, 1);\n            }\n            if (viewZoneWhitespace.afterLineNumber > 0) {\n                // There are more lines above this view zone\n                positionBefore = new Position(viewZoneWhitespace.afterLineNumber, context.viewModel.getLineMaxColumn(viewZoneWhitespace.afterLineNumber));\n            }\n            if (positionAfter === null) {\n                position = positionBefore;\n            }\n            else if (positionBefore === null) {\n                position = positionAfter;\n            }\n            else if (mouseVerticalOffset < viewZoneMiddle) {\n                position = positionBefore;\n            }\n            else {\n                position = positionAfter;\n            }\n            return {\n                viewZoneId: viewZoneWhitespace.id,\n                afterLineNumber: viewZoneWhitespace.afterLineNumber,\n                positionBefore: positionBefore,\n                positionAfter: positionAfter,\n                position: position\n            };\n        }\n        return null;\n    }\n    getFullLineRangeAtCoord(mouseVerticalOffset) {\n        if (this._context.viewLayout.isAfterLines(mouseVerticalOffset)) {\n            // Below the last line\n            const lineNumber = this._context.viewModel.getLineCount();\n            const maxLineColumn = this._context.viewModel.getLineMaxColumn(lineNumber);\n            return {\n                range: new EditorRange(lineNumber, maxLineColumn, lineNumber, maxLineColumn),\n                isAfterLines: true\n            };\n        }\n        const lineNumber = this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n        const maxLineColumn = this._context.viewModel.getLineMaxColumn(lineNumber);\n        return {\n            range: new EditorRange(lineNumber, 1, lineNumber, maxLineColumn),\n            isAfterLines: false\n        };\n    }\n    getLineNumberAtVerticalOffset(mouseVerticalOffset) {\n        return this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n    }\n    isAfterLines(mouseVerticalOffset) {\n        return this._context.viewLayout.isAfterLines(mouseVerticalOffset);\n    }\n    isInTopPadding(mouseVerticalOffset) {\n        return this._context.viewLayout.isInTopPadding(mouseVerticalOffset);\n    }\n    isInBottomPadding(mouseVerticalOffset) {\n        return this._context.viewLayout.isInBottomPadding(mouseVerticalOffset);\n    }\n    getVerticalOffsetForLineNumber(lineNumber) {\n        return this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber);\n    }\n    findAttribute(element, attr) {\n        return HitTestContext._findAttribute(element, attr, this._viewHelper.viewDomNode);\n    }\n    static _findAttribute(element, attr, stopAt) {\n        while (element && element !== element.ownerDocument.body) {\n            if (element.hasAttribute && element.hasAttribute(attr)) {\n                return element.getAttribute(attr);\n            }\n            if (element === stopAt) {\n                return null;\n            }\n            element = element.parentNode;\n        }\n        return null;\n    }\n    getLineWidth(lineNumber) {\n        return this._viewHelper.getLineWidth(lineNumber);\n    }\n    visibleRangeForPosition(lineNumber, column) {\n        return this._viewHelper.visibleRangeForPosition(lineNumber, column);\n    }\n    getPositionFromDOMInfo(spanNode, offset) {\n        return this._viewHelper.getPositionFromDOMInfo(spanNode, offset);\n    }\n    getCurrentScrollTop() {\n        return this._context.viewLayout.getCurrentScrollTop();\n    }\n    getCurrentScrollLeft() {\n        return this._context.viewLayout.getCurrentScrollLeft();\n    }\n}\nclass BareHitTestRequest {\n    constructor(ctx, editorPos, pos, relativePos) {\n        this.editorPos = editorPos;\n        this.pos = pos;\n        this.relativePos = relativePos;\n        this.mouseVerticalOffset = Math.max(0, ctx.getCurrentScrollTop() + this.relativePos.y);\n        this.mouseContentHorizontalOffset = ctx.getCurrentScrollLeft() + this.relativePos.x - ctx.layoutInfo.contentLeft;\n        this.isInMarginArea = (this.relativePos.x < ctx.layoutInfo.contentLeft && this.relativePos.x >= ctx.layoutInfo.glyphMarginLeft);\n        this.isInContentArea = !this.isInMarginArea;\n        this.mouseColumn = Math.max(0, MouseTargetFactory._getMouseColumn(this.mouseContentHorizontalOffset, ctx.typicalHalfwidthCharacterWidth));\n    }\n}\nclass HitTestRequest extends BareHitTestRequest {\n    get target() {\n        if (this._useHitTestTarget) {\n            return this.hitTestResult.value.hitTarget;\n        }\n        return this._eventTarget;\n    }\n    get targetPath() {\n        if (this._targetPathCacheElement !== this.target) {\n            this._targetPathCacheElement = this.target;\n            this._targetPathCacheValue = PartFingerprints.collect(this.target, this._ctx.viewDomNode);\n        }\n        return this._targetPathCacheValue;\n    }\n    constructor(ctx, editorPos, pos, relativePos, eventTarget) {\n        super(ctx, editorPos, pos, relativePos);\n        this.hitTestResult = new Lazy(() => MouseTargetFactory.doHitTest(this._ctx, this));\n        this._targetPathCacheElement = null;\n        this._targetPathCacheValue = new Uint8Array(0);\n        this._ctx = ctx;\n        this._eventTarget = eventTarget;\n        // If no event target is passed in, we will use the hit test target\n        const hasEventTarget = Boolean(this._eventTarget);\n        this._useHitTestTarget = !hasEventTarget;\n    }\n    toString() {\n        return `pos(${this.pos.x},${this.pos.y}), editorPos(${this.editorPos.x},${this.editorPos.y}), relativePos(${this.relativePos.x},${this.relativePos.y}), mouseVerticalOffset: ${this.mouseVerticalOffset}, mouseContentHorizontalOffset: ${this.mouseContentHorizontalOffset}\\n\\ttarget: ${this.target ? this.target.outerHTML : null}`;\n    }\n    get wouldBenefitFromHitTestTargetSwitch() {\n        return (!this._useHitTestTarget\n            && this.hitTestResult.value.hitTarget !== null\n            && this.target !== this.hitTestResult.value.hitTarget);\n    }\n    switchToHitTestTarget() {\n        this._useHitTestTarget = true;\n    }\n    _getMouseColumn(position = null) {\n        if (position && position.column < this._ctx.viewModel.getLineMaxColumn(position.lineNumber)) {\n            // Most likely, the line contains foreign decorations...\n            return CursorColumns.visibleColumnFromColumn(this._ctx.viewModel.getLineContent(position.lineNumber), position.column, this._ctx.viewModel.model.getOptions().tabSize) + 1;\n        }\n        return this.mouseColumn;\n    }\n    fulfillUnknown(position = null) {\n        return MouseTarget.createUnknown(this.target, this._getMouseColumn(position), position);\n    }\n    fulfillTextarea() {\n        return MouseTarget.createTextarea(this.target, this._getMouseColumn());\n    }\n    fulfillMargin(type, position, range, detail) {\n        return MouseTarget.createMargin(type, this.target, this._getMouseColumn(position), position, range, detail);\n    }\n    fulfillViewZone(type, position, detail) {\n        return MouseTarget.createViewZone(type, this.target, this._getMouseColumn(position), position, detail);\n    }\n    fulfillContentText(position, range, detail) {\n        return MouseTarget.createContentText(this.target, this._getMouseColumn(position), position, range, detail);\n    }\n    fulfillContentEmpty(position, detail) {\n        return MouseTarget.createContentEmpty(this.target, this._getMouseColumn(position), position, detail);\n    }\n    fulfillContentWidget(detail) {\n        return MouseTarget.createContentWidget(this.target, this._getMouseColumn(), detail);\n    }\n    fulfillScrollbar(position) {\n        return MouseTarget.createScrollbar(this.target, this._getMouseColumn(position), position);\n    }\n    fulfillOverlayWidget(detail) {\n        return MouseTarget.createOverlayWidget(this.target, this._getMouseColumn(), detail);\n    }\n}\nconst EMPTY_CONTENT_AFTER_LINES = { isAfterLines: true };\nfunction createEmptyContentDataInLines(horizontalDistanceToText) {\n    return {\n        isAfterLines: false,\n        horizontalDistanceToText: horizontalDistanceToText\n    };\n}\nexport class MouseTargetFactory {\n    constructor(context, viewHelper) {\n        this._context = context;\n        this._viewHelper = viewHelper;\n    }\n    mouseTargetIsWidget(e) {\n        const t = e.target;\n        const path = PartFingerprints.collect(t, this._viewHelper.viewDomNode);\n        // Is it a content widget?\n        if (ElementPath.isChildOfContentWidgets(path) || ElementPath.isChildOfOverflowingContentWidgets(path)) {\n            return true;\n        }\n        // Is it an overlay widget?\n        if (ElementPath.isChildOfOverlayWidgets(path) || ElementPath.isChildOfOverflowingOverlayWidgets(path)) {\n            return true;\n        }\n        return false;\n    }\n    createMouseTarget(lastRenderData, editorPos, pos, relativePos, target) {\n        const ctx = new HitTestContext(this._context, this._viewHelper, lastRenderData);\n        const request = new HitTestRequest(ctx, editorPos, pos, relativePos, target);\n        try {\n            const r = MouseTargetFactory._createMouseTarget(ctx, request);\n            if (r.type === 6 /* MouseTargetType.CONTENT_TEXT */) {\n                // Snap to the nearest soft tab boundary if atomic soft tabs are enabled.\n                if (ctx.stickyTabStops && r.position !== null) {\n                    const position = MouseTargetFactory._snapToSoftTabBoundary(r.position, ctx.viewModel);\n                    const range = EditorRange.fromPositions(position, position).plusRange(r.range);\n                    return request.fulfillContentText(position, range, r.detail);\n                }\n            }\n            // console.log(MouseTarget.toString(r));\n            return r;\n        }\n        catch (err) {\n            // console.log(err);\n            return request.fulfillUnknown();\n        }\n    }\n    static _createMouseTarget(ctx, request) {\n        // console.log(`${domHitTestExecuted ? '=>' : ''}CAME IN REQUEST: ${request}`);\n        if (request.target === null) {\n            // No target\n            return request.fulfillUnknown();\n        }\n        // we know for a fact that request.target is not null\n        const resolvedRequest = request;\n        let result = null;\n        if (!ElementPath.isChildOfOverflowGuard(request.targetPath) && !ElementPath.isChildOfOverflowingContentWidgets(request.targetPath) && !ElementPath.isChildOfOverflowingOverlayWidgets(request.targetPath)) {\n            // We only render dom nodes inside the overflow guard or in the overflowing content widgets\n            result = result || request.fulfillUnknown();\n        }\n        result = result || MouseTargetFactory._hitTestContentWidget(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestOverlayWidget(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestMinimap(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestScrollbarSlider(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestViewZone(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestMargin(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestViewCursor(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestTextArea(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestViewLines(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestScrollbar(ctx, resolvedRequest);\n        return (result || request.fulfillUnknown());\n    }\n    static _hitTestContentWidget(ctx, request) {\n        // Is it a content widget?\n        if (ElementPath.isChildOfContentWidgets(request.targetPath) || ElementPath.isChildOfOverflowingContentWidgets(request.targetPath)) {\n            const widgetId = ctx.findAttribute(request.target, 'widgetId');\n            if (widgetId) {\n                return request.fulfillContentWidget(widgetId);\n            }\n            else {\n                return request.fulfillUnknown();\n            }\n        }\n        return null;\n    }\n    static _hitTestOverlayWidget(ctx, request) {\n        // Is it an overlay widget?\n        if (ElementPath.isChildOfOverlayWidgets(request.targetPath) || ElementPath.isChildOfOverflowingOverlayWidgets(request.targetPath)) {\n            const widgetId = ctx.findAttribute(request.target, 'widgetId');\n            if (widgetId) {\n                return request.fulfillOverlayWidget(widgetId);\n            }\n            else {\n                return request.fulfillUnknown();\n            }\n        }\n        return null;\n    }\n    static _hitTestViewCursor(ctx, request) {\n        if (request.target) {\n            // Check if we've hit a painted cursor\n            const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n            for (const d of lastViewCursorsRenderData) {\n                if (request.target === d.domNode) {\n                    return request.fulfillContentText(d.position, null, { mightBeForeignElement: false, injectedText: null });\n                }\n            }\n        }\n        if (request.isInContentArea) {\n            // Edge has a bug when hit-testing the exact position of a cursor,\n            // instead of returning the correct dom node, it returns the\n            // first or last rendered view line dom node, therefore help it out\n            // and first check if we are on top of a cursor\n            const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n            const mouseContentHorizontalOffset = request.mouseContentHorizontalOffset;\n            const mouseVerticalOffset = request.mouseVerticalOffset;\n            for (const d of lastViewCursorsRenderData) {\n                if (mouseContentHorizontalOffset < d.contentLeft) {\n                    // mouse position is to the left of the cursor\n                    continue;\n                }\n                if (mouseContentHorizontalOffset > d.contentLeft + d.width) {\n                    // mouse position is to the right of the cursor\n                    continue;\n                }\n                const cursorVerticalOffset = ctx.getVerticalOffsetForLineNumber(d.position.lineNumber);\n                if (cursorVerticalOffset <= mouseVerticalOffset\n                    && mouseVerticalOffset <= cursorVerticalOffset + d.height) {\n                    return request.fulfillContentText(d.position, null, { mightBeForeignElement: false, injectedText: null });\n                }\n            }\n        }\n        return null;\n    }\n    static _hitTestViewZone(ctx, request) {\n        const viewZoneData = ctx.getZoneAtCoord(request.mouseVerticalOffset);\n        if (viewZoneData) {\n            const mouseTargetType = (request.isInContentArea ? 8 /* MouseTargetType.CONTENT_VIEW_ZONE */ : 5 /* MouseTargetType.GUTTER_VIEW_ZONE */);\n            return request.fulfillViewZone(mouseTargetType, viewZoneData.position, viewZoneData);\n        }\n        return null;\n    }\n    static _hitTestTextArea(ctx, request) {\n        // Is it the textarea?\n        if (ElementPath.isTextArea(request.targetPath)) {\n            if (ctx.lastRenderData.lastTextareaPosition) {\n                return request.fulfillContentText(ctx.lastRenderData.lastTextareaPosition, null, { mightBeForeignElement: false, injectedText: null });\n            }\n            return request.fulfillTextarea();\n        }\n        return null;\n    }\n    static _hitTestMargin(ctx, request) {\n        if (request.isInMarginArea) {\n            const res = ctx.getFullLineRangeAtCoord(request.mouseVerticalOffset);\n            const pos = res.range.getStartPosition();\n            let offset = Math.abs(request.relativePos.x);\n            const detail = {\n                isAfterLines: res.isAfterLines,\n                glyphMarginLeft: ctx.layoutInfo.glyphMarginLeft,\n                glyphMarginWidth: ctx.layoutInfo.glyphMarginWidth,\n                lineNumbersWidth: ctx.layoutInfo.lineNumbersWidth,\n                offsetX: offset\n            };\n            offset -= ctx.layoutInfo.glyphMarginLeft;\n            if (offset <= ctx.layoutInfo.glyphMarginWidth) {\n                // On the glyph margin\n                const modelCoordinate = ctx.viewModel.coordinatesConverter.convertViewPositionToModelPosition(res.range.getStartPosition());\n                const lanes = ctx.viewModel.glyphLanes.getLanesAtLine(modelCoordinate.lineNumber);\n                detail.glyphMarginLane = lanes[Math.floor(offset / ctx.lineHeight)];\n                return request.fulfillMargin(2 /* MouseTargetType.GUTTER_GLYPH_MARGIN */, pos, res.range, detail);\n            }\n            offset -= ctx.layoutInfo.glyphMarginWidth;\n            if (offset <= ctx.layoutInfo.lineNumbersWidth) {\n                // On the line numbers\n                return request.fulfillMargin(3 /* MouseTargetType.GUTTER_LINE_NUMBERS */, pos, res.range, detail);\n            }\n            offset -= ctx.layoutInfo.lineNumbersWidth;\n            // On the line decorations\n            return request.fulfillMargin(4 /* MouseTargetType.GUTTER_LINE_DECORATIONS */, pos, res.range, detail);\n        }\n        return null;\n    }\n    static _hitTestViewLines(ctx, request) {\n        if (!ElementPath.isChildOfViewLines(request.targetPath)) {\n            return null;\n        }\n        if (ctx.isInTopPadding(request.mouseVerticalOffset)) {\n            return request.fulfillContentEmpty(new Position(1, 1), EMPTY_CONTENT_AFTER_LINES);\n        }\n        // Check if it is below any lines and any view zones\n        if (ctx.isAfterLines(request.mouseVerticalOffset) || ctx.isInBottomPadding(request.mouseVerticalOffset)) {\n            // This most likely indicates it happened after the last view-line\n            const lineCount = ctx.viewModel.getLineCount();\n            const maxLineColumn = ctx.viewModel.getLineMaxColumn(lineCount);\n            return request.fulfillContentEmpty(new Position(lineCount, maxLineColumn), EMPTY_CONTENT_AFTER_LINES);\n        }\n        // Check if we are hitting a view-line (can happen in the case of inline decorations on empty lines)\n        // See https://github.com/microsoft/vscode/issues/46942\n        if (ElementPath.isStrictChildOfViewLines(request.targetPath)) {\n            const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n            if (ctx.viewModel.getLineLength(lineNumber) === 0) {\n                const lineWidth = ctx.getLineWidth(lineNumber);\n                const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n                return request.fulfillContentEmpty(new Position(lineNumber, 1), detail);\n            }\n            const lineWidth = ctx.getLineWidth(lineNumber);\n            if (request.mouseContentHorizontalOffset >= lineWidth) {\n                // TODO: This is wrong for RTL\n                const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n                const pos = new Position(lineNumber, ctx.viewModel.getLineMaxColumn(lineNumber));\n                return request.fulfillContentEmpty(pos, detail);\n            }\n        }\n        // Do the hit test (if not already done)\n        const hitTestResult = request.hitTestResult.value;\n        if (hitTestResult.type === 1 /* HitTestResultType.Content */) {\n            return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.spanNode, hitTestResult.position, hitTestResult.injectedText);\n        }\n        // We didn't hit content...\n        if (request.wouldBenefitFromHitTestTargetSwitch) {\n            // We actually hit something different... Give it one last change by trying again with this new target\n            request.switchToHitTestTarget();\n            return this._createMouseTarget(ctx, request);\n        }\n        // We have tried everything...\n        return request.fulfillUnknown();\n    }\n    static _hitTestMinimap(ctx, request) {\n        if (ElementPath.isChildOfMinimap(request.targetPath)) {\n            const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n            const maxColumn = ctx.viewModel.getLineMaxColumn(possibleLineNumber);\n            return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n        }\n        return null;\n    }\n    static _hitTestScrollbarSlider(ctx, request) {\n        if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n            if (request.target && request.target.nodeType === 1) {\n                const className = request.target.className;\n                if (className && /\\b(slider|scrollbar)\\b/.test(className)) {\n                    const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n                    const maxColumn = ctx.viewModel.getLineMaxColumn(possibleLineNumber);\n                    return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n                }\n            }\n        }\n        return null;\n    }\n    static _hitTestScrollbar(ctx, request) {\n        // Is it the overview ruler?\n        // Is it a child of the scrollable element?\n        if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n            const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n            const maxColumn = ctx.viewModel.getLineMaxColumn(possibleLineNumber);\n            return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n        }\n        return null;\n    }\n    getMouseColumn(relativePos) {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(145 /* EditorOption.layoutInfo */);\n        const mouseContentHorizontalOffset = this._context.viewLayout.getCurrentScrollLeft() + relativePos.x - layoutInfo.contentLeft;\n        return MouseTargetFactory._getMouseColumn(mouseContentHorizontalOffset, options.get(50 /* EditorOption.fontInfo */).typicalHalfwidthCharacterWidth);\n    }\n    static _getMouseColumn(mouseContentHorizontalOffset, typicalHalfwidthCharacterWidth) {\n        if (mouseContentHorizontalOffset < 0) {\n            return 1;\n        }\n        const chars = Math.round(mouseContentHorizontalOffset / typicalHalfwidthCharacterWidth);\n        return (chars + 1);\n    }\n    static createMouseTargetFromHitTestPosition(ctx, request, spanNode, pos, injectedText) {\n        const lineNumber = pos.lineNumber;\n        const column = pos.column;\n        const lineWidth = ctx.getLineWidth(lineNumber);\n        if (request.mouseContentHorizontalOffset > lineWidth) {\n            const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n            return request.fulfillContentEmpty(pos, detail);\n        }\n        const visibleRange = ctx.visibleRangeForPosition(lineNumber, column);\n        if (!visibleRange) {\n            return request.fulfillUnknown(pos);\n        }\n        const columnHorizontalOffset = visibleRange.left;\n        if (Math.abs(request.mouseContentHorizontalOffset - columnHorizontalOffset) < 1) {\n            return request.fulfillContentText(pos, null, { mightBeForeignElement: !!injectedText, injectedText });\n        }\n        const points = [];\n        points.push({ offset: visibleRange.left, column: column });\n        if (column > 1) {\n            const visibleRange = ctx.visibleRangeForPosition(lineNumber, column - 1);\n            if (visibleRange) {\n                points.push({ offset: visibleRange.left, column: column - 1 });\n            }\n        }\n        const lineMaxColumn = ctx.viewModel.getLineMaxColumn(lineNumber);\n        if (column < lineMaxColumn) {\n            const visibleRange = ctx.visibleRangeForPosition(lineNumber, column + 1);\n            if (visibleRange) {\n                points.push({ offset: visibleRange.left, column: column + 1 });\n            }\n        }\n        points.sort((a, b) => a.offset - b.offset);\n        const mouseCoordinates = request.pos.toClientCoordinates(dom.getWindow(ctx.viewDomNode));\n        const spanNodeClientRect = spanNode.getBoundingClientRect();\n        const mouseIsOverSpanNode = (spanNodeClientRect.left <= mouseCoordinates.clientX && mouseCoordinates.clientX <= spanNodeClientRect.right);\n        let rng = null;\n        for (let i = 1; i < points.length; i++) {\n            const prev = points[i - 1];\n            const curr = points[i];\n            if (prev.offset <= request.mouseContentHorizontalOffset && request.mouseContentHorizontalOffset <= curr.offset) {\n                rng = new EditorRange(lineNumber, prev.column, lineNumber, curr.column);\n                // See https://github.com/microsoft/vscode/issues/152819\n                // Due to the use of zwj, the browser's hit test result is skewed towards the left\n                // Here we try to correct that if the mouse horizontal offset is closer to the right than the left\n                const prevDelta = Math.abs(prev.offset - request.mouseContentHorizontalOffset);\n                const nextDelta = Math.abs(curr.offset - request.mouseContentHorizontalOffset);\n                pos = (prevDelta < nextDelta\n                    ? new Position(lineNumber, prev.column)\n                    : new Position(lineNumber, curr.column));\n                break;\n            }\n        }\n        return request.fulfillContentText(pos, rng, { mightBeForeignElement: !mouseIsOverSpanNode || !!injectedText, injectedText });\n    }\n    /**\n     * Most probably WebKit browsers and Edge\n     */\n    static _doHitTestWithCaretRangeFromPoint(ctx, request) {\n        // In Chrome, especially on Linux it is possible to click between lines,\n        // so try to adjust the `hity` below so that it lands in the center of a line\n        const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n        const lineStartVerticalOffset = ctx.getVerticalOffsetForLineNumber(lineNumber);\n        const lineEndVerticalOffset = lineStartVerticalOffset + ctx.lineHeight;\n        const isBelowLastLine = (lineNumber === ctx.viewModel.getLineCount()\n            && request.mouseVerticalOffset > lineEndVerticalOffset);\n        if (!isBelowLastLine) {\n            const lineCenteredVerticalOffset = Math.floor((lineStartVerticalOffset + lineEndVerticalOffset) / 2);\n            let adjustedPageY = request.pos.y + (lineCenteredVerticalOffset - request.mouseVerticalOffset);\n            if (adjustedPageY <= request.editorPos.y) {\n                adjustedPageY = request.editorPos.y + 1;\n            }\n            if (adjustedPageY >= request.editorPos.y + request.editorPos.height) {\n                adjustedPageY = request.editorPos.y + request.editorPos.height - 1;\n            }\n            const adjustedPage = new PageCoordinates(request.pos.x, adjustedPageY);\n            const r = this._actualDoHitTestWithCaretRangeFromPoint(ctx, adjustedPage.toClientCoordinates(dom.getWindow(ctx.viewDomNode)));\n            if (r.type === 1 /* HitTestResultType.Content */) {\n                return r;\n            }\n        }\n        // Also try to hit test without the adjustment (for the edge cases that we are near the top or bottom)\n        return this._actualDoHitTestWithCaretRangeFromPoint(ctx, request.pos.toClientCoordinates(dom.getWindow(ctx.viewDomNode)));\n    }\n    static _actualDoHitTestWithCaretRangeFromPoint(ctx, coords) {\n        const shadowRoot = dom.getShadowRoot(ctx.viewDomNode);\n        let range;\n        if (shadowRoot) {\n            if (typeof shadowRoot.caretRangeFromPoint === 'undefined') {\n                range = shadowCaretRangeFromPoint(shadowRoot, coords.clientX, coords.clientY);\n            }\n            else {\n                range = shadowRoot.caretRangeFromPoint(coords.clientX, coords.clientY);\n            }\n        }\n        else {\n            range = ctx.viewDomNode.ownerDocument.caretRangeFromPoint(coords.clientX, coords.clientY);\n        }\n        if (!range || !range.startContainer) {\n            return new UnknownHitTestResult();\n        }\n        // Chrome always hits a TEXT_NODE, while Edge sometimes hits a token span\n        const startContainer = range.startContainer;\n        if (startContainer.nodeType === startContainer.TEXT_NODE) {\n            // startContainer is expected to be the token text\n            const parent1 = startContainer.parentNode; // expected to be the token span\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n            const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n            const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n            if (parent3ClassName === ViewLine.CLASS_NAME) {\n                return HitTestResult.createFromDOMInfo(ctx, parent1, range.startOffset);\n            }\n            else {\n                return new UnknownHitTestResult(startContainer.parentNode);\n            }\n        }\n        else if (startContainer.nodeType === startContainer.ELEMENT_NODE) {\n            // startContainer is expected to be the token span\n            const parent1 = startContainer.parentNode; // expected to be the view line container span\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line div\n            const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\n            if (parent2ClassName === ViewLine.CLASS_NAME) {\n                return HitTestResult.createFromDOMInfo(ctx, startContainer, startContainer.textContent.length);\n            }\n            else {\n                return new UnknownHitTestResult(startContainer);\n            }\n        }\n        return new UnknownHitTestResult();\n    }\n    /**\n     * Most probably Gecko\n     */\n    static _doHitTestWithCaretPositionFromPoint(ctx, coords) {\n        const hitResult = ctx.viewDomNode.ownerDocument.caretPositionFromPoint(coords.clientX, coords.clientY);\n        if (hitResult.offsetNode.nodeType === hitResult.offsetNode.TEXT_NODE) {\n            // offsetNode is expected to be the token text\n            const parent1 = hitResult.offsetNode.parentNode; // expected to be the token span\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n            const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n            const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n            if (parent3ClassName === ViewLine.CLASS_NAME) {\n                return HitTestResult.createFromDOMInfo(ctx, hitResult.offsetNode.parentNode, hitResult.offset);\n            }\n            else {\n                return new UnknownHitTestResult(hitResult.offsetNode.parentNode);\n            }\n        }\n        // For inline decorations, Gecko sometimes returns the `<span>` of the line and the offset is the `<span>` with the inline decoration\n        // Some other times, it returns the `<span>` with the inline decoration\n        if (hitResult.offsetNode.nodeType === hitResult.offsetNode.ELEMENT_NODE) {\n            const parent1 = hitResult.offsetNode.parentNode;\n            const parent1ClassName = parent1 && parent1.nodeType === parent1.ELEMENT_NODE ? parent1.className : null;\n            const parent2 = parent1 ? parent1.parentNode : null;\n            const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\n            if (parent1ClassName === ViewLine.CLASS_NAME) {\n                // it returned the `<span>` of the line and the offset is the `<span>` with the inline decoration\n                const tokenSpan = hitResult.offsetNode.childNodes[Math.min(hitResult.offset, hitResult.offsetNode.childNodes.length - 1)];\n                if (tokenSpan) {\n                    return HitTestResult.createFromDOMInfo(ctx, tokenSpan, 0);\n                }\n            }\n            else if (parent2ClassName === ViewLine.CLASS_NAME) {\n                // it returned the `<span>` with the inline decoration\n                return HitTestResult.createFromDOMInfo(ctx, hitResult.offsetNode, 0);\n            }\n        }\n        return new UnknownHitTestResult(hitResult.offsetNode);\n    }\n    static _snapToSoftTabBoundary(position, viewModel) {\n        const lineContent = viewModel.getLineContent(position.lineNumber);\n        const { tabSize } = viewModel.model.getOptions();\n        const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 2 /* Direction.Nearest */);\n        if (newPosition !== -1) {\n            return new Position(position.lineNumber, newPosition + 1);\n        }\n        return position;\n    }\n    static doHitTest(ctx, request) {\n        let result = new UnknownHitTestResult();\n        if (typeof ctx.viewDomNode.ownerDocument.caretRangeFromPoint === 'function') {\n            result = this._doHitTestWithCaretRangeFromPoint(ctx, request);\n        }\n        else if (ctx.viewDomNode.ownerDocument.caretPositionFromPoint) {\n            result = this._doHitTestWithCaretPositionFromPoint(ctx, request.pos.toClientCoordinates(dom.getWindow(ctx.viewDomNode)));\n        }\n        if (result.type === 1 /* HitTestResultType.Content */) {\n            const injectedText = ctx.viewModel.getInjectedTextAt(result.position);\n            const normalizedPosition = ctx.viewModel.normalizePosition(result.position, 2 /* PositionAffinity.None */);\n            if (injectedText || !normalizedPosition.equals(result.position)) {\n                result = new ContentHitTestResult(normalizedPosition, result.spanNode, injectedText);\n            }\n        }\n        return result;\n    }\n}\nfunction shadowCaretRangeFromPoint(shadowRoot, x, y) {\n    const range = document.createRange();\n    // Get the element under the point\n    let el = shadowRoot.elementFromPoint(x, y);\n    if (el !== null) {\n        // Get the last child of the element until its firstChild is a text node\n        // This assumes that the pointer is on the right of the line, out of the tokens\n        // and that we want to get the offset of the last token of the line\n        while (el && el.firstChild && el.firstChild.nodeType !== el.firstChild.TEXT_NODE && el.lastChild && el.lastChild.firstChild) {\n            el = el.lastChild;\n        }\n        // Grab its rect\n        const rect = el.getBoundingClientRect();\n        // And its font (the computed shorthand font property might be empty, see #3217)\n        const elWindow = dom.getWindow(el);\n        const fontStyle = elWindow.getComputedStyle(el, null).getPropertyValue('font-style');\n        const fontVariant = elWindow.getComputedStyle(el, null).getPropertyValue('font-variant');\n        const fontWeight = elWindow.getComputedStyle(el, null).getPropertyValue('font-weight');\n        const fontSize = elWindow.getComputedStyle(el, null).getPropertyValue('font-size');\n        const lineHeight = elWindow.getComputedStyle(el, null).getPropertyValue('line-height');\n        const fontFamily = elWindow.getComputedStyle(el, null).getPropertyValue('font-family');\n        const font = `${fontStyle} ${fontVariant} ${fontWeight} ${fontSize}/${lineHeight} ${fontFamily}`;\n        // And also its txt content\n        const text = el.innerText;\n        // Position the pixel cursor at the left of the element\n        let pixelCursor = rect.left;\n        let offset = 0;\n        let step;\n        // If the point is on the right of the box put the cursor after the last character\n        if (x > rect.left + rect.width) {\n            offset = text.length;\n        }\n        else {\n            const charWidthReader = CharWidthReader.getInstance();\n            // Goes through all the characters of the innerText, and checks if the x of the point\n            // belongs to the character.\n            for (let i = 0; i < text.length + 1; i++) {\n                // The step is half the width of the character\n                step = charWidthReader.getCharWidth(text.charAt(i), font) / 2;\n                // Move to the center of the character\n                pixelCursor += step;\n                // If the x of the point is smaller that the position of the cursor, the point is over that character\n                if (x < pixelCursor) {\n                    offset = i;\n                    break;\n                }\n                // Move between the current character and the next\n                pixelCursor += step;\n            }\n        }\n        // Creates a range with the text node of the element and set the offset found\n        range.setStart(el.firstChild, offset);\n        range.setEnd(el.firstChild, offset);\n    }\n    return range;\n}\nclass CharWidthReader {\n    static getInstance() {\n        if (!CharWidthReader._INSTANCE) {\n            CharWidthReader._INSTANCE = new CharWidthReader();\n        }\n        return CharWidthReader._INSTANCE;\n    }\n    constructor() {\n        this._cache = {};\n        this._canvas = document.createElement('canvas');\n    }\n    getCharWidth(char, font) {\n        const cacheKey = char + font;\n        if (this._cache[cacheKey]) {\n            return this._cache[cacheKey];\n        }\n        const context = this._canvas.getContext('2d');\n        context.font = font;\n        const metrics = context.measureText(char);\n        const width = metrics.width;\n        this._cache[cacheKey] = width;\n        return width;\n    }\n}\nCharWidthReader._INSTANCE = null;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}