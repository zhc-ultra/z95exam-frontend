{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nexport var DeleteOperations = /*#__PURE__*/function () {\n  function DeleteOperations() {\n    _classCallCheck(this, DeleteOperations);\n  }\n  return _createClass(DeleteOperations, null, [{\n    key: \"deleteRight\",\n    value: function deleteRight(prevEditOperationType, config, model, selections) {\n      var commands = [];\n      var shouldPushStackElementBefore = prevEditOperationType !== 3 /* EditOperationType.DeletingRight */;\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n        var deleteSelection = selection;\n        if (deleteSelection.isEmpty()) {\n          var position = selection.getPosition();\n          var rightOfPosition = MoveOperations.right(config, model, position);\n          deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);\n        }\n        if (deleteSelection.isEmpty()) {\n          // Probably at end of file => ignore\n          commands[i] = null;\n          continue;\n        }\n        if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n          shouldPushStackElementBefore = true;\n        }\n        commands[i] = new ReplaceCommand(deleteSelection, '');\n      }\n      return [shouldPushStackElementBefore, commands];\n    }\n  }, {\n    key: \"isAutoClosingPairDelete\",\n    value: function isAutoClosingPairDelete(autoClosingDelete, autoClosingBrackets, autoClosingQuotes, autoClosingPairsOpen, model, selections, autoClosedCharacters) {\n      if (autoClosingBrackets === 'never' && autoClosingQuotes === 'never') {\n        return false;\n      }\n      if (autoClosingDelete === 'never') {\n        return false;\n      }\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n        var position = selection.getPosition();\n        if (!selection.isEmpty()) {\n          return false;\n        }\n        var lineText = model.getLineContent(position.lineNumber);\n        if (position.column < 2 || position.column >= lineText.length + 1) {\n          return false;\n        }\n        var character = lineText.charAt(position.column - 2);\n        var autoClosingPairCandidates = autoClosingPairsOpen.get(character);\n        if (!autoClosingPairCandidates) {\n          return false;\n        }\n        if (isQuote(character)) {\n          if (autoClosingQuotes === 'never') {\n            return false;\n          }\n        } else {\n          if (autoClosingBrackets === 'never') {\n            return false;\n          }\n        }\n        var afterCharacter = lineText.charAt(position.column - 1);\n        var foundAutoClosingPair = false;\n        var _iterator = _createForOfIteratorHelper(autoClosingPairCandidates),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var autoClosingPairCandidate = _step.value;\n            if (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\n              foundAutoClosingPair = true;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        if (!foundAutoClosingPair) {\n          return false;\n        }\n        // Must delete the pair only if it was automatically inserted by the editor\n        if (autoClosingDelete === 'auto') {\n          var found = false;\n          for (var j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n            var autoClosedCharacter = autoClosedCharacters[j];\n            if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"_runAutoClosingPairDelete\",\n    value: function _runAutoClosingPairDelete(config, model, selections) {\n      var commands = [];\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var position = selections[i].getPosition();\n        var deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n        commands[i] = new ReplaceCommand(deleteSelection, '');\n      }\n      return [true, commands];\n    }\n  }, {\n    key: \"deleteLeft\",\n    value: function deleteLeft(prevEditOperationType, config, model, selections, autoClosedCharacters) {\n      if (this.isAutoClosingPairDelete(config.autoClosingDelete, config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections, autoClosedCharacters)) {\n        return this._runAutoClosingPairDelete(config, model, selections);\n      }\n      var commands = [];\n      var shouldPushStackElementBefore = prevEditOperationType !== 2 /* EditOperationType.DeletingLeft */;\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var deleteRange = DeleteOperations.getDeleteRange(selections[i], model, config);\n        // Ignore empty delete ranges, as they have no effect\n        // They happen if the cursor is at the beginning of the file.\n        if (deleteRange.isEmpty()) {\n          commands[i] = null;\n          continue;\n        }\n        if (deleteRange.startLineNumber !== deleteRange.endLineNumber) {\n          shouldPushStackElementBefore = true;\n        }\n        commands[i] = new ReplaceCommand(deleteRange, '');\n      }\n      return [shouldPushStackElementBefore, commands];\n    }\n  }, {\n    key: \"getDeleteRange\",\n    value: function getDeleteRange(selection, model, config) {\n      if (!selection.isEmpty()) {\n        return selection;\n      }\n      var position = selection.getPosition();\n      // Unintend when using tab stops and cursor is within indentation\n      if (config.useTabStops && position.column > 1) {\n        var lineContent = model.getLineContent(position.lineNumber);\n        var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n        var lastIndentationColumn = firstNonWhitespaceIndex === -1 ? /* entire string is whitespace */lineContent.length + 1 : firstNonWhitespaceIndex + 1;\n        if (position.column <= lastIndentationColumn) {\n          var fromVisibleColumn = config.visibleColumnFromColumn(model, position);\n          var toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n          var toColumn = config.columnFromVisibleColumn(model, position.lineNumber, toVisibleColumn);\n          return new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n        }\n      }\n      return Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(position, model), position);\n    }\n  }, {\n    key: \"getPositionAfterDeleteLeft\",\n    value: function getPositionAfterDeleteLeft(position, model) {\n      if (position.column > 1) {\n        // Convert 1-based columns to 0-based offsets and back.\n        var idx = strings.getLeftDeleteOffset(position.column - 1, model.getLineContent(position.lineNumber));\n        return position[\"with\"](undefined, idx + 1);\n      } else if (position.lineNumber > 1) {\n        var newLine = position.lineNumber - 1;\n        return new Position(newLine, model.getLineMaxColumn(newLine));\n      } else {\n        return position;\n      }\n    }\n  }, {\n    key: \"cut\",\n    value: function cut(config, model, selections) {\n      var commands = [];\n      var lastCutRange = null;\n      selections.sort(function (a, b) {\n        return Position.compare(a.getStartPosition(), b.getEndPosition());\n      });\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n        if (selection.isEmpty()) {\n          if (config.emptySelectionClipboard) {\n            // This is a full line cut\n            var position = selection.getPosition();\n            var startLineNumber = void 0,\n              startColumn = void 0,\n              endLineNumber = void 0,\n              endColumn = void 0;\n            if (position.lineNumber < model.getLineCount()) {\n              // Cutting a line in the middle of the model\n              startLineNumber = position.lineNumber;\n              startColumn = 1;\n              endLineNumber = position.lineNumber + 1;\n              endColumn = 1;\n            } else if (position.lineNumber > 1 && (lastCutRange === null || lastCutRange === void 0 ? void 0 : lastCutRange.endLineNumber) !== position.lineNumber) {\n              // Cutting the last line & there are more than 1 lines in the model & a previous cut operation does not touch the current cut operation\n              startLineNumber = position.lineNumber - 1;\n              startColumn = model.getLineMaxColumn(position.lineNumber - 1);\n              endLineNumber = position.lineNumber;\n              endColumn = model.getLineMaxColumn(position.lineNumber);\n            } else {\n              // Cutting the single line that the model contains\n              startLineNumber = position.lineNumber;\n              startColumn = 1;\n              endLineNumber = position.lineNumber;\n              endColumn = model.getLineMaxColumn(position.lineNumber);\n            }\n            var deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            lastCutRange = deleteSelection;\n            if (!deleteSelection.isEmpty()) {\n              commands[i] = new ReplaceCommand(deleteSelection, '');\n            } else {\n              commands[i] = null;\n            }\n          } else {\n            // Cannot cut empty selection\n            commands[i] = null;\n          }\n        } else {\n          commands[i] = new ReplaceCommand(selection, '');\n        }\n      }\n      return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: true\n      });\n    }\n  }]);\n}();","map":{"version":3,"names":["strings","ReplaceCommand","EditOperationResult","isQuote","CursorColumns","MoveOperations","Range","Position","DeleteOperations","_classCallCheck","_createClass","key","value","deleteRight","prevEditOperationType","config","model","selections","commands","shouldPushStackElementBefore","i","len","length","selection","deleteSelection","isEmpty","position","getPosition","rightOfPosition","right","lineNumber","column","startLineNumber","endLineNumber","isAutoClosingPairDelete","autoClosingDelete","autoClosingBrackets","autoClosingQuotes","autoClosingPairsOpen","autoClosedCharacters","lineText","getLineContent","character","charAt","autoClosingPairCandidates","get","afterCharacter","foundAutoClosingPair","_iterator","_createForOfIteratorHelper","_step","s","n","done","autoClosingPairCandidate","open","close","err","e","f","found","j","lenJ","autoClosedCharacter","startColumn","_runAutoClosingPairDelete","deleteLeft","autoClosingPairs","autoClosingPairsOpenByEnd","deleteRange","getDeleteRange","useTabStops","lineContent","firstNonWhitespaceIndex","lastIndentationColumn","fromVisibleColumn","visibleColumnFromColumn","toVisibleColumn","prevIndentTabStop","indentSize","toColumn","columnFromVisibleColumn","fromPositions","getPositionAfterDeleteLeft","idx","getLeftDeleteOffset","undefined","newLine","getLineMaxColumn","cut","lastCutRange","sort","a","b","compare","getStartPosition","getEndPosition","emptySelectionClipboard","endColumn","getLineCount","shouldPushStackElementAfter"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorDeleteOperations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nexport class DeleteOperations {\n    static deleteRight(prevEditOperationType, config, model, selections) {\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 3 /* EditOperationType.DeletingRight */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            let deleteSelection = selection;\n            if (deleteSelection.isEmpty()) {\n                const position = selection.getPosition();\n                const rightOfPosition = MoveOperations.right(config, model, position);\n                deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);\n            }\n            if (deleteSelection.isEmpty()) {\n                // Probably at end of file => ignore\n                commands[i] = null;\n                continue;\n            }\n            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static isAutoClosingPairDelete(autoClosingDelete, autoClosingBrackets, autoClosingQuotes, autoClosingPairsOpen, model, selections, autoClosedCharacters) {\n        if (autoClosingBrackets === 'never' && autoClosingQuotes === 'never') {\n            return false;\n        }\n        if (autoClosingDelete === 'never') {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const lineText = model.getLineContent(position.lineNumber);\n            if (position.column < 2 || position.column >= lineText.length + 1) {\n                return false;\n            }\n            const character = lineText.charAt(position.column - 2);\n            const autoClosingPairCandidates = autoClosingPairsOpen.get(character);\n            if (!autoClosingPairCandidates) {\n                return false;\n            }\n            if (isQuote(character)) {\n                if (autoClosingQuotes === 'never') {\n                    return false;\n                }\n            }\n            else {\n                if (autoClosingBrackets === 'never') {\n                    return false;\n                }\n            }\n            const afterCharacter = lineText.charAt(position.column - 1);\n            let foundAutoClosingPair = false;\n            for (const autoClosingPairCandidate of autoClosingPairCandidates) {\n                if (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\n                    foundAutoClosingPair = true;\n                }\n            }\n            if (!foundAutoClosingPair) {\n                return false;\n            }\n            // Must delete the pair only if it was automatically inserted by the editor\n            if (autoClosingDelete === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingPairDelete(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const position = selections[i].getPosition();\n            const deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [true, commands];\n    }\n    static deleteLeft(prevEditOperationType, config, model, selections, autoClosedCharacters) {\n        if (this.isAutoClosingPairDelete(config.autoClosingDelete, config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections, autoClosedCharacters)) {\n            return this._runAutoClosingPairDelete(config, model, selections);\n        }\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 2 /* EditOperationType.DeletingLeft */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const deleteRange = DeleteOperations.getDeleteRange(selections[i], model, config);\n            // Ignore empty delete ranges, as they have no effect\n            // They happen if the cursor is at the beginning of the file.\n            if (deleteRange.isEmpty()) {\n                commands[i] = null;\n                continue;\n            }\n            if (deleteRange.startLineNumber !== deleteRange.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteRange, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static getDeleteRange(selection, model, config) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = selection.getPosition();\n        // Unintend when using tab stops and cursor is within indentation\n        if (config.useTabStops && position.column > 1) {\n            const lineContent = model.getLineContent(position.lineNumber);\n            const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n            const lastIndentationColumn = (firstNonWhitespaceIndex === -1\n                ? /* entire string is whitespace */ lineContent.length + 1\n                : firstNonWhitespaceIndex + 1);\n            if (position.column <= lastIndentationColumn) {\n                const fromVisibleColumn = config.visibleColumnFromColumn(model, position);\n                const toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n                const toColumn = config.columnFromVisibleColumn(model, position.lineNumber, toVisibleColumn);\n                return new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n            }\n        }\n        return Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(position, model), position);\n    }\n    static getPositionAfterDeleteLeft(position, model) {\n        if (position.column > 1) {\n            // Convert 1-based columns to 0-based offsets and back.\n            const idx = strings.getLeftDeleteOffset(position.column - 1, model.getLineContent(position.lineNumber));\n            return position.with(undefined, idx + 1);\n        }\n        else if (position.lineNumber > 1) {\n            const newLine = position.lineNumber - 1;\n            return new Position(newLine, model.getLineMaxColumn(newLine));\n        }\n        else {\n            return position;\n        }\n    }\n    static cut(config, model, selections) {\n        const commands = [];\n        let lastCutRange = null;\n        selections.sort((a, b) => Position.compare(a.getStartPosition(), b.getEndPosition()));\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                if (config.emptySelectionClipboard) {\n                    // This is a full line cut\n                    const position = selection.getPosition();\n                    let startLineNumber, startColumn, endLineNumber, endColumn;\n                    if (position.lineNumber < model.getLineCount()) {\n                        // Cutting a line in the middle of the model\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber + 1;\n                        endColumn = 1;\n                    }\n                    else if (position.lineNumber > 1 && (lastCutRange === null || lastCutRange === void 0 ? void 0 : lastCutRange.endLineNumber) !== position.lineNumber) {\n                        // Cutting the last line & there are more than 1 lines in the model & a previous cut operation does not touch the current cut operation\n                        startLineNumber = position.lineNumber - 1;\n                        startColumn = model.getLineMaxColumn(position.lineNumber - 1);\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    else {\n                        // Cutting the single line that the model contains\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    const deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n                    lastCutRange = deleteSelection;\n                    if (!deleteSelection.isEmpty()) {\n                        commands[i] = new ReplaceCommand(deleteSelection, '');\n                    }\n                    else {\n                        commands[i] = null;\n                    }\n                }\n                else {\n                    // Cannot cut empty selection\n                    commands[i] = null;\n                }\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, '');\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}