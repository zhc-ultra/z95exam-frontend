{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _typeof from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.date.to-json.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.reflect.to-string-tag.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.bold.js\";\nimport \"core-js/modules/es.string.italics.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nimport { IThemeService } from '../../../platform/theme/common/themeService.js';\nimport { ILogService, LogLevel } from '../../../platform/log/common/log.js';\nimport { SparseMultilineTokens } from '../tokens/sparseMultilineTokens.js';\nimport { ILanguageService } from '../languages/language.js';\nvar SemanticTokensProviderStyling = /*#__PURE__*/function () {\n  function SemanticTokensProviderStyling(_legend, _themeService, _languageService, _logService) {\n    _classCallCheck(this, SemanticTokensProviderStyling);\n    this._legend = _legend;\n    this._themeService = _themeService;\n    this._languageService = _languageService;\n    this._logService = _logService;\n    this._hasWarnedOverlappingTokens = false;\n    this._hasWarnedInvalidLengthTokens = false;\n    this._hasWarnedInvalidEditStart = false;\n    this._hashTable = new HashTable();\n  }\n  return _createClass(SemanticTokensProviderStyling, [{\n    key: \"getMetadata\",\n    value: function getMetadata(tokenTypeIndex, tokenModifierSet, languageId) {\n      var encodedLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);\n      var entry = this._hashTable.get(tokenTypeIndex, tokenModifierSet, encodedLanguageId);\n      var metadata;\n      if (entry) {\n        metadata = entry.metadata;\n        if (this._logService.getLevel() === LogLevel.Trace) {\n          this._logService.trace(\"SemanticTokensProviderStyling [CACHED] \".concat(tokenTypeIndex, \" / \").concat(tokenModifierSet, \": foreground \").concat(TokenMetadata.getForeground(metadata), \", fontStyle \").concat(TokenMetadata.getFontStyle(metadata).toString(2)));\n        }\n      } else {\n        var tokenType = this._legend.tokenTypes[tokenTypeIndex];\n        var tokenModifiers = [];\n        if (tokenType) {\n          var modifierSet = tokenModifierSet;\n          for (var modifierIndex = 0; modifierSet > 0 && modifierIndex < this._legend.tokenModifiers.length; modifierIndex++) {\n            if (modifierSet & 1) {\n              tokenModifiers.push(this._legend.tokenModifiers[modifierIndex]);\n            }\n            modifierSet = modifierSet >> 1;\n          }\n          if (modifierSet > 0 && this._logService.getLevel() === LogLevel.Trace) {\n            this._logService.trace(\"SemanticTokensProviderStyling: unknown token modifier index: \".concat(tokenModifierSet.toString(2), \" for legend: \").concat(JSON.stringify(this._legend.tokenModifiers)));\n            tokenModifiers.push('not-in-legend');\n          }\n          var tokenStyle = this._themeService.getColorTheme().getTokenStyleMetadata(tokenType, tokenModifiers, languageId);\n          if (typeof tokenStyle === 'undefined') {\n            metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;\n          } else {\n            metadata = 0;\n            if (typeof tokenStyle.italic !== 'undefined') {\n              var italicBit = (tokenStyle.italic ? 1 /* FontStyle.Italic */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n              metadata |= italicBit | 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */;\n            }\n            if (typeof tokenStyle.bold !== 'undefined') {\n              var boldBit = (tokenStyle.bold ? 2 /* FontStyle.Bold */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n              metadata |= boldBit | 2 /* MetadataConsts.SEMANTIC_USE_BOLD */;\n            }\n            if (typeof tokenStyle.underline !== 'undefined') {\n              var underlineBit = (tokenStyle.underline ? 4 /* FontStyle.Underline */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n              metadata |= underlineBit | 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */;\n            }\n            if (typeof tokenStyle.strikethrough !== 'undefined') {\n              var strikethroughBit = (tokenStyle.strikethrough ? 8 /* FontStyle.Strikethrough */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n              metadata |= strikethroughBit | 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */;\n            }\n            if (tokenStyle.foreground) {\n              var foregroundBits = tokenStyle.foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */;\n              metadata |= foregroundBits | 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */;\n            }\n            if (metadata === 0) {\n              // Nothing!\n              metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;\n            }\n          }\n        } else {\n          if (this._logService.getLevel() === LogLevel.Trace) {\n            this._logService.trace(\"SemanticTokensProviderStyling: unknown token type index: \".concat(tokenTypeIndex, \" for legend: \").concat(JSON.stringify(this._legend.tokenTypes)));\n          }\n          metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;\n          tokenType = 'not-in-legend';\n        }\n        this._hashTable.add(tokenTypeIndex, tokenModifierSet, encodedLanguageId, metadata);\n        if (this._logService.getLevel() === LogLevel.Trace) {\n          this._logService.trace(\"SemanticTokensProviderStyling \".concat(tokenTypeIndex, \" (\").concat(tokenType, \") / \").concat(tokenModifierSet, \" (\").concat(tokenModifiers.join(' '), \"): foreground \").concat(TokenMetadata.getForeground(metadata), \", fontStyle \").concat(TokenMetadata.getFontStyle(metadata).toString(2)));\n        }\n      }\n      return metadata;\n    }\n  }, {\n    key: \"warnOverlappingSemanticTokens\",\n    value: function warnOverlappingSemanticTokens(lineNumber, startColumn) {\n      if (!this._hasWarnedOverlappingTokens) {\n        this._hasWarnedOverlappingTokens = true;\n        this._logService.warn(\"Overlapping semantic tokens detected at lineNumber \".concat(lineNumber, \", column \").concat(startColumn));\n      }\n    }\n  }, {\n    key: \"warnInvalidLengthSemanticTokens\",\n    value: function warnInvalidLengthSemanticTokens(lineNumber, startColumn) {\n      if (!this._hasWarnedInvalidLengthTokens) {\n        this._hasWarnedInvalidLengthTokens = true;\n        this._logService.warn(\"Semantic token with invalid length detected at lineNumber \".concat(lineNumber, \", column \").concat(startColumn));\n      }\n    }\n  }, {\n    key: \"warnInvalidEditStart\",\n    value: function warnInvalidEditStart(previousResultId, resultId, editIndex, editStart, maxExpectedStart) {\n      if (!this._hasWarnedInvalidEditStart) {\n        this._hasWarnedInvalidEditStart = true;\n        this._logService.warn(\"Invalid semantic tokens edit detected (previousResultId: \".concat(previousResultId, \", resultId: \").concat(resultId, \") at edit #\").concat(editIndex, \": The provided start offset \").concat(editStart, \" is outside the previous data (length \").concat(maxExpectedStart, \").\"));\n      }\n    }\n  }]);\n}();\nSemanticTokensProviderStyling = __decorate([__param(1, IThemeService), __param(2, ILanguageService), __param(3, ILogService)], SemanticTokensProviderStyling);\nexport { SemanticTokensProviderStyling };\nexport function toMultilineTokens2(tokens, styling, languageId) {\n  var srcData = tokens.data;\n  var tokenCount = tokens.data.length / 5 | 0;\n  var tokensPerArea = Math.max(Math.ceil(tokenCount / 1024 /* SemanticColoringConstants.DesiredMaxAreas */), 400 /* SemanticColoringConstants.DesiredTokensPerArea */);\n  var result = [];\n  var tokenIndex = 0;\n  var lastLineNumber = 1;\n  var lastStartCharacter = 0;\n  while (tokenIndex < tokenCount) {\n    var tokenStartIndex = tokenIndex;\n    var tokenEndIndex = Math.min(tokenStartIndex + tokensPerArea, tokenCount);\n    // Keep tokens on the same line in the same area...\n    if (tokenEndIndex < tokenCount) {\n      var smallTokenEndIndex = tokenEndIndex;\n      while (smallTokenEndIndex - 1 > tokenStartIndex && srcData[5 * smallTokenEndIndex] === 0) {\n        smallTokenEndIndex--;\n      }\n      if (smallTokenEndIndex - 1 === tokenStartIndex) {\n        // there are so many tokens on this line that our area would be empty, we must now go right\n        var bigTokenEndIndex = tokenEndIndex;\n        while (bigTokenEndIndex + 1 < tokenCount && srcData[5 * bigTokenEndIndex] === 0) {\n          bigTokenEndIndex++;\n        }\n        tokenEndIndex = bigTokenEndIndex;\n      } else {\n        tokenEndIndex = smallTokenEndIndex;\n      }\n    }\n    var destData = new Uint32Array((tokenEndIndex - tokenStartIndex) * 4);\n    var destOffset = 0;\n    var areaLine = 0;\n    var prevLineNumber = 0;\n    var prevEndCharacter = 0;\n    while (tokenIndex < tokenEndIndex) {\n      var srcOffset = 5 * tokenIndex;\n      var deltaLine = srcData[srcOffset];\n      var deltaCharacter = srcData[srcOffset + 1];\n      // Casting both `lineNumber`, `startCharacter` and `endCharacter` here to uint32 using `|0`\n      // to validate below with the actual values that will be inserted in the Uint32Array result\n      var lineNumber = lastLineNumber + deltaLine | 0;\n      var startCharacter = deltaLine === 0 ? lastStartCharacter + deltaCharacter | 0 : deltaCharacter;\n      var length = srcData[srcOffset + 2];\n      var endCharacter = startCharacter + length | 0;\n      var tokenTypeIndex = srcData[srcOffset + 3];\n      var tokenModifierSet = srcData[srcOffset + 4];\n      if (endCharacter <= startCharacter) {\n        // this token is invalid (most likely a negative length casted to uint32)\n        styling.warnInvalidLengthSemanticTokens(lineNumber, startCharacter + 1);\n      } else if (prevLineNumber === lineNumber && prevEndCharacter > startCharacter) {\n        // this token overlaps with the previous token\n        styling.warnOverlappingSemanticTokens(lineNumber, startCharacter + 1);\n      } else {\n        var metadata = styling.getMetadata(tokenTypeIndex, tokenModifierSet, languageId);\n        if (metadata !== 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */) {\n          if (areaLine === 0) {\n            areaLine = lineNumber;\n          }\n          destData[destOffset] = lineNumber - areaLine;\n          destData[destOffset + 1] = startCharacter;\n          destData[destOffset + 2] = endCharacter;\n          destData[destOffset + 3] = metadata;\n          destOffset += 4;\n          prevLineNumber = lineNumber;\n          prevEndCharacter = endCharacter;\n        }\n      }\n      lastLineNumber = lineNumber;\n      lastStartCharacter = startCharacter;\n      tokenIndex++;\n    }\n    if (destOffset !== destData.length) {\n      destData = destData.subarray(0, destOffset);\n    }\n    var _tokens = SparseMultilineTokens.create(areaLine, destData);\n    result.push(_tokens);\n  }\n  return result;\n}\nvar HashTableEntry = /*#__PURE__*/_createClass(function HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n  _classCallCheck(this, HashTableEntry);\n  this.tokenTypeIndex = tokenTypeIndex;\n  this.tokenModifierSet = tokenModifierSet;\n  this.languageId = languageId;\n  this.metadata = metadata;\n  this.next = null;\n});\nvar HashTable = /*#__PURE__*/function () {\n  function HashTable() {\n    _classCallCheck(this, HashTable);\n    this._elementsCount = 0;\n    this._currentLengthIndex = 0;\n    this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n    this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n    this._elements = [];\n    HashTable._nullOutEntries(this._elements, this._currentLength);\n  }\n  return _createClass(HashTable, [{\n    key: \"_hash2\",\n    value: function _hash2(n1, n2) {\n      return (n1 << 5) - n1 + n2 | 0; // n1 * 31 + n2, keep as int32\n    }\n  }, {\n    key: \"_hashFunc\",\n    value: function _hashFunc(tokenTypeIndex, tokenModifierSet, languageId) {\n      return this._hash2(this._hash2(tokenTypeIndex, tokenModifierSet), languageId) % this._currentLength;\n    }\n  }, {\n    key: \"get\",\n    value: function get(tokenTypeIndex, tokenModifierSet, languageId) {\n      var hash = this._hashFunc(tokenTypeIndex, tokenModifierSet, languageId);\n      var p = this._elements[hash];\n      while (p) {\n        if (p.tokenTypeIndex === tokenTypeIndex && p.tokenModifierSet === tokenModifierSet && p.languageId === languageId) {\n          return p;\n        }\n        p = p.next;\n      }\n      return null;\n    }\n  }, {\n    key: \"add\",\n    value: function add(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n      this._elementsCount++;\n      if (this._growCount !== 0 && this._elementsCount >= this._growCount) {\n        // expand!\n        var oldElements = this._elements;\n        this._currentLengthIndex++;\n        this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n        this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n        this._elements = [];\n        HashTable._nullOutEntries(this._elements, this._currentLength);\n        var _iterator = _createForOfIteratorHelper(oldElements),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var first = _step.value;\n            var p = first;\n            while (p) {\n              var oldNext = p.next;\n              p.next = null;\n              this._add(p);\n              p = oldNext;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      this._add(new HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata));\n    }\n  }, {\n    key: \"_add\",\n    value: function _add(element) {\n      var hash = this._hashFunc(element.tokenTypeIndex, element.tokenModifierSet, element.languageId);\n      element.next = this._elements[hash];\n      this._elements[hash] = element;\n    }\n  }], [{\n    key: \"_nullOutEntries\",\n    value: function _nullOutEntries(entries, length) {\n      for (var i = 0; i < length; i++) {\n        entries[i] = null;\n      }\n    }\n  }]);\n}();\nHashTable._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","_typeof","decorate","i","defineProperty","__param","paramIndex","decorator","TokenMetadata","IThemeService","ILogService","LogLevel","SparseMultilineTokens","ILanguageService","SemanticTokensProviderStyling","_legend","_themeService","_languageService","_logService","_classCallCheck","_hasWarnedOverlappingTokens","_hasWarnedInvalidLengthTokens","_hasWarnedInvalidEditStart","_hashTable","HashTable","_createClass","value","getMetadata","tokenTypeIndex","tokenModifierSet","languageId","encodedLanguageId","languageIdCodec","encodeLanguageId","entry","get","metadata","getLevel","Trace","trace","concat","getForeground","getFontStyle","toString","tokenType","tokenTypes","tokenModifiers","modifierSet","modifierIndex","push","JSON","stringify","tokenStyle","getColorTheme","getTokenStyleMetadata","italic","italicBit","bold","boldBit","underline","underlineBit","strikethrough","strikethroughBit","foreground","foregroundBits","add","join","warnOverlappingSemanticTokens","lineNumber","startColumn","warn","warnInvalidLengthSemanticTokens","warnInvalidEditStart","previousResultId","resultId","editIndex","editStart","maxExpectedStart","toMultilineTokens2","tokens","styling","srcData","data","tokenCount","tokensPerArea","Math","max","ceil","result","tokenIndex","lastLineNumber","lastStartCharacter","tokenStartIndex","tokenEndIndex","min","smallTokenEndIndex","bigTokenEndIndex","destData","Uint32Array","destOffset","areaLine","prevLineNumber","prevEndCharacter","srcOffset","deltaLine","deltaCharacter","startCharacter","endCharacter","subarray","create","HashTableEntry","next","_elementsCount","_currentLengthIndex","_currentLength","_SIZES","_growCount","round","_elements","_nullOutEntries","_hash2","n1","n2","_hashFunc","hash","p","oldElements","_iterator","_createForOfIteratorHelper","_step","s","n","done","first","oldNext","_add","err","e","f","element","entries"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nimport { IThemeService } from '../../../platform/theme/common/themeService.js';\nimport { ILogService, LogLevel } from '../../../platform/log/common/log.js';\nimport { SparseMultilineTokens } from '../tokens/sparseMultilineTokens.js';\nimport { ILanguageService } from '../languages/language.js';\nlet SemanticTokensProviderStyling = class SemanticTokensProviderStyling {\n    constructor(_legend, _themeService, _languageService, _logService) {\n        this._legend = _legend;\n        this._themeService = _themeService;\n        this._languageService = _languageService;\n        this._logService = _logService;\n        this._hasWarnedOverlappingTokens = false;\n        this._hasWarnedInvalidLengthTokens = false;\n        this._hasWarnedInvalidEditStart = false;\n        this._hashTable = new HashTable();\n    }\n    getMetadata(tokenTypeIndex, tokenModifierSet, languageId) {\n        const encodedLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);\n        const entry = this._hashTable.get(tokenTypeIndex, tokenModifierSet, encodedLanguageId);\n        let metadata;\n        if (entry) {\n            metadata = entry.metadata;\n            if (this._logService.getLevel() === LogLevel.Trace) {\n                this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${tokenTypeIndex} / ${tokenModifierSet}: foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\n            }\n        }\n        else {\n            let tokenType = this._legend.tokenTypes[tokenTypeIndex];\n            const tokenModifiers = [];\n            if (tokenType) {\n                let modifierSet = tokenModifierSet;\n                for (let modifierIndex = 0; modifierSet > 0 && modifierIndex < this._legend.tokenModifiers.length; modifierIndex++) {\n                    if (modifierSet & 1) {\n                        tokenModifiers.push(this._legend.tokenModifiers[modifierIndex]);\n                    }\n                    modifierSet = modifierSet >> 1;\n                }\n                if (modifierSet > 0 && this._logService.getLevel() === LogLevel.Trace) {\n                    this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${tokenModifierSet.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`);\n                    tokenModifiers.push('not-in-legend');\n                }\n                const tokenStyle = this._themeService.getColorTheme().getTokenStyleMetadata(tokenType, tokenModifiers, languageId);\n                if (typeof tokenStyle === 'undefined') {\n                    metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;\n                }\n                else {\n                    metadata = 0;\n                    if (typeof tokenStyle.italic !== 'undefined') {\n                        const italicBit = (tokenStyle.italic ? 1 /* FontStyle.Italic */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n                        metadata |= italicBit | 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */;\n                    }\n                    if (typeof tokenStyle.bold !== 'undefined') {\n                        const boldBit = (tokenStyle.bold ? 2 /* FontStyle.Bold */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n                        metadata |= boldBit | 2 /* MetadataConsts.SEMANTIC_USE_BOLD */;\n                    }\n                    if (typeof tokenStyle.underline !== 'undefined') {\n                        const underlineBit = (tokenStyle.underline ? 4 /* FontStyle.Underline */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n                        metadata |= underlineBit | 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */;\n                    }\n                    if (typeof tokenStyle.strikethrough !== 'undefined') {\n                        const strikethroughBit = (tokenStyle.strikethrough ? 8 /* FontStyle.Strikethrough */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n                        metadata |= strikethroughBit | 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */;\n                    }\n                    if (tokenStyle.foreground) {\n                        const foregroundBits = (tokenStyle.foreground) << 15 /* MetadataConsts.FOREGROUND_OFFSET */;\n                        metadata |= foregroundBits | 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */;\n                    }\n                    if (metadata === 0) {\n                        // Nothing!\n                        metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;\n                    }\n                }\n            }\n            else {\n                if (this._logService.getLevel() === LogLevel.Trace) {\n                    this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${tokenTypeIndex} for legend: ${JSON.stringify(this._legend.tokenTypes)}`);\n                }\n                metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;\n                tokenType = 'not-in-legend';\n            }\n            this._hashTable.add(tokenTypeIndex, tokenModifierSet, encodedLanguageId, metadata);\n            if (this._logService.getLevel() === LogLevel.Trace) {\n                this._logService.trace(`SemanticTokensProviderStyling ${tokenTypeIndex} (${tokenType}) / ${tokenModifierSet} (${tokenModifiers.join(' ')}): foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\n            }\n        }\n        return metadata;\n    }\n    warnOverlappingSemanticTokens(lineNumber, startColumn) {\n        if (!this._hasWarnedOverlappingTokens) {\n            this._hasWarnedOverlappingTokens = true;\n            this._logService.warn(`Overlapping semantic tokens detected at lineNumber ${lineNumber}, column ${startColumn}`);\n        }\n    }\n    warnInvalidLengthSemanticTokens(lineNumber, startColumn) {\n        if (!this._hasWarnedInvalidLengthTokens) {\n            this._hasWarnedInvalidLengthTokens = true;\n            this._logService.warn(`Semantic token with invalid length detected at lineNumber ${lineNumber}, column ${startColumn}`);\n        }\n    }\n    warnInvalidEditStart(previousResultId, resultId, editIndex, editStart, maxExpectedStart) {\n        if (!this._hasWarnedInvalidEditStart) {\n            this._hasWarnedInvalidEditStart = true;\n            this._logService.warn(`Invalid semantic tokens edit detected (previousResultId: ${previousResultId}, resultId: ${resultId}) at edit #${editIndex}: The provided start offset ${editStart} is outside the previous data (length ${maxExpectedStart}).`);\n        }\n    }\n};\nSemanticTokensProviderStyling = __decorate([\n    __param(1, IThemeService),\n    __param(2, ILanguageService),\n    __param(3, ILogService)\n], SemanticTokensProviderStyling);\nexport { SemanticTokensProviderStyling };\nexport function toMultilineTokens2(tokens, styling, languageId) {\n    const srcData = tokens.data;\n    const tokenCount = (tokens.data.length / 5) | 0;\n    const tokensPerArea = Math.max(Math.ceil(tokenCount / 1024 /* SemanticColoringConstants.DesiredMaxAreas */), 400 /* SemanticColoringConstants.DesiredTokensPerArea */);\n    const result = [];\n    let tokenIndex = 0;\n    let lastLineNumber = 1;\n    let lastStartCharacter = 0;\n    while (tokenIndex < tokenCount) {\n        const tokenStartIndex = tokenIndex;\n        let tokenEndIndex = Math.min(tokenStartIndex + tokensPerArea, tokenCount);\n        // Keep tokens on the same line in the same area...\n        if (tokenEndIndex < tokenCount) {\n            let smallTokenEndIndex = tokenEndIndex;\n            while (smallTokenEndIndex - 1 > tokenStartIndex && srcData[5 * smallTokenEndIndex] === 0) {\n                smallTokenEndIndex--;\n            }\n            if (smallTokenEndIndex - 1 === tokenStartIndex) {\n                // there are so many tokens on this line that our area would be empty, we must now go right\n                let bigTokenEndIndex = tokenEndIndex;\n                while (bigTokenEndIndex + 1 < tokenCount && srcData[5 * bigTokenEndIndex] === 0) {\n                    bigTokenEndIndex++;\n                }\n                tokenEndIndex = bigTokenEndIndex;\n            }\n            else {\n                tokenEndIndex = smallTokenEndIndex;\n            }\n        }\n        let destData = new Uint32Array((tokenEndIndex - tokenStartIndex) * 4);\n        let destOffset = 0;\n        let areaLine = 0;\n        let prevLineNumber = 0;\n        let prevEndCharacter = 0;\n        while (tokenIndex < tokenEndIndex) {\n            const srcOffset = 5 * tokenIndex;\n            const deltaLine = srcData[srcOffset];\n            const deltaCharacter = srcData[srcOffset + 1];\n            // Casting both `lineNumber`, `startCharacter` and `endCharacter` here to uint32 using `|0`\n            // to validate below with the actual values that will be inserted in the Uint32Array result\n            const lineNumber = (lastLineNumber + deltaLine) | 0;\n            const startCharacter = (deltaLine === 0 ? (lastStartCharacter + deltaCharacter) | 0 : deltaCharacter);\n            const length = srcData[srcOffset + 2];\n            const endCharacter = (startCharacter + length) | 0;\n            const tokenTypeIndex = srcData[srcOffset + 3];\n            const tokenModifierSet = srcData[srcOffset + 4];\n            if (endCharacter <= startCharacter) {\n                // this token is invalid (most likely a negative length casted to uint32)\n                styling.warnInvalidLengthSemanticTokens(lineNumber, startCharacter + 1);\n            }\n            else if (prevLineNumber === lineNumber && prevEndCharacter > startCharacter) {\n                // this token overlaps with the previous token\n                styling.warnOverlappingSemanticTokens(lineNumber, startCharacter + 1);\n            }\n            else {\n                const metadata = styling.getMetadata(tokenTypeIndex, tokenModifierSet, languageId);\n                if (metadata !== 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */) {\n                    if (areaLine === 0) {\n                        areaLine = lineNumber;\n                    }\n                    destData[destOffset] = lineNumber - areaLine;\n                    destData[destOffset + 1] = startCharacter;\n                    destData[destOffset + 2] = endCharacter;\n                    destData[destOffset + 3] = metadata;\n                    destOffset += 4;\n                    prevLineNumber = lineNumber;\n                    prevEndCharacter = endCharacter;\n                }\n            }\n            lastLineNumber = lineNumber;\n            lastStartCharacter = startCharacter;\n            tokenIndex++;\n        }\n        if (destOffset !== destData.length) {\n            destData = destData.subarray(0, destOffset);\n        }\n        const tokens = SparseMultilineTokens.create(areaLine, destData);\n        result.push(tokens);\n    }\n    return result;\n}\nclass HashTableEntry {\n    constructor(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n        this.tokenTypeIndex = tokenTypeIndex;\n        this.tokenModifierSet = tokenModifierSet;\n        this.languageId = languageId;\n        this.metadata = metadata;\n        this.next = null;\n    }\n}\nclass HashTable {\n    constructor() {\n        this._elementsCount = 0;\n        this._currentLengthIndex = 0;\n        this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n        this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n        this._elements = [];\n        HashTable._nullOutEntries(this._elements, this._currentLength);\n    }\n    static _nullOutEntries(entries, length) {\n        for (let i = 0; i < length; i++) {\n            entries[i] = null;\n        }\n    }\n    _hash2(n1, n2) {\n        return (((n1 << 5) - n1) + n2) | 0; // n1 * 31 + n2, keep as int32\n    }\n    _hashFunc(tokenTypeIndex, tokenModifierSet, languageId) {\n        return this._hash2(this._hash2(tokenTypeIndex, tokenModifierSet), languageId) % this._currentLength;\n    }\n    get(tokenTypeIndex, tokenModifierSet, languageId) {\n        const hash = this._hashFunc(tokenTypeIndex, tokenModifierSet, languageId);\n        let p = this._elements[hash];\n        while (p) {\n            if (p.tokenTypeIndex === tokenTypeIndex && p.tokenModifierSet === tokenModifierSet && p.languageId === languageId) {\n                return p;\n            }\n            p = p.next;\n        }\n        return null;\n    }\n    add(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n        this._elementsCount++;\n        if (this._growCount !== 0 && this._elementsCount >= this._growCount) {\n            // expand!\n            const oldElements = this._elements;\n            this._currentLengthIndex++;\n            this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n            this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n            this._elements = [];\n            HashTable._nullOutEntries(this._elements, this._currentLength);\n            for (const first of oldElements) {\n                let p = first;\n                while (p) {\n                    const oldNext = p.next;\n                    p.next = null;\n                    this._add(p);\n                    p = oldNext;\n                }\n            }\n        }\n        this._add(new HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata));\n    }\n    _add(element) {\n        const hash = this._hashFunc(element.tokenTypeIndex, element.tokenModifierSet, element.languageId);\n        element.next = this._elements[hash];\n        this._elements[hash] = element;\n    }\n}\nHashTable._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}