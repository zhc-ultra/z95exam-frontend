{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nimport { CallbackIterable } from '../../../../../base/common/arrays.js';\nimport { combineTextEditInfos } from './combineTextEditInfos.js';\nexport var BracketPairsTree = /*#__PURE__*/function (_Disposable) {\n  function BracketPairsTree(textModel, getLanguageConfiguration) {\n    var _this;\n    _classCallCheck(this, BracketPairsTree);\n    _this = _callSuper(this, BracketPairsTree);\n    _this.textModel = textModel;\n    _this.getLanguageConfiguration = getLanguageConfiguration;\n    _this.didChangeEmitter = new Emitter();\n    _this.denseKeyProvider = new DenseKeyProvider();\n    _this.brackets = new LanguageAgnosticBracketTokens(_this.denseKeyProvider, _this.getLanguageConfiguration);\n    _this.onDidChange = _this.didChangeEmitter.event;\n    _this.queuedTextEditsForInitialAstWithoutTokens = [];\n    _this.queuedTextEdits = [];\n    if (!textModel.tokenization.hasTokens) {\n      var brackets = _this.brackets.getSingleLanguageBracketTokens(_this.textModel.getLanguageId());\n      var tokenizer = new FastTokenizer(_this.textModel.getValue(), brackets);\n      _this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n      _this.astWithTokens = _this.initialAstWithoutTokens;\n    } else if (textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n      // Skip the initial ast, as there is no flickering.\n      // Directly create the tree with token information.\n      _this.initialAstWithoutTokens = undefined;\n      _this.astWithTokens = _this.parseDocumentFromTextBuffer([], undefined, false);\n    } else {\n      // We missed some token changes already, so we cannot use the fast tokenizer + delta increments\n      _this.initialAstWithoutTokens = _this.parseDocumentFromTextBuffer([], undefined, true);\n      _this.astWithTokens = _this.initialAstWithoutTokens;\n    }\n    return _this;\n  }\n  //#region TextModel events\n  _inherits(BracketPairsTree, _Disposable);\n  return _createClass(BracketPairsTree, [{\n    key: \"didLanguageChange\",\n    value: function didLanguageChange(languageId) {\n      return this.brackets.didLanguageChange(languageId);\n    }\n  }, {\n    key: \"handleDidChangeBackgroundTokenizationState\",\n    value: function handleDidChangeBackgroundTokenizationState() {\n      if (this.textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n        var wasUndefined = this.initialAstWithoutTokens === undefined;\n        // Clear the initial tree as we can use the tree with token information now.\n        this.initialAstWithoutTokens = undefined;\n        if (!wasUndefined) {\n          this.didChangeEmitter.fire();\n        }\n      }\n    }\n  }, {\n    key: \"handleDidChangeTokens\",\n    value: function handleDidChangeTokens(_ref) {\n      var ranges = _ref.ranges;\n      var edits = ranges.map(function (r) {\n        return new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0));\n      });\n      this.handleEdits(edits, true);\n      if (!this.initialAstWithoutTokens) {\n        this.didChangeEmitter.fire();\n      }\n    }\n  }, {\n    key: \"handleContentChanged\",\n    value: function handleContentChanged(change) {\n      var edits = TextEditInfo.fromModelContentChanges(change.changes);\n      this.handleEdits(edits, false);\n    }\n  }, {\n    key: \"handleEdits\",\n    value: function handleEdits(edits, tokenChange) {\n      // Lazily queue the edits and only apply them when the tree is accessed.\n      var result = combineTextEditInfos(this.queuedTextEdits, edits);\n      this.queuedTextEdits = result;\n      if (this.initialAstWithoutTokens && !tokenChange) {\n        this.queuedTextEditsForInitialAstWithoutTokens = combineTextEditInfos(this.queuedTextEditsForInitialAstWithoutTokens, edits);\n      }\n    }\n    //#endregion\n  }, {\n    key: \"flushQueue\",\n    value: function flushQueue() {\n      if (this.queuedTextEdits.length > 0) {\n        this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);\n        this.queuedTextEdits = [];\n      }\n      if (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {\n        if (this.initialAstWithoutTokens) {\n          this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);\n        }\n        this.queuedTextEditsForInitialAstWithoutTokens = [];\n      }\n    }\n    /**\n     * @pure (only if isPure = true)\n    */\n  }, {\n    key: \"parseDocumentFromTextBuffer\",\n    value: function parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n      // Is much faster if `isPure = false`.\n      var isPure = false;\n      var previousAstClone = isPure ? previousAst === null || previousAst === void 0 ? void 0 : previousAst.deepClone() : previousAst;\n      var tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n      var result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n      return result;\n    }\n  }, {\n    key: \"getBracketsInRange\",\n    value: function getBracketsInRange(range, onlyColorizedBrackets) {\n      var _this2 = this;\n      this.flushQueue();\n      var startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n      var endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n      return new CallbackIterable(function (cb) {\n        var node = _this2.initialAstWithoutTokens || _this2.astWithTokens;\n        collectBrackets(node, lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);\n      });\n    }\n  }, {\n    key: \"getBracketPairsInRange\",\n    value: function getBracketPairsInRange(range, includeMinIndentation) {\n      var _this3 = this;\n      this.flushQueue();\n      var startLength = positionToLength(range.getStartPosition());\n      var endLength = positionToLength(range.getEndPosition());\n      return new CallbackIterable(function (cb) {\n        var node = _this3.initialAstWithoutTokens || _this3.astWithTokens;\n        var context = new CollectBracketPairsContext(cb, includeMinIndentation, _this3.textModel);\n        collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n      });\n    }\n  }, {\n    key: \"getFirstBracketAfter\",\n    value: function getFirstBracketAfter(position) {\n      this.flushQueue();\n      var node = this.initialAstWithoutTokens || this.astWithTokens;\n      return _getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n    }\n  }, {\n    key: \"getFirstBracketBefore\",\n    value: function getFirstBracketBefore(position) {\n      this.flushQueue();\n      var node = this.initialAstWithoutTokens || this.astWithTokens;\n      return _getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n    }\n  }]);\n}(Disposable);\nfunction _getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {\n  if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n    var lengths = [];\n    var _iterator = _createForOfIteratorHelper(node.children),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var child = _step.value;\n        nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n        lengths.push({\n          nodeOffsetStart: nodeOffsetStart,\n          nodeOffsetEnd: nodeOffsetEnd\n        });\n        nodeOffsetStart = nodeOffsetEnd;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    for (var i = lengths.length - 1; i >= 0; i--) {\n      var _lengths$i = lengths[i],\n        _nodeOffsetStart = _lengths$i.nodeOffsetStart,\n        _nodeOffsetEnd = _lengths$i.nodeOffsetEnd;\n      if (lengthLessThan(_nodeOffsetStart, position)) {\n        var result = _getFirstBracketBefore(node.children[i], _nodeOffsetStart, _nodeOffsetEnd, position);\n        if (result) {\n          return result;\n        }\n      }\n    }\n    return null;\n  } else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n    return null;\n  } else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n    var range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n    return {\n      bracketInfo: node.bracketInfo,\n      range: range\n    };\n  }\n  return null;\n}\nfunction _getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {\n  if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n    var _iterator2 = _createForOfIteratorHelper(node.children),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var child = _step2.value;\n        nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n        if (lengthLessThan(position, nodeOffsetEnd)) {\n          var result = _getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n          if (result) {\n            return result;\n          }\n        }\n        nodeOffsetStart = nodeOffsetEnd;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    return null;\n  } else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n    return null;\n  } else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n    var range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n    return {\n      bracketInfo: node.bracketInfo,\n      range: range\n    };\n  }\n  return null;\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, nestingLevelOfEqualBracketType, levelPerBracketType, onlyColorizedBrackets) {\n  var parentPairIsIncomplete = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : false;\n  if (level > 200) {\n    return true;\n  }\n  whileLoop: while (true) {\n    switch (node.kind) {\n      case 4 /* AstNodeKind.List */:\n        {\n          var childCount = node.childrenLength;\n          for (var i = 0; i < childCount; i++) {\n            var child = node.getChild(i);\n            if (!child) {\n              continue;\n            }\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n              var childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n              if (childEndsAfterEnd) {\n                // No child after this child in the requested window, don't recurse\n                node = child;\n                continue whileLoop;\n              }\n              var shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);\n              if (!shouldContinue) {\n                return false;\n              }\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n          }\n          return true;\n        }\n      case 2 /* AstNodeKind.Pair */:\n        {\n          var colorize = !onlyColorizedBrackets || !node.closingBracket || node.closingBracket.bracketInfo.closesColorized(node.openingBracket.bracketInfo);\n          var levelPerBracket = 0;\n          if (levelPerBracketType) {\n            var existing = levelPerBracketType.get(node.openingBracket.text);\n            if (existing === undefined) {\n              existing = 0;\n            }\n            levelPerBracket = existing;\n            if (colorize) {\n              existing++;\n              levelPerBracketType.set(node.openingBracket.text, existing);\n            }\n          }\n          var _childCount = node.childrenLength;\n          for (var _i = 0; _i < _childCount; _i++) {\n            var _child = node.getChild(_i);\n            if (!_child) {\n              continue;\n            }\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, _child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n              var _childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n              if (_childEndsAfterEnd && _child.kind !== 1 /* AstNodeKind.Bracket */) {\n                // No child after this child in the requested window, don't recurse\n                // Don't do this for brackets because of unclosed/unopened brackets\n                node = _child;\n                if (colorize) {\n                  level++;\n                  nestingLevelOfEqualBracketType = levelPerBracket + 1;\n                } else {\n                  nestingLevelOfEqualBracketType = levelPerBracket;\n                }\n                continue whileLoop;\n              }\n              if (colorize || _child.kind !== 1 /* AstNodeKind.Bracket */ || !node.closingBracket) {\n                var _shouldContinue = collectBrackets(_child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, colorize ? level + 1 : level, colorize ? levelPerBracket + 1 : levelPerBracket, levelPerBracketType, onlyColorizedBrackets, !node.closingBracket);\n                if (!_shouldContinue) {\n                  return false;\n                }\n              }\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n          }\n          levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);\n          return true;\n        }\n      case 3 /* AstNodeKind.UnexpectedClosingBracket */:\n        {\n          var range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n          return push(new BracketInfo(range, level - 1, 0, true));\n        }\n      case 1 /* AstNodeKind.Bracket */:\n        {\n          var _range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n          return push(new BracketInfo(_range, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));\n        }\n      case 0 /* AstNodeKind.Text */:\n        return true;\n    }\n  }\n}\nvar CollectBracketPairsContext = /*#__PURE__*/_createClass(function CollectBracketPairsContext(push, includeMinIndentation, textModel) {\n  _classCallCheck(this, CollectBracketPairsContext);\n  this.push = push;\n  this.includeMinIndentation = includeMinIndentation;\n  this.textModel = textModel;\n});\nfunction collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {\n  var _a;\n  if (level > 200) {\n    return true;\n  }\n  var shouldContinue = true;\n  if (node.kind === 2 /* AstNodeKind.Pair */) {\n    var levelPerBracket = 0;\n    if (levelPerBracketType) {\n      var existing = levelPerBracketType.get(node.openingBracket.text);\n      if (existing === undefined) {\n        existing = 0;\n      }\n      levelPerBracket = existing;\n      existing++;\n      levelPerBracketType.set(node.openingBracket.text, existing);\n    }\n    var openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n    var minIndentation = -1;\n    if (context.includeMinIndentation) {\n      minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);\n    }\n    shouldContinue = context.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart, nodeOffsetEnd), lengthsToRange(nodeOffsetStart, openingBracketEnd), node.closingBracket ? lengthsToRange(lengthAdd(openingBracketEnd, ((_a = node.child) === null || _a === void 0 ? void 0 : _a.length) || lengthZero), nodeOffsetEnd) : undefined, level, levelPerBracket, node, minIndentation));\n    nodeOffsetStart = openingBracketEnd;\n    if (shouldContinue && node.child) {\n      var child = node.child;\n      nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n      if (lengthLessThanEqual(nodeOffsetStart, endOffset) && lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n        shouldContinue = collectBracketPairs(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType);\n        if (!shouldContinue) {\n          return false;\n        }\n      }\n    }\n    levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);\n  } else {\n    var curOffset = nodeOffsetStart;\n    var _iterator3 = _createForOfIteratorHelper(node.children),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _child2 = _step3.value;\n        var childOffset = curOffset;\n        curOffset = lengthAdd(curOffset, _child2.length);\n        if (lengthLessThanEqual(childOffset, endOffset) && lengthLessThanEqual(startOffset, curOffset)) {\n          shouldContinue = collectBracketPairs(_child2, childOffset, curOffset, startOffset, endOffset, context, level, levelPerBracketType);\n          if (!shouldContinue) {\n            return false;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n  return shouldContinue;\n}","map":{"version":3,"names":["Emitter","Disposable","BracketInfo","BracketPairWithMinIndentationInfo","TextEditInfo","LanguageAgnosticBracketTokens","lengthAdd","lengthGreaterThanEqual","lengthLessThan","lengthLessThanEqual","lengthsToRange","lengthZero","positionToLength","toLength","parseDocument","DenseKeyProvider","FastTokenizer","TextBufferTokenizer","CallbackIterable","combineTextEditInfos","BracketPairsTree","_Disposable","textModel","getLanguageConfiguration","_this","_classCallCheck","_callSuper","didChangeEmitter","denseKeyProvider","brackets","onDidChange","event","queuedTextEditsForInitialAstWithoutTokens","queuedTextEdits","tokenization","hasTokens","getSingleLanguageBracketTokens","getLanguageId","tokenizer","getValue","initialAstWithoutTokens","undefined","astWithTokens","backgroundTokenizationState","parseDocumentFromTextBuffer","_inherits","_createClass","key","value","didLanguageChange","languageId","handleDidChangeBackgroundTokenizationState","wasUndefined","fire","handleDidChangeTokens","_ref","ranges","edits","map","r","fromLineNumber","toLineNumber","handleEdits","handleContentChanged","change","fromModelContentChanges","changes","tokenChange","result","flushQueue","length","previousAst","immutable","isPure","previousAstClone","deepClone","getBracketsInRange","range","onlyColorizedBrackets","_this2","startOffset","startLineNumber","startColumn","endOffset","endLineNumber","endColumn","cb","node","collectBrackets","Map","getBracketPairsInRange","includeMinIndentation","_this3","startLength","getStartPosition","endLength","getEndPosition","context","CollectBracketPairsContext","collectBracketPairs","getFirstBracketAfter","position","getFirstBracketBefore","nodeOffsetStart","nodeOffsetEnd","kind","lengths","_iterator","_createForOfIteratorHelper","children","_step","s","n","done","child","push","err","e","f","i","_lengths$i","bracketInfo","_iterator2","_step2","level","nestingLevelOfEqualBracketType","levelPerBracketType","parentPairIsIncomplete","arguments","whileLoop","childCount","childrenLength","getChild","childEndsAfterEnd","shouldContinue","colorize","closingBracket","closesColorized","openingBracket","levelPerBracket","existing","get","text","set","_a","openingBracketEnd","minIndentation","computeMinIndentation","curOffset","_iterator3","_step3","childOffset"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nimport { CallbackIterable } from '../../../../../base/common/arrays.js';\nimport { combineTextEditInfos } from './combineTextEditInfos.js';\nexport class BracketPairsTree extends Disposable {\n    didLanguageChange(languageId) {\n        return this.brackets.didLanguageChange(languageId);\n    }\n    constructor(textModel, getLanguageConfiguration) {\n        super();\n        this.textModel = textModel;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.didChangeEmitter = new Emitter();\n        this.denseKeyProvider = new DenseKeyProvider();\n        this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n        this.onDidChange = this.didChangeEmitter.event;\n        this.queuedTextEditsForInitialAstWithoutTokens = [];\n        this.queuedTextEdits = [];\n        if (!textModel.tokenization.hasTokens) {\n            const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n            const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n            this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n        else if (textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            // Skip the initial ast, as there is no flickering.\n            // Directly create the tree with token information.\n            this.initialAstWithoutTokens = undefined;\n            this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n        }\n        else {\n            // We missed some token changes already, so we cannot use the fast tokenizer + delta increments\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n    }\n    //#region TextModel events\n    handleDidChangeBackgroundTokenizationState() {\n        if (this.textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            const wasUndefined = this.initialAstWithoutTokens === undefined;\n            // Clear the initial tree as we can use the tree with token information now.\n            this.initialAstWithoutTokens = undefined;\n            if (!wasUndefined) {\n                this.didChangeEmitter.fire();\n            }\n        }\n    }\n    handleDidChangeTokens({ ranges }) {\n        const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n        this.handleEdits(edits, true);\n        if (!this.initialAstWithoutTokens) {\n            this.didChangeEmitter.fire();\n        }\n    }\n    handleContentChanged(change) {\n        const edits = TextEditInfo.fromModelContentChanges(change.changes);\n        this.handleEdits(edits, false);\n    }\n    handleEdits(edits, tokenChange) {\n        // Lazily queue the edits and only apply them when the tree is accessed.\n        const result = combineTextEditInfos(this.queuedTextEdits, edits);\n        this.queuedTextEdits = result;\n        if (this.initialAstWithoutTokens && !tokenChange) {\n            this.queuedTextEditsForInitialAstWithoutTokens = combineTextEditInfos(this.queuedTextEditsForInitialAstWithoutTokens, edits);\n        }\n    }\n    //#endregion\n    flushQueue() {\n        if (this.queuedTextEdits.length > 0) {\n            this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);\n            this.queuedTextEdits = [];\n        }\n        if (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {\n            if (this.initialAstWithoutTokens) {\n                this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);\n            }\n            this.queuedTextEditsForInitialAstWithoutTokens = [];\n        }\n    }\n    /**\n     * @pure (only if isPure = true)\n    */\n    parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n        // Is much faster if `isPure = false`.\n        const isPure = false;\n        const previousAstClone = isPure ? previousAst === null || previousAst === void 0 ? void 0 : previousAst.deepClone() : previousAst;\n        const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n        const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n        return result;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets) {\n        this.flushQueue();\n        const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n        const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            collectBrackets(node, lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);\n        });\n    }\n    getBracketPairsInRange(range, includeMinIndentation) {\n        this.flushQueue();\n        const startLength = positionToLength(range.getStartPosition());\n        const endLength = positionToLength(range.getEndPosition());\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            const context = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);\n            collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n        });\n    }\n    getFirstBracketAfter(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n    }\n    getFirstBracketBefore(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n    }\n}\nfunction getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        const lengths = [];\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            lengths.push({ nodeOffsetStart, nodeOffsetEnd });\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        for (let i = lengths.length - 1; i >= 0; i--) {\n            const { nodeOffsetStart, nodeOffsetEnd } = lengths[i];\n            if (lengthLessThan(nodeOffsetStart, position)) {\n                const result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThan(position, nodeOffsetEnd)) {\n                const result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, nestingLevelOfEqualBracketType, levelPerBracketType, onlyColorizedBrackets, parentPairIsIncomplete = false) {\n    if (level > 200) {\n        return true;\n    }\n    whileLoop: while (true) {\n        switch (node.kind) {\n            case 4 /* AstNodeKind.List */: {\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd) {\n                            // No child after this child in the requested window, don't recurse\n                            node = child;\n                            continue whileLoop;\n                        }\n                        const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);\n                        if (!shouldContinue) {\n                            return false;\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                return true;\n            }\n            case 2 /* AstNodeKind.Pair */: {\n                const colorize = !onlyColorizedBrackets || !node.closingBracket || node.closingBracket.bracketInfo.closesColorized(node.openingBracket.bracketInfo);\n                let levelPerBracket = 0;\n                if (levelPerBracketType) {\n                    let existing = levelPerBracketType.get(node.openingBracket.text);\n                    if (existing === undefined) {\n                        existing = 0;\n                    }\n                    levelPerBracket = existing;\n                    if (colorize) {\n                        existing++;\n                        levelPerBracketType.set(node.openingBracket.text, existing);\n                    }\n                }\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd && child.kind !== 1 /* AstNodeKind.Bracket */) {\n                            // No child after this child in the requested window, don't recurse\n                            // Don't do this for brackets because of unclosed/unopened brackets\n                            node = child;\n                            if (colorize) {\n                                level++;\n                                nestingLevelOfEqualBracketType = levelPerBracket + 1;\n                            }\n                            else {\n                                nestingLevelOfEqualBracketType = levelPerBracket;\n                            }\n                            continue whileLoop;\n                        }\n                        if (colorize || child.kind !== 1 /* AstNodeKind.Bracket */ || !node.closingBracket) {\n                            const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, colorize ? level + 1 : level, colorize ? levelPerBracket + 1 : levelPerBracket, levelPerBracketType, onlyColorizedBrackets, !node.closingBracket);\n                            if (!shouldContinue) {\n                                return false;\n                            }\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);\n                return true;\n            }\n            case 3 /* AstNodeKind.UnexpectedClosingBracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, 0, true));\n            }\n            case 1 /* AstNodeKind.Bracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));\n            }\n            case 0 /* AstNodeKind.Text */:\n                return true;\n        }\n    }\n}\nclass CollectBracketPairsContext {\n    constructor(push, includeMinIndentation, textModel) {\n        this.push = push;\n        this.includeMinIndentation = includeMinIndentation;\n        this.textModel = textModel;\n    }\n}\nfunction collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {\n    var _a;\n    if (level > 200) {\n        return true;\n    }\n    let shouldContinue = true;\n    if (node.kind === 2 /* AstNodeKind.Pair */) {\n        let levelPerBracket = 0;\n        if (levelPerBracketType) {\n            let existing = levelPerBracketType.get(node.openingBracket.text);\n            if (existing === undefined) {\n                existing = 0;\n            }\n            levelPerBracket = existing;\n            existing++;\n            levelPerBracketType.set(node.openingBracket.text, existing);\n        }\n        const openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n        let minIndentation = -1;\n        if (context.includeMinIndentation) {\n            minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);\n        }\n        shouldContinue = context.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart, nodeOffsetEnd), lengthsToRange(nodeOffsetStart, openingBracketEnd), node.closingBracket\n            ? lengthsToRange(lengthAdd(openingBracketEnd, ((_a = node.child) === null || _a === void 0 ? void 0 : _a.length) || lengthZero), nodeOffsetEnd)\n            : undefined, level, levelPerBracket, node, minIndentation));\n        nodeOffsetStart = openingBracketEnd;\n        if (shouldContinue && node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                shouldContinue = collectBracketPairs(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n        levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);\n    }\n    else {\n        let curOffset = nodeOffsetStart;\n        for (const child of node.children) {\n            const childOffset = curOffset;\n            curOffset = lengthAdd(curOffset, child.length);\n            if (lengthLessThanEqual(childOffset, endOffset) &&\n                lengthLessThanEqual(startOffset, curOffset)) {\n                shouldContinue = collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n    }\n    return shouldContinue;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}