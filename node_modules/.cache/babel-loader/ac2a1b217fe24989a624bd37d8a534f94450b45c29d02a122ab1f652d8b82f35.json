{"ast":null,"code":"import _toConsumableArray from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.string.substr.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableMap, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { DefaultBackgroundTokenizer, TokenizerWithStateStoreAndTextModel, TrackingTokenizationStateStore } from './textModelTokens.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nexport var TokenizationTextModelPart = /*#__PURE__*/function (_TextModelPart) {\n  function TokenizationTextModelPart(_languageService, _languageConfigurationService, _textModel, _bracketPairsTextModelPart, _languageId, _attachedViews) {\n    var _this;\n    _classCallCheck(this, TokenizationTextModelPart);\n    _this = _callSuper(this, TokenizationTextModelPart);\n    _this._languageService = _languageService;\n    _this._languageConfigurationService = _languageConfigurationService;\n    _this._textModel = _textModel;\n    _this._bracketPairsTextModelPart = _bracketPairsTextModelPart;\n    _this._languageId = _languageId;\n    _this._attachedViews = _attachedViews;\n    _this._semanticTokens = new SparseTokensStore(_this._languageService.languageIdCodec);\n    _this._onDidChangeLanguage = _this._register(new Emitter());\n    _this.onDidChangeLanguage = _this._onDidChangeLanguage.event;\n    _this._onDidChangeLanguageConfiguration = _this._register(new Emitter());\n    _this.onDidChangeLanguageConfiguration = _this._onDidChangeLanguageConfiguration.event;\n    _this._onDidChangeTokens = _this._register(new Emitter());\n    _this.onDidChangeTokens = _this._onDidChangeTokens.event;\n    _this.grammarTokens = _this._register(new GrammarTokens(_this._languageService.languageIdCodec, _this._textModel, function () {\n      return _this._languageId;\n    }, _this._attachedViews));\n    _this._register(_this._languageConfigurationService.onDidChange(function (e) {\n      if (e.affects(_this._languageId)) {\n        _this._onDidChangeLanguageConfiguration.fire({});\n      }\n    }));\n    _this._register(_this.grammarTokens.onDidChangeTokens(function (e) {\n      _this._emitModelTokensChangedEvent(e);\n    }));\n    _this._register(_this.grammarTokens.onDidChangeBackgroundTokenizationState(function (e) {\n      _this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n    }));\n    return _this;\n  }\n  _inherits(TokenizationTextModelPart, _TextModelPart);\n  return _createClass(TokenizationTextModelPart, [{\n    key: \"handleDidChangeContent\",\n    value: function handleDidChangeContent(e) {\n      if (e.isFlush) {\n        this._semanticTokens.flush();\n      } else if (!e.isEolChange) {\n        // We don't have to do anything on an EOL change\n        var _iterator = _createForOfIteratorHelper(e.changes),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var c = _step.value;\n            var _countEOL = countEOL(c.text),\n              _countEOL2 = _slicedToArray(_countEOL, 3),\n              eolCount = _countEOL2[0],\n              firstLineLength = _countEOL2[1],\n              lastLineLength = _countEOL2[2];\n            this._semanticTokens.acceptEdit(c.range, eolCount, firstLineLength, lastLineLength, c.text.length > 0 ? c.text.charCodeAt(0) : 0 /* CharCode.Null */);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      this.grammarTokens.handleDidChangeContent(e);\n    }\n  }, {\n    key: \"handleDidChangeAttached\",\n    value: function handleDidChangeAttached() {\n      this.grammarTokens.handleDidChangeAttached();\n    }\n    /**\n     * Includes grammar and semantic tokens.\n     */\n  }, {\n    key: \"getLineTokens\",\n    value: function getLineTokens(lineNumber) {\n      this.validateLineNumber(lineNumber);\n      var syntacticTokens = this.grammarTokens.getLineTokens(lineNumber);\n      return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n    }\n  }, {\n    key: \"_emitModelTokensChangedEvent\",\n    value: function _emitModelTokensChangedEvent(e) {\n      if (!this._textModel._isDisposing()) {\n        this._bracketPairsTextModelPart.handleDidChangeTokens(e);\n        this._onDidChangeTokens.fire(e);\n      }\n    }\n    // #region Grammar Tokens\n  }, {\n    key: \"validateLineNumber\",\n    value: function validateLineNumber(lineNumber) {\n      if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n        throw new BugIndicatingError('Illegal value for lineNumber');\n      }\n    }\n  }, {\n    key: \"hasTokens\",\n    get: function get() {\n      return this.grammarTokens.hasTokens;\n    }\n  }, {\n    key: \"resetTokenization\",\n    value: function resetTokenization() {\n      this.grammarTokens.resetTokenization();\n    }\n  }, {\n    key: \"backgroundTokenizationState\",\n    get: function get() {\n      return this.grammarTokens.backgroundTokenizationState;\n    }\n  }, {\n    key: \"forceTokenization\",\n    value: function forceTokenization(lineNumber) {\n      this.validateLineNumber(lineNumber);\n      this.grammarTokens.forceTokenization(lineNumber);\n    }\n  }, {\n    key: \"hasAccurateTokensForLine\",\n    value: function hasAccurateTokensForLine(lineNumber) {\n      this.validateLineNumber(lineNumber);\n      return this.grammarTokens.hasAccurateTokensForLine(lineNumber);\n    }\n  }, {\n    key: \"isCheapToTokenize\",\n    value: function isCheapToTokenize(lineNumber) {\n      this.validateLineNumber(lineNumber);\n      return this.grammarTokens.isCheapToTokenize(lineNumber);\n    }\n  }, {\n    key: \"tokenizeIfCheap\",\n    value: function tokenizeIfCheap(lineNumber) {\n      this.validateLineNumber(lineNumber);\n      this.grammarTokens.tokenizeIfCheap(lineNumber);\n    }\n  }, {\n    key: \"getTokenTypeIfInsertingCharacter\",\n    value: function getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n      return this.grammarTokens.getTokenTypeIfInsertingCharacter(lineNumber, column, character);\n    }\n  }, {\n    key: \"tokenizeLineWithEdit\",\n    value: function tokenizeLineWithEdit(position, length, newText) {\n      return this.grammarTokens.tokenizeLineWithEdit(position, length, newText);\n    }\n    // #endregion\n    // #region Semantic Tokens\n  }, {\n    key: \"setSemanticTokens\",\n    value: function setSemanticTokens(tokens, isComplete) {\n      this._semanticTokens.set(tokens, isComplete);\n      this._emitModelTokensChangedEvent({\n        semanticTokensApplied: tokens !== null,\n        ranges: [{\n          fromLineNumber: 1,\n          toLineNumber: this._textModel.getLineCount()\n        }]\n      });\n    }\n  }, {\n    key: \"hasCompleteSemanticTokens\",\n    value: function hasCompleteSemanticTokens() {\n      return this._semanticTokens.isComplete();\n    }\n  }, {\n    key: \"hasSomeSemanticTokens\",\n    value: function hasSomeSemanticTokens() {\n      return !this._semanticTokens.isEmpty();\n    }\n  }, {\n    key: \"setPartialSemanticTokens\",\n    value: function setPartialSemanticTokens(range, tokens) {\n      if (this.hasCompleteSemanticTokens()) {\n        return;\n      }\n      var changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));\n      this._emitModelTokensChangedEvent({\n        semanticTokensApplied: true,\n        ranges: [{\n          fromLineNumber: changedRange.startLineNumber,\n          toLineNumber: changedRange.endLineNumber\n        }]\n      });\n    }\n    // #endregion\n    // #region Utility Methods\n  }, {\n    key: \"getWordAtPosition\",\n    value: function getWordAtPosition(_position) {\n      this.assertNotDisposed();\n      var position = this._textModel.validatePosition(_position);\n      var lineContent = this._textModel.getLineContent(position.lineNumber);\n      var lineTokens = this.getLineTokens(position.lineNumber);\n      var tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n      // (1). First try checking right biased word\n      var _TokenizationTextMode = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex),\n        _TokenizationTextMode2 = _slicedToArray(_TokenizationTextMode, 2),\n        rbStartOffset = _TokenizationTextMode2[0],\n        rbEndOffset = _TokenizationTextMode2[1];\n      var rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n      // Make sure the result touches the original passed in position\n      if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {\n        return rightBiasedWord;\n      }\n      // (2). Else, if we were at a language boundary, check the left biased word\n      if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n        // edge case, where `position` sits between two tokens belonging to two different languages\n        var _TokenizationTextMode3 = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex - 1),\n          _TokenizationTextMode4 = _slicedToArray(_TokenizationTextMode3, 2),\n          lbStartOffset = _TokenizationTextMode4[0],\n          lbEndOffset = _TokenizationTextMode4[1];\n        var leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {\n          return leftBiasedWord;\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"getLanguageConfiguration\",\n    value: function getLanguageConfiguration(languageId) {\n      return this._languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n  }, {\n    key: \"getWordUntilPosition\",\n    value: function getWordUntilPosition(position) {\n      var wordAtPosition = this.getWordAtPosition(position);\n      if (!wordAtPosition) {\n        return {\n          word: '',\n          startColumn: position.column,\n          endColumn: position.column\n        };\n      }\n      return {\n        word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n        startColumn: wordAtPosition.startColumn,\n        endColumn: position.column\n      };\n    }\n    // #endregion\n    // #region Language Id handling\n  }, {\n    key: \"getLanguageId\",\n    value: function getLanguageId() {\n      return this._languageId;\n    }\n  }, {\n    key: \"getLanguageIdAtPosition\",\n    value: function getLanguageIdAtPosition(lineNumber, column) {\n      var position = this._textModel.validatePosition(new Position(lineNumber, column));\n      var lineTokens = this.getLineTokens(position.lineNumber);\n      return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n  }, {\n    key: \"setLanguageId\",\n    value: function setLanguageId(languageId) {\n      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'api';\n      if (this._languageId === languageId) {\n        // There's nothing to do\n        return;\n      }\n      var e = {\n        oldLanguage: this._languageId,\n        newLanguage: languageId,\n        source: source\n      };\n      this._languageId = languageId;\n      this._bracketPairsTextModelPart.handleDidChangeLanguage(e);\n      this.grammarTokens.resetTokenization();\n      this._onDidChangeLanguage.fire(e);\n      this._onDidChangeLanguageConfiguration.fire({});\n    }\n  }], [{\n    key: \"_findLanguageBoundaries\",\n    value: function _findLanguageBoundaries(lineTokens, tokenIndex) {\n      var languageId = lineTokens.getLanguageId(tokenIndex);\n      // go left until a different language is hit\n      var startOffset = 0;\n      for (var i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n        startOffset = lineTokens.getStartOffset(i);\n      }\n      // go right until a different language is hit\n      var endOffset = lineTokens.getLineContent().length;\n      for (var _i = tokenIndex, tokenCount = lineTokens.getCount(); _i < tokenCount && lineTokens.getLanguageId(_i) === languageId; _i++) {\n        endOffset = lineTokens.getEndOffset(_i);\n      }\n      return [startOffset, endOffset];\n    }\n  }]);\n}(TextModelPart);\nvar GrammarTokens = /*#__PURE__*/function (_Disposable) {\n  function GrammarTokens(_languageIdCodec, _textModel, getLanguageId, attachedViews) {\n    var _this2;\n    _classCallCheck(this, GrammarTokens);\n    _this2 = _callSuper(this, GrammarTokens);\n    _this2._languageIdCodec = _languageIdCodec;\n    _this2._textModel = _textModel;\n    _this2.getLanguageId = getLanguageId;\n    _this2._tokenizer = null;\n    _this2._defaultBackgroundTokenizer = null;\n    _this2._backgroundTokenizer = _this2._register(new MutableDisposable());\n    _this2._tokens = new ContiguousTokensStore(_this2._languageIdCodec);\n    _this2._debugBackgroundTokenizer = _this2._register(new MutableDisposable());\n    _this2._backgroundTokenizationState = 1 /* BackgroundTokenizationState.InProgress */;\n    _this2._onDidChangeBackgroundTokenizationState = _this2._register(new Emitter());\n    /** @internal, should not be exposed by the text model! */\n    _this2.onDidChangeBackgroundTokenizationState = _this2._onDidChangeBackgroundTokenizationState.event;\n    _this2._onDidChangeTokens = _this2._register(new Emitter());\n    /** @internal, should not be exposed by the text model! */\n    _this2.onDidChangeTokens = _this2._onDidChangeTokens.event;\n    _this2._attachedViewStates = _this2._register(new DisposableMap());\n    _this2._register(TokenizationRegistry.onDidChange(function (e) {\n      var languageId = _this2.getLanguageId();\n      if (e.changedLanguages.indexOf(languageId) === -1) {\n        return;\n      }\n      _this2.resetTokenization();\n    }));\n    _this2.resetTokenization();\n    _this2._register(attachedViews.onDidChangeVisibleRanges(function (_ref) {\n      var view = _ref.view,\n        state = _ref.state;\n      if (state) {\n        var existing = _this2._attachedViewStates.get(view);\n        if (!existing) {\n          existing = new AttachedViewHandler(function () {\n            return _this2.refreshRanges(existing.lineRanges);\n          });\n          _this2._attachedViewStates.set(view, existing);\n        }\n        existing.handleStateChange(state);\n      } else {\n        _this2._attachedViewStates.deleteAndDispose(view);\n      }\n    }));\n    return _this2;\n  }\n  _inherits(GrammarTokens, _Disposable);\n  return _createClass(GrammarTokens, [{\n    key: \"backgroundTokenizationState\",\n    get: function get() {\n      return this._backgroundTokenizationState;\n    }\n  }, {\n    key: \"resetTokenization\",\n    value: function resetTokenization() {\n      var _this3 = this;\n      var fireTokenChangeEvent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var _a;\n      this._tokens.flush();\n      (_a = this._debugBackgroundTokens) === null || _a === void 0 ? void 0 : _a.flush();\n      if (this._debugBackgroundStates) {\n        this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n      }\n      if (fireTokenChangeEvent) {\n        this._onDidChangeTokens.fire({\n          semanticTokensApplied: false,\n          ranges: [{\n            fromLineNumber: 1,\n            toLineNumber: this._textModel.getLineCount()\n          }]\n        });\n      }\n      var initializeTokenization = function initializeTokenization() {\n        if (_this3._textModel.isTooLargeForTokenization()) {\n          return [null, null];\n        }\n        var tokenizationSupport = TokenizationRegistry.get(_this3.getLanguageId());\n        if (!tokenizationSupport) {\n          return [null, null];\n        }\n        var initialState;\n        try {\n          initialState = tokenizationSupport.getInitialState();\n        } catch (e) {\n          onUnexpectedError(e);\n          return [null, null];\n        }\n        return [tokenizationSupport, initialState];\n      };\n      var _initializeTokenizati = initializeTokenization(),\n        _initializeTokenizati2 = _slicedToArray(_initializeTokenizati, 2),\n        tokenizationSupport = _initializeTokenizati2[0],\n        initialState = _initializeTokenizati2[1];\n      if (tokenizationSupport && initialState) {\n        this._tokenizer = new TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);\n      } else {\n        this._tokenizer = null;\n      }\n      this._backgroundTokenizer.clear();\n      this._defaultBackgroundTokenizer = null;\n      if (this._tokenizer) {\n        var b = {\n          setTokens: function setTokens(tokens) {\n            _this3.setTokens(tokens);\n          },\n          backgroundTokenizationFinished: function backgroundTokenizationFinished() {\n            if (_this3._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n              // We already did a full tokenization and don't go back to progressing.\n              return;\n            }\n            var newState = 2 /* BackgroundTokenizationState.Completed */;\n            _this3._backgroundTokenizationState = newState;\n            _this3._onDidChangeBackgroundTokenizationState.fire();\n          },\n          setEndState: function setEndState(lineNumber, state) {\n            var _a;\n            if (!_this3._tokenizer) {\n              return;\n            }\n            var firstInvalidEndStateLineNumber = _this3._tokenizer.store.getFirstInvalidEndStateLineNumber();\n            // Don't accept states for definitely valid states, the renderer is ahead of the worker!\n            if (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {\n              (_a = _this3._tokenizer) === null || _a === void 0 ? void 0 : _a.store.setEndState(lineNumber, state);\n            }\n          }\n        };\n        if (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {\n          this._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);\n        }\n        if (!this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization()) {\n          this._backgroundTokenizer.value = this._defaultBackgroundTokenizer = new DefaultBackgroundTokenizer(this._tokenizer, b);\n          this._defaultBackgroundTokenizer.handleChanges();\n        }\n        if ((tokenizationSupport === null || tokenizationSupport === void 0 ? void 0 : tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) && tokenizationSupport.createBackgroundTokenizer) {\n          this._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);\n          this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n          this._debugBackgroundTokenizer.clear();\n          this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {\n            setTokens: function setTokens(tokens) {\n              var _a;\n              (_a = _this3._debugBackgroundTokens) === null || _a === void 0 ? void 0 : _a.setMultilineTokens(tokens, _this3._textModel);\n            },\n            backgroundTokenizationFinished: function backgroundTokenizationFinished() {\n              // NO OP\n            },\n            setEndState: function setEndState(lineNumber, state) {\n              var _a;\n              (_a = _this3._debugBackgroundStates) === null || _a === void 0 ? void 0 : _a.setEndState(lineNumber, state);\n            }\n          });\n        } else {\n          this._debugBackgroundTokens = undefined;\n          this._debugBackgroundStates = undefined;\n          this._debugBackgroundTokenizer.value = undefined;\n        }\n      }\n      this.refreshAllVisibleLineTokens();\n    }\n  }, {\n    key: \"handleDidChangeAttached\",\n    value: function handleDidChangeAttached() {\n      var _a;\n      (_a = this._defaultBackgroundTokenizer) === null || _a === void 0 ? void 0 : _a.handleChanges();\n    }\n  }, {\n    key: \"handleDidChangeContent\",\n    value: function handleDidChangeContent(e) {\n      var _a, _b, _c;\n      if (e.isFlush) {\n        // Don't fire the event, as the view might not have got the text change event yet\n        this.resetTokenization(false);\n      } else if (!e.isEolChange) {\n        // We don't have to do anything on an EOL change\n        var _iterator2 = _createForOfIteratorHelper(e.changes),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var c = _step2.value;\n            var _countEOL3 = countEOL(c.text),\n              _countEOL4 = _slicedToArray(_countEOL3, 2),\n              eolCount = _countEOL4[0],\n              firstLineLength = _countEOL4[1];\n            this._tokens.acceptEdit(c.range, eolCount, firstLineLength);\n            (_a = this._debugBackgroundTokens) === null || _a === void 0 ? void 0 : _a.acceptEdit(c.range, eolCount, firstLineLength);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        (_b = this._debugBackgroundStates) === null || _b === void 0 ? void 0 : _b.acceptChanges(e.changes);\n        if (this._tokenizer) {\n          this._tokenizer.store.acceptChanges(e.changes);\n        }\n        (_c = this._defaultBackgroundTokenizer) === null || _c === void 0 ? void 0 : _c.handleChanges();\n      }\n    }\n  }, {\n    key: \"setTokens\",\n    value: function setTokens(tokens) {\n      var _this$_tokens$setMult = this._tokens.setMultilineTokens(tokens, this._textModel),\n        changes = _this$_tokens$setMult.changes;\n      if (changes.length > 0) {\n        this._onDidChangeTokens.fire({\n          semanticTokensApplied: false,\n          ranges: changes\n        });\n      }\n      return {\n        changes: changes\n      };\n    }\n  }, {\n    key: \"refreshAllVisibleLineTokens\",\n    value: function refreshAllVisibleLineTokens() {\n      var ranges = LineRange.joinMany(_toConsumableArray(this._attachedViewStates).map(function (_ref2) {\n        var _ref3 = _slicedToArray(_ref2, 2),\n          _ = _ref3[0],\n          s = _ref3[1];\n        return s.lineRanges;\n      }));\n      this.refreshRanges(ranges);\n    }\n  }, {\n    key: \"refreshRanges\",\n    value: function refreshRanges(ranges) {\n      var _iterator3 = _createForOfIteratorHelper(ranges),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var range = _step3.value;\n          this.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"refreshRange\",\n    value: function refreshRange(startLineNumber, endLineNumber) {\n      var _a, _b;\n      if (!this._tokenizer) {\n        return;\n      }\n      startLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));\n      endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n      var builder = new ContiguousMultilineTokensBuilder();\n      var _this$_tokenizer$toke = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber),\n        heuristicTokens = _this$_tokenizer$toke.heuristicTokens;\n      var changedTokens = this.setTokens(builder.finalize());\n      if (heuristicTokens) {\n        // We overrode tokens with heuristically computed ones.\n        // Because old states might get reused (thus stopping invalidation),\n        // we have to explicitly request the tokens for the changed ranges again.\n        var _iterator4 = _createForOfIteratorHelper(changedTokens.changes),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var c = _step4.value;\n            (_a = this._backgroundTokenizer.value) === null || _a === void 0 ? void 0 : _a.requestTokens(c.fromLineNumber, c.toLineNumber + 1);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n      (_b = this._defaultBackgroundTokenizer) === null || _b === void 0 ? void 0 : _b.checkFinished();\n    }\n  }, {\n    key: \"forceTokenization\",\n    value: function forceTokenization(lineNumber) {\n      var _a, _b;\n      var builder = new ContiguousMultilineTokensBuilder();\n      (_a = this._tokenizer) === null || _a === void 0 ? void 0 : _a.updateTokensUntilLine(builder, lineNumber);\n      this.setTokens(builder.finalize());\n      (_b = this._defaultBackgroundTokenizer) === null || _b === void 0 ? void 0 : _b.checkFinished();\n    }\n  }, {\n    key: \"hasAccurateTokensForLine\",\n    value: function hasAccurateTokensForLine(lineNumber) {\n      if (!this._tokenizer) {\n        return true;\n      }\n      return this._tokenizer.hasAccurateTokensForLine(lineNumber);\n    }\n  }, {\n    key: \"isCheapToTokenize\",\n    value: function isCheapToTokenize(lineNumber) {\n      if (!this._tokenizer) {\n        return true;\n      }\n      return this._tokenizer.isCheapToTokenize(lineNumber);\n    }\n  }, {\n    key: \"tokenizeIfCheap\",\n    value: function tokenizeIfCheap(lineNumber) {\n      if (this.isCheapToTokenize(lineNumber)) {\n        this.forceTokenization(lineNumber);\n      }\n    }\n  }, {\n    key: \"getLineTokens\",\n    value: function getLineTokens(lineNumber) {\n      var _a;\n      var lineText = this._textModel.getLineContent(lineNumber);\n      var result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n      if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {\n        if (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {\n          var backgroundResult = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n          if (!result.equals(backgroundResult) && ((_a = this._debugBackgroundTokenizer.value) === null || _a === void 0 ? void 0 : _a.reportMismatchingTokens)) {\n            this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);\n          }\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"getTokenTypeIfInsertingCharacter\",\n    value: function getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n      if (!this._tokenizer) {\n        return 0 /* StandardTokenType.Other */;\n      }\n      var position = this._textModel.validatePosition(new Position(lineNumber, column));\n      this.forceTokenization(position.lineNumber);\n      return this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);\n    }\n  }, {\n    key: \"tokenizeLineWithEdit\",\n    value: function tokenizeLineWithEdit(position, length, newText) {\n      if (!this._tokenizer) {\n        return null;\n      }\n      var validatedPosition = this._textModel.validatePosition(position);\n      this.forceTokenization(validatedPosition.lineNumber);\n      return this._tokenizer.tokenizeLineWithEdit(validatedPosition, length, newText);\n    }\n  }, {\n    key: \"hasTokens\",\n    get: function get() {\n      return this._tokens.hasTokens;\n    }\n  }]);\n}(Disposable);\nvar AttachedViewHandler = /*#__PURE__*/function (_Disposable2) {\n  function AttachedViewHandler(_refreshTokens) {\n    var _this4;\n    _classCallCheck(this, AttachedViewHandler);\n    _this4 = _callSuper(this, AttachedViewHandler);\n    _this4._refreshTokens = _refreshTokens;\n    _this4.runner = _this4._register(new RunOnceScheduler(function () {\n      return _this4.update();\n    }, 50));\n    _this4._computedLineRanges = [];\n    _this4._lineRanges = [];\n    return _this4;\n  }\n  _inherits(AttachedViewHandler, _Disposable2);\n  return _createClass(AttachedViewHandler, [{\n    key: \"lineRanges\",\n    get: function get() {\n      return this._lineRanges;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (equals(this._computedLineRanges, this._lineRanges, function (a, b) {\n        return a.equals(b);\n      })) {\n        return;\n      }\n      this._computedLineRanges = this._lineRanges;\n      this._refreshTokens();\n    }\n  }, {\n    key: \"handleStateChange\",\n    value: function handleStateChange(state) {\n      this._lineRanges = state.visibleLineRanges;\n      if (state.stabilized) {\n        this.runner.cancel();\n        this.update();\n      } else {\n        this.runner.schedule();\n      }\n    }\n  }]);\n}(Disposable);","map":{"version":3,"names":["equals","RunOnceScheduler","BugIndicatingError","onUnexpectedError","Emitter","Disposable","DisposableMap","MutableDisposable","countEOL","LineRange","Position","getWordAtText","TokenizationRegistry","TextModelPart","DefaultBackgroundTokenizer","TokenizerWithStateStoreAndTextModel","TrackingTokenizationStateStore","ContiguousMultilineTokensBuilder","ContiguousTokensStore","SparseTokensStore","TokenizationTextModelPart","_TextModelPart","_languageService","_languageConfigurationService","_textModel","_bracketPairsTextModelPart","_languageId","_attachedViews","_this","_classCallCheck","_callSuper","_semanticTokens","languageIdCodec","_onDidChangeLanguage","_register","onDidChangeLanguage","event","_onDidChangeLanguageConfiguration","onDidChangeLanguageConfiguration","_onDidChangeTokens","onDidChangeTokens","grammarTokens","GrammarTokens","onDidChange","e","affects","fire","_emitModelTokensChangedEvent","onDidChangeBackgroundTokenizationState","handleDidChangeBackgroundTokenizationState","_inherits","_createClass","key","value","handleDidChangeContent","isFlush","flush","isEolChange","_iterator","_createForOfIteratorHelper","changes","_step","s","n","done","c","_countEOL","text","_countEOL2","_slicedToArray","eolCount","firstLineLength","lastLineLength","acceptEdit","range","length","charCodeAt","err","f","handleDidChangeAttached","getLineTokens","lineNumber","validateLineNumber","syntacticTokens","addSparseTokens","_isDisposing","handleDidChangeTokens","getLineCount","get","hasTokens","resetTokenization","backgroundTokenizationState","forceTokenization","hasAccurateTokensForLine","isCheapToTokenize","tokenizeIfCheap","getTokenTypeIfInsertingCharacter","column","character","tokenizeLineWithEdit","position","newText","setSemanticTokens","tokens","isComplete","set","semanticTokensApplied","ranges","fromLineNumber","toLineNumber","hasCompleteSemanticTokens","hasSomeSemanticTokens","isEmpty","setPartialSemanticTokens","changedRange","validateRange","setPartial","startLineNumber","endLineNumber","getWordAtPosition","_position","assertNotDisposed","validatePosition","lineContent","getLineContent","lineTokens","tokenIndex","findTokenIndexAtOffset","_TokenizationTextMode","_findLanguageBoundaries","_TokenizationTextMode2","rbStartOffset","rbEndOffset","rightBiasedWord","getLanguageConfiguration","getLanguageId","getWordDefinition","substring","startColumn","endColumn","_TokenizationTextMode3","_TokenizationTextMode4","lbStartOffset","lbEndOffset","leftBiasedWord","languageId","getWordUntilPosition","wordAtPosition","word","substr","getLanguageIdAtPosition","setLanguageId","source","arguments","undefined","oldLanguage","newLanguage","handleDidChangeLanguage","startOffset","i","getStartOffset","endOffset","tokenCount","getCount","getEndOffset","_Disposable","_languageIdCodec","attachedViews","_this2","_tokenizer","_defaultBackgroundTokenizer","_backgroundTokenizer","_tokens","_debugBackgroundTokenizer","_backgroundTokenizationState","_onDidChangeBackgroundTokenizationState","_attachedViewStates","changedLanguages","indexOf","onDidChangeVisibleRanges","_ref","view","state","existing","AttachedViewHandler","refreshRanges","lineRanges","handleStateChange","deleteAndDispose","_this3","fireTokenChangeEvent","_a","_debugBackgroundTokens","_debugBackgroundStates","initializeTokenization","isTooLargeForTokenization","tokenizationSupport","initialState","getInitialState","_initializeTokenizati","_initializeTokenizati2","clear","b","setTokens","backgroundTokenizationFinished","newState","setEndState","firstInvalidEndStateLineNumber","store","getFirstInvalidEndStateLineNumber","createBackgroundTokenizer","backgroundTokenizerShouldOnlyVerifyTokens","handleChanges","setMultilineTokens","refreshAllVisibleLineTokens","_b","_c","_iterator2","_step2","_countEOL3","_countEOL4","acceptChanges","_this$_tokens$setMult","joinMany","_toConsumableArray","map","_ref2","_ref3","_","_iterator3","_step3","refreshRange","endLineNumberExclusive","Math","max","min","builder","_this$_tokenizer$toke","tokenizeHeuristically","heuristicTokens","changedTokens","finalize","_iterator4","_step4","requestTokens","checkFinished","updateTokensUntilLine","lineText","result","getTokens","getFirstInvalidEndStateLineNumberOrMax","backgroundResult","reportMismatchingTokens","validatedPosition","_Disposable2","_refreshTokens","_this4","runner","update","_computedLineRanges","_lineRanges","a","visibleLineRanges","stabilized","cancel","schedule"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/model/tokenizationTextModelPart.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableMap, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { DefaultBackgroundTokenizer, TokenizerWithStateStoreAndTextModel, TrackingTokenizationStateStore } from './textModelTokens.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nexport class TokenizationTextModelPart extends TextModelPart {\n    constructor(_languageService, _languageConfigurationService, _textModel, _bracketPairsTextModelPart, _languageId, _attachedViews) {\n        super();\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._textModel = _textModel;\n        this._bracketPairsTextModelPart = _bracketPairsTextModelPart;\n        this._languageId = _languageId;\n        this._attachedViews = _attachedViews;\n        this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n        this._onDidChangeLanguage = this._register(new Emitter());\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this.grammarTokens = this._register(new GrammarTokens(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            if (e.affects(this._languageId)) {\n                this._onDidChangeLanguageConfiguration.fire({});\n            }\n        }));\n        this._register(this.grammarTokens.onDidChangeTokens(e => {\n            this._emitModelTokensChangedEvent(e);\n        }));\n        this._register(this.grammarTokens.onDidChangeBackgroundTokenizationState(e => {\n            this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n        }));\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            this._semanticTokens.flush();\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(c.text);\n                this._semanticTokens.acceptEdit(c.range, eolCount, firstLineLength, lastLineLength, c.text.length > 0 ? c.text.charCodeAt(0) : 0 /* CharCode.Null */);\n            }\n        }\n        this.grammarTokens.handleDidChangeContent(e);\n    }\n    handleDidChangeAttached() {\n        this.grammarTokens.handleDidChangeAttached();\n    }\n    /**\n     * Includes grammar and semantic tokens.\n     */\n    getLineTokens(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        const syntacticTokens = this.grammarTokens.getLineTokens(lineNumber);\n        return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n    }\n    _emitModelTokensChangedEvent(e) {\n        if (!this._textModel._isDisposing()) {\n            this._bracketPairsTextModelPart.handleDidChangeTokens(e);\n            this._onDidChangeTokens.fire(e);\n        }\n    }\n    // #region Grammar Tokens\n    validateLineNumber(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n    }\n    get hasTokens() {\n        return this.grammarTokens.hasTokens;\n    }\n    resetTokenization() {\n        this.grammarTokens.resetTokenization();\n    }\n    get backgroundTokenizationState() {\n        return this.grammarTokens.backgroundTokenizationState;\n    }\n    forceTokenization(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this.grammarTokens.forceTokenization(lineNumber);\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this.grammarTokens.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this.grammarTokens.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this.grammarTokens.tokenizeIfCheap(lineNumber);\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        return this.grammarTokens.getTokenTypeIfInsertingCharacter(lineNumber, column, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        return this.grammarTokens.tokenizeLineWithEdit(position, length, newText);\n    }\n    // #endregion\n    // #region Semantic Tokens\n    setSemanticTokens(tokens, isComplete) {\n        this._semanticTokens.set(tokens, isComplete);\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: tokens !== null,\n            ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }],\n        });\n    }\n    hasCompleteSemanticTokens() {\n        return this._semanticTokens.isComplete();\n    }\n    hasSomeSemanticTokens() {\n        return !this._semanticTokens.isEmpty();\n    }\n    setPartialSemanticTokens(range, tokens) {\n        if (this.hasCompleteSemanticTokens()) {\n            return;\n        }\n        const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: true,\n            ranges: [\n                {\n                    fromLineNumber: changedRange.startLineNumber,\n                    toLineNumber: changedRange.endLineNumber,\n                },\n            ],\n        });\n    }\n    // #endregion\n    // #region Utility Methods\n    getWordAtPosition(_position) {\n        this.assertNotDisposed();\n        const position = this._textModel.validatePosition(_position);\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        const [rbStartOffset, rbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex);\n        const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord &&\n            rightBiasedWord.startColumn <= _position.column &&\n            _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n            const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord &&\n                leftBiasedWord.startColumn <= _position.column &&\n                _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    }\n    getLanguageConfiguration(languageId) {\n        return this._languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\n        const languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        let startOffset = 0;\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        let endOffset = lineTokens.getLineContent().length;\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    }\n    getWordUntilPosition(position) {\n        const wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return { word: '', startColumn: position.column, endColumn: position.column, };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column,\n        };\n    }\n    // #endregion\n    // #region Language Id handling\n    getLanguageId() {\n        return this._languageId;\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n    setLanguageId(languageId, source = 'api') {\n        if (this._languageId === languageId) {\n            // There's nothing to do\n            return;\n        }\n        const e = {\n            oldLanguage: this._languageId,\n            newLanguage: languageId,\n            source\n        };\n        this._languageId = languageId;\n        this._bracketPairsTextModelPart.handleDidChangeLanguage(e);\n        this.grammarTokens.resetTokenization();\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    }\n}\nclass GrammarTokens extends Disposable {\n    get backgroundTokenizationState() {\n        return this._backgroundTokenizationState;\n    }\n    constructor(_languageIdCodec, _textModel, getLanguageId, attachedViews) {\n        super();\n        this._languageIdCodec = _languageIdCodec;\n        this._textModel = _textModel;\n        this.getLanguageId = getLanguageId;\n        this._tokenizer = null;\n        this._defaultBackgroundTokenizer = null;\n        this._backgroundTokenizer = this._register(new MutableDisposable());\n        this._tokens = new ContiguousTokensStore(this._languageIdCodec);\n        this._debugBackgroundTokenizer = this._register(new MutableDisposable());\n        this._backgroundTokenizationState = 1 /* BackgroundTokenizationState.InProgress */;\n        this._onDidChangeBackgroundTokenizationState = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this._attachedViewStates = this._register(new DisposableMap());\n        this._register(TokenizationRegistry.onDidChange((e) => {\n            const languageId = this.getLanguageId();\n            if (e.changedLanguages.indexOf(languageId) === -1) {\n                return;\n            }\n            this.resetTokenization();\n        }));\n        this.resetTokenization();\n        this._register(attachedViews.onDidChangeVisibleRanges(({ view, state }) => {\n            if (state) {\n                let existing = this._attachedViewStates.get(view);\n                if (!existing) {\n                    existing = new AttachedViewHandler(() => this.refreshRanges(existing.lineRanges));\n                    this._attachedViewStates.set(view, existing);\n                }\n                existing.handleStateChange(state);\n            }\n            else {\n                this._attachedViewStates.deleteAndDispose(view);\n            }\n        }));\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        var _a;\n        this._tokens.flush();\n        (_a = this._debugBackgroundTokens) === null || _a === void 0 ? void 0 : _a.flush();\n        if (this._debugBackgroundStates) {\n            this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n        }\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        const initializeTokenization = () => {\n            if (this._textModel.isTooLargeForTokenization()) {\n                return [null, null];\n            }\n            const tokenizationSupport = TokenizationRegistry.get(this.getLanguageId());\n            if (!tokenizationSupport) {\n                return [null, null];\n            }\n            let initialState;\n            try {\n                initialState = tokenizationSupport.getInitialState();\n            }\n            catch (e) {\n                onUnexpectedError(e);\n                return [null, null];\n            }\n            return [tokenizationSupport, initialState];\n        };\n        const [tokenizationSupport, initialState] = initializeTokenization();\n        if (tokenizationSupport && initialState) {\n            this._tokenizer = new TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);\n        }\n        else {\n            this._tokenizer = null;\n        }\n        this._backgroundTokenizer.clear();\n        this._defaultBackgroundTokenizer = null;\n        if (this._tokenizer) {\n            const b = {\n                setTokens: (tokens) => {\n                    this.setTokens(tokens);\n                },\n                backgroundTokenizationFinished: () => {\n                    if (this._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n                        // We already did a full tokenization and don't go back to progressing.\n                        return;\n                    }\n                    const newState = 2 /* BackgroundTokenizationState.Completed */;\n                    this._backgroundTokenizationState = newState;\n                    this._onDidChangeBackgroundTokenizationState.fire();\n                },\n                setEndState: (lineNumber, state) => {\n                    var _a;\n                    if (!this._tokenizer) {\n                        return;\n                    }\n                    const firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();\n                    // Don't accept states for definitely valid states, the renderer is ahead of the worker!\n                    if (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {\n                        (_a = this._tokenizer) === null || _a === void 0 ? void 0 : _a.store.setEndState(lineNumber, state);\n                    }\n                },\n            };\n            if (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {\n                this._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);\n            }\n            if (!this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization()) {\n                this._backgroundTokenizer.value = this._defaultBackgroundTokenizer =\n                    new DefaultBackgroundTokenizer(this._tokenizer, b);\n                this._defaultBackgroundTokenizer.handleChanges();\n            }\n            if ((tokenizationSupport === null || tokenizationSupport === void 0 ? void 0 : tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) && tokenizationSupport.createBackgroundTokenizer) {\n                this._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);\n                this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n                this._debugBackgroundTokenizer.clear();\n                this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {\n                    setTokens: (tokens) => {\n                        var _a;\n                        (_a = this._debugBackgroundTokens) === null || _a === void 0 ? void 0 : _a.setMultilineTokens(tokens, this._textModel);\n                    },\n                    backgroundTokenizationFinished() {\n                        // NO OP\n                    },\n                    setEndState: (lineNumber, state) => {\n                        var _a;\n                        (_a = this._debugBackgroundStates) === null || _a === void 0 ? void 0 : _a.setEndState(lineNumber, state);\n                    },\n                });\n            }\n            else {\n                this._debugBackgroundTokens = undefined;\n                this._debugBackgroundStates = undefined;\n                this._debugBackgroundTokenizer.value = undefined;\n            }\n        }\n        this.refreshAllVisibleLineTokens();\n    }\n    handleDidChangeAttached() {\n        var _a;\n        (_a = this._defaultBackgroundTokenizer) === null || _a === void 0 ? void 0 : _a.handleChanges();\n    }\n    handleDidChangeContent(e) {\n        var _a, _b, _c;\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength] = countEOL(c.text);\n                this._tokens.acceptEdit(c.range, eolCount, firstLineLength);\n                (_a = this._debugBackgroundTokens) === null || _a === void 0 ? void 0 : _a.acceptEdit(c.range, eolCount, firstLineLength);\n            }\n            (_b = this._debugBackgroundStates) === null || _b === void 0 ? void 0 : _b.acceptChanges(e.changes);\n            if (this._tokenizer) {\n                this._tokenizer.store.acceptChanges(e.changes);\n            }\n            (_c = this._defaultBackgroundTokenizer) === null || _c === void 0 ? void 0 : _c.handleChanges();\n        }\n    }\n    setTokens(tokens) {\n        const { changes } = this._tokens.setMultilineTokens(tokens, this._textModel);\n        if (changes.length > 0) {\n            this._onDidChangeTokens.fire({ semanticTokensApplied: false, ranges: changes, });\n        }\n        return { changes: changes };\n    }\n    refreshAllVisibleLineTokens() {\n        const ranges = LineRange.joinMany([...this._attachedViewStates].map(([_, s]) => s.lineRanges));\n        this.refreshRanges(ranges);\n    }\n    refreshRanges(ranges) {\n        for (const range of ranges) {\n            this.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);\n        }\n    }\n    refreshRange(startLineNumber, endLineNumber) {\n        var _a, _b;\n        if (!this._tokenizer) {\n            return;\n        }\n        startLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));\n        endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n        const builder = new ContiguousMultilineTokensBuilder();\n        const { heuristicTokens } = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber);\n        const changedTokens = this.setTokens(builder.finalize());\n        if (heuristicTokens) {\n            // We overrode tokens with heuristically computed ones.\n            // Because old states might get reused (thus stopping invalidation),\n            // we have to explicitly request the tokens for the changed ranges again.\n            for (const c of changedTokens.changes) {\n                (_a = this._backgroundTokenizer.value) === null || _a === void 0 ? void 0 : _a.requestTokens(c.fromLineNumber, c.toLineNumber + 1);\n            }\n        }\n        (_b = this._defaultBackgroundTokenizer) === null || _b === void 0 ? void 0 : _b.checkFinished();\n    }\n    forceTokenization(lineNumber) {\n        var _a, _b;\n        const builder = new ContiguousMultilineTokensBuilder();\n        (_a = this._tokenizer) === null || _a === void 0 ? void 0 : _a.updateTokensUntilLine(builder, lineNumber);\n        this.setTokens(builder.finalize());\n        (_b = this._defaultBackgroundTokenizer) === null || _b === void 0 ? void 0 : _b.checkFinished();\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        if (this.isCheapToTokenize(lineNumber)) {\n            this.forceTokenization(lineNumber);\n        }\n    }\n    getLineTokens(lineNumber) {\n        var _a;\n        const lineText = this._textModel.getLineContent(lineNumber);\n        const result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n        if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {\n            if (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {\n                const backgroundResult = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n                if (!result.equals(backgroundResult) && ((_a = this._debugBackgroundTokenizer.value) === null || _a === void 0 ? void 0 : _a.reportMismatchingTokens)) {\n                    this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);\n                }\n            }\n        }\n        return result;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        if (!this._tokenizer) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        this.forceTokenization(position.lineNumber);\n        return this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        if (!this._tokenizer) {\n            return null;\n        }\n        const validatedPosition = this._textModel.validatePosition(position);\n        this.forceTokenization(validatedPosition.lineNumber);\n        return this._tokenizer.tokenizeLineWithEdit(validatedPosition, length, newText);\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n}\nclass AttachedViewHandler extends Disposable {\n    get lineRanges() { return this._lineRanges; }\n    constructor(_refreshTokens) {\n        super();\n        this._refreshTokens = _refreshTokens;\n        this.runner = this._register(new RunOnceScheduler(() => this.update(), 50));\n        this._computedLineRanges = [];\n        this._lineRanges = [];\n    }\n    update() {\n        if (equals(this._computedLineRanges, this._lineRanges, (a, b) => a.equals(b))) {\n            return;\n        }\n        this._computedLineRanges = this._lineRanges;\n        this._refreshTokens();\n    }\n    handleStateChange(state) {\n        this._lineRanges = state.visibleLineRanges;\n        if (state.stabilized) {\n            this.runner.cancel();\n            this.update();\n        }\n        else {\n            this.runner.schedule();\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}