{"ast":null,"code":"import _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { AtomicTabMoveOperations } from './cursorAtomicMoveOperations.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nexport var CursorPosition = /*#__PURE__*/_createClass(function CursorPosition(lineNumber, column, leftoverVisibleColumns) {\n  _classCallCheck(this, CursorPosition);\n  this._cursorPositionBrand = undefined;\n  this.lineNumber = lineNumber;\n  this.column = column;\n  this.leftoverVisibleColumns = leftoverVisibleColumns;\n});\nexport var MoveOperations = /*#__PURE__*/function () {\n  function MoveOperations() {\n    _classCallCheck(this, MoveOperations);\n  }\n  return _createClass(MoveOperations, null, [{\n    key: \"leftPosition\",\n    value: function leftPosition(model, position) {\n      if (position.column > model.getLineMinColumn(position.lineNumber)) {\n        return position.delta(undefined, -strings.prevCharLength(model.getLineContent(position.lineNumber), position.column - 1));\n      } else if (position.lineNumber > 1) {\n        var newLineNumber = position.lineNumber - 1;\n        return new Position(newLineNumber, model.getLineMaxColumn(newLineNumber));\n      } else {\n        return position;\n      }\n    }\n  }, {\n    key: \"leftPositionAtomicSoftTabs\",\n    value: function leftPositionAtomicSoftTabs(model, position, tabSize) {\n      if (position.column <= model.getLineIndentColumn(position.lineNumber)) {\n        var minColumn = model.getLineMinColumn(position.lineNumber);\n        var lineContent = model.getLineContent(position.lineNumber);\n        var newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 0 /* Direction.Left */);\n        if (newPosition !== -1 && newPosition + 1 >= minColumn) {\n          return new Position(position.lineNumber, newPosition + 1);\n        }\n      }\n      return this.leftPosition(model, position);\n    }\n  }, {\n    key: \"left\",\n    value: function left(config, model, position) {\n      var pos = config.stickyTabStops ? MoveOperations.leftPositionAtomicSoftTabs(model, position, config.tabSize) : MoveOperations.leftPosition(model, position);\n      return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    /**\n     * @param noOfColumns Must be either `1`\n     * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).\n    */\n  }, {\n    key: \"moveLeft\",\n    value: function moveLeft(config, model, cursor, inSelectionMode, noOfColumns) {\n      var lineNumber, column;\n      if (cursor.hasSelection() && !inSelectionMode) {\n        // If the user has a selection and does not want to extend it,\n        // put the cursor at the beginning of the selection.\n        lineNumber = cursor.selection.startLineNumber;\n        column = cursor.selection.startColumn;\n      } else {\n        // This has no effect if noOfColumns === 1.\n        // It is ok to do so in the half-line scenario.\n        var pos = cursor.position.delta(undefined, -(noOfColumns - 1));\n        // We clip the position before normalization, as normalization is not defined\n        // for possibly negative columns.\n        var normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 0 /* PositionAffinity.Left */);\n        var p = MoveOperations.left(config, model, normalizedPos);\n        lineNumber = p.lineNumber;\n        column = p.column;\n      }\n      return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    /**\n     * Adjusts the column so that it is within min/max of the line.\n    */\n  }, {\n    key: \"clipPositionColumn\",\n    value: function clipPositionColumn(position, model) {\n      return new Position(position.lineNumber, MoveOperations.clipRange(position.column, model.getLineMinColumn(position.lineNumber), model.getLineMaxColumn(position.lineNumber)));\n    }\n  }, {\n    key: \"clipRange\",\n    value: function clipRange(value, min, max) {\n      if (value < min) {\n        return min;\n      }\n      if (value > max) {\n        return max;\n      }\n      return value;\n    }\n  }, {\n    key: \"rightPosition\",\n    value: function rightPosition(model, lineNumber, column) {\n      if (column < model.getLineMaxColumn(lineNumber)) {\n        column = column + strings.nextCharLength(model.getLineContent(lineNumber), column - 1);\n      } else if (lineNumber < model.getLineCount()) {\n        lineNumber = lineNumber + 1;\n        column = model.getLineMinColumn(lineNumber);\n      }\n      return new Position(lineNumber, column);\n    }\n  }, {\n    key: \"rightPositionAtomicSoftTabs\",\n    value: function rightPositionAtomicSoftTabs(model, lineNumber, column, tabSize, indentSize) {\n      if (column < model.getLineIndentColumn(lineNumber)) {\n        var lineContent = model.getLineContent(lineNumber);\n        var newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 1 /* Direction.Right */);\n        if (newPosition !== -1) {\n          return new Position(lineNumber, newPosition + 1);\n        }\n      }\n      return this.rightPosition(model, lineNumber, column);\n    }\n  }, {\n    key: \"right\",\n    value: function right(config, model, position) {\n      var pos = config.stickyTabStops ? MoveOperations.rightPositionAtomicSoftTabs(model, position.lineNumber, position.column, config.tabSize, config.indentSize) : MoveOperations.rightPosition(model, position.lineNumber, position.column);\n      return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n  }, {\n    key: \"moveRight\",\n    value: function moveRight(config, model, cursor, inSelectionMode, noOfColumns) {\n      var lineNumber, column;\n      if (cursor.hasSelection() && !inSelectionMode) {\n        // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection\n        lineNumber = cursor.selection.endLineNumber;\n        column = cursor.selection.endColumn;\n      } else {\n        var pos = cursor.position.delta(undefined, noOfColumns - 1);\n        var normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 1 /* PositionAffinity.Right */);\n        var r = MoveOperations.right(config, model, normalizedPos);\n        lineNumber = r.lineNumber;\n        column = r.column;\n      }\n      return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n  }, {\n    key: \"vertical\",\n    value: function vertical(config, model, lineNumber, column, leftoverVisibleColumns, newLineNumber, allowMoveOnEdgeLine, normalizationAffinity) {\n      var currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n      var lineCount = model.getLineCount();\n      var wasOnFirstPosition = lineNumber === 1 && column === 1;\n      var wasOnLastPosition = lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber);\n      var wasAtEdgePosition = newLineNumber < lineNumber ? wasOnFirstPosition : wasOnLastPosition;\n      lineNumber = newLineNumber;\n      if (lineNumber < 1) {\n        lineNumber = 1;\n        if (allowMoveOnEdgeLine) {\n          column = model.getLineMinColumn(lineNumber);\n        } else {\n          column = Math.min(model.getLineMaxColumn(lineNumber), column);\n        }\n      } else if (lineNumber > lineCount) {\n        lineNumber = lineCount;\n        if (allowMoveOnEdgeLine) {\n          column = model.getLineMaxColumn(lineNumber);\n        } else {\n          column = Math.min(model.getLineMaxColumn(lineNumber), column);\n        }\n      } else {\n        column = config.columnFromVisibleColumn(model, lineNumber, currentVisibleColumn);\n      }\n      if (wasAtEdgePosition) {\n        leftoverVisibleColumns = 0;\n      } else {\n        leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n      }\n      if (normalizationAffinity !== undefined) {\n        var position = new Position(lineNumber, column);\n        var newPosition = model.normalizePosition(position, normalizationAffinity);\n        leftoverVisibleColumns = leftoverVisibleColumns + (column - newPosition.column);\n        lineNumber = newPosition.lineNumber;\n        column = newPosition.column;\n      }\n      return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n    }\n  }, {\n    key: \"down\",\n    value: function down(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {\n      return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber + count, allowMoveOnLastLine, 4 /* PositionAffinity.RightOfInjectedText */);\n    }\n  }, {\n    key: \"moveDown\",\n    value: function moveDown(config, model, cursor, inSelectionMode, linesCount) {\n      var lineNumber, column;\n      if (cursor.hasSelection() && !inSelectionMode) {\n        // If we are in selection mode, move down acts relative to the end of selection\n        lineNumber = cursor.selection.endLineNumber;\n        column = cursor.selection.endColumn;\n      } else {\n        lineNumber = cursor.position.lineNumber;\n        column = cursor.position.column;\n      }\n      var i = 0;\n      var r;\n      do {\n        r = MoveOperations.down(config, model, lineNumber + i, column, cursor.leftoverVisibleColumns, linesCount, true);\n        var np = model.normalizePosition(new Position(r.lineNumber, r.column), 2 /* PositionAffinity.None */);\n        if (np.lineNumber > lineNumber) {\n          break;\n        }\n      } while (i++ < 10 && lineNumber + i < model.getLineCount());\n      return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n  }, {\n    key: \"translateDown\",\n    value: function translateDown(config, model, cursor) {\n      var selection = cursor.selection;\n      var selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n      var position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n      return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n  }, {\n    key: \"up\",\n    value: function up(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {\n      return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber - count, allowMoveOnFirstLine, 3 /* PositionAffinity.LeftOfInjectedText */);\n    }\n  }, {\n    key: \"moveUp\",\n    value: function moveUp(config, model, cursor, inSelectionMode, linesCount) {\n      var lineNumber, column;\n      if (cursor.hasSelection() && !inSelectionMode) {\n        // If we are in selection mode, move up acts relative to the beginning of selection\n        lineNumber = cursor.selection.startLineNumber;\n        column = cursor.selection.startColumn;\n      } else {\n        lineNumber = cursor.position.lineNumber;\n        column = cursor.position.column;\n      }\n      var r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n      return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n  }, {\n    key: \"translateUp\",\n    value: function translateUp(config, model, cursor) {\n      var selection = cursor.selection;\n      var selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n      var position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n      return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n  }, {\n    key: \"_isBlankLine\",\n    value: function _isBlankLine(model, lineNumber) {\n      if (model.getLineFirstNonWhitespaceColumn(lineNumber) === 0) {\n        // empty or contains only whitespace\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"moveToPrevBlankLine\",\n    value: function moveToPrevBlankLine(config, model, cursor, inSelectionMode) {\n      var lineNumber = cursor.position.lineNumber;\n      // If our current line is blank, move to the previous non-blank line\n      while (lineNumber > 1 && this._isBlankLine(model, lineNumber)) {\n        lineNumber--;\n      }\n      // Find the previous blank line\n      while (lineNumber > 1 && !this._isBlankLine(model, lineNumber)) {\n        lineNumber--;\n      }\n      return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n  }, {\n    key: \"moveToNextBlankLine\",\n    value: function moveToNextBlankLine(config, model, cursor, inSelectionMode) {\n      var lineCount = model.getLineCount();\n      var lineNumber = cursor.position.lineNumber;\n      // If our current line is blank, move to the next non-blank line\n      while (lineNumber < lineCount && this._isBlankLine(model, lineNumber)) {\n        lineNumber++;\n      }\n      // Find the next blank line\n      while (lineNumber < lineCount && !this._isBlankLine(model, lineNumber)) {\n        lineNumber++;\n      }\n      return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n  }, {\n    key: \"moveToBeginningOfLine\",\n    value: function moveToBeginningOfLine(config, model, cursor, inSelectionMode) {\n      var lineNumber = cursor.position.lineNumber;\n      var minColumn = model.getLineMinColumn(lineNumber);\n      var firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;\n      var column;\n      var relevantColumnNumber = cursor.position.column;\n      if (relevantColumnNumber === firstNonBlankColumn) {\n        column = minColumn;\n      } else {\n        column = firstNonBlankColumn;\n      }\n      return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n  }, {\n    key: \"moveToEndOfLine\",\n    value: function moveToEndOfLine(config, model, cursor, inSelectionMode, sticky) {\n      var lineNumber = cursor.position.lineNumber;\n      var maxColumn = model.getLineMaxColumn(lineNumber);\n      return cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */ - maxColumn : 0);\n    }\n  }, {\n    key: \"moveToBeginningOfBuffer\",\n    value: function moveToBeginningOfBuffer(config, model, cursor, inSelectionMode) {\n      return cursor.move(inSelectionMode, 1, 1, 0);\n    }\n  }, {\n    key: \"moveToEndOfBuffer\",\n    value: function moveToEndOfBuffer(config, model, cursor, inSelectionMode) {\n      var lastLineNumber = model.getLineCount();\n      var lastColumn = model.getLineMaxColumn(lastLineNumber);\n      return cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);\n    }\n  }]);\n}();","map":{"version":3,"names":["strings","CursorColumns","Position","Range","AtomicTabMoveOperations","SingleCursorState","CursorPosition","_createClass","lineNumber","column","leftoverVisibleColumns","_classCallCheck","_cursorPositionBrand","undefined","MoveOperations","key","value","leftPosition","model","position","getLineMinColumn","delta","prevCharLength","getLineContent","newLineNumber","getLineMaxColumn","leftPositionAtomicSoftTabs","tabSize","getLineIndentColumn","minColumn","lineContent","newPosition","atomicPosition","left","config","pos","stickyTabStops","moveLeft","cursor","inSelectionMode","noOfColumns","hasSelection","selection","startLineNumber","startColumn","normalizedPos","normalizePosition","clipPositionColumn","p","move","clipRange","min","max","rightPosition","nextCharLength","getLineCount","rightPositionAtomicSoftTabs","indentSize","right","moveRight","endLineNumber","endColumn","r","vertical","allowMoveOnEdgeLine","normalizationAffinity","currentVisibleColumn","visibleColumnFromColumn","lineCount","wasOnFirstPosition","wasOnLastPosition","wasAtEdgePosition","Math","columnFromVisibleColumn","down","count","allowMoveOnLastLine","moveDown","linesCount","i","np","translateDown","selectionStart","selectionStartLineNumber","selectionStartColumn","selectionStartLeftoverVisibleColumns","positionLineNumber","positionColumn","up","allowMoveOnFirstLine","moveUp","translateUp","_isBlankLine","getLineFirstNonWhitespaceColumn","moveToPrevBlankLine","moveToNextBlankLine","moveToBeginningOfLine","firstNonBlankColumn","relevantColumnNumber","moveToEndOfLine","sticky","maxColumn","moveToBeginningOfBuffer","moveToEndOfBuffer","lastLineNumber","lastColumn"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveOperations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { AtomicTabMoveOperations } from './cursorAtomicMoveOperations.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nexport class CursorPosition {\n    constructor(lineNumber, column, leftoverVisibleColumns) {\n        this._cursorPositionBrand = undefined;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n    }\n}\nexport class MoveOperations {\n    static leftPosition(model, position) {\n        if (position.column > model.getLineMinColumn(position.lineNumber)) {\n            return position.delta(undefined, -strings.prevCharLength(model.getLineContent(position.lineNumber), position.column - 1));\n        }\n        else if (position.lineNumber > 1) {\n            const newLineNumber = position.lineNumber - 1;\n            return new Position(newLineNumber, model.getLineMaxColumn(newLineNumber));\n        }\n        else {\n            return position;\n        }\n    }\n    static leftPositionAtomicSoftTabs(model, position, tabSize) {\n        if (position.column <= model.getLineIndentColumn(position.lineNumber)) {\n            const minColumn = model.getLineMinColumn(position.lineNumber);\n            const lineContent = model.getLineContent(position.lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 0 /* Direction.Left */);\n            if (newPosition !== -1 && newPosition + 1 >= minColumn) {\n                return new Position(position.lineNumber, newPosition + 1);\n            }\n        }\n        return this.leftPosition(model, position);\n    }\n    static left(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.leftPositionAtomicSoftTabs(model, position, config.tabSize)\n            : MoveOperations.leftPosition(model, position);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    /**\n     * @param noOfColumns Must be either `1`\n     * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).\n    */\n    static moveLeft(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If the user has a selection and does not want to extend it,\n            // put the cursor at the beginning of the selection.\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            // This has no effect if noOfColumns === 1.\n            // It is ok to do so in the half-line scenario.\n            const pos = cursor.position.delta(undefined, -(noOfColumns - 1));\n            // We clip the position before normalization, as normalization is not defined\n            // for possibly negative columns.\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 0 /* PositionAffinity.Left */);\n            const p = MoveOperations.left(config, model, normalizedPos);\n            lineNumber = p.lineNumber;\n            column = p.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    /**\n     * Adjusts the column so that it is within min/max of the line.\n    */\n    static clipPositionColumn(position, model) {\n        return new Position(position.lineNumber, MoveOperations.clipRange(position.column, model.getLineMinColumn(position.lineNumber), model.getLineMaxColumn(position.lineNumber)));\n    }\n    static clipRange(value, min, max) {\n        if (value < min) {\n            return min;\n        }\n        if (value > max) {\n            return max;\n        }\n        return value;\n    }\n    static rightPosition(model, lineNumber, column) {\n        if (column < model.getLineMaxColumn(lineNumber)) {\n            column = column + strings.nextCharLength(model.getLineContent(lineNumber), column - 1);\n        }\n        else if (lineNumber < model.getLineCount()) {\n            lineNumber = lineNumber + 1;\n            column = model.getLineMinColumn(lineNumber);\n        }\n        return new Position(lineNumber, column);\n    }\n    static rightPositionAtomicSoftTabs(model, lineNumber, column, tabSize, indentSize) {\n        if (column < model.getLineIndentColumn(lineNumber)) {\n            const lineContent = model.getLineContent(lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 1 /* Direction.Right */);\n            if (newPosition !== -1) {\n                return new Position(lineNumber, newPosition + 1);\n            }\n        }\n        return this.rightPosition(model, lineNumber, column);\n    }\n    static right(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.rightPositionAtomicSoftTabs(model, position.lineNumber, position.column, config.tabSize, config.indentSize)\n            : MoveOperations.rightPosition(model, position.lineNumber, position.column);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    static moveRight(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            const pos = cursor.position.delta(undefined, noOfColumns - 1);\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 1 /* PositionAffinity.Right */);\n            const r = MoveOperations.right(config, model, normalizedPos);\n            lineNumber = r.lineNumber;\n            column = r.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static vertical(config, model, lineNumber, column, leftoverVisibleColumns, newLineNumber, allowMoveOnEdgeLine, normalizationAffinity) {\n        const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n        const lineCount = model.getLineCount();\n        const wasOnFirstPosition = (lineNumber === 1 && column === 1);\n        const wasOnLastPosition = (lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber));\n        const wasAtEdgePosition = (newLineNumber < lineNumber ? wasOnFirstPosition : wasOnLastPosition);\n        lineNumber = newLineNumber;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMinColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else if (lineNumber > lineCount) {\n            lineNumber = lineCount;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else {\n            column = config.columnFromVisibleColumn(model, lineNumber, currentVisibleColumn);\n        }\n        if (wasAtEdgePosition) {\n            leftoverVisibleColumns = 0;\n        }\n        else {\n            leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n        }\n        if (normalizationAffinity !== undefined) {\n            const position = new Position(lineNumber, column);\n            const newPosition = model.normalizePosition(position, normalizationAffinity);\n            leftoverVisibleColumns = leftoverVisibleColumns + (column - newPosition.column);\n            lineNumber = newPosition.lineNumber;\n            column = newPosition.column;\n        }\n        return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n    }\n    static down(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber + count, allowMoveOnLastLine, 4 /* PositionAffinity.RightOfInjectedText */);\n    }\n    static moveDown(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move down acts relative to the end of selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        let i = 0;\n        let r;\n        do {\n            r = MoveOperations.down(config, model, lineNumber + i, column, cursor.leftoverVisibleColumns, linesCount, true);\n            const np = model.normalizePosition(new Position(r.lineNumber, r.column), 2 /* PositionAffinity.None */);\n            if (np.lineNumber > lineNumber) {\n                break;\n            }\n        } while (i++ < 10 && lineNumber + i < model.getLineCount());\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateDown(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static up(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber - count, allowMoveOnFirstLine, 3 /* PositionAffinity.LeftOfInjectedText */);\n    }\n    static moveUp(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move up acts relative to the beginning of selection\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        const r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateUp(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static _isBlankLine(model, lineNumber) {\n        if (model.getLineFirstNonWhitespaceColumn(lineNumber) === 0) {\n            // empty or contains only whitespace\n            return true;\n        }\n        return false;\n    }\n    static moveToPrevBlankLine(config, model, cursor, inSelectionMode) {\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the previous non-blank line\n        while (lineNumber > 1 && this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        // Find the previous blank line\n        while (lineNumber > 1 && !this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToNextBlankLine(config, model, cursor, inSelectionMode) {\n        const lineCount = model.getLineCount();\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the next non-blank line\n        while (lineNumber < lineCount && this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        // Find the next blank line\n        while (lineNumber < lineCount && !this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToBeginningOfLine(config, model, cursor, inSelectionMode) {\n        const lineNumber = cursor.position.lineNumber;\n        const minColumn = model.getLineMinColumn(lineNumber);\n        const firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;\n        let column;\n        const relevantColumnNumber = cursor.position.column;\n        if (relevantColumnNumber === firstNonBlankColumn) {\n            column = minColumn;\n        }\n        else {\n            column = firstNonBlankColumn;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static moveToEndOfLine(config, model, cursor, inSelectionMode, sticky) {\n        const lineNumber = cursor.position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        return cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */ - maxColumn : 0);\n    }\n    static moveToBeginningOfBuffer(config, model, cursor, inSelectionMode) {\n        return cursor.move(inSelectionMode, 1, 1, 0);\n    }\n    static moveToEndOfBuffer(config, model, cursor, inSelectionMode) {\n        const lastLineNumber = model.getLineCount();\n        const lastColumn = model.getLineMaxColumn(lastLineNumber);\n        return cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}