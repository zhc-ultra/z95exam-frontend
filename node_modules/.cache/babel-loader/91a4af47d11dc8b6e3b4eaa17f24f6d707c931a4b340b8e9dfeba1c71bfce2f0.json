{"ast":null,"code":"import _callSuper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _typeof from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.create.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.reflect.to-string-tag.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.string.search.js\";\nimport \"core-js/modules/es.string.substr.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar MonarchTokenizer_1;\n/**\n * Create a syntax highighter with a fully declarative JSON style lexer description\n * using regular expressions.\n */\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport * as languages from '../../../common/languages.js';\nimport { NullState, nullTokenizeEncoded, nullTokenize } from '../../../common/languages/nullTokenize.js';\nimport * as monarchCommon from './monarchCommon.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nvar CACHE_STACK_DEPTH = 5;\n/**\n * Reuse the same stack elements up to a certain depth.\n */\nvar MonarchStackElementFactory = /*#__PURE__*/function () {\n  function MonarchStackElementFactory(maxCacheDepth) {\n    _classCallCheck(this, MonarchStackElementFactory);\n    this._maxCacheDepth = maxCacheDepth;\n    this._entries = Object.create(null);\n  }\n  return _createClass(MonarchStackElementFactory, [{\n    key: \"create\",\n    value: function create(parent, state) {\n      if (parent !== null && parent.depth >= this._maxCacheDepth) {\n        // no caching above a certain depth\n        return new MonarchStackElement(parent, state);\n      }\n      var stackElementId = MonarchStackElement.getStackElementId(parent);\n      if (stackElementId.length > 0) {\n        stackElementId += '|';\n      }\n      stackElementId += state;\n      var result = this._entries[stackElementId];\n      if (result) {\n        return result;\n      }\n      result = new MonarchStackElement(parent, state);\n      this._entries[stackElementId] = result;\n      return result;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(parent, state) {\n      return this._INSTANCE.create(parent, state);\n    }\n  }]);\n}();\nMonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);\nvar MonarchStackElement = /*#__PURE__*/function () {\n  function MonarchStackElement(parent, state) {\n    _classCallCheck(this, MonarchStackElement);\n    this.parent = parent;\n    this.state = state;\n    this.depth = (this.parent ? this.parent.depth : 0) + 1;\n  }\n  return _createClass(MonarchStackElement, [{\n    key: \"equals\",\n    value: function equals(other) {\n      return MonarchStackElement._equals(this, other);\n    }\n  }, {\n    key: \"push\",\n    value: function push(state) {\n      return MonarchStackElementFactory.create(this, state);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      return this.parent;\n    }\n  }, {\n    key: \"popall\",\n    value: function popall() {\n      var result = this;\n      while (result.parent) {\n        result = result.parent;\n      }\n      return result;\n    }\n  }, {\n    key: \"switchTo\",\n    value: function switchTo(state) {\n      return MonarchStackElementFactory.create(this.parent, state);\n    }\n  }], [{\n    key: \"getStackElementId\",\n    value: function getStackElementId(element) {\n      var result = '';\n      while (element !== null) {\n        if (result.length > 0) {\n          result += '|';\n        }\n        result += element.state;\n        element = element.parent;\n      }\n      return result;\n    }\n  }, {\n    key: \"_equals\",\n    value: function _equals(a, b) {\n      while (a !== null && b !== null) {\n        if (a === b) {\n          return true;\n        }\n        if (a.state !== b.state) {\n          return false;\n        }\n        a = a.parent;\n        b = b.parent;\n      }\n      if (a === null && b === null) {\n        return true;\n      }\n      return false;\n    }\n  }]);\n}();\nvar EmbeddedLanguageData = /*#__PURE__*/function () {\n  function EmbeddedLanguageData(languageId, state) {\n    _classCallCheck(this, EmbeddedLanguageData);\n    this.languageId = languageId;\n    this.state = state;\n  }\n  return _createClass(EmbeddedLanguageData, [{\n    key: \"equals\",\n    value: function equals(other) {\n      return this.languageId === other.languageId && this.state.equals(other.state);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var stateClone = this.state.clone();\n      // save an object\n      if (stateClone === this.state) {\n        return this;\n      }\n      return new EmbeddedLanguageData(this.languageId, this.state);\n    }\n  }]);\n}();\n/**\n * Reuse the same line states up to a certain depth.\n */\nvar MonarchLineStateFactory = /*#__PURE__*/function () {\n  function MonarchLineStateFactory(maxCacheDepth) {\n    _classCallCheck(this, MonarchLineStateFactory);\n    this._maxCacheDepth = maxCacheDepth;\n    this._entries = Object.create(null);\n  }\n  return _createClass(MonarchLineStateFactory, [{\n    key: \"create\",\n    value: function create(stack, embeddedLanguageData) {\n      if (embeddedLanguageData !== null) {\n        // no caching when embedding\n        return new MonarchLineState(stack, embeddedLanguageData);\n      }\n      if (stack !== null && stack.depth >= this._maxCacheDepth) {\n        // no caching above a certain depth\n        return new MonarchLineState(stack, embeddedLanguageData);\n      }\n      var stackElementId = MonarchStackElement.getStackElementId(stack);\n      var result = this._entries[stackElementId];\n      if (result) {\n        return result;\n      }\n      result = new MonarchLineState(stack, null);\n      this._entries[stackElementId] = result;\n      return result;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(stack, embeddedLanguageData) {\n      return this._INSTANCE.create(stack, embeddedLanguageData);\n    }\n  }]);\n}();\nMonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);\nvar MonarchLineState = /*#__PURE__*/function () {\n  function MonarchLineState(stack, embeddedLanguageData) {\n    _classCallCheck(this, MonarchLineState);\n    this.stack = stack;\n    this.embeddedLanguageData = embeddedLanguageData;\n  }\n  return _createClass(MonarchLineState, [{\n    key: \"clone\",\n    value: function clone() {\n      var embeddedlanguageDataClone = this.embeddedLanguageData ? this.embeddedLanguageData.clone() : null;\n      // save an object\n      if (embeddedlanguageDataClone === this.embeddedLanguageData) {\n        return this;\n      }\n      return MonarchLineStateFactory.create(this.stack, this.embeddedLanguageData);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (!(other instanceof MonarchLineState)) {\n        return false;\n      }\n      if (!this.stack.equals(other.stack)) {\n        return false;\n      }\n      if (this.embeddedLanguageData === null && other.embeddedLanguageData === null) {\n        return true;\n      }\n      if (this.embeddedLanguageData === null || other.embeddedLanguageData === null) {\n        return false;\n      }\n      return this.embeddedLanguageData.equals(other.embeddedLanguageData);\n    }\n  }]);\n}();\nvar MonarchClassicTokensCollector = /*#__PURE__*/function () {\n  function MonarchClassicTokensCollector() {\n    _classCallCheck(this, MonarchClassicTokensCollector);\n    this._tokens = [];\n    this._languageId = null;\n    this._lastTokenType = null;\n    this._lastTokenLanguage = null;\n  }\n  return _createClass(MonarchClassicTokensCollector, [{\n    key: \"enterLanguage\",\n    value: function enterLanguage(languageId) {\n      this._languageId = languageId;\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(startOffset, type) {\n      if (this._lastTokenType === type && this._lastTokenLanguage === this._languageId) {\n        return;\n      }\n      this._lastTokenType = type;\n      this._lastTokenLanguage = this._languageId;\n      this._tokens.push(new languages.Token(startOffset, type, this._languageId));\n    }\n  }, {\n    key: \"nestedLanguageTokenize\",\n    value: function nestedLanguageTokenize(embeddedLanguageLine, hasEOL, embeddedLanguageData, offsetDelta) {\n      var nestedLanguageId = embeddedLanguageData.languageId;\n      var embeddedModeState = embeddedLanguageData.state;\n      var nestedLanguageTokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n      if (!nestedLanguageTokenizationSupport) {\n        this.enterLanguage(nestedLanguageId);\n        this.emit(offsetDelta, '');\n        return embeddedModeState;\n      }\n      var nestedResult = nestedLanguageTokenizationSupport.tokenize(embeddedLanguageLine, hasEOL, embeddedModeState);\n      if (offsetDelta !== 0) {\n        var _iterator = _createForOfIteratorHelper(nestedResult.tokens),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var token = _step.value;\n            this._tokens.push(new languages.Token(token.offset + offsetDelta, token.type, token.language));\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        this._tokens = this._tokens.concat(nestedResult.tokens);\n      }\n      this._lastTokenType = null;\n      this._lastTokenLanguage = null;\n      this._languageId = null;\n      return nestedResult.endState;\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize(endState) {\n      return new languages.TokenizationResult(this._tokens, endState);\n    }\n  }]);\n}();\nvar MonarchModernTokensCollector = /*#__PURE__*/function () {\n  function MonarchModernTokensCollector(languageService, theme) {\n    _classCallCheck(this, MonarchModernTokensCollector);\n    this._languageService = languageService;\n    this._theme = theme;\n    this._prependTokens = null;\n    this._tokens = [];\n    this._currentLanguageId = 0 /* LanguageId.Null */;\n    this._lastTokenMetadata = 0;\n  }\n  return _createClass(MonarchModernTokensCollector, [{\n    key: \"enterLanguage\",\n    value: function enterLanguage(languageId) {\n      this._currentLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(startOffset, type) {\n      var metadata = this._theme.match(this._currentLanguageId, type) | 1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */;\n      if (this._lastTokenMetadata === metadata) {\n        return;\n      }\n      this._lastTokenMetadata = metadata;\n      this._tokens.push(startOffset);\n      this._tokens.push(metadata);\n    }\n  }, {\n    key: \"nestedLanguageTokenize\",\n    value: function nestedLanguageTokenize(embeddedLanguageLine, hasEOL, embeddedLanguageData, offsetDelta) {\n      var nestedLanguageId = embeddedLanguageData.languageId;\n      var embeddedModeState = embeddedLanguageData.state;\n      var nestedLanguageTokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n      if (!nestedLanguageTokenizationSupport) {\n        this.enterLanguage(nestedLanguageId);\n        this.emit(offsetDelta, '');\n        return embeddedModeState;\n      }\n      var nestedResult = nestedLanguageTokenizationSupport.tokenizeEncoded(embeddedLanguageLine, hasEOL, embeddedModeState);\n      if (offsetDelta !== 0) {\n        for (var i = 0, len = nestedResult.tokens.length; i < len; i += 2) {\n          nestedResult.tokens[i] += offsetDelta;\n        }\n      }\n      this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);\n      this._tokens = [];\n      this._currentLanguageId = 0;\n      this._lastTokenMetadata = 0;\n      return nestedResult.endState;\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize(endState) {\n      return new languages.EncodedTokenizationResult(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);\n    }\n  }], [{\n    key: \"_merge\",\n    value: function _merge(a, b, c) {\n      var aLen = a !== null ? a.length : 0;\n      var bLen = b.length;\n      var cLen = c !== null ? c.length : 0;\n      if (aLen === 0 && bLen === 0 && cLen === 0) {\n        return new Uint32Array(0);\n      }\n      if (aLen === 0 && bLen === 0) {\n        return c;\n      }\n      if (bLen === 0 && cLen === 0) {\n        return a;\n      }\n      var result = new Uint32Array(aLen + bLen + cLen);\n      if (a !== null) {\n        result.set(a);\n      }\n      for (var i = 0; i < bLen; i++) {\n        result[aLen + i] = b[i];\n      }\n      if (c !== null) {\n        result.set(c, aLen + bLen);\n      }\n      return result;\n    }\n  }]);\n}();\nvar MonarchTokenizer = MonarchTokenizer_1 = /*#__PURE__*/function (_Disposable) {\n  function MonarchTokenizer(languageService, standaloneThemeService, languageId, lexer, _configurationService) {\n    var _this;\n    _classCallCheck(this, MonarchTokenizer);\n    _this = _callSuper(this, MonarchTokenizer);\n    _this._configurationService = _configurationService;\n    _this._languageService = languageService;\n    _this._standaloneThemeService = standaloneThemeService;\n    _this._languageId = languageId;\n    _this._lexer = lexer;\n    _this._embeddedLanguages = Object.create(null);\n    _this.embeddedLoaded = Promise.resolve(undefined);\n    // Set up listening for embedded modes\n    var emitting = false;\n    _this._register(languages.TokenizationRegistry.onDidChange(function (e) {\n      if (emitting) {\n        return;\n      }\n      var isOneOfMyEmbeddedModes = false;\n      for (var i = 0, len = e.changedLanguages.length; i < len; i++) {\n        var language = e.changedLanguages[i];\n        if (_this._embeddedLanguages[language]) {\n          isOneOfMyEmbeddedModes = true;\n          break;\n        }\n      }\n      if (isOneOfMyEmbeddedModes) {\n        emitting = true;\n        languages.TokenizationRegistry.handleChange([_this._languageId]);\n        emitting = false;\n      }\n    }));\n    _this._maxTokenizationLineLength = _this._configurationService.getValue('editor.maxTokenizationLineLength', {\n      overrideIdentifier: _this._languageId\n    });\n    _this._register(_this._configurationService.onDidChangeConfiguration(function (e) {\n      if (e.affectsConfiguration('editor.maxTokenizationLineLength')) {\n        _this._maxTokenizationLineLength = _this._configurationService.getValue('editor.maxTokenizationLineLength', {\n          overrideIdentifier: _this._languageId\n        });\n      }\n    }));\n    return _this;\n  }\n  _inherits(MonarchTokenizer, _Disposable);\n  return _createClass(MonarchTokenizer, [{\n    key: \"getLoadStatus\",\n    value: function getLoadStatus() {\n      var promises = [];\n      for (var nestedLanguageId in this._embeddedLanguages) {\n        var tokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n        if (tokenizationSupport) {\n          // The nested language is already loaded\n          if (tokenizationSupport instanceof MonarchTokenizer_1) {\n            var nestedModeStatus = tokenizationSupport.getLoadStatus();\n            if (nestedModeStatus.loaded === false) {\n              promises.push(nestedModeStatus.promise);\n            }\n          }\n          continue;\n        }\n        if (!languages.TokenizationRegistry.isResolved(nestedLanguageId)) {\n          // The nested language is in the process of being loaded\n          promises.push(languages.TokenizationRegistry.getOrCreate(nestedLanguageId));\n        }\n      }\n      if (promises.length === 0) {\n        return {\n          loaded: true\n        };\n      }\n      return {\n        loaded: false,\n        promise: Promise.all(promises).then(function (_) {\n          return undefined;\n        })\n      };\n    }\n  }, {\n    key: \"getInitialState\",\n    value: function getInitialState() {\n      var rootState = MonarchStackElementFactory.create(null, this._lexer.start);\n      return MonarchLineStateFactory.create(rootState, null);\n    }\n  }, {\n    key: \"tokenize\",\n    value: function tokenize(line, hasEOL, lineState) {\n      if (line.length >= this._maxTokenizationLineLength) {\n        return nullTokenize(this._languageId, lineState);\n      }\n      var tokensCollector = new MonarchClassicTokensCollector();\n      var endLineState = this._tokenize(line, hasEOL, lineState, tokensCollector);\n      return tokensCollector.finalize(endLineState);\n    }\n  }, {\n    key: \"tokenizeEncoded\",\n    value: function tokenizeEncoded(line, hasEOL, lineState) {\n      if (line.length >= this._maxTokenizationLineLength) {\n        return nullTokenizeEncoded(this._languageService.languageIdCodec.encodeLanguageId(this._languageId), lineState);\n      }\n      var tokensCollector = new MonarchModernTokensCollector(this._languageService, this._standaloneThemeService.getColorTheme().tokenTheme);\n      var endLineState = this._tokenize(line, hasEOL, lineState, tokensCollector);\n      return tokensCollector.finalize(endLineState);\n    }\n  }, {\n    key: \"_tokenize\",\n    value: function _tokenize(line, hasEOL, lineState, collector) {\n      if (lineState.embeddedLanguageData) {\n        return this._nestedTokenize(line, hasEOL, lineState, 0, collector);\n      } else {\n        return this._myTokenize(line, hasEOL, lineState, 0, collector);\n      }\n    }\n  }, {\n    key: \"_findLeavingNestedLanguageOffset\",\n    value: function _findLeavingNestedLanguageOffset(line, state) {\n      var rules = this._lexer.tokenizer[state.stack.state];\n      if (!rules) {\n        rules = monarchCommon.findRules(this._lexer, state.stack.state); // do parent matching\n        if (!rules) {\n          throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);\n        }\n      }\n      var popOffset = -1;\n      var hasEmbeddedPopRule = false;\n      var _iterator2 = _createForOfIteratorHelper(rules),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var rule = _step2.value;\n          if (!monarchCommon.isIAction(rule.action) || rule.action.nextEmbedded !== '@pop') {\n            continue;\n          }\n          hasEmbeddedPopRule = true;\n          var regex = rule.resolveRegex(state.stack.state);\n          var regexSource = regex.source;\n          if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {\n            var flags = (regex.ignoreCase ? 'i' : '') + (regex.unicode ? 'u' : '');\n            regex = new RegExp(regexSource.substr(4, regexSource.length - 5), flags);\n          }\n          var result = line.search(regex);\n          if (result === -1 || result !== 0 && rule.matchOnlyAtLineStart) {\n            continue;\n          }\n          if (popOffset === -1 || result < popOffset) {\n            popOffset = result;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      if (!hasEmbeddedPopRule) {\n        throw monarchCommon.createError(this._lexer, 'no rule containing nextEmbedded: \"@pop\" in tokenizer embedded state: ' + state.stack.state);\n      }\n      return popOffset;\n    }\n  }, {\n    key: \"_nestedTokenize\",\n    value: function _nestedTokenize(line, hasEOL, lineState, offsetDelta, tokensCollector) {\n      var popOffset = this._findLeavingNestedLanguageOffset(line, lineState);\n      if (popOffset === -1) {\n        // tokenization will not leave nested language\n        var nestedEndState = tokensCollector.nestedLanguageTokenize(line, hasEOL, lineState.embeddedLanguageData, offsetDelta);\n        return MonarchLineStateFactory.create(lineState.stack, new EmbeddedLanguageData(lineState.embeddedLanguageData.languageId, nestedEndState));\n      }\n      var nestedLanguageLine = line.substring(0, popOffset);\n      if (nestedLanguageLine.length > 0) {\n        // tokenize with the nested language\n        tokensCollector.nestedLanguageTokenize(nestedLanguageLine, false, lineState.embeddedLanguageData, offsetDelta);\n      }\n      var restOfTheLine = line.substring(popOffset);\n      return this._myTokenize(restOfTheLine, hasEOL, lineState, offsetDelta + popOffset, tokensCollector);\n    }\n  }, {\n    key: \"_safeRuleName\",\n    value: function _safeRuleName(rule) {\n      if (rule) {\n        return rule.name;\n      }\n      return '(unknown)';\n    }\n  }, {\n    key: \"_myTokenize\",\n    value: function _myTokenize(lineWithoutLF, hasEOL, lineState, offsetDelta, tokensCollector) {\n      var _this2 = this;\n      tokensCollector.enterLanguage(this._languageId);\n      var lineWithoutLFLength = lineWithoutLF.length;\n      var line = hasEOL && this._lexer.includeLF ? lineWithoutLF + '\\n' : lineWithoutLF;\n      var lineLength = line.length;\n      var embeddedLanguageData = lineState.embeddedLanguageData;\n      var stack = lineState.stack;\n      var pos = 0;\n      var groupMatching = null;\n      // See https://github.com/microsoft/monaco-editor/issues/1235\n      // Evaluate rules at least once for an empty line\n      var forceEvaluation = true;\n      while (forceEvaluation || pos < lineLength) {\n        var pos0 = pos;\n        var stackLen0 = stack.depth;\n        var groupLen0 = groupMatching ? groupMatching.groups.length : 0;\n        var state = stack.state;\n        var matches = null;\n        var matched = null;\n        var action = null;\n        var rule = null;\n        var enteringEmbeddedLanguage = null;\n        // check if we need to process group matches first\n        if (groupMatching) {\n          matches = groupMatching.matches;\n          var groupEntry = groupMatching.groups.shift();\n          matched = groupEntry.matched;\n          action = groupEntry.action;\n          rule = groupMatching.rule;\n          // cleanup if necessary\n          if (groupMatching.groups.length === 0) {\n            groupMatching = null;\n          }\n        } else {\n          // otherwise we match on the token stream\n          if (!forceEvaluation && pos >= lineLength) {\n            // nothing to do\n            break;\n          }\n          forceEvaluation = false;\n          // get the rules for this state\n          var rules = this._lexer.tokenizer[state];\n          if (!rules) {\n            rules = monarchCommon.findRules(this._lexer, state); // do parent matching\n            if (!rules) {\n              throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state);\n            }\n          }\n          // try each rule until we match\n          var restOfLine = line.substr(pos);\n          var _iterator3 = _createForOfIteratorHelper(rules),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _rule = _step3.value;\n              if (pos === 0 || !_rule.matchOnlyAtLineStart) {\n                matches = restOfLine.match(_rule.resolveRegex(state));\n                if (matches) {\n                  matched = matches[0];\n                  action = _rule.action;\n                  break;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n        // We matched 'rule' with 'matches' and 'action'\n        if (!matches) {\n          matches = [''];\n          matched = '';\n        }\n        if (!action) {\n          // bad: we didn't match anything, and there is no action to take\n          // we need to advance the stream or we get progress trouble\n          if (pos < lineLength) {\n            matches = [line.charAt(pos)];\n            matched = matches[0];\n          }\n          action = this._lexer.defaultToken;\n        }\n        if (matched === null) {\n          // should never happen, needed for strict null checking\n          break;\n        }\n        // advance stream\n        pos += matched.length;\n        // maybe call action function (used for 'cases')\n        while (monarchCommon.isFuzzyAction(action) && monarchCommon.isIAction(action) && action.test) {\n          action = action.test(matched, matches, state, pos === lineLength);\n        }\n        var result = null;\n        // set the result: either a string or an array of actions\n        if (typeof action === 'string' || Array.isArray(action)) {\n          result = action;\n        } else if (action.group) {\n          result = action.group;\n        } else if (action.token !== null && action.token !== undefined) {\n          // do $n replacements?\n          if (action.tokenSubst) {\n            result = monarchCommon.substituteMatches(this._lexer, action.token, matched, matches, state);\n          } else {\n            result = action.token;\n          }\n          // enter embedded language?\n          if (action.nextEmbedded) {\n            if (action.nextEmbedded === '@pop') {\n              if (!embeddedLanguageData) {\n                throw monarchCommon.createError(this._lexer, 'cannot pop embedded language if not inside one');\n              }\n              embeddedLanguageData = null;\n            } else if (embeddedLanguageData) {\n              throw monarchCommon.createError(this._lexer, 'cannot enter embedded language from within an embedded language');\n            } else {\n              enteringEmbeddedLanguage = monarchCommon.substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);\n            }\n          }\n          // state transformations\n          if (action.goBack) {\n            // back up the stream..\n            pos = Math.max(0, pos - action.goBack);\n          }\n          if (action.switchTo && typeof action.switchTo === 'string') {\n            var nextState = monarchCommon.substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...\n            if (nextState[0] === '@') {\n              nextState = nextState.substr(1); // peel off starting '@'\n            }\n            if (!monarchCommon.findRules(this._lexer, nextState)) {\n              throw monarchCommon.createError(this._lexer, 'trying to switch to a state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n            } else {\n              stack = stack.switchTo(nextState);\n            }\n          } else if (action.transform && typeof action.transform === 'function') {\n            throw monarchCommon.createError(this._lexer, 'action.transform not supported');\n          } else if (action.next) {\n            if (action.next === '@push') {\n              if (stack.depth >= this._lexer.maxStack) {\n                throw monarchCommon.createError(this._lexer, 'maximum tokenizer stack size reached: [' + stack.state + ',' + stack.parent.state + ',...]');\n              } else {\n                stack = stack.push(state);\n              }\n            } else if (action.next === '@pop') {\n              if (stack.depth <= 1) {\n                throw monarchCommon.createError(this._lexer, 'trying to pop an empty stack in rule: ' + this._safeRuleName(rule));\n              } else {\n                stack = stack.pop();\n              }\n            } else if (action.next === '@popall') {\n              stack = stack.popall();\n            } else {\n              var _nextState = monarchCommon.substituteMatches(this._lexer, action.next, matched, matches, state);\n              if (_nextState[0] === '@') {\n                _nextState = _nextState.substr(1); // peel off starting '@'\n              }\n              if (!monarchCommon.findRules(this._lexer, _nextState)) {\n                throw monarchCommon.createError(this._lexer, 'trying to set a next state \\'' + _nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n              } else {\n                stack = stack.push(_nextState);\n              }\n            }\n          }\n          if (action.log && typeof action.log === 'string') {\n            monarchCommon.log(this._lexer, this._lexer.languageId + ': ' + monarchCommon.substituteMatches(this._lexer, action.log, matched, matches, state));\n          }\n        }\n        // check result\n        if (result === null) {\n          throw monarchCommon.createError(this._lexer, 'lexer rule has no well-defined action in rule: ' + this._safeRuleName(rule));\n        }\n        var computeNewStateForEmbeddedLanguage = function computeNewStateForEmbeddedLanguage(enteringEmbeddedLanguage) {\n          // support language names, mime types, and language ids\n          var languageId = _this2._languageService.getLanguageIdByLanguageName(enteringEmbeddedLanguage) || _this2._languageService.getLanguageIdByMimeType(enteringEmbeddedLanguage) || enteringEmbeddedLanguage;\n          var embeddedLanguageData = _this2._getNestedEmbeddedLanguageData(languageId);\n          if (pos < lineLength) {\n            // there is content from the embedded language on this line\n            var _restOfLine = lineWithoutLF.substr(pos);\n            return _this2._nestedTokenize(_restOfLine, hasEOL, MonarchLineStateFactory.create(stack, embeddedLanguageData), offsetDelta + pos, tokensCollector);\n          } else {\n            return MonarchLineStateFactory.create(stack, embeddedLanguageData);\n          }\n        };\n        // is the result a group match?\n        if (Array.isArray(result)) {\n          if (groupMatching && groupMatching.groups.length > 0) {\n            throw monarchCommon.createError(this._lexer, 'groups cannot be nested: ' + this._safeRuleName(rule));\n          }\n          if (matches.length !== result.length + 1) {\n            throw monarchCommon.createError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + this._safeRuleName(rule));\n          }\n          var totalLen = 0;\n          for (var i = 1; i < matches.length; i++) {\n            totalLen += matches[i].length;\n          }\n          if (totalLen !== matched.length) {\n            throw monarchCommon.createError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + this._safeRuleName(rule));\n          }\n          groupMatching = {\n            rule: rule,\n            matches: matches,\n            groups: []\n          };\n          for (var _i = 0; _i < result.length; _i++) {\n            groupMatching.groups[_i] = {\n              action: result[_i],\n              matched: matches[_i + 1]\n            };\n          }\n          pos -= matched.length;\n          // call recursively to initiate first result match\n          continue;\n        } else {\n          // regular result\n          // check for '@rematch'\n          if (result === '@rematch') {\n            pos -= matched.length;\n            matched = ''; // better set the next state too..\n            matches = null;\n            result = '';\n            // Even though `@rematch` was specified, if `nextEmbedded` also specified,\n            // a state transition should occur.\n            if (enteringEmbeddedLanguage !== null) {\n              return computeNewStateForEmbeddedLanguage(enteringEmbeddedLanguage);\n            }\n          }\n          // check progress\n          if (matched.length === 0) {\n            if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {\n              continue;\n            } else {\n              throw monarchCommon.createError(this._lexer, 'no progress in tokenizer in rule: ' + this._safeRuleName(rule));\n            }\n          }\n          // return the result (and check for brace matching)\n          // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions\n          var tokenType = null;\n          if (monarchCommon.isString(result) && result.indexOf('@brackets') === 0) {\n            var rest = result.substr('@brackets'.length);\n            var bracket = findBracket(this._lexer, matched);\n            if (!bracket) {\n              throw monarchCommon.createError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);\n            }\n            tokenType = monarchCommon.sanitize(bracket.token + rest);\n          } else {\n            var token = result === '' ? '' : result + this._lexer.tokenPostfix;\n            tokenType = monarchCommon.sanitize(token);\n          }\n          if (pos0 < lineWithoutLFLength) {\n            tokensCollector.emit(pos0 + offsetDelta, tokenType);\n          }\n        }\n        if (enteringEmbeddedLanguage !== null) {\n          return computeNewStateForEmbeddedLanguage(enteringEmbeddedLanguage);\n        }\n      }\n      return MonarchLineStateFactory.create(stack, embeddedLanguageData);\n    }\n  }, {\n    key: \"_getNestedEmbeddedLanguageData\",\n    value: function _getNestedEmbeddedLanguageData(languageId) {\n      if (!this._languageService.isRegisteredLanguageId(languageId)) {\n        return new EmbeddedLanguageData(languageId, NullState);\n      }\n      if (languageId !== this._languageId) {\n        // Fire language loading event\n        this._languageService.requestBasicLanguageFeatures(languageId);\n        languages.TokenizationRegistry.getOrCreate(languageId);\n        this._embeddedLanguages[languageId] = true;\n      }\n      var tokenizationSupport = languages.TokenizationRegistry.get(languageId);\n      if (tokenizationSupport) {\n        return new EmbeddedLanguageData(languageId, tokenizationSupport.getInitialState());\n      }\n      return new EmbeddedLanguageData(languageId, NullState);\n    }\n  }]);\n}(Disposable);\nMonarchTokenizer = MonarchTokenizer_1 = __decorate([__param(4, IConfigurationService)], MonarchTokenizer);\nexport { MonarchTokenizer };\n/**\n * Searches for a bracket in the 'brackets' attribute that matches the input.\n */\nfunction findBracket(lexer, matched) {\n  if (!matched) {\n    return null;\n  }\n  matched = monarchCommon.fixCase(lexer, matched);\n  var brackets = lexer.brackets;\n  var _iterator4 = _createForOfIteratorHelper(brackets),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var bracket = _step4.value;\n      if (bracket.open === matched) {\n        return {\n          token: bracket.token,\n          bracketType: 1 /* monarchCommon.MonarchBracket.Open */\n        };\n      } else if (bracket.close === matched) {\n        return {\n          token: bracket.token,\n          bracketType: -1 /* monarchCommon.MonarchBracket.Close */\n        };\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return null;\n}","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","_typeof","decorate","i","defineProperty","__param","paramIndex","decorator","MonarchTokenizer_1","Disposable","languages","NullState","nullTokenizeEncoded","nullTokenize","monarchCommon","IConfigurationService","CACHE_STACK_DEPTH","MonarchStackElementFactory","maxCacheDepth","_classCallCheck","_maxCacheDepth","_entries","create","_createClass","value","parent","state","depth","MonarchStackElement","stackElementId","getStackElementId","result","_INSTANCE","equals","other","_equals","push","pop","popall","switchTo","element","a","b","EmbeddedLanguageData","languageId","clone","stateClone","MonarchLineStateFactory","stack","embeddedLanguageData","MonarchLineState","embeddedlanguageDataClone","MonarchClassicTokensCollector","_tokens","_languageId","_lastTokenType","_lastTokenLanguage","enterLanguage","emit","startOffset","type","Token","nestedLanguageTokenize","embeddedLanguageLine","hasEOL","offsetDelta","nestedLanguageId","embeddedModeState","nestedLanguageTokenizationSupport","TokenizationRegistry","get","nestedResult","tokenize","_iterator","_createForOfIteratorHelper","tokens","_step","s","n","done","token","offset","language","err","e","f","concat","endState","finalize","TokenizationResult","MonarchModernTokensCollector","languageService","theme","_languageService","_theme","_prependTokens","_currentLanguageId","_lastTokenMetadata","languageIdCodec","encodeLanguageId","metadata","match","tokenizeEncoded","len","_merge","EncodedTokenizationResult","aLen","bLen","cLen","Uint32Array","set","MonarchTokenizer","_Disposable","standaloneThemeService","lexer","_configurationService","_this","_callSuper","_standaloneThemeService","_lexer","_embeddedLanguages","embeddedLoaded","Promise","resolve","undefined","emitting","_register","onDidChange","isOneOfMyEmbeddedModes","changedLanguages","handleChange","_maxTokenizationLineLength","getValue","overrideIdentifier","onDidChangeConfiguration","affectsConfiguration","_inherits","getLoadStatus","promises","tokenizationSupport","nestedModeStatus","loaded","promise","isResolved","getOrCreate","all","then","_","getInitialState","rootState","start","line","lineState","tokensCollector","endLineState","_tokenize","getColorTheme","tokenTheme","collector","_nestedTokenize","_myTokenize","_findLeavingNestedLanguageOffset","rules","tokenizer","findRules","createError","popOffset","hasEmbeddedPopRule","_iterator2","_step2","rule","isIAction","action","nextEmbedded","regex","resolveRegex","regexSource","source","substr","flags","ignoreCase","unicode","RegExp","search","matchOnlyAtLineStart","nestedEndState","nestedLanguageLine","substring","restOfTheLine","_safeRuleName","name","lineWithoutLF","_this2","lineWithoutLFLength","includeLF","lineLength","pos","groupMatching","forceEvaluation","pos0","stackLen0","groupLen0","groups","matches","matched","enteringEmbeddedLanguage","groupEntry","shift","restOfLine","_iterator3","_step3","charAt","defaultToken","isFuzzyAction","test","Array","isArray","group","tokenSubst","substituteMatches","goBack","Math","max","nextState","transform","next","maxStack","log","computeNewStateForEmbeddedLanguage","getLanguageIdByLanguageName","getLanguageIdByMimeType","_getNestedEmbeddedLanguageData","totalLen","tokenType","isString","indexOf","rest","bracket","findBracket","sanitize","tokenPostfix","isRegisteredLanguageId","requestBasicLanguageFeatures","fixCase","brackets","_iterator4","_step4","open","bracketType","close"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchLexer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar MonarchTokenizer_1;\n/**\n * Create a syntax highighter with a fully declarative JSON style lexer description\n * using regular expressions.\n */\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport * as languages from '../../../common/languages.js';\nimport { NullState, nullTokenizeEncoded, nullTokenize } from '../../../common/languages/nullTokenize.js';\nimport * as monarchCommon from './monarchCommon.js';\nimport { IConfigurationService } from '../../../../platform/configuration/common/configuration.js';\nconst CACHE_STACK_DEPTH = 5;\n/**\n * Reuse the same stack elements up to a certain depth.\n */\nclass MonarchStackElementFactory {\n    static create(parent, state) {\n        return this._INSTANCE.create(parent, state);\n    }\n    constructor(maxCacheDepth) {\n        this._maxCacheDepth = maxCacheDepth;\n        this._entries = Object.create(null);\n    }\n    create(parent, state) {\n        if (parent !== null && parent.depth >= this._maxCacheDepth) {\n            // no caching above a certain depth\n            return new MonarchStackElement(parent, state);\n        }\n        let stackElementId = MonarchStackElement.getStackElementId(parent);\n        if (stackElementId.length > 0) {\n            stackElementId += '|';\n        }\n        stackElementId += state;\n        let result = this._entries[stackElementId];\n        if (result) {\n            return result;\n        }\n        result = new MonarchStackElement(parent, state);\n        this._entries[stackElementId] = result;\n        return result;\n    }\n}\nMonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);\nclass MonarchStackElement {\n    constructor(parent, state) {\n        this.parent = parent;\n        this.state = state;\n        this.depth = (this.parent ? this.parent.depth : 0) + 1;\n    }\n    static getStackElementId(element) {\n        let result = '';\n        while (element !== null) {\n            if (result.length > 0) {\n                result += '|';\n            }\n            result += element.state;\n            element = element.parent;\n        }\n        return result;\n    }\n    static _equals(a, b) {\n        while (a !== null && b !== null) {\n            if (a === b) {\n                return true;\n            }\n            if (a.state !== b.state) {\n                return false;\n            }\n            a = a.parent;\n            b = b.parent;\n        }\n        if (a === null && b === null) {\n            return true;\n        }\n        return false;\n    }\n    equals(other) {\n        return MonarchStackElement._equals(this, other);\n    }\n    push(state) {\n        return MonarchStackElementFactory.create(this, state);\n    }\n    pop() {\n        return this.parent;\n    }\n    popall() {\n        let result = this;\n        while (result.parent) {\n            result = result.parent;\n        }\n        return result;\n    }\n    switchTo(state) {\n        return MonarchStackElementFactory.create(this.parent, state);\n    }\n}\nclass EmbeddedLanguageData {\n    constructor(languageId, state) {\n        this.languageId = languageId;\n        this.state = state;\n    }\n    equals(other) {\n        return (this.languageId === other.languageId\n            && this.state.equals(other.state));\n    }\n    clone() {\n        const stateClone = this.state.clone();\n        // save an object\n        if (stateClone === this.state) {\n            return this;\n        }\n        return new EmbeddedLanguageData(this.languageId, this.state);\n    }\n}\n/**\n * Reuse the same line states up to a certain depth.\n */\nclass MonarchLineStateFactory {\n    static create(stack, embeddedLanguageData) {\n        return this._INSTANCE.create(stack, embeddedLanguageData);\n    }\n    constructor(maxCacheDepth) {\n        this._maxCacheDepth = maxCacheDepth;\n        this._entries = Object.create(null);\n    }\n    create(stack, embeddedLanguageData) {\n        if (embeddedLanguageData !== null) {\n            // no caching when embedding\n            return new MonarchLineState(stack, embeddedLanguageData);\n        }\n        if (stack !== null && stack.depth >= this._maxCacheDepth) {\n            // no caching above a certain depth\n            return new MonarchLineState(stack, embeddedLanguageData);\n        }\n        const stackElementId = MonarchStackElement.getStackElementId(stack);\n        let result = this._entries[stackElementId];\n        if (result) {\n            return result;\n        }\n        result = new MonarchLineState(stack, null);\n        this._entries[stackElementId] = result;\n        return result;\n    }\n}\nMonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);\nclass MonarchLineState {\n    constructor(stack, embeddedLanguageData) {\n        this.stack = stack;\n        this.embeddedLanguageData = embeddedLanguageData;\n    }\n    clone() {\n        const embeddedlanguageDataClone = this.embeddedLanguageData ? this.embeddedLanguageData.clone() : null;\n        // save an object\n        if (embeddedlanguageDataClone === this.embeddedLanguageData) {\n            return this;\n        }\n        return MonarchLineStateFactory.create(this.stack, this.embeddedLanguageData);\n    }\n    equals(other) {\n        if (!(other instanceof MonarchLineState)) {\n            return false;\n        }\n        if (!this.stack.equals(other.stack)) {\n            return false;\n        }\n        if (this.embeddedLanguageData === null && other.embeddedLanguageData === null) {\n            return true;\n        }\n        if (this.embeddedLanguageData === null || other.embeddedLanguageData === null) {\n            return false;\n        }\n        return this.embeddedLanguageData.equals(other.embeddedLanguageData);\n    }\n}\nclass MonarchClassicTokensCollector {\n    constructor() {\n        this._tokens = [];\n        this._languageId = null;\n        this._lastTokenType = null;\n        this._lastTokenLanguage = null;\n    }\n    enterLanguage(languageId) {\n        this._languageId = languageId;\n    }\n    emit(startOffset, type) {\n        if (this._lastTokenType === type && this._lastTokenLanguage === this._languageId) {\n            return;\n        }\n        this._lastTokenType = type;\n        this._lastTokenLanguage = this._languageId;\n        this._tokens.push(new languages.Token(startOffset, type, this._languageId));\n    }\n    nestedLanguageTokenize(embeddedLanguageLine, hasEOL, embeddedLanguageData, offsetDelta) {\n        const nestedLanguageId = embeddedLanguageData.languageId;\n        const embeddedModeState = embeddedLanguageData.state;\n        const nestedLanguageTokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n        if (!nestedLanguageTokenizationSupport) {\n            this.enterLanguage(nestedLanguageId);\n            this.emit(offsetDelta, '');\n            return embeddedModeState;\n        }\n        const nestedResult = nestedLanguageTokenizationSupport.tokenize(embeddedLanguageLine, hasEOL, embeddedModeState);\n        if (offsetDelta !== 0) {\n            for (const token of nestedResult.tokens) {\n                this._tokens.push(new languages.Token(token.offset + offsetDelta, token.type, token.language));\n            }\n        }\n        else {\n            this._tokens = this._tokens.concat(nestedResult.tokens);\n        }\n        this._lastTokenType = null;\n        this._lastTokenLanguage = null;\n        this._languageId = null;\n        return nestedResult.endState;\n    }\n    finalize(endState) {\n        return new languages.TokenizationResult(this._tokens, endState);\n    }\n}\nclass MonarchModernTokensCollector {\n    constructor(languageService, theme) {\n        this._languageService = languageService;\n        this._theme = theme;\n        this._prependTokens = null;\n        this._tokens = [];\n        this._currentLanguageId = 0 /* LanguageId.Null */;\n        this._lastTokenMetadata = 0;\n    }\n    enterLanguage(languageId) {\n        this._currentLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);\n    }\n    emit(startOffset, type) {\n        const metadata = this._theme.match(this._currentLanguageId, type) | 1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */;\n        if (this._lastTokenMetadata === metadata) {\n            return;\n        }\n        this._lastTokenMetadata = metadata;\n        this._tokens.push(startOffset);\n        this._tokens.push(metadata);\n    }\n    static _merge(a, b, c) {\n        const aLen = (a !== null ? a.length : 0);\n        const bLen = b.length;\n        const cLen = (c !== null ? c.length : 0);\n        if (aLen === 0 && bLen === 0 && cLen === 0) {\n            return new Uint32Array(0);\n        }\n        if (aLen === 0 && bLen === 0) {\n            return c;\n        }\n        if (bLen === 0 && cLen === 0) {\n            return a;\n        }\n        const result = new Uint32Array(aLen + bLen + cLen);\n        if (a !== null) {\n            result.set(a);\n        }\n        for (let i = 0; i < bLen; i++) {\n            result[aLen + i] = b[i];\n        }\n        if (c !== null) {\n            result.set(c, aLen + bLen);\n        }\n        return result;\n    }\n    nestedLanguageTokenize(embeddedLanguageLine, hasEOL, embeddedLanguageData, offsetDelta) {\n        const nestedLanguageId = embeddedLanguageData.languageId;\n        const embeddedModeState = embeddedLanguageData.state;\n        const nestedLanguageTokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n        if (!nestedLanguageTokenizationSupport) {\n            this.enterLanguage(nestedLanguageId);\n            this.emit(offsetDelta, '');\n            return embeddedModeState;\n        }\n        const nestedResult = nestedLanguageTokenizationSupport.tokenizeEncoded(embeddedLanguageLine, hasEOL, embeddedModeState);\n        if (offsetDelta !== 0) {\n            for (let i = 0, len = nestedResult.tokens.length; i < len; i += 2) {\n                nestedResult.tokens[i] += offsetDelta;\n            }\n        }\n        this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);\n        this._tokens = [];\n        this._currentLanguageId = 0;\n        this._lastTokenMetadata = 0;\n        return nestedResult.endState;\n    }\n    finalize(endState) {\n        return new languages.EncodedTokenizationResult(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);\n    }\n}\nlet MonarchTokenizer = MonarchTokenizer_1 = class MonarchTokenizer extends Disposable {\n    constructor(languageService, standaloneThemeService, languageId, lexer, _configurationService) {\n        super();\n        this._configurationService = _configurationService;\n        this._languageService = languageService;\n        this._standaloneThemeService = standaloneThemeService;\n        this._languageId = languageId;\n        this._lexer = lexer;\n        this._embeddedLanguages = Object.create(null);\n        this.embeddedLoaded = Promise.resolve(undefined);\n        // Set up listening for embedded modes\n        let emitting = false;\n        this._register(languages.TokenizationRegistry.onDidChange((e) => {\n            if (emitting) {\n                return;\n            }\n            let isOneOfMyEmbeddedModes = false;\n            for (let i = 0, len = e.changedLanguages.length; i < len; i++) {\n                const language = e.changedLanguages[i];\n                if (this._embeddedLanguages[language]) {\n                    isOneOfMyEmbeddedModes = true;\n                    break;\n                }\n            }\n            if (isOneOfMyEmbeddedModes) {\n                emitting = true;\n                languages.TokenizationRegistry.handleChange([this._languageId]);\n                emitting = false;\n            }\n        }));\n        this._maxTokenizationLineLength = this._configurationService.getValue('editor.maxTokenizationLineLength', {\n            overrideIdentifier: this._languageId\n        });\n        this._register(this._configurationService.onDidChangeConfiguration(e => {\n            if (e.affectsConfiguration('editor.maxTokenizationLineLength')) {\n                this._maxTokenizationLineLength = this._configurationService.getValue('editor.maxTokenizationLineLength', {\n                    overrideIdentifier: this._languageId\n                });\n            }\n        }));\n    }\n    getLoadStatus() {\n        const promises = [];\n        for (const nestedLanguageId in this._embeddedLanguages) {\n            const tokenizationSupport = languages.TokenizationRegistry.get(nestedLanguageId);\n            if (tokenizationSupport) {\n                // The nested language is already loaded\n                if (tokenizationSupport instanceof MonarchTokenizer_1) {\n                    const nestedModeStatus = tokenizationSupport.getLoadStatus();\n                    if (nestedModeStatus.loaded === false) {\n                        promises.push(nestedModeStatus.promise);\n                    }\n                }\n                continue;\n            }\n            if (!languages.TokenizationRegistry.isResolved(nestedLanguageId)) {\n                // The nested language is in the process of being loaded\n                promises.push(languages.TokenizationRegistry.getOrCreate(nestedLanguageId));\n            }\n        }\n        if (promises.length === 0) {\n            return {\n                loaded: true\n            };\n        }\n        return {\n            loaded: false,\n            promise: Promise.all(promises).then(_ => undefined)\n        };\n    }\n    getInitialState() {\n        const rootState = MonarchStackElementFactory.create(null, this._lexer.start);\n        return MonarchLineStateFactory.create(rootState, null);\n    }\n    tokenize(line, hasEOL, lineState) {\n        if (line.length >= this._maxTokenizationLineLength) {\n            return nullTokenize(this._languageId, lineState);\n        }\n        const tokensCollector = new MonarchClassicTokensCollector();\n        const endLineState = this._tokenize(line, hasEOL, lineState, tokensCollector);\n        return tokensCollector.finalize(endLineState);\n    }\n    tokenizeEncoded(line, hasEOL, lineState) {\n        if (line.length >= this._maxTokenizationLineLength) {\n            return nullTokenizeEncoded(this._languageService.languageIdCodec.encodeLanguageId(this._languageId), lineState);\n        }\n        const tokensCollector = new MonarchModernTokensCollector(this._languageService, this._standaloneThemeService.getColorTheme().tokenTheme);\n        const endLineState = this._tokenize(line, hasEOL, lineState, tokensCollector);\n        return tokensCollector.finalize(endLineState);\n    }\n    _tokenize(line, hasEOL, lineState, collector) {\n        if (lineState.embeddedLanguageData) {\n            return this._nestedTokenize(line, hasEOL, lineState, 0, collector);\n        }\n        else {\n            return this._myTokenize(line, hasEOL, lineState, 0, collector);\n        }\n    }\n    _findLeavingNestedLanguageOffset(line, state) {\n        let rules = this._lexer.tokenizer[state.stack.state];\n        if (!rules) {\n            rules = monarchCommon.findRules(this._lexer, state.stack.state); // do parent matching\n            if (!rules) {\n                throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);\n            }\n        }\n        let popOffset = -1;\n        let hasEmbeddedPopRule = false;\n        for (const rule of rules) {\n            if (!monarchCommon.isIAction(rule.action) || rule.action.nextEmbedded !== '@pop') {\n                continue;\n            }\n            hasEmbeddedPopRule = true;\n            let regex = rule.resolveRegex(state.stack.state);\n            const regexSource = regex.source;\n            if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {\n                const flags = (regex.ignoreCase ? 'i' : '') + (regex.unicode ? 'u' : '');\n                regex = new RegExp(regexSource.substr(4, regexSource.length - 5), flags);\n            }\n            const result = line.search(regex);\n            if (result === -1 || (result !== 0 && rule.matchOnlyAtLineStart)) {\n                continue;\n            }\n            if (popOffset === -1 || result < popOffset) {\n                popOffset = result;\n            }\n        }\n        if (!hasEmbeddedPopRule) {\n            throw monarchCommon.createError(this._lexer, 'no rule containing nextEmbedded: \"@pop\" in tokenizer embedded state: ' + state.stack.state);\n        }\n        return popOffset;\n    }\n    _nestedTokenize(line, hasEOL, lineState, offsetDelta, tokensCollector) {\n        const popOffset = this._findLeavingNestedLanguageOffset(line, lineState);\n        if (popOffset === -1) {\n            // tokenization will not leave nested language\n            const nestedEndState = tokensCollector.nestedLanguageTokenize(line, hasEOL, lineState.embeddedLanguageData, offsetDelta);\n            return MonarchLineStateFactory.create(lineState.stack, new EmbeddedLanguageData(lineState.embeddedLanguageData.languageId, nestedEndState));\n        }\n        const nestedLanguageLine = line.substring(0, popOffset);\n        if (nestedLanguageLine.length > 0) {\n            // tokenize with the nested language\n            tokensCollector.nestedLanguageTokenize(nestedLanguageLine, false, lineState.embeddedLanguageData, offsetDelta);\n        }\n        const restOfTheLine = line.substring(popOffset);\n        return this._myTokenize(restOfTheLine, hasEOL, lineState, offsetDelta + popOffset, tokensCollector);\n    }\n    _safeRuleName(rule) {\n        if (rule) {\n            return rule.name;\n        }\n        return '(unknown)';\n    }\n    _myTokenize(lineWithoutLF, hasEOL, lineState, offsetDelta, tokensCollector) {\n        tokensCollector.enterLanguage(this._languageId);\n        const lineWithoutLFLength = lineWithoutLF.length;\n        const line = (hasEOL && this._lexer.includeLF ? lineWithoutLF + '\\n' : lineWithoutLF);\n        const lineLength = line.length;\n        let embeddedLanguageData = lineState.embeddedLanguageData;\n        let stack = lineState.stack;\n        let pos = 0;\n        let groupMatching = null;\n        // See https://github.com/microsoft/monaco-editor/issues/1235\n        // Evaluate rules at least once for an empty line\n        let forceEvaluation = true;\n        while (forceEvaluation || pos < lineLength) {\n            const pos0 = pos;\n            const stackLen0 = stack.depth;\n            const groupLen0 = groupMatching ? groupMatching.groups.length : 0;\n            const state = stack.state;\n            let matches = null;\n            let matched = null;\n            let action = null;\n            let rule = null;\n            let enteringEmbeddedLanguage = null;\n            // check if we need to process group matches first\n            if (groupMatching) {\n                matches = groupMatching.matches;\n                const groupEntry = groupMatching.groups.shift();\n                matched = groupEntry.matched;\n                action = groupEntry.action;\n                rule = groupMatching.rule;\n                // cleanup if necessary\n                if (groupMatching.groups.length === 0) {\n                    groupMatching = null;\n                }\n            }\n            else {\n                // otherwise we match on the token stream\n                if (!forceEvaluation && pos >= lineLength) {\n                    // nothing to do\n                    break;\n                }\n                forceEvaluation = false;\n                // get the rules for this state\n                let rules = this._lexer.tokenizer[state];\n                if (!rules) {\n                    rules = monarchCommon.findRules(this._lexer, state); // do parent matching\n                    if (!rules) {\n                        throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state);\n                    }\n                }\n                // try each rule until we match\n                const restOfLine = line.substr(pos);\n                for (const rule of rules) {\n                    if (pos === 0 || !rule.matchOnlyAtLineStart) {\n                        matches = restOfLine.match(rule.resolveRegex(state));\n                        if (matches) {\n                            matched = matches[0];\n                            action = rule.action;\n                            break;\n                        }\n                    }\n                }\n            }\n            // We matched 'rule' with 'matches' and 'action'\n            if (!matches) {\n                matches = [''];\n                matched = '';\n            }\n            if (!action) {\n                // bad: we didn't match anything, and there is no action to take\n                // we need to advance the stream or we get progress trouble\n                if (pos < lineLength) {\n                    matches = [line.charAt(pos)];\n                    matched = matches[0];\n                }\n                action = this._lexer.defaultToken;\n            }\n            if (matched === null) {\n                // should never happen, needed for strict null checking\n                break;\n            }\n            // advance stream\n            pos += matched.length;\n            // maybe call action function (used for 'cases')\n            while (monarchCommon.isFuzzyAction(action) && monarchCommon.isIAction(action) && action.test) {\n                action = action.test(matched, matches, state, pos === lineLength);\n            }\n            let result = null;\n            // set the result: either a string or an array of actions\n            if (typeof action === 'string' || Array.isArray(action)) {\n                result = action;\n            }\n            else if (action.group) {\n                result = action.group;\n            }\n            else if (action.token !== null && action.token !== undefined) {\n                // do $n replacements?\n                if (action.tokenSubst) {\n                    result = monarchCommon.substituteMatches(this._lexer, action.token, matched, matches, state);\n                }\n                else {\n                    result = action.token;\n                }\n                // enter embedded language?\n                if (action.nextEmbedded) {\n                    if (action.nextEmbedded === '@pop') {\n                        if (!embeddedLanguageData) {\n                            throw monarchCommon.createError(this._lexer, 'cannot pop embedded language if not inside one');\n                        }\n                        embeddedLanguageData = null;\n                    }\n                    else if (embeddedLanguageData) {\n                        throw monarchCommon.createError(this._lexer, 'cannot enter embedded language from within an embedded language');\n                    }\n                    else {\n                        enteringEmbeddedLanguage = monarchCommon.substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);\n                    }\n                }\n                // state transformations\n                if (action.goBack) { // back up the stream..\n                    pos = Math.max(0, pos - action.goBack);\n                }\n                if (action.switchTo && typeof action.switchTo === 'string') {\n                    let nextState = monarchCommon.substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...\n                    if (nextState[0] === '@') {\n                        nextState = nextState.substr(1); // peel off starting '@'\n                    }\n                    if (!monarchCommon.findRules(this._lexer, nextState)) {\n                        throw monarchCommon.createError(this._lexer, 'trying to switch to a state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n                    }\n                    else {\n                        stack = stack.switchTo(nextState);\n                    }\n                }\n                else if (action.transform && typeof action.transform === 'function') {\n                    throw monarchCommon.createError(this._lexer, 'action.transform not supported');\n                }\n                else if (action.next) {\n                    if (action.next === '@push') {\n                        if (stack.depth >= this._lexer.maxStack) {\n                            throw monarchCommon.createError(this._lexer, 'maximum tokenizer stack size reached: [' +\n                                stack.state + ',' + stack.parent.state + ',...]');\n                        }\n                        else {\n                            stack = stack.push(state);\n                        }\n                    }\n                    else if (action.next === '@pop') {\n                        if (stack.depth <= 1) {\n                            throw monarchCommon.createError(this._lexer, 'trying to pop an empty stack in rule: ' + this._safeRuleName(rule));\n                        }\n                        else {\n                            stack = stack.pop();\n                        }\n                    }\n                    else if (action.next === '@popall') {\n                        stack = stack.popall();\n                    }\n                    else {\n                        let nextState = monarchCommon.substituteMatches(this._lexer, action.next, matched, matches, state);\n                        if (nextState[0] === '@') {\n                            nextState = nextState.substr(1); // peel off starting '@'\n                        }\n                        if (!monarchCommon.findRules(this._lexer, nextState)) {\n                            throw monarchCommon.createError(this._lexer, 'trying to set a next state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n                        }\n                        else {\n                            stack = stack.push(nextState);\n                        }\n                    }\n                }\n                if (action.log && typeof (action.log) === 'string') {\n                    monarchCommon.log(this._lexer, this._lexer.languageId + ': ' + monarchCommon.substituteMatches(this._lexer, action.log, matched, matches, state));\n                }\n            }\n            // check result\n            if (result === null) {\n                throw monarchCommon.createError(this._lexer, 'lexer rule has no well-defined action in rule: ' + this._safeRuleName(rule));\n            }\n            const computeNewStateForEmbeddedLanguage = (enteringEmbeddedLanguage) => {\n                // support language names, mime types, and language ids\n                const languageId = (this._languageService.getLanguageIdByLanguageName(enteringEmbeddedLanguage)\n                    || this._languageService.getLanguageIdByMimeType(enteringEmbeddedLanguage)\n                    || enteringEmbeddedLanguage);\n                const embeddedLanguageData = this._getNestedEmbeddedLanguageData(languageId);\n                if (pos < lineLength) {\n                    // there is content from the embedded language on this line\n                    const restOfLine = lineWithoutLF.substr(pos);\n                    return this._nestedTokenize(restOfLine, hasEOL, MonarchLineStateFactory.create(stack, embeddedLanguageData), offsetDelta + pos, tokensCollector);\n                }\n                else {\n                    return MonarchLineStateFactory.create(stack, embeddedLanguageData);\n                }\n            };\n            // is the result a group match?\n            if (Array.isArray(result)) {\n                if (groupMatching && groupMatching.groups.length > 0) {\n                    throw monarchCommon.createError(this._lexer, 'groups cannot be nested: ' + this._safeRuleName(rule));\n                }\n                if (matches.length !== result.length + 1) {\n                    throw monarchCommon.createError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + this._safeRuleName(rule));\n                }\n                let totalLen = 0;\n                for (let i = 1; i < matches.length; i++) {\n                    totalLen += matches[i].length;\n                }\n                if (totalLen !== matched.length) {\n                    throw monarchCommon.createError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + this._safeRuleName(rule));\n                }\n                groupMatching = {\n                    rule: rule,\n                    matches: matches,\n                    groups: []\n                };\n                for (let i = 0; i < result.length; i++) {\n                    groupMatching.groups[i] = {\n                        action: result[i],\n                        matched: matches[i + 1]\n                    };\n                }\n                pos -= matched.length;\n                // call recursively to initiate first result match\n                continue;\n            }\n            else {\n                // regular result\n                // check for '@rematch'\n                if (result === '@rematch') {\n                    pos -= matched.length;\n                    matched = ''; // better set the next state too..\n                    matches = null;\n                    result = '';\n                    // Even though `@rematch` was specified, if `nextEmbedded` also specified,\n                    // a state transition should occur.\n                    if (enteringEmbeddedLanguage !== null) {\n                        return computeNewStateForEmbeddedLanguage(enteringEmbeddedLanguage);\n                    }\n                }\n                // check progress\n                if (matched.length === 0) {\n                    if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {\n                        continue;\n                    }\n                    else {\n                        throw monarchCommon.createError(this._lexer, 'no progress in tokenizer in rule: ' + this._safeRuleName(rule));\n                    }\n                }\n                // return the result (and check for brace matching)\n                // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions\n                let tokenType = null;\n                if (monarchCommon.isString(result) && result.indexOf('@brackets') === 0) {\n                    const rest = result.substr('@brackets'.length);\n                    const bracket = findBracket(this._lexer, matched);\n                    if (!bracket) {\n                        throw monarchCommon.createError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);\n                    }\n                    tokenType = monarchCommon.sanitize(bracket.token + rest);\n                }\n                else {\n                    const token = (result === '' ? '' : result + this._lexer.tokenPostfix);\n                    tokenType = monarchCommon.sanitize(token);\n                }\n                if (pos0 < lineWithoutLFLength) {\n                    tokensCollector.emit(pos0 + offsetDelta, tokenType);\n                }\n            }\n            if (enteringEmbeddedLanguage !== null) {\n                return computeNewStateForEmbeddedLanguage(enteringEmbeddedLanguage);\n            }\n        }\n        return MonarchLineStateFactory.create(stack, embeddedLanguageData);\n    }\n    _getNestedEmbeddedLanguageData(languageId) {\n        if (!this._languageService.isRegisteredLanguageId(languageId)) {\n            return new EmbeddedLanguageData(languageId, NullState);\n        }\n        if (languageId !== this._languageId) {\n            // Fire language loading event\n            this._languageService.requestBasicLanguageFeatures(languageId);\n            languages.TokenizationRegistry.getOrCreate(languageId);\n            this._embeddedLanguages[languageId] = true;\n        }\n        const tokenizationSupport = languages.TokenizationRegistry.get(languageId);\n        if (tokenizationSupport) {\n            return new EmbeddedLanguageData(languageId, tokenizationSupport.getInitialState());\n        }\n        return new EmbeddedLanguageData(languageId, NullState);\n    }\n};\nMonarchTokenizer = MonarchTokenizer_1 = __decorate([\n    __param(4, IConfigurationService)\n], MonarchTokenizer);\nexport { MonarchTokenizer };\n/**\n * Searches for a bracket in the 'brackets' attribute that matches the input.\n */\nfunction findBracket(lexer, matched) {\n    if (!matched) {\n        return null;\n    }\n    matched = monarchCommon.fixCase(lexer, matched);\n    const brackets = lexer.brackets;\n    for (const bracket of brackets) {\n        if (bracket.open === matched) {\n            return { token: bracket.token, bracketType: 1 /* monarchCommon.MonarchBracket.Open */ };\n        }\n        else if (bracket.close === matched) {\n            return { token: bracket.token, bracketType: -1 /* monarchCommon.MonarchBracket.Close */ };\n        }\n    }\n    return null;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}