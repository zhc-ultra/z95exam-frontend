{"ast":null,"code":"import _slicedToArray from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { quickSelect } from '../../../../base/common/arrays.js';\nimport { anyScore, fuzzyScore, FuzzyScore, fuzzyScoreGracefulAggressive, FuzzyScoreOptions } from '../../../../base/common/filters.js';\nimport { compareIgnoreCase } from '../../../../base/common/strings.js';\nexport var LineContext = /*#__PURE__*/_createClass(function LineContext(leadingLineContent, characterCountDelta) {\n  _classCallCheck(this, LineContext);\n  this.leadingLineContent = leadingLineContent;\n  this.characterCountDelta = characterCountDelta;\n});\n/**\n * Sorted, filtered completion view model\n * */\nexport var CompletionModel = /*#__PURE__*/function () {\n  function CompletionModel(items, column, lineContext, wordDistance, options, snippetSuggestions) {\n    var fuzzyScoreOptions = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : FuzzyScoreOptions[\"default\"];\n    var clipboardText = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n    _classCallCheck(this, CompletionModel);\n    this.clipboardText = clipboardText;\n    this._snippetCompareFn = CompletionModel._compareCompletionItems;\n    this._items = items;\n    this._column = column;\n    this._wordDistance = wordDistance;\n    this._options = options;\n    this._refilterKind = 1 /* Refilter.All */;\n    this._lineContext = lineContext;\n    this._fuzzyScoreOptions = fuzzyScoreOptions;\n    if (snippetSuggestions === 'top') {\n      this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsUp;\n    } else if (snippetSuggestions === 'bottom') {\n      this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsDown;\n    }\n  }\n  return _createClass(CompletionModel, [{\n    key: \"lineContext\",\n    get: function get() {\n      return this._lineContext;\n    },\n    set: function set(value) {\n      if (this._lineContext.leadingLineContent !== value.leadingLineContent || this._lineContext.characterCountDelta !== value.characterCountDelta) {\n        this._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? 2 /* Refilter.Incr */ : 1 /* Refilter.All */;\n        this._lineContext = value;\n      }\n    }\n  }, {\n    key: \"items\",\n    get: function get() {\n      this._ensureCachedState();\n      return this._filteredItems;\n    }\n  }, {\n    key: \"getItemsByProvider\",\n    value: function getItemsByProvider() {\n      this._ensureCachedState();\n      return this._itemsByProvider;\n    }\n  }, {\n    key: \"getIncompleteProvider\",\n    value: function getIncompleteProvider() {\n      this._ensureCachedState();\n      var result = new Set();\n      var _iterator = _createForOfIteratorHelper(this.getItemsByProvider()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            provider = _step$value[0],\n            items = _step$value[1];\n          if (items.length > 0 && items[0].container.incomplete) {\n            result.add(provider);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return result;\n    }\n  }, {\n    key: \"stats\",\n    get: function get() {\n      this._ensureCachedState();\n      return this._stats;\n    }\n  }, {\n    key: \"_ensureCachedState\",\n    value: function _ensureCachedState() {\n      if (this._refilterKind !== 0 /* Refilter.Nothing */) {\n        this._createCachedState();\n      }\n    }\n  }, {\n    key: \"_createCachedState\",\n    value: function _createCachedState() {\n      this._itemsByProvider = new Map();\n      var labelLengths = [];\n      var _this$_lineContext = this._lineContext,\n        leadingLineContent = _this$_lineContext.leadingLineContent,\n        characterCountDelta = _this$_lineContext.characterCountDelta;\n      var word = '';\n      var wordLow = '';\n      // incrementally filter less\n      var source = this._refilterKind === 1 /* Refilter.All */ ? this._items : this._filteredItems;\n      var target = [];\n      // picks a score function based on the number of\n      // items that we have to score/filter and based on the\n      // user-configuration\n      var scoreFn = !this._options.filterGraceful || source.length > 2000 ? fuzzyScore : fuzzyScoreGracefulAggressive;\n      for (var i = 0; i < source.length; i++) {\n        var item = source[i];\n        if (item.isInvalid) {\n          continue; // SKIP invalid items\n        }\n        // keep all items by their provider\n        var arr = this._itemsByProvider.get(item.provider);\n        if (arr) {\n          arr.push(item);\n        } else {\n          this._itemsByProvider.set(item.provider, [item]);\n        }\n        // 'word' is that remainder of the current line that we\n        // filter and score against. In theory each suggestion uses a\n        // different word, but in practice not - that's why we cache\n        var overwriteBefore = item.position.column - item.editStart.column;\n        var wordLen = overwriteBefore + characterCountDelta - (item.position.column - this._column);\n        if (word.length !== wordLen) {\n          word = wordLen === 0 ? '' : leadingLineContent.slice(-wordLen);\n          wordLow = word.toLowerCase();\n        }\n        // remember the word against which this item was\n        // scored\n        item.word = word;\n        if (wordLen === 0) {\n          // when there is nothing to score against, don't\n          // event try to do. Use a const rank and rely on\n          // the fallback-sort using the initial sort order.\n          // use a score of `-100` because that is out of the\n          // bound of values `fuzzyScore` will return\n          item.score = FuzzyScore.Default;\n        } else {\n          // skip word characters that are whitespace until\n          // we have hit the replace range (overwriteBefore)\n          var wordPos = 0;\n          while (wordPos < overwriteBefore) {\n            var ch = word.charCodeAt(wordPos);\n            if (ch === 32 /* CharCode.Space */ || ch === 9 /* CharCode.Tab */) {\n              wordPos += 1;\n            } else {\n              break;\n            }\n          }\n          if (wordPos >= wordLen) {\n            // the wordPos at which scoring starts is the whole word\n            // and therefore the same rules as not having a word apply\n            item.score = FuzzyScore.Default;\n          } else if (typeof item.completion.filterText === 'string') {\n            // when there is a `filterText` it must match the `word`.\n            // if it matches we check with the label to compute highlights\n            // and if that doesn't yield a result we have no highlights,\n            // despite having the match\n            var match = scoreFn(word, wordLow, wordPos, item.completion.filterText, item.filterTextLow, 0, this._fuzzyScoreOptions);\n            if (!match) {\n              continue; // NO match\n            }\n            if (compareIgnoreCase(item.completion.filterText, item.textLabel) === 0) {\n              // filterText and label are actually the same -> use good highlights\n              item.score = match;\n            } else {\n              // re-run the scorer on the label in the hope of a result BUT use the rank\n              // of the filterText-match\n              item.score = anyScore(word, wordLow, wordPos, item.textLabel, item.labelLow, 0);\n              item.score[0] = match[0]; // use score from filterText\n            }\n          } else {\n            // by default match `word` against the `label`\n            var _match = scoreFn(word, wordLow, wordPos, item.textLabel, item.labelLow, 0, this._fuzzyScoreOptions);\n            if (!_match) {\n              continue; // NO match\n            }\n            item.score = _match;\n          }\n        }\n        item.idx = i;\n        item.distance = this._wordDistance.distance(item.position, item.completion);\n        target.push(item);\n        // update stats\n        labelLengths.push(item.textLabel.length);\n      }\n      this._filteredItems = target.sort(this._snippetCompareFn);\n      this._refilterKind = 0 /* Refilter.Nothing */;\n      this._stats = {\n        pLabelLen: labelLengths.length ? quickSelect(labelLengths.length - .85, labelLengths, function (a, b) {\n          return a - b;\n        }) : 0\n      };\n    }\n  }], [{\n    key: \"_compareCompletionItems\",\n    value: function _compareCompletionItems(a, b) {\n      if (a.score[0] > b.score[0]) {\n        return -1;\n      } else if (a.score[0] < b.score[0]) {\n        return 1;\n      } else if (a.distance < b.distance) {\n        return -1;\n      } else if (a.distance > b.distance) {\n        return 1;\n      } else if (a.idx < b.idx) {\n        return -1;\n      } else if (a.idx > b.idx) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: \"_compareCompletionItemsSnippetsDown\",\n    value: function _compareCompletionItemsSnippetsDown(a, b) {\n      if (a.completion.kind !== b.completion.kind) {\n        if (a.completion.kind === 27 /* CompletionItemKind.Snippet */) {\n          return 1;\n        } else if (b.completion.kind === 27 /* CompletionItemKind.Snippet */) {\n          return -1;\n        }\n      }\n      return CompletionModel._compareCompletionItems(a, b);\n    }\n  }, {\n    key: \"_compareCompletionItemsSnippetsUp\",\n    value: function _compareCompletionItemsSnippetsUp(a, b) {\n      if (a.completion.kind !== b.completion.kind) {\n        if (a.completion.kind === 27 /* CompletionItemKind.Snippet */) {\n          return -1;\n        } else if (b.completion.kind === 27 /* CompletionItemKind.Snippet */) {\n          return 1;\n        }\n      }\n      return CompletionModel._compareCompletionItems(a, b);\n    }\n  }]);\n}();","map":{"version":3,"names":["quickSelect","anyScore","fuzzyScore","FuzzyScore","fuzzyScoreGracefulAggressive","FuzzyScoreOptions","compareIgnoreCase","LineContext","_createClass","leadingLineContent","characterCountDelta","_classCallCheck","CompletionModel","items","column","lineContext","wordDistance","options","snippetSuggestions","fuzzyScoreOptions","arguments","length","undefined","clipboardText","_snippetCompareFn","_compareCompletionItems","_items","_column","_wordDistance","_options","_refilterKind","_lineContext","_fuzzyScoreOptions","_compareCompletionItemsSnippetsUp","_compareCompletionItemsSnippetsDown","key","get","set","value","_filteredItems","_ensureCachedState","getItemsByProvider","_itemsByProvider","getIncompleteProvider","result","Set","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","_slicedToArray","provider","container","incomplete","add","err","e","f","_stats","_createCachedState","Map","labelLengths","_this$_lineContext","word","wordLow","source","target","scoreFn","filterGraceful","i","item","isInvalid","arr","push","overwriteBefore","position","editStart","wordLen","slice","toLowerCase","score","Default","wordPos","ch","charCodeAt","completion","filterText","match","filterTextLow","textLabel","labelLow","idx","distance","sort","pLabelLen","a","b","kind"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/completionModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { quickSelect } from '../../../../base/common/arrays.js';\nimport { anyScore, fuzzyScore, FuzzyScore, fuzzyScoreGracefulAggressive, FuzzyScoreOptions } from '../../../../base/common/filters.js';\nimport { compareIgnoreCase } from '../../../../base/common/strings.js';\nexport class LineContext {\n    constructor(leadingLineContent, characterCountDelta) {\n        this.leadingLineContent = leadingLineContent;\n        this.characterCountDelta = characterCountDelta;\n    }\n}\n/**\n * Sorted, filtered completion view model\n * */\nexport class CompletionModel {\n    constructor(items, column, lineContext, wordDistance, options, snippetSuggestions, fuzzyScoreOptions = FuzzyScoreOptions.default, clipboardText = undefined) {\n        this.clipboardText = clipboardText;\n        this._snippetCompareFn = CompletionModel._compareCompletionItems;\n        this._items = items;\n        this._column = column;\n        this._wordDistance = wordDistance;\n        this._options = options;\n        this._refilterKind = 1 /* Refilter.All */;\n        this._lineContext = lineContext;\n        this._fuzzyScoreOptions = fuzzyScoreOptions;\n        if (snippetSuggestions === 'top') {\n            this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsUp;\n        }\n        else if (snippetSuggestions === 'bottom') {\n            this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsDown;\n        }\n    }\n    get lineContext() {\n        return this._lineContext;\n    }\n    set lineContext(value) {\n        if (this._lineContext.leadingLineContent !== value.leadingLineContent\n            || this._lineContext.characterCountDelta !== value.characterCountDelta) {\n            this._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? 2 /* Refilter.Incr */ : 1 /* Refilter.All */;\n            this._lineContext = value;\n        }\n    }\n    get items() {\n        this._ensureCachedState();\n        return this._filteredItems;\n    }\n    getItemsByProvider() {\n        this._ensureCachedState();\n        return this._itemsByProvider;\n    }\n    getIncompleteProvider() {\n        this._ensureCachedState();\n        const result = new Set();\n        for (const [provider, items] of this.getItemsByProvider()) {\n            if (items.length > 0 && items[0].container.incomplete) {\n                result.add(provider);\n            }\n        }\n        return result;\n    }\n    get stats() {\n        this._ensureCachedState();\n        return this._stats;\n    }\n    _ensureCachedState() {\n        if (this._refilterKind !== 0 /* Refilter.Nothing */) {\n            this._createCachedState();\n        }\n    }\n    _createCachedState() {\n        this._itemsByProvider = new Map();\n        const labelLengths = [];\n        const { leadingLineContent, characterCountDelta } = this._lineContext;\n        let word = '';\n        let wordLow = '';\n        // incrementally filter less\n        const source = this._refilterKind === 1 /* Refilter.All */ ? this._items : this._filteredItems;\n        const target = [];\n        // picks a score function based on the number of\n        // items that we have to score/filter and based on the\n        // user-configuration\n        const scoreFn = (!this._options.filterGraceful || source.length > 2000) ? fuzzyScore : fuzzyScoreGracefulAggressive;\n        for (let i = 0; i < source.length; i++) {\n            const item = source[i];\n            if (item.isInvalid) {\n                continue; // SKIP invalid items\n            }\n            // keep all items by their provider\n            const arr = this._itemsByProvider.get(item.provider);\n            if (arr) {\n                arr.push(item);\n            }\n            else {\n                this._itemsByProvider.set(item.provider, [item]);\n            }\n            // 'word' is that remainder of the current line that we\n            // filter and score against. In theory each suggestion uses a\n            // different word, but in practice not - that's why we cache\n            const overwriteBefore = item.position.column - item.editStart.column;\n            const wordLen = overwriteBefore + characterCountDelta - (item.position.column - this._column);\n            if (word.length !== wordLen) {\n                word = wordLen === 0 ? '' : leadingLineContent.slice(-wordLen);\n                wordLow = word.toLowerCase();\n            }\n            // remember the word against which this item was\n            // scored\n            item.word = word;\n            if (wordLen === 0) {\n                // when there is nothing to score against, don't\n                // event try to do. Use a const rank and rely on\n                // the fallback-sort using the initial sort order.\n                // use a score of `-100` because that is out of the\n                // bound of values `fuzzyScore` will return\n                item.score = FuzzyScore.Default;\n            }\n            else {\n                // skip word characters that are whitespace until\n                // we have hit the replace range (overwriteBefore)\n                let wordPos = 0;\n                while (wordPos < overwriteBefore) {\n                    const ch = word.charCodeAt(wordPos);\n                    if (ch === 32 /* CharCode.Space */ || ch === 9 /* CharCode.Tab */) {\n                        wordPos += 1;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                if (wordPos >= wordLen) {\n                    // the wordPos at which scoring starts is the whole word\n                    // and therefore the same rules as not having a word apply\n                    item.score = FuzzyScore.Default;\n                }\n                else if (typeof item.completion.filterText === 'string') {\n                    // when there is a `filterText` it must match the `word`.\n                    // if it matches we check with the label to compute highlights\n                    // and if that doesn't yield a result we have no highlights,\n                    // despite having the match\n                    const match = scoreFn(word, wordLow, wordPos, item.completion.filterText, item.filterTextLow, 0, this._fuzzyScoreOptions);\n                    if (!match) {\n                        continue; // NO match\n                    }\n                    if (compareIgnoreCase(item.completion.filterText, item.textLabel) === 0) {\n                        // filterText and label are actually the same -> use good highlights\n                        item.score = match;\n                    }\n                    else {\n                        // re-run the scorer on the label in the hope of a result BUT use the rank\n                        // of the filterText-match\n                        item.score = anyScore(word, wordLow, wordPos, item.textLabel, item.labelLow, 0);\n                        item.score[0] = match[0]; // use score from filterText\n                    }\n                }\n                else {\n                    // by default match `word` against the `label`\n                    const match = scoreFn(word, wordLow, wordPos, item.textLabel, item.labelLow, 0, this._fuzzyScoreOptions);\n                    if (!match) {\n                        continue; // NO match\n                    }\n                    item.score = match;\n                }\n            }\n            item.idx = i;\n            item.distance = this._wordDistance.distance(item.position, item.completion);\n            target.push(item);\n            // update stats\n            labelLengths.push(item.textLabel.length);\n        }\n        this._filteredItems = target.sort(this._snippetCompareFn);\n        this._refilterKind = 0 /* Refilter.Nothing */;\n        this._stats = {\n            pLabelLen: labelLengths.length ?\n                quickSelect(labelLengths.length - .85, labelLengths, (a, b) => a - b)\n                : 0\n        };\n    }\n    static _compareCompletionItems(a, b) {\n        if (a.score[0] > b.score[0]) {\n            return -1;\n        }\n        else if (a.score[0] < b.score[0]) {\n            return 1;\n        }\n        else if (a.distance < b.distance) {\n            return -1;\n        }\n        else if (a.distance > b.distance) {\n            return 1;\n        }\n        else if (a.idx < b.idx) {\n            return -1;\n        }\n        else if (a.idx > b.idx) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n    static _compareCompletionItemsSnippetsDown(a, b) {\n        if (a.completion.kind !== b.completion.kind) {\n            if (a.completion.kind === 27 /* CompletionItemKind.Snippet */) {\n                return 1;\n            }\n            else if (b.completion.kind === 27 /* CompletionItemKind.Snippet */) {\n                return -1;\n            }\n        }\n        return CompletionModel._compareCompletionItems(a, b);\n    }\n    static _compareCompletionItemsSnippetsUp(a, b) {\n        if (a.completion.kind !== b.completion.kind) {\n            if (a.completion.kind === 27 /* CompletionItemKind.Snippet */) {\n                return -1;\n            }\n            else if (b.completion.kind === 27 /* CompletionItemKind.Snippet */) {\n                return 1;\n            }\n        }\n        return CompletionModel._compareCompletionItems(a, b);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}