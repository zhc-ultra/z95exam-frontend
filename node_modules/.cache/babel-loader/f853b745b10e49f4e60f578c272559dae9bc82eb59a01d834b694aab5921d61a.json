{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.int32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../../core/offsetRange.js';\nimport { DiffAlgorithmResult, InfiniteTimeout, SequenceDiff } from './diffAlgorithm.js';\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n*/\nexport var MyersDiffAlgorithm = /*#__PURE__*/function () {\n  function MyersDiffAlgorithm() {\n    _classCallCheck(this, MyersDiffAlgorithm);\n  }\n  return _createClass(MyersDiffAlgorithm, [{\n    key: \"compute\",\n    value: function compute(seq1, seq2) {\n      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : InfiniteTimeout.instance;\n      // These are common special cases.\n      // The early return improves performance dramatically.\n      if (seq1.length === 0 || seq2.length === 0) {\n        return DiffAlgorithmResult.trivial(seq1, seq2);\n      }\n      var seqX = seq1; // Text on the x axis\n      var seqY = seq2; // Text on the y axis\n      function getXAfterSnake(x, y) {\n        while (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {\n          x++;\n          y++;\n        }\n        return x;\n      }\n      var d = 0;\n      // V[k]: X value of longest d-line that ends in diagonal k.\n      // d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n      // diagonal k: Set of points (x,y) with x-y = k.\n      // k=1 -> (1,0),(2,1)\n      var V = new FastInt32Array();\n      V.set(0, getXAfterSnake(0, 0));\n      var paths = new FastArrayNegativeIndices();\n      paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n      var k = 0;\n      loop: while (true) {\n        d++;\n        if (!timeout.isValid()) {\n          return DiffAlgorithmResult.trivialTimedOut(seqX, seqY);\n        }\n        // The paper has `for (k = -d; k <= d; k += 2)`, but we can ignore diagonals that cannot influence the result.\n        var lowerBound = -Math.min(d, seqY.length + d % 2);\n        var upperBound = Math.min(d, seqX.length + d % 2);\n        for (k = lowerBound; k <= upperBound; k += 2) {\n          var step = 0;\n          // We can use the X values of (d-1)-lines to compute X value of the longest d-lines.\n          var maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1); // We take a vertical non-diagonal (add a symbol in seqX)\n          var maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x) (delete a symbol in seqX)\n          step++;\n          var x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);\n          var y = x - k;\n          step++;\n          if (x > seqX.length || y > seqY.length) {\n            // This diagonal is irrelevant for the result.\n            // TODO: Don't pay the cost for this in the next iteration.\n            continue;\n          }\n          var newMaxX = getXAfterSnake(x, y);\n          V.set(k, newMaxX);\n          var lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n          paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n          if (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {\n            break loop;\n          }\n        }\n      }\n      var path = paths.get(k);\n      var result = [];\n      var lastAligningPosS1 = seqX.length;\n      var lastAligningPosS2 = seqY.length;\n      while (true) {\n        var endX = path ? path.x + path.length : 0;\n        var endY = path ? path.y + path.length : 0;\n        if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n          result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));\n        }\n        if (!path) {\n          break;\n        }\n        lastAligningPosS1 = path.x;\n        lastAligningPosS2 = path.y;\n        path = path.prev;\n      }\n      result.reverse();\n      return new DiffAlgorithmResult(result, false);\n    }\n  }]);\n}();\nvar SnakePath = /*#__PURE__*/_createClass(function SnakePath(prev, x, y, length) {\n  _classCallCheck(this, SnakePath);\n  this.prev = prev;\n  this.x = x;\n  this.y = y;\n  this.length = length;\n});\n/**\n * An array that supports fast negative indices.\n*/\nvar FastInt32Array = /*#__PURE__*/function () {\n  function FastInt32Array() {\n    _classCallCheck(this, FastInt32Array);\n    this.positiveArr = new Int32Array(10);\n    this.negativeArr = new Int32Array(10);\n  }\n  return _createClass(FastInt32Array, [{\n    key: \"get\",\n    value: function get(idx) {\n      if (idx < 0) {\n        idx = -idx - 1;\n        return this.negativeArr[idx];\n      } else {\n        return this.positiveArr[idx];\n      }\n    }\n  }, {\n    key: \"set\",\n    value: function set(idx, value) {\n      if (idx < 0) {\n        idx = -idx - 1;\n        if (idx >= this.negativeArr.length) {\n          var arr = this.negativeArr;\n          this.negativeArr = new Int32Array(arr.length * 2);\n          this.negativeArr.set(arr);\n        }\n        this.negativeArr[idx] = value;\n      } else {\n        if (idx >= this.positiveArr.length) {\n          var _arr = this.positiveArr;\n          this.positiveArr = new Int32Array(_arr.length * 2);\n          this.positiveArr.set(_arr);\n        }\n        this.positiveArr[idx] = value;\n      }\n    }\n  }]);\n}();\n/**\n * An array that supports fast negative indices.\n*/\nvar FastArrayNegativeIndices = /*#__PURE__*/function () {\n  function FastArrayNegativeIndices() {\n    _classCallCheck(this, FastArrayNegativeIndices);\n    this.positiveArr = [];\n    this.negativeArr = [];\n  }\n  return _createClass(FastArrayNegativeIndices, [{\n    key: \"get\",\n    value: function get(idx) {\n      if (idx < 0) {\n        idx = -idx - 1;\n        return this.negativeArr[idx];\n      } else {\n        return this.positiveArr[idx];\n      }\n    }\n  }, {\n    key: \"set\",\n    value: function set(idx, value) {\n      if (idx < 0) {\n        idx = -idx - 1;\n        this.negativeArr[idx] = value;\n      } else {\n        this.positiveArr[idx] = value;\n      }\n    }\n  }]);\n}();","map":{"version":3,"names":["OffsetRange","DiffAlgorithmResult","InfiniteTimeout","SequenceDiff","MyersDiffAlgorithm","_classCallCheck","_createClass","key","value","compute","seq1","seq2","timeout","arguments","length","undefined","instance","trivial","seqX","seqY","getXAfterSnake","x","y","getElement","d","V","FastInt32Array","set","paths","FastArrayNegativeIndices","get","SnakePath","k","loop","isValid","trivialTimedOut","lowerBound","Math","min","upperBound","step","maxXofDLineTop","maxXofDLineLeft","max","newMaxX","lastPath","path","result","lastAligningPosS1","lastAligningPosS2","endX","endY","push","prev","reverse","positiveArr","Int32Array","negativeArr","idx","arr"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../../core/offsetRange.js';\nimport { DiffAlgorithmResult, InfiniteTimeout, SequenceDiff } from './diffAlgorithm.js';\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n*/\nexport class MyersDiffAlgorithm {\n    compute(seq1, seq2, timeout = InfiniteTimeout.instance) {\n        // These are common special cases.\n        // The early return improves performance dramatically.\n        if (seq1.length === 0 || seq2.length === 0) {\n            return DiffAlgorithmResult.trivial(seq1, seq2);\n        }\n        const seqX = seq1; // Text on the x axis\n        const seqY = seq2; // Text on the y axis\n        function getXAfterSnake(x, y) {\n            while (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {\n                x++;\n                y++;\n            }\n            return x;\n        }\n        let d = 0;\n        // V[k]: X value of longest d-line that ends in diagonal k.\n        // d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n        // diagonal k: Set of points (x,y) with x-y = k.\n        // k=1 -> (1,0),(2,1)\n        const V = new FastInt32Array();\n        V.set(0, getXAfterSnake(0, 0));\n        const paths = new FastArrayNegativeIndices();\n        paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n        let k = 0;\n        loop: while (true) {\n            d++;\n            if (!timeout.isValid()) {\n                return DiffAlgorithmResult.trivialTimedOut(seqX, seqY);\n            }\n            // The paper has `for (k = -d; k <= d; k += 2)`, but we can ignore diagonals that cannot influence the result.\n            const lowerBound = -Math.min(d, seqY.length + (d % 2));\n            const upperBound = Math.min(d, seqX.length + (d % 2));\n            for (k = lowerBound; k <= upperBound; k += 2) {\n                let step = 0;\n                // We can use the X values of (d-1)-lines to compute X value of the longest d-lines.\n                const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1); // We take a vertical non-diagonal (add a symbol in seqX)\n                const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x) (delete a symbol in seqX)\n                step++;\n                const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);\n                const y = x - k;\n                step++;\n                if (x > seqX.length || y > seqY.length) {\n                    // This diagonal is irrelevant for the result.\n                    // TODO: Don't pay the cost for this in the next iteration.\n                    continue;\n                }\n                const newMaxX = getXAfterSnake(x, y);\n                V.set(k, newMaxX);\n                const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n                paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n                if (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {\n                    break loop;\n                }\n            }\n        }\n        let path = paths.get(k);\n        const result = [];\n        let lastAligningPosS1 = seqX.length;\n        let lastAligningPosS2 = seqY.length;\n        while (true) {\n            const endX = path ? path.x + path.length : 0;\n            const endY = path ? path.y + path.length : 0;\n            if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));\n            }\n            if (!path) {\n                break;\n            }\n            lastAligningPosS1 = path.x;\n            lastAligningPosS2 = path.y;\n            path = path.prev;\n        }\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\nclass SnakePath {\n    constructor(prev, x, y, length) {\n        this.prev = prev;\n        this.x = x;\n        this.y = y;\n        this.length = length;\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastInt32Array {\n    constructor() {\n        this.positiveArr = new Int32Array(10);\n        this.negativeArr = new Int32Array(10);\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            if (idx >= this.negativeArr.length) {\n                const arr = this.negativeArr;\n                this.negativeArr = new Int32Array(arr.length * 2);\n                this.negativeArr.set(arr);\n            }\n            this.negativeArr[idx] = value;\n        }\n        else {\n            if (idx >= this.positiveArr.length) {\n                const arr = this.positiveArr;\n                this.positiveArr = new Int32Array(arr.length * 2);\n                this.positiveArr.set(arr);\n            }\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastArrayNegativeIndices {\n    constructor() {\n        this.positiveArr = [];\n        this.negativeArr = [];\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            this.negativeArr[idx] = value;\n        }\n        else {\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}