{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport var Range = /*#__PURE__*/function () {\n  function Range(startLineNumber, startColumn, endLineNumber, endColumn) {\n    _classCallCheck(this, Range);\n    if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {\n      this.startLineNumber = endLineNumber;\n      this.startColumn = endColumn;\n      this.endLineNumber = startLineNumber;\n      this.endColumn = startColumn;\n    } else {\n      this.startLineNumber = startLineNumber;\n      this.startColumn = startColumn;\n      this.endLineNumber = endLineNumber;\n      this.endColumn = endColumn;\n    }\n  }\n  /**\n   * Test if this range is empty.\n   */\n  return _createClass(Range, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return Range.isEmpty(this);\n    }\n    /**\n     * Test if `range` is empty.\n     */\n  }, {\n    key: \"containsPosition\",\n    value:\n    /**\n     * Test if position is in this range. If the position is at the edges, will return true.\n     */\n    function containsPosition(position) {\n      return Range.containsPosition(this, position);\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\n     */\n  }, {\n    key: \"containsRange\",\n    value:\n    /**\n     * Test if range is in this range. If the range is equal to this range, will return true.\n     */\n    function containsRange(range) {\n      return Range.containsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n     */\n  }, {\n    key: \"strictContainsRange\",\n    value:\n    /**\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n     */\n    function strictContainsRange(range) {\n      return Range.strictContainsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n     */\n  }, {\n    key: \"plusRange\",\n    value:\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    function plusRange(range) {\n      return Range.plusRange(this, range);\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n  }, {\n    key: \"intersectRanges\",\n    value:\n    /**\n     * A intersection of the two ranges.\n     */\n    function intersectRanges(range) {\n      return Range.intersectRanges(this, range);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n  }, {\n    key: \"equalsRange\",\n    value:\n    /**\n     * Test if this range equals other.\n     */\n    function equalsRange(other) {\n      return Range.equalsRange(this, other);\n    }\n    /**\n     * Test if range `a` equals `b`.\n     */\n  }, {\n    key: \"getEndPosition\",\n    value:\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    function getEndPosition() {\n      return Range.getEndPosition(this);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n  }, {\n    key: \"getStartPosition\",\n    value:\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    function getStartPosition() {\n      return Range.getStartPosition(this);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n  }, {\n    key: \"toString\",\n    value:\n    /**\n     * Transform to a user presentable string representation.\n     */\n    function toString() {\n      return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n    }\n    /**\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n     */\n  }, {\n    key: \"setEndPosition\",\n    value: function setEndPosition(endLineNumber, endColumn) {\n      return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n     */\n  }, {\n    key: \"setStartPosition\",\n    value: function setStartPosition(startLineNumber, startColumn) {\n      return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n  }, {\n    key: \"collapseToStart\",\n    value: function collapseToStart() {\n      return Range.collapseToStart(this);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n  }, {\n    key: \"collapseToEnd\",\n    value:\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    function collapseToEnd() {\n      return Range.collapseToEnd(this);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n  }, {\n    key: \"delta\",\n    value:\n    /**\n     * Moves the range by the given amount of lines.\n     */\n    function delta(lineCount) {\n      return new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\n    }\n    // ---\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this;\n    }\n  }], [{\n    key: \"isEmpty\",\n    value: function isEmpty(range) {\n      return range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn;\n    }\n  }, {\n    key: \"containsPosition\",\n    value: function containsPosition(range, position) {\n      if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n        return false;\n      }\n      if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n        return false;\n      }\n      if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n        return false;\n      }\n      return true;\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return false.\n     * @internal\n     */\n  }, {\n    key: \"strictContainsPosition\",\n    value: function strictContainsPosition(range, position) {\n      if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n        return false;\n      }\n      if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n        return false;\n      }\n      if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"containsRange\",\n    value: function containsRange(range, otherRange) {\n      if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n        return false;\n      }\n      if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n        return false;\n      }\n      if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n        return false;\n      }\n      if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"strictContainsRange\",\n    value: function strictContainsRange(range, otherRange) {\n      if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n        return false;\n      }\n      if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n        return false;\n      }\n      if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n        return false;\n      }\n      if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"plusRange\",\n    value: function plusRange(a, b) {\n      var startLineNumber;\n      var startColumn;\n      var endLineNumber;\n      var endColumn;\n      if (b.startLineNumber < a.startLineNumber) {\n        startLineNumber = b.startLineNumber;\n        startColumn = b.startColumn;\n      } else if (b.startLineNumber === a.startLineNumber) {\n        startLineNumber = b.startLineNumber;\n        startColumn = Math.min(b.startColumn, a.startColumn);\n      } else {\n        startLineNumber = a.startLineNumber;\n        startColumn = a.startColumn;\n      }\n      if (b.endLineNumber > a.endLineNumber) {\n        endLineNumber = b.endLineNumber;\n        endColumn = b.endColumn;\n      } else if (b.endLineNumber === a.endLineNumber) {\n        endLineNumber = b.endLineNumber;\n        endColumn = Math.max(b.endColumn, a.endColumn);\n      } else {\n        endLineNumber = a.endLineNumber;\n        endColumn = a.endColumn;\n      }\n      return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n  }, {\n    key: \"intersectRanges\",\n    value: function intersectRanges(a, b) {\n      var resultStartLineNumber = a.startLineNumber;\n      var resultStartColumn = a.startColumn;\n      var resultEndLineNumber = a.endLineNumber;\n      var resultEndColumn = a.endColumn;\n      var otherStartLineNumber = b.startLineNumber;\n      var otherStartColumn = b.startColumn;\n      var otherEndLineNumber = b.endLineNumber;\n      var otherEndColumn = b.endColumn;\n      if (resultStartLineNumber < otherStartLineNumber) {\n        resultStartLineNumber = otherStartLineNumber;\n        resultStartColumn = otherStartColumn;\n      } else if (resultStartLineNumber === otherStartLineNumber) {\n        resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n      }\n      if (resultEndLineNumber > otherEndLineNumber) {\n        resultEndLineNumber = otherEndLineNumber;\n        resultEndColumn = otherEndColumn;\n      } else if (resultEndLineNumber === otherEndLineNumber) {\n        resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n      }\n      // Check if selection is now empty\n      if (resultStartLineNumber > resultEndLineNumber) {\n        return null;\n      }\n      if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n        return null;\n      }\n      return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n    }\n  }, {\n    key: \"equalsRange\",\n    value: function equalsRange(a, b) {\n      if (!a && !b) {\n        return true;\n      }\n      return !!a && !!b && a.startLineNumber === b.startLineNumber && a.startColumn === b.startColumn && a.endLineNumber === b.endLineNumber && a.endColumn === b.endColumn;\n    }\n  }, {\n    key: \"getEndPosition\",\n    value: function getEndPosition(range) {\n      return new Position(range.endLineNumber, range.endColumn);\n    }\n  }, {\n    key: \"getStartPosition\",\n    value: function getStartPosition(range) {\n      return new Position(range.startLineNumber, range.startColumn);\n    }\n  }, {\n    key: \"collapseToStart\",\n    value: function collapseToStart(range) {\n      return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n    }\n  }, {\n    key: \"collapseToEnd\",\n    value: function collapseToEnd(range) {\n      return new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n    }\n  }, {\n    key: \"fromPositions\",\n    value: function fromPositions(start) {\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : start;\n      return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n  }, {\n    key: \"lift\",\n    value: function lift(range) {\n      if (!range) {\n        return null;\n      }\n      return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Test if `obj` is an `IRange`.\n     */\n  }, {\n    key: \"isIRange\",\n    value: function isIRange(obj) {\n      return obj && typeof obj.startLineNumber === 'number' && typeof obj.startColumn === 'number' && typeof obj.endLineNumber === 'number' && typeof obj.endColumn === 'number';\n    }\n    /**\n     * Test if the two ranges are touching in any way.\n     */\n  }, {\n    key: \"areIntersectingOrTouching\",\n    value: function areIntersectingOrTouching(a, b) {\n      // Check if `a` is before `b`\n      if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn) {\n        return false;\n      }\n      // Check if `b` is before `a`\n      if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn) {\n        return false;\n      }\n      // These ranges must intersect\n      return true;\n    }\n    /**\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n     */\n  }, {\n    key: \"areIntersecting\",\n    value: function areIntersecting(a, b) {\n      // Check if `a` is before `b`\n      if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn) {\n        return false;\n      }\n      // Check if `b` is before `a`\n      if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn) {\n        return false;\n      }\n      // These ranges must intersect\n      return true;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the startPosition and then on the endPosition\n     */\n  }, {\n    key: \"compareRangesUsingStarts\",\n    value: function compareRangesUsingStarts(a, b) {\n      if (a && b) {\n        var aStartLineNumber = a.startLineNumber | 0;\n        var bStartLineNumber = b.startLineNumber | 0;\n        if (aStartLineNumber === bStartLineNumber) {\n          var aStartColumn = a.startColumn | 0;\n          var bStartColumn = b.startColumn | 0;\n          if (aStartColumn === bStartColumn) {\n            var aEndLineNumber = a.endLineNumber | 0;\n            var bEndLineNumber = b.endLineNumber | 0;\n            if (aEndLineNumber === bEndLineNumber) {\n              var aEndColumn = a.endColumn | 0;\n              var bEndColumn = b.endColumn | 0;\n              return aEndColumn - bEndColumn;\n            }\n            return aEndLineNumber - bEndLineNumber;\n          }\n          return aStartColumn - bStartColumn;\n        }\n        return aStartLineNumber - bStartLineNumber;\n      }\n      var aExists = a ? 1 : 0;\n      var bExists = b ? 1 : 0;\n      return aExists - bExists;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the endPosition and then on the startPosition\n     */\n  }, {\n    key: \"compareRangesUsingEnds\",\n    value: function compareRangesUsingEnds(a, b) {\n      if (a.endLineNumber === b.endLineNumber) {\n        if (a.endColumn === b.endColumn) {\n          if (a.startLineNumber === b.startLineNumber) {\n            return a.startColumn - b.startColumn;\n          }\n          return a.startLineNumber - b.startLineNumber;\n        }\n        return a.endColumn - b.endColumn;\n      }\n      return a.endLineNumber - b.endLineNumber;\n    }\n    /**\n     * Test if the range spans multiple lines.\n     */\n  }, {\n    key: \"spansMultipleLines\",\n    value: function spansMultipleLines(range) {\n      return range.endLineNumber > range.startLineNumber;\n    }\n  }]);\n}();","map":{"version":3,"names":["Position","Range","startLineNumber","startColumn","endLineNumber","endColumn","_classCallCheck","_createClass","key","value","isEmpty","containsPosition","position","containsRange","range","strictContainsRange","plusRange","intersectRanges","equalsRange","other","getEndPosition","getStartPosition","toString","setEndPosition","setStartPosition","collapseToStart","collapseToEnd","delta","lineCount","toJSON","lineNumber","column","strictContainsPosition","otherRange","a","b","Math","min","max","resultStartLineNumber","resultStartColumn","resultEndLineNumber","resultEndColumn","otherStartLineNumber","otherStartColumn","otherEndLineNumber","otherEndColumn","fromPositions","start","end","arguments","length","undefined","lift","isIRange","obj","areIntersectingOrTouching","areIntersecting","compareRangesUsingStarts","aStartLineNumber","bStartLineNumber","aStartColumn","bStartColumn","aEndLineNumber","bEndLineNumber","aEndColumn","bEndColumn","aExists","bExists","compareRangesUsingEnds","spansMultipleLines"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/core/range.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n            this.startLineNumber = endLineNumber;\n            this.startColumn = endColumn;\n            this.endLineNumber = startLineNumber;\n            this.endColumn = startColumn;\n        }\n        else {\n            this.startLineNumber = startLineNumber;\n            this.startColumn = startColumn;\n            this.endLineNumber = endLineNumber;\n            this.endColumn = endColumn;\n        }\n    }\n    /**\n     * Test if this range is empty.\n     */\n    isEmpty() {\n        return Range.isEmpty(this);\n    }\n    /**\n     * Test if `range` is empty.\n     */\n    static isEmpty(range) {\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n    }\n    /**\n     * Test if position is in this range. If the position is at the edges, will return true.\n     */\n    containsPosition(position) {\n        return Range.containsPosition(this, position);\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\n     */\n    static containsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return false.\n     * @internal\n     */\n    static strictContainsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if range is in this range. If the range is equal to this range, will return true.\n     */\n    containsRange(range) {\n        return Range.containsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n     */\n    static containsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n     */\n    strictContainsRange(range) {\n        return Range.strictContainsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n     */\n    static strictContainsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    plusRange(range) {\n        return Range.plusRange(this, range);\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    static plusRange(a, b) {\n        let startLineNumber;\n        let startColumn;\n        let endLineNumber;\n        let endColumn;\n        if (b.startLineNumber < a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = b.startColumn;\n        }\n        else if (b.startLineNumber === a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = Math.min(b.startColumn, a.startColumn);\n        }\n        else {\n            startLineNumber = a.startLineNumber;\n            startColumn = a.startColumn;\n        }\n        if (b.endLineNumber > a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = b.endColumn;\n        }\n        else if (b.endLineNumber === a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = Math.max(b.endColumn, a.endColumn);\n        }\n        else {\n            endLineNumber = a.endLineNumber;\n            endColumn = a.endColumn;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    intersectRanges(range) {\n        return Range.intersectRanges(this, range);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    static intersectRanges(a, b) {\n        let resultStartLineNumber = a.startLineNumber;\n        let resultStartColumn = a.startColumn;\n        let resultEndLineNumber = a.endLineNumber;\n        let resultEndColumn = a.endColumn;\n        const otherStartLineNumber = b.startLineNumber;\n        const otherStartColumn = b.startColumn;\n        const otherEndLineNumber = b.endLineNumber;\n        const otherEndColumn = b.endColumn;\n        if (resultStartLineNumber < otherStartLineNumber) {\n            resultStartLineNumber = otherStartLineNumber;\n            resultStartColumn = otherStartColumn;\n        }\n        else if (resultStartLineNumber === otherStartLineNumber) {\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n        }\n        if (resultEndLineNumber > otherEndLineNumber) {\n            resultEndLineNumber = otherEndLineNumber;\n            resultEndColumn = otherEndColumn;\n        }\n        else if (resultEndLineNumber === otherEndLineNumber) {\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n        }\n        // Check if selection is now empty\n        if (resultStartLineNumber > resultEndLineNumber) {\n            return null;\n        }\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n            return null;\n        }\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n    }\n    /**\n     * Test if this range equals other.\n     */\n    equalsRange(other) {\n        return Range.equalsRange(this, other);\n    }\n    /**\n     * Test if range `a` equals `b`.\n     */\n    static equalsRange(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.startLineNumber === b.startLineNumber &&\n            a.startColumn === b.startColumn &&\n            a.endLineNumber === b.endLineNumber &&\n            a.endColumn === b.endColumn);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    getEndPosition() {\n        return Range.getEndPosition(this);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    static getEndPosition(range) {\n        return new Position(range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    getStartPosition() {\n        return Range.getStartPosition(this);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    static getStartPosition(range) {\n        return new Position(range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Transform to a user presentable string representation.\n     */\n    toString() {\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n    }\n    /**\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    collapseToStart() {\n        return Range.collapseToStart(this);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    static collapseToStart(range) {\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    collapseToEnd() {\n        return Range.collapseToEnd(this);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    static collapseToEnd(range) {\n        return new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Moves the range by the given amount of lines.\n     */\n    delta(lineCount) {\n        return new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\n    }\n    // ---\n    static fromPositions(start, end = start) {\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    static lift(range) {\n        if (!range) {\n            return null;\n        }\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Test if `obj` is an `IRange`.\n     */\n    static isIRange(obj) {\n        return (obj\n            && (typeof obj.startLineNumber === 'number')\n            && (typeof obj.startColumn === 'number')\n            && (typeof obj.endLineNumber === 'number')\n            && (typeof obj.endColumn === 'number'));\n    }\n    /**\n     * Test if the two ranges are touching in any way.\n     */\n    static areIntersectingOrTouching(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n     */\n    static areIntersecting(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the startPosition and then on the endPosition\n     */\n    static compareRangesUsingStarts(a, b) {\n        if (a && b) {\n            const aStartLineNumber = a.startLineNumber | 0;\n            const bStartLineNumber = b.startLineNumber | 0;\n            if (aStartLineNumber === bStartLineNumber) {\n                const aStartColumn = a.startColumn | 0;\n                const bStartColumn = b.startColumn | 0;\n                if (aStartColumn === bStartColumn) {\n                    const aEndLineNumber = a.endLineNumber | 0;\n                    const bEndLineNumber = b.endLineNumber | 0;\n                    if (aEndLineNumber === bEndLineNumber) {\n                        const aEndColumn = a.endColumn | 0;\n                        const bEndColumn = b.endColumn | 0;\n                        return aEndColumn - bEndColumn;\n                    }\n                    return aEndLineNumber - bEndLineNumber;\n                }\n                return aStartColumn - bStartColumn;\n            }\n            return aStartLineNumber - bStartLineNumber;\n        }\n        const aExists = (a ? 1 : 0);\n        const bExists = (b ? 1 : 0);\n        return aExists - bExists;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the endPosition and then on the startPosition\n     */\n    static compareRangesUsingEnds(a, b) {\n        if (a.endLineNumber === b.endLineNumber) {\n            if (a.endColumn === b.endColumn) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.startColumn - b.startColumn;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return a.endColumn - b.endColumn;\n        }\n        return a.endLineNumber - b.endLineNumber;\n    }\n    /**\n     * Test if the range spans multiple lines.\n     */\n    static spansMultipleLines(range) {\n        return range.endLineNumber > range.startLineNumber;\n    }\n    toJSON() {\n        return this;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}