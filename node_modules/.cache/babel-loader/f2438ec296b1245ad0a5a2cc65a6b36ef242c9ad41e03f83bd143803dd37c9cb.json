{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError, onUnexpectedError } from './errors.js';\n/**\n * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.\n *\n * @deprecated Use `assert(...)` instead.\n * This method is usually used like this:\n * ```ts\n * import * as assert from 'vs/base/common/assert';\n * assert.ok(...);\n * ```\n *\n * However, `assert` in that example is a user chosen name.\n * There is no tooling for generating such an import statement.\n * Thus, the `assert(...)` function should be used instead.\n */\nexport function ok(value, message) {\n  if (!value) {\n    throw new Error(message ? \"Assertion failed (\".concat(message, \")\") : 'Assertion Failed');\n  }\n}\nexport function assertNever(value) {\n  var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Unreachable';\n  throw new Error(message);\n}\n/**\n * Like assert, but doesn't throw.\n */\nexport function softAssert(condition) {\n  if (!condition) {\n    onUnexpectedError(new BugIndicatingError('Soft Assertion Failed'));\n  }\n}\n/**\n * condition must be side-effect free!\n */\nexport function assertFn(condition) {\n  if (!condition()) {\n    // eslint-disable-next-line no-debugger\n    debugger;\n    // Reevaluate `condition` again to make debugging easier\n    condition();\n    onUnexpectedError(new BugIndicatingError('Assertion Failed'));\n  }\n}\nexport function checkAdjacentItems(items, predicate) {\n  var i = 0;\n  while (i < items.length - 1) {\n    var a = items[i];\n    var b = items[i + 1];\n    if (!predicate(a, b)) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n}","map":{"version":3,"names":["BugIndicatingError","onUnexpectedError","ok","value","message","Error","concat","assertNever","arguments","length","undefined","softAssert","condition","assertFn","checkAdjacentItems","items","predicate","i","a","b"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/base/common/assert.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError, onUnexpectedError } from './errors.js';\n/**\n * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.\n *\n * @deprecated Use `assert(...)` instead.\n * This method is usually used like this:\n * ```ts\n * import * as assert from 'vs/base/common/assert';\n * assert.ok(...);\n * ```\n *\n * However, `assert` in that example is a user chosen name.\n * There is no tooling for generating such an import statement.\n * Thus, the `assert(...)` function should be used instead.\n */\nexport function ok(value, message) {\n    if (!value) {\n        throw new Error(message ? `Assertion failed (${message})` : 'Assertion Failed');\n    }\n}\nexport function assertNever(value, message = 'Unreachable') {\n    throw new Error(message);\n}\n/**\n * Like assert, but doesn't throw.\n */\nexport function softAssert(condition) {\n    if (!condition) {\n        onUnexpectedError(new BugIndicatingError('Soft Assertion Failed'));\n    }\n}\n/**\n * condition must be side-effect free!\n */\nexport function assertFn(condition) {\n    if (!condition()) {\n        // eslint-disable-next-line no-debugger\n        debugger;\n        // Reevaluate `condition` again to make debugging easier\n        condition();\n        onUnexpectedError(new BugIndicatingError('Assertion Failed'));\n    }\n}\nexport function checkAdjacentItems(items, predicate) {\n    let i = 0;\n    while (i < items.length - 1) {\n        const a = items[i];\n        const b = items[i + 1];\n        if (!predicate(a, b)) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA,SAASA,kBAAkB,EAAEC,iBAAiB,QAAQ,aAAa;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,EAAEA,CAACC,KAAK,EAAEC,OAAO,EAAE;EAC/B,IAAI,CAACD,KAAK,EAAE;IACR,MAAM,IAAIE,KAAK,CAACD,OAAO,wBAAAE,MAAA,CAAwBF,OAAO,SAAM,kBAAkB,CAAC;EACnF;AACJ;AACA,OAAO,SAASG,WAAWA,CAACJ,KAAK,EAA2B;EAAA,IAAzBC,OAAO,GAAAI,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,aAAa;EACtD,MAAM,IAAIH,KAAK,CAACD,OAAO,CAAC;AAC5B;AACA;AACA;AACA;AACA,OAAO,SAASO,UAAUA,CAACC,SAAS,EAAE;EAClC,IAAI,CAACA,SAAS,EAAE;IACZX,iBAAiB,CAAC,IAAID,kBAAkB,CAAC,uBAAuB,CAAC,CAAC;EACtE;AACJ;AACA;AACA;AACA;AACA,OAAO,SAASa,QAAQA,CAACD,SAAS,EAAE;EAChC,IAAI,CAACA,SAAS,CAAC,CAAC,EAAE;IACd;IACA;IACA;IACAA,SAAS,CAAC,CAAC;IACXX,iBAAiB,CAAC,IAAID,kBAAkB,CAAC,kBAAkB,CAAC,CAAC;EACjE;AACJ;AACA,OAAO,SAASc,kBAAkBA,CAACC,KAAK,EAAEC,SAAS,EAAE;EACjD,IAAIC,CAAC,GAAG,CAAC;EACT,OAAOA,CAAC,GAAGF,KAAK,CAACN,MAAM,GAAG,CAAC,EAAE;IACzB,IAAMS,CAAC,GAAGH,KAAK,CAACE,CAAC,CAAC;IAClB,IAAME,CAAC,GAAGJ,KAAK,CAACE,CAAC,GAAG,CAAC,CAAC;IACtB,IAAI,CAACD,SAAS,CAACE,CAAC,EAAEC,CAAC,CAAC,EAAE;MAClB,OAAO,KAAK;IAChB;IACAF,CAAC,EAAE;EACP;EACA,OAAO,IAAI;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}