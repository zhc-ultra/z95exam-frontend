{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.aggregate-error.js\";\nimport \"core-js/modules/es.aggregate-error.cause.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.freeze.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/web.timers.js\";\nimport { createSingleCallFunction } from './functional.js';\nimport { Iterable } from './iterator.js';\n// #region Disposable Tracking\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nvar TRACK_DISPOSABLES = false;\nvar disposableTracker = null;\nexport function setDisposableTracker(tracker) {\n  disposableTracker = tracker;\n}\nif (TRACK_DISPOSABLES) {\n  var __is_disposable_tracked__ = '__is_disposable_tracked__';\n  setDisposableTracker(new ( /*#__PURE__*/function () {\n    function _class() {\n      _classCallCheck(this, _class);\n    }\n    return _createClass(_class, [{\n      key: \"trackDisposable\",\n      value: function trackDisposable(x) {\n        var stack = new Error('Potentially leaked disposable').stack;\n        setTimeout(function () {\n          if (!x[__is_disposable_tracked__]) {\n            console.log(stack);\n          }\n        }, 3000);\n      }\n    }, {\n      key: \"setParent\",\n      value: function setParent(child, parent) {\n        if (child && child !== Disposable.None) {\n          try {\n            child[__is_disposable_tracked__] = true;\n          } catch (_a) {\n            // noop\n          }\n        }\n      }\n    }, {\n      key: \"markAsDisposed\",\n      value: function markAsDisposed(disposable) {\n        if (disposable && disposable !== Disposable.None) {\n          try {\n            disposable[__is_disposable_tracked__] = true;\n          } catch (_a) {\n            // noop\n          }\n        }\n      }\n    }, {\n      key: \"markAsSingleton\",\n      value: function markAsSingleton(disposable) {}\n    }]);\n  }())());\n}\nexport function trackDisposable(x) {\n  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);\n  return x;\n}\nexport function markAsDisposed(disposable) {\n  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);\n}\nfunction setParentOfDisposable(child, parent) {\n  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);\n}\nfunction setParentOfDisposables(children, parent) {\n  if (!disposableTracker) {\n    return;\n  }\n  var _iterator = _createForOfIteratorHelper(children),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var child = _step.value;\n      disposableTracker.setParent(child, parent);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n/**\n * Indicates that the given object is a singleton which does not need to be disposed.\n*/\nexport function markAsSingleton(singleton) {\n  disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsSingleton(singleton);\n  return singleton;\n}\n/**\n * Check if `thing` is {@link IDisposable disposable}.\n */\nexport function isDisposable(thing) {\n  return typeof thing.dispose === 'function' && thing.dispose.length === 0;\n}\nexport function dispose(arg) {\n  if (Iterable.is(arg)) {\n    var errors = [];\n    var _iterator2 = _createForOfIteratorHelper(arg),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var d = _step2.value;\n        if (d) {\n          try {\n            d.dispose();\n          } catch (e) {\n            errors.push(e);\n          }\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    if (errors.length === 1) {\n      throw errors[0];\n    } else if (errors.length > 1) {\n      throw new AggregateError(errors, 'Encountered errors while disposing of store');\n    }\n    return Array.isArray(arg) ? [] : arg;\n  } else if (arg) {\n    arg.dispose();\n    return arg;\n  }\n}\n/**\n * Combine multiple disposable values into a single {@link IDisposable}.\n */\nexport function combinedDisposable() {\n  for (var _len = arguments.length, disposables = new Array(_len), _key = 0; _key < _len; _key++) {\n    disposables[_key] = arguments[_key];\n  }\n  var parent = toDisposable(function () {\n    return dispose(disposables);\n  });\n  setParentOfDisposables(disposables, parent);\n  return parent;\n}\n/**\n * Turn a function that implements dispose into an {@link IDisposable}.\n *\n * @param fn Clean up function, guaranteed to be called only **once**.\n */\nexport function toDisposable(fn) {\n  var self = trackDisposable({\n    dispose: createSingleCallFunction(function () {\n      markAsDisposed(self);\n      fn();\n    })\n  });\n  return self;\n}\n/**\n * Manages a collection of disposable values.\n *\n * This is the preferred way to manage multiple disposables. A `DisposableStore` is safer to work with than an\n * `IDisposable[]` as it considers edge cases, such as registering the same value multiple times or adding an item to a\n * store that has already been disposed of.\n */\nexport var DisposableStore = /*#__PURE__*/function () {\n  function DisposableStore() {\n    _classCallCheck(this, DisposableStore);\n    this._toDispose = new Set();\n    this._isDisposed = false;\n    trackDisposable(this);\n  }\n  /**\n   * Dispose of all registered disposables and mark this object as disposed.\n   *\n   * Any future disposables added to this object will be disposed of on `add`.\n   */\n  return _createClass(DisposableStore, [{\n    key: \"dispose\",\n    value: function dispose() {\n      if (this._isDisposed) {\n        return;\n      }\n      markAsDisposed(this);\n      this._isDisposed = true;\n      this.clear();\n    }\n    /**\n     * @return `true` if this object has been disposed of.\n     */\n  }, {\n    key: \"isDisposed\",\n    get: function get() {\n      return this._isDisposed;\n    }\n    /**\n     * Dispose of all registered disposables but do not mark this object as disposed.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (this._toDispose.size === 0) {\n        return;\n      }\n      try {\n        dispose(this._toDispose);\n      } finally {\n        this._toDispose.clear();\n      }\n    }\n    /**\n     * Add a new {@link IDisposable disposable} to the collection.\n     */\n  }, {\n    key: \"add\",\n    value: function add(o) {\n      if (!o) {\n        return o;\n      }\n      if (o === this) {\n        throw new Error('Cannot register a disposable on itself!');\n      }\n      setParentOfDisposable(o, this);\n      if (this._isDisposed) {\n        if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n          console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n        }\n      } else {\n        this._toDispose.add(o);\n      }\n      return o;\n    }\n    /**\n     * Deletes the value from the store, but does not dispose it.\n     */\n  }, {\n    key: \"deleteAndLeak\",\n    value: function deleteAndLeak(o) {\n      if (!o) {\n        return;\n      }\n      if (this._toDispose.has(o)) {\n        this._toDispose[\"delete\"](o);\n        setParentOfDisposable(o, null);\n      }\n    }\n  }]);\n}();\nDisposableStore.DISABLE_DISPOSED_WARNING = false;\n/**\n * Abstract base class for a {@link IDisposable disposable} object.\n *\n * Subclasses can {@linkcode _register} disposables that will be automatically cleaned up when this object is disposed of.\n */\nexport var Disposable = /*#__PURE__*/function () {\n  function Disposable() {\n    _classCallCheck(this, Disposable);\n    this._store = new DisposableStore();\n    trackDisposable(this);\n    setParentOfDisposable(this._store, this);\n  }\n  return _createClass(Disposable, [{\n    key: \"dispose\",\n    value: function dispose() {\n      markAsDisposed(this);\n      this._store.dispose();\n    }\n    /**\n     * Adds `o` to the collection of disposables managed by this object.\n     */\n  }, {\n    key: \"_register\",\n    value: function _register(o) {\n      if (o === this) {\n        throw new Error('Cannot register a disposable on itself!');\n      }\n      return this._store.add(o);\n    }\n  }]);\n}();\n/**\n * A disposable that does nothing when it is disposed of.\n *\n * TODO: This should not be a static property.\n */\nDisposable.None = Object.freeze({\n  dispose: function dispose() {}\n});\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nexport var MutableDisposable = /*#__PURE__*/function () {\n  function MutableDisposable() {\n    _classCallCheck(this, MutableDisposable);\n    this._isDisposed = false;\n    trackDisposable(this);\n  }\n  return _createClass(MutableDisposable, [{\n    key: \"value\",\n    get: function get() {\n      return this._isDisposed ? undefined : this._value;\n    },\n    set: function set(value) {\n      var _a;\n      if (this._isDisposed || value === this._value) {\n        return;\n      }\n      (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n      if (value) {\n        setParentOfDisposable(value, this);\n      }\n      this._value = value;\n    }\n    /**\n     * Resets the stored value and disposed of the previously stored value.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.value = undefined;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var _a;\n      this._isDisposed = true;\n      markAsDisposed(this);\n      (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n      this._value = undefined;\n    }\n  }]);\n}();\nexport var RefCountedDisposable = /*#__PURE__*/function () {\n  function RefCountedDisposable(_disposable) {\n    _classCallCheck(this, RefCountedDisposable);\n    this._disposable = _disposable;\n    this._counter = 1;\n  }\n  return _createClass(RefCountedDisposable, [{\n    key: \"acquire\",\n    value: function acquire() {\n      this._counter++;\n      return this;\n    }\n  }, {\n    key: \"release\",\n    value: function release() {\n      if (--this._counter === 0) {\n        this._disposable.dispose();\n      }\n      return this;\n    }\n  }]);\n}();\nexport var ImmortalReference = /*#__PURE__*/function () {\n  function ImmortalReference(object) {\n    _classCallCheck(this, ImmortalReference);\n    this.object = object;\n  }\n  return _createClass(ImmortalReference, [{\n    key: \"dispose\",\n    value: function dispose() {}\n  }]);\n}();\n/**\n * A map the manages the lifecycle of the values that it stores.\n */\nexport var DisposableMap = /*#__PURE__*/function () {\n  function DisposableMap() {\n    _classCallCheck(this, DisposableMap);\n    this._store = new Map();\n    this._isDisposed = false;\n    trackDisposable(this);\n  }\n  /**\n   * Disposes of all stored values and mark this object as disposed.\n   *\n   * Trying to use this object after it has been disposed of is an error.\n   */\n  return _createClass(DisposableMap, [{\n    key: \"dispose\",\n    value: function dispose() {\n      markAsDisposed(this);\n      this._isDisposed = true;\n      this.clearAndDisposeAll();\n    }\n    /**\n     * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.\n     */\n  }, {\n    key: \"clearAndDisposeAll\",\n    value: function clearAndDisposeAll() {\n      if (!this._store.size) {\n        return;\n      }\n      try {\n        dispose(this._store.values());\n      } finally {\n        this._store.clear();\n      }\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      return this._store.get(key);\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      var skipDisposeOnOverwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var _a;\n      if (this._isDisposed) {\n        console.warn(new Error('Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!').stack);\n      }\n      if (!skipDisposeOnOverwrite) {\n        (_a = this._store.get(key)) === null || _a === void 0 ? void 0 : _a.dispose();\n      }\n      this._store.set(key, value);\n    }\n    /**\n     * Delete the value stored for `key` from this map and also dispose of it.\n     */\n  }, {\n    key: \"deleteAndDispose\",\n    value: function deleteAndDispose(key) {\n      var _a;\n      (_a = this._store.get(key)) === null || _a === void 0 ? void 0 : _a.dispose();\n      this._store[\"delete\"](key);\n    }\n  }, {\n    key: Symbol.iterator,\n    value: function value() {\n      return this._store[Symbol.iterator]();\n    }\n  }]);\n}();","map":{"version":3,"names":["createSingleCallFunction","Iterable","TRACK_DISPOSABLES","disposableTracker","setDisposableTracker","tracker","__is_disposable_tracked__","_class","_classCallCheck","_createClass","key","value","trackDisposable","x","stack","Error","setTimeout","console","log","setParent","child","parent","Disposable","None","_a","markAsDisposed","disposable","markAsSingleton","setParentOfDisposable","setParentOfDisposables","children","_iterator","_createForOfIteratorHelper","_step","s","n","done","err","e","f","singleton","isDisposable","thing","dispose","length","arg","is","errors","_iterator2","_step2","d","push","AggregateError","Array","isArray","combinedDisposable","_len","arguments","disposables","_key","toDisposable","fn","self","DisposableStore","_toDispose","Set","_isDisposed","clear","get","size","add","o","DISABLE_DISPOSED_WARNING","warn","deleteAndLeak","has","_store","_register","Object","freeze","MutableDisposable","undefined","_value","set","RefCountedDisposable","_disposable","_counter","acquire","release","ImmortalReference","object","DisposableMap","Map","clearAndDisposeAll","values","skipDisposeOnOverwrite","deleteAndDispose","Symbol","iterator"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js"],"sourcesContent":["import { createSingleCallFunction } from './functional.js';\nimport { Iterable } from './iterator.js';\n// #region Disposable Tracking\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker = null;\nexport function setDisposableTracker(tracker) {\n    disposableTracker = tracker;\n}\nif (TRACK_DISPOSABLES) {\n    const __is_disposable_tracked__ = '__is_disposable_tracked__';\n    setDisposableTracker(new class {\n        trackDisposable(x) {\n            const stack = new Error('Potentially leaked disposable').stack;\n            setTimeout(() => {\n                if (!x[__is_disposable_tracked__]) {\n                    console.log(stack);\n                }\n            }, 3000);\n        }\n        setParent(child, parent) {\n            if (child && child !== Disposable.None) {\n                try {\n                    child[__is_disposable_tracked__] = true;\n                }\n                catch (_a) {\n                    // noop\n                }\n            }\n        }\n        markAsDisposed(disposable) {\n            if (disposable && disposable !== Disposable.None) {\n                try {\n                    disposable[__is_disposable_tracked__] = true;\n                }\n                catch (_a) {\n                    // noop\n                }\n            }\n        }\n        markAsSingleton(disposable) { }\n    });\n}\nexport function trackDisposable(x) {\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);\n    return x;\n}\nexport function markAsDisposed(disposable) {\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);\n}\nfunction setParentOfDisposable(child, parent) {\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);\n}\nfunction setParentOfDisposables(children, parent) {\n    if (!disposableTracker) {\n        return;\n    }\n    for (const child of children) {\n        disposableTracker.setParent(child, parent);\n    }\n}\n/**\n * Indicates that the given object is a singleton which does not need to be disposed.\n*/\nexport function markAsSingleton(singleton) {\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsSingleton(singleton);\n    return singleton;\n}\n/**\n * Check if `thing` is {@link IDisposable disposable}.\n */\nexport function isDisposable(thing) {\n    return typeof thing.dispose === 'function' && thing.dispose.length === 0;\n}\nexport function dispose(arg) {\n    if (Iterable.is(arg)) {\n        const errors = [];\n        for (const d of arg) {\n            if (d) {\n                try {\n                    d.dispose();\n                }\n                catch (e) {\n                    errors.push(e);\n                }\n            }\n        }\n        if (errors.length === 1) {\n            throw errors[0];\n        }\n        else if (errors.length > 1) {\n            throw new AggregateError(errors, 'Encountered errors while disposing of store');\n        }\n        return Array.isArray(arg) ? [] : arg;\n    }\n    else if (arg) {\n        arg.dispose();\n        return arg;\n    }\n}\n/**\n * Combine multiple disposable values into a single {@link IDisposable}.\n */\nexport function combinedDisposable(...disposables) {\n    const parent = toDisposable(() => dispose(disposables));\n    setParentOfDisposables(disposables, parent);\n    return parent;\n}\n/**\n * Turn a function that implements dispose into an {@link IDisposable}.\n *\n * @param fn Clean up function, guaranteed to be called only **once**.\n */\nexport function toDisposable(fn) {\n    const self = trackDisposable({\n        dispose: createSingleCallFunction(() => {\n            markAsDisposed(self);\n            fn();\n        })\n    });\n    return self;\n}\n/**\n * Manages a collection of disposable values.\n *\n * This is the preferred way to manage multiple disposables. A `DisposableStore` is safer to work with than an\n * `IDisposable[]` as it considers edge cases, such as registering the same value multiple times or adding an item to a\n * store that has already been disposed of.\n */\nexport class DisposableStore {\n    constructor() {\n        this._toDispose = new Set();\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    /**\n     * Dispose of all registered disposables and mark this object as disposed.\n     *\n     * Any future disposables added to this object will be disposed of on `add`.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        markAsDisposed(this);\n        this._isDisposed = true;\n        this.clear();\n    }\n    /**\n     * @return `true` if this object has been disposed of.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of all registered disposables but do not mark this object as disposed.\n     */\n    clear() {\n        if (this._toDispose.size === 0) {\n            return;\n        }\n        try {\n            dispose(this._toDispose);\n        }\n        finally {\n            this._toDispose.clear();\n        }\n    }\n    /**\n     * Add a new {@link IDisposable disposable} to the collection.\n     */\n    add(o) {\n        if (!o) {\n            return o;\n        }\n        if (o === this) {\n            throw new Error('Cannot register a disposable on itself!');\n        }\n        setParentOfDisposable(o, this);\n        if (this._isDisposed) {\n            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n                console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n            }\n        }\n        else {\n            this._toDispose.add(o);\n        }\n        return o;\n    }\n    /**\n     * Deletes the value from the store, but does not dispose it.\n     */\n    deleteAndLeak(o) {\n        if (!o) {\n            return;\n        }\n        if (this._toDispose.has(o)) {\n            this._toDispose.delete(o);\n            setParentOfDisposable(o, null);\n        }\n    }\n}\nDisposableStore.DISABLE_DISPOSED_WARNING = false;\n/**\n * Abstract base class for a {@link IDisposable disposable} object.\n *\n * Subclasses can {@linkcode _register} disposables that will be automatically cleaned up when this object is disposed of.\n */\nexport class Disposable {\n    constructor() {\n        this._store = new DisposableStore();\n        trackDisposable(this);\n        setParentOfDisposable(this._store, this);\n    }\n    dispose() {\n        markAsDisposed(this);\n        this._store.dispose();\n    }\n    /**\n     * Adds `o` to the collection of disposables managed by this object.\n     */\n    _register(o) {\n        if (o === this) {\n            throw new Error('Cannot register a disposable on itself!');\n        }\n        return this._store.add(o);\n    }\n}\n/**\n * A disposable that does nothing when it is disposed of.\n *\n * TODO: This should not be a static property.\n */\nDisposable.None = Object.freeze({ dispose() { } });\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nexport class MutableDisposable {\n    constructor() {\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    get value() {\n        return this._isDisposed ? undefined : this._value;\n    }\n    set value(value) {\n        var _a;\n        if (this._isDisposed || value === this._value) {\n            return;\n        }\n        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n        if (value) {\n            setParentOfDisposable(value, this);\n        }\n        this._value = value;\n    }\n    /**\n     * Resets the stored value and disposed of the previously stored value.\n     */\n    clear() {\n        this.value = undefined;\n    }\n    dispose() {\n        var _a;\n        this._isDisposed = true;\n        markAsDisposed(this);\n        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._value = undefined;\n    }\n}\nexport class RefCountedDisposable {\n    constructor(_disposable) {\n        this._disposable = _disposable;\n        this._counter = 1;\n    }\n    acquire() {\n        this._counter++;\n        return this;\n    }\n    release() {\n        if (--this._counter === 0) {\n            this._disposable.dispose();\n        }\n        return this;\n    }\n}\nexport class ImmortalReference {\n    constructor(object) {\n        this.object = object;\n    }\n    dispose() { }\n}\n/**\n * A map the manages the lifecycle of the values that it stores.\n */\nexport class DisposableMap {\n    constructor() {\n        this._store = new Map();\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    /**\n     * Disposes of all stored values and mark this object as disposed.\n     *\n     * Trying to use this object after it has been disposed of is an error.\n     */\n    dispose() {\n        markAsDisposed(this);\n        this._isDisposed = true;\n        this.clearAndDisposeAll();\n    }\n    /**\n     * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.\n     */\n    clearAndDisposeAll() {\n        if (!this._store.size) {\n            return;\n        }\n        try {\n            dispose(this._store.values());\n        }\n        finally {\n            this._store.clear();\n        }\n    }\n    get(key) {\n        return this._store.get(key);\n    }\n    set(key, value, skipDisposeOnOverwrite = false) {\n        var _a;\n        if (this._isDisposed) {\n            console.warn(new Error('Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!').stack);\n        }\n        if (!skipDisposeOnOverwrite) {\n            (_a = this._store.get(key)) === null || _a === void 0 ? void 0 : _a.dispose();\n        }\n        this._store.set(key, value);\n    }\n    /**\n     * Delete the value stored for `key` from this map and also dispose of it.\n     */\n    deleteAndDispose(key) {\n        var _a;\n        (_a = this._store.get(key)) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._store.delete(key);\n    }\n    [Symbol.iterator]() {\n        return this._store[Symbol.iterator]();\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}