{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.find-index.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var foldSourceAbbr = _defineProperty(_defineProperty(_defineProperty({}, 0 /* FoldSource.provider */, ' '), 1 /* FoldSource.userDefined */, 'u'), 2 /* FoldSource.recovered */, 'r');\nexport var MAX_FOLDING_REGIONS = 0xFFFF;\nexport var MAX_LINE_NUMBER = 0xFFFFFF;\nvar MASK_INDENT = 0xFF000000;\nvar BitField = /*#__PURE__*/function () {\n  function BitField(size) {\n    _classCallCheck(this, BitField);\n    var numWords = Math.ceil(size / 32);\n    this._states = new Uint32Array(numWords);\n  }\n  return _createClass(BitField, [{\n    key: \"get\",\n    value: function get(index) {\n      var arrayIndex = index / 32 | 0;\n      var bit = index % 32;\n      return (this._states[arrayIndex] & 1 << bit) !== 0;\n    }\n  }, {\n    key: \"set\",\n    value: function set(index, newState) {\n      var arrayIndex = index / 32 | 0;\n      var bit = index % 32;\n      var value = this._states[arrayIndex];\n      if (newState) {\n        this._states[arrayIndex] = value | 1 << bit;\n      } else {\n        this._states[arrayIndex] = value & ~(1 << bit);\n      }\n    }\n  }]);\n}();\nexport var FoldingRegions = /*#__PURE__*/function () {\n  function FoldingRegions(startIndexes, endIndexes, types) {\n    _classCallCheck(this, FoldingRegions);\n    if (startIndexes.length !== endIndexes.length || startIndexes.length > MAX_FOLDING_REGIONS) {\n      throw new Error('invalid startIndexes or endIndexes size');\n    }\n    this._startIndexes = startIndexes;\n    this._endIndexes = endIndexes;\n    this._collapseStates = new BitField(startIndexes.length);\n    this._userDefinedStates = new BitField(startIndexes.length);\n    this._recoveredStates = new BitField(startIndexes.length);\n    this._types = types;\n    this._parentsComputed = false;\n  }\n  return _createClass(FoldingRegions, [{\n    key: \"ensureParentIndices\",\n    value: function ensureParentIndices() {\n      var _this = this;\n      if (!this._parentsComputed) {\n        this._parentsComputed = true;\n        var parentIndexes = [];\n        var isInsideLast = function isInsideLast(startLineNumber, endLineNumber) {\n          var index = parentIndexes[parentIndexes.length - 1];\n          return _this.getStartLineNumber(index) <= startLineNumber && _this.getEndLineNumber(index) >= endLineNumber;\n        };\n        for (var i = 0, len = this._startIndexes.length; i < len; i++) {\n          var startLineNumber = this._startIndexes[i];\n          var endLineNumber = this._endIndexes[i];\n          if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n            throw new Error('startLineNumber or endLineNumber must not exceed ' + MAX_LINE_NUMBER);\n          }\n          while (parentIndexes.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {\n            parentIndexes.pop();\n          }\n          var parentIndex = parentIndexes.length > 0 ? parentIndexes[parentIndexes.length - 1] : -1;\n          parentIndexes.push(i);\n          this._startIndexes[i] = startLineNumber + ((parentIndex & 0xFF) << 24);\n          this._endIndexes[i] = endLineNumber + ((parentIndex & 0xFF00) << 16);\n        }\n      }\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._startIndexes.length;\n    }\n  }, {\n    key: \"getStartLineNumber\",\n    value: function getStartLineNumber(index) {\n      return this._startIndexes[index] & MAX_LINE_NUMBER;\n    }\n  }, {\n    key: \"getEndLineNumber\",\n    value: function getEndLineNumber(index) {\n      return this._endIndexes[index] & MAX_LINE_NUMBER;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType(index) {\n      return this._types ? this._types[index] : undefined;\n    }\n  }, {\n    key: \"hasTypes\",\n    value: function hasTypes() {\n      return !!this._types;\n    }\n  }, {\n    key: \"isCollapsed\",\n    value: function isCollapsed(index) {\n      return this._collapseStates.get(index);\n    }\n  }, {\n    key: \"setCollapsed\",\n    value: function setCollapsed(index, newState) {\n      this._collapseStates.set(index, newState);\n    }\n  }, {\n    key: \"isUserDefined\",\n    value: function isUserDefined(index) {\n      return this._userDefinedStates.get(index);\n    }\n  }, {\n    key: \"setUserDefined\",\n    value: function setUserDefined(index, newState) {\n      return this._userDefinedStates.set(index, newState);\n    }\n  }, {\n    key: \"isRecovered\",\n    value: function isRecovered(index) {\n      return this._recoveredStates.get(index);\n    }\n  }, {\n    key: \"setRecovered\",\n    value: function setRecovered(index, newState) {\n      return this._recoveredStates.set(index, newState);\n    }\n  }, {\n    key: \"getSource\",\n    value: function getSource(index) {\n      if (this.isUserDefined(index)) {\n        return 1 /* FoldSource.userDefined */;\n      } else if (this.isRecovered(index)) {\n        return 2 /* FoldSource.recovered */;\n      }\n      return 0 /* FoldSource.provider */;\n    }\n  }, {\n    key: \"setSource\",\n    value: function setSource(index, source) {\n      if (source === 1 /* FoldSource.userDefined */) {\n        this.setUserDefined(index, true);\n        this.setRecovered(index, false);\n      } else if (source === 2 /* FoldSource.recovered */) {\n        this.setUserDefined(index, false);\n        this.setRecovered(index, true);\n      } else {\n        this.setUserDefined(index, false);\n        this.setRecovered(index, false);\n      }\n    }\n  }, {\n    key: \"setCollapsedAllOfType\",\n    value: function setCollapsedAllOfType(type, newState) {\n      var hasChanged = false;\n      if (this._types) {\n        for (var i = 0; i < this._types.length; i++) {\n          if (this._types[i] === type) {\n            this.setCollapsed(i, newState);\n            hasChanged = true;\n          }\n        }\n      }\n      return hasChanged;\n    }\n  }, {\n    key: \"toRegion\",\n    value: function toRegion(index) {\n      return new FoldingRegion(this, index);\n    }\n  }, {\n    key: \"getParentIndex\",\n    value: function getParentIndex(index) {\n      this.ensureParentIndices();\n      var parent = ((this._startIndexes[index] & MASK_INDENT) >>> 24) + ((this._endIndexes[index] & MASK_INDENT) >>> 16);\n      if (parent === MAX_FOLDING_REGIONS) {\n        return -1;\n      }\n      return parent;\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(index, line) {\n      return this.getStartLineNumber(index) <= line && this.getEndLineNumber(index) >= line;\n    }\n  }, {\n    key: \"findIndex\",\n    value: function findIndex(line) {\n      var low = 0,\n        high = this._startIndexes.length;\n      if (high === 0) {\n        return -1; // no children\n      }\n      while (low < high) {\n        var mid = Math.floor((low + high) / 2);\n        if (line < this.getStartLineNumber(mid)) {\n          high = mid;\n        } else {\n          low = mid + 1;\n        }\n      }\n      return low - 1;\n    }\n  }, {\n    key: \"findRange\",\n    value: function findRange(line) {\n      var index = this.findIndex(line);\n      if (index >= 0) {\n        var endLineNumber = this.getEndLineNumber(index);\n        if (endLineNumber >= line) {\n          return index;\n        }\n        index = this.getParentIndex(index);\n        while (index !== -1) {\n          if (this.contains(index, line)) {\n            return index;\n          }\n          index = this.getParentIndex(index);\n        }\n      }\n      return -1;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var res = [];\n      for (var i = 0; i < this.length; i++) {\n        res[i] = \"[\".concat(foldSourceAbbr[this.getSource(i)]).concat(this.isCollapsed(i) ? '+' : '-', \"] \").concat(this.getStartLineNumber(i), \"/\").concat(this.getEndLineNumber(i));\n      }\n      return res.join(', ');\n    }\n  }, {\n    key: \"toFoldRange\",\n    value: function toFoldRange(index) {\n      return {\n        startLineNumber: this._startIndexes[index] & MAX_LINE_NUMBER,\n        endLineNumber: this._endIndexes[index] & MAX_LINE_NUMBER,\n        type: this._types ? this._types[index] : undefined,\n        isCollapsed: this.isCollapsed(index),\n        source: this.getSource(index)\n      };\n    }\n  }], [{\n    key: \"fromFoldRanges\",\n    value: function fromFoldRanges(ranges) {\n      var rangesLength = ranges.length;\n      var startIndexes = new Uint32Array(rangesLength);\n      var endIndexes = new Uint32Array(rangesLength);\n      var types = [];\n      var gotTypes = false;\n      for (var i = 0; i < rangesLength; i++) {\n        var range = ranges[i];\n        startIndexes[i] = range.startLineNumber;\n        endIndexes[i] = range.endLineNumber;\n        types.push(range.type);\n        if (range.type) {\n          gotTypes = true;\n        }\n      }\n      if (!gotTypes) {\n        types = undefined;\n      }\n      var regions = new FoldingRegions(startIndexes, endIndexes, types);\n      for (var _i = 0; _i < rangesLength; _i++) {\n        if (ranges[_i].isCollapsed) {\n          regions.setCollapsed(_i, true);\n        }\n        regions.setSource(_i, ranges[_i].source);\n      }\n      return regions;\n    }\n    /**\n     * Two inputs, each a FoldingRegions or a FoldRange[], are merged.\n     * Each input must be pre-sorted on startLineNumber.\n     * The first list is assumed to always include all regions currently defined by range providers.\n     * The second list only contains the previously collapsed and all manual ranges.\n     * If the line position matches, the range of the new range is taken, and the range is no longer manual\n     * When an entry in one list overlaps an entry in the other, the second list's entry \"wins\" and\n     * overlapping entries in the first list are discarded.\n     * Invalid entries are discarded. An entry is invalid if:\n     * \t\tthe start and end line numbers aren't a valid range of line numbers,\n     * \t\tit is out of sequence or has the same start line as a preceding entry,\n     * \t\tit overlaps a preceding entry and is not fully contained by that entry.\n     */\n  }, {\n    key: \"sanitizeAndMerge\",\n    value: function sanitizeAndMerge(rangesA, rangesB, maxLineNumber) {\n      maxLineNumber = maxLineNumber !== null && maxLineNumber !== void 0 ? maxLineNumber : Number.MAX_VALUE;\n      var getIndexedFunction = function getIndexedFunction(r, limit) {\n        return Array.isArray(r) ? function (i) {\n          return i < limit ? r[i] : undefined;\n        } : function (i) {\n          return i < limit ? r.toFoldRange(i) : undefined;\n        };\n      };\n      var getA = getIndexedFunction(rangesA, rangesA.length);\n      var getB = getIndexedFunction(rangesB, rangesB.length);\n      var indexA = 0;\n      var indexB = 0;\n      var nextA = getA(0);\n      var nextB = getB(0);\n      var stackedRanges = [];\n      var topStackedRange;\n      var prevLineNumber = 0;\n      var resultRanges = [];\n      while (nextA || nextB) {\n        var useRange = undefined;\n        if (nextB && (!nextA || nextA.startLineNumber >= nextB.startLineNumber)) {\n          if (nextA && nextA.startLineNumber === nextB.startLineNumber) {\n            if (nextB.source === 1 /* FoldSource.userDefined */) {\n              // a user defined range (possibly unfolded)\n              useRange = nextB;\n            } else {\n              // a previously folded range or a (possibly unfolded) recovered range\n              useRange = nextA;\n              useRange.isCollapsed = nextB.isCollapsed && nextA.endLineNumber === nextB.endLineNumber;\n              useRange.source = 0 /* FoldSource.provider */;\n            }\n            nextA = getA(++indexA); // not necessary, just for speed\n          } else {\n            useRange = nextB;\n            if (nextB.isCollapsed && nextB.source === 0 /* FoldSource.provider */) {\n              // a previously collapsed range\n              useRange.source = 2 /* FoldSource.recovered */;\n            }\n          }\n          nextB = getB(++indexB);\n        } else {\n          // nextA is next. The user folded B set takes precedence and we sometimes need to look\n          // ahead in it to check for an upcoming conflict.\n          var scanIndex = indexB;\n          var prescanB = nextB;\n          while (true) {\n            if (!prescanB || prescanB.startLineNumber > nextA.endLineNumber) {\n              useRange = nextA;\n              break; // no conflict, use this nextA\n            }\n            if (prescanB.source === 1 /* FoldSource.userDefined */ && prescanB.endLineNumber > nextA.endLineNumber) {\n              // we found a user folded range, it wins\n              break; // without setting nextResult, so this nextA gets skipped\n            }\n            prescanB = getB(++scanIndex);\n          }\n          nextA = getA(++indexA);\n        }\n        if (useRange) {\n          while (topStackedRange && topStackedRange.endLineNumber < useRange.startLineNumber) {\n            topStackedRange = stackedRanges.pop();\n          }\n          if (useRange.endLineNumber > useRange.startLineNumber && useRange.startLineNumber > prevLineNumber && useRange.endLineNumber <= maxLineNumber && (!topStackedRange || topStackedRange.endLineNumber >= useRange.endLineNumber)) {\n            resultRanges.push(useRange);\n            prevLineNumber = useRange.startLineNumber;\n            if (topStackedRange) {\n              stackedRanges.push(topStackedRange);\n            }\n            topStackedRange = useRange;\n          }\n        }\n      }\n      return resultRanges;\n    }\n  }]);\n}();\nexport var FoldingRegion = /*#__PURE__*/function () {\n  function FoldingRegion(ranges, index) {\n    _classCallCheck(this, FoldingRegion);\n    this.ranges = ranges;\n    this.index = index;\n  }\n  return _createClass(FoldingRegion, [{\n    key: \"startLineNumber\",\n    get: function get() {\n      return this.ranges.getStartLineNumber(this.index);\n    }\n  }, {\n    key: \"endLineNumber\",\n    get: function get() {\n      return this.ranges.getEndLineNumber(this.index);\n    }\n  }, {\n    key: \"regionIndex\",\n    get: function get() {\n      return this.index;\n    }\n  }, {\n    key: \"parentIndex\",\n    get: function get() {\n      return this.ranges.getParentIndex(this.index);\n    }\n  }, {\n    key: \"isCollapsed\",\n    get: function get() {\n      return this.ranges.isCollapsed(this.index);\n    }\n  }, {\n    key: \"containedBy\",\n    value: function containedBy(range) {\n      return range.startLineNumber <= this.startLineNumber && range.endLineNumber >= this.endLineNumber;\n    }\n  }, {\n    key: \"containsLine\",\n    value: function containsLine(lineNumber) {\n      return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;\n    }\n  }]);\n}();","map":{"version":3,"names":["foldSourceAbbr","_defineProperty","MAX_FOLDING_REGIONS","MAX_LINE_NUMBER","MASK_INDENT","BitField","size","_classCallCheck","numWords","Math","ceil","_states","Uint32Array","_createClass","key","value","get","index","arrayIndex","bit","set","newState","FoldingRegions","startIndexes","endIndexes","types","length","Error","_startIndexes","_endIndexes","_collapseStates","_userDefinedStates","_recoveredStates","_types","_parentsComputed","ensureParentIndices","_this","parentIndexes","isInsideLast","startLineNumber","endLineNumber","getStartLineNumber","getEndLineNumber","i","len","pop","parentIndex","push","getType","undefined","hasTypes","isCollapsed","setCollapsed","isUserDefined","setUserDefined","isRecovered","setRecovered","getSource","setSource","source","setCollapsedAllOfType","type","hasChanged","toRegion","FoldingRegion","getParentIndex","parent","contains","line","findIndex","low","high","mid","floor","findRange","toString","res","concat","join","toFoldRange","fromFoldRanges","ranges","rangesLength","gotTypes","range","regions","sanitizeAndMerge","rangesA","rangesB","maxLineNumber","Number","MAX_VALUE","getIndexedFunction","r","limit","Array","isArray","getA","getB","indexA","indexB","nextA","nextB","stackedRanges","topStackedRange","prevLineNumber","resultRanges","useRange","scanIndex","prescanB","containedBy","containsLine","lineNumber"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingRanges.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const foldSourceAbbr = {\n    [0 /* FoldSource.provider */]: ' ',\n    [1 /* FoldSource.userDefined */]: 'u',\n    [2 /* FoldSource.recovered */]: 'r',\n};\nexport const MAX_FOLDING_REGIONS = 0xFFFF;\nexport const MAX_LINE_NUMBER = 0xFFFFFF;\nconst MASK_INDENT = 0xFF000000;\nclass BitField {\n    constructor(size) {\n        const numWords = Math.ceil(size / 32);\n        this._states = new Uint32Array(numWords);\n    }\n    get(index) {\n        const arrayIndex = (index / 32) | 0;\n        const bit = index % 32;\n        return (this._states[arrayIndex] & (1 << bit)) !== 0;\n    }\n    set(index, newState) {\n        const arrayIndex = (index / 32) | 0;\n        const bit = index % 32;\n        const value = this._states[arrayIndex];\n        if (newState) {\n            this._states[arrayIndex] = value | (1 << bit);\n        }\n        else {\n            this._states[arrayIndex] = value & ~(1 << bit);\n        }\n    }\n}\nexport class FoldingRegions {\n    constructor(startIndexes, endIndexes, types) {\n        if (startIndexes.length !== endIndexes.length || startIndexes.length > MAX_FOLDING_REGIONS) {\n            throw new Error('invalid startIndexes or endIndexes size');\n        }\n        this._startIndexes = startIndexes;\n        this._endIndexes = endIndexes;\n        this._collapseStates = new BitField(startIndexes.length);\n        this._userDefinedStates = new BitField(startIndexes.length);\n        this._recoveredStates = new BitField(startIndexes.length);\n        this._types = types;\n        this._parentsComputed = false;\n    }\n    ensureParentIndices() {\n        if (!this._parentsComputed) {\n            this._parentsComputed = true;\n            const parentIndexes = [];\n            const isInsideLast = (startLineNumber, endLineNumber) => {\n                const index = parentIndexes[parentIndexes.length - 1];\n                return this.getStartLineNumber(index) <= startLineNumber && this.getEndLineNumber(index) >= endLineNumber;\n            };\n            for (let i = 0, len = this._startIndexes.length; i < len; i++) {\n                const startLineNumber = this._startIndexes[i];\n                const endLineNumber = this._endIndexes[i];\n                if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {\n                    throw new Error('startLineNumber or endLineNumber must not exceed ' + MAX_LINE_NUMBER);\n                }\n                while (parentIndexes.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {\n                    parentIndexes.pop();\n                }\n                const parentIndex = parentIndexes.length > 0 ? parentIndexes[parentIndexes.length - 1] : -1;\n                parentIndexes.push(i);\n                this._startIndexes[i] = startLineNumber + ((parentIndex & 0xFF) << 24);\n                this._endIndexes[i] = endLineNumber + ((parentIndex & 0xFF00) << 16);\n            }\n        }\n    }\n    get length() {\n        return this._startIndexes.length;\n    }\n    getStartLineNumber(index) {\n        return this._startIndexes[index] & MAX_LINE_NUMBER;\n    }\n    getEndLineNumber(index) {\n        return this._endIndexes[index] & MAX_LINE_NUMBER;\n    }\n    getType(index) {\n        return this._types ? this._types[index] : undefined;\n    }\n    hasTypes() {\n        return !!this._types;\n    }\n    isCollapsed(index) {\n        return this._collapseStates.get(index);\n    }\n    setCollapsed(index, newState) {\n        this._collapseStates.set(index, newState);\n    }\n    isUserDefined(index) {\n        return this._userDefinedStates.get(index);\n    }\n    setUserDefined(index, newState) {\n        return this._userDefinedStates.set(index, newState);\n    }\n    isRecovered(index) {\n        return this._recoveredStates.get(index);\n    }\n    setRecovered(index, newState) {\n        return this._recoveredStates.set(index, newState);\n    }\n    getSource(index) {\n        if (this.isUserDefined(index)) {\n            return 1 /* FoldSource.userDefined */;\n        }\n        else if (this.isRecovered(index)) {\n            return 2 /* FoldSource.recovered */;\n        }\n        return 0 /* FoldSource.provider */;\n    }\n    setSource(index, source) {\n        if (source === 1 /* FoldSource.userDefined */) {\n            this.setUserDefined(index, true);\n            this.setRecovered(index, false);\n        }\n        else if (source === 2 /* FoldSource.recovered */) {\n            this.setUserDefined(index, false);\n            this.setRecovered(index, true);\n        }\n        else {\n            this.setUserDefined(index, false);\n            this.setRecovered(index, false);\n        }\n    }\n    setCollapsedAllOfType(type, newState) {\n        let hasChanged = false;\n        if (this._types) {\n            for (let i = 0; i < this._types.length; i++) {\n                if (this._types[i] === type) {\n                    this.setCollapsed(i, newState);\n                    hasChanged = true;\n                }\n            }\n        }\n        return hasChanged;\n    }\n    toRegion(index) {\n        return new FoldingRegion(this, index);\n    }\n    getParentIndex(index) {\n        this.ensureParentIndices();\n        const parent = ((this._startIndexes[index] & MASK_INDENT) >>> 24) + ((this._endIndexes[index] & MASK_INDENT) >>> 16);\n        if (parent === MAX_FOLDING_REGIONS) {\n            return -1;\n        }\n        return parent;\n    }\n    contains(index, line) {\n        return this.getStartLineNumber(index) <= line && this.getEndLineNumber(index) >= line;\n    }\n    findIndex(line) {\n        let low = 0, high = this._startIndexes.length;\n        if (high === 0) {\n            return -1; // no children\n        }\n        while (low < high) {\n            const mid = Math.floor((low + high) / 2);\n            if (line < this.getStartLineNumber(mid)) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        return low - 1;\n    }\n    findRange(line) {\n        let index = this.findIndex(line);\n        if (index >= 0) {\n            const endLineNumber = this.getEndLineNumber(index);\n            if (endLineNumber >= line) {\n                return index;\n            }\n            index = this.getParentIndex(index);\n            while (index !== -1) {\n                if (this.contains(index, line)) {\n                    return index;\n                }\n                index = this.getParentIndex(index);\n            }\n        }\n        return -1;\n    }\n    toString() {\n        const res = [];\n        for (let i = 0; i < this.length; i++) {\n            res[i] = `[${foldSourceAbbr[this.getSource(i)]}${this.isCollapsed(i) ? '+' : '-'}] ${this.getStartLineNumber(i)}/${this.getEndLineNumber(i)}`;\n        }\n        return res.join(', ');\n    }\n    toFoldRange(index) {\n        return {\n            startLineNumber: this._startIndexes[index] & MAX_LINE_NUMBER,\n            endLineNumber: this._endIndexes[index] & MAX_LINE_NUMBER,\n            type: this._types ? this._types[index] : undefined,\n            isCollapsed: this.isCollapsed(index),\n            source: this.getSource(index)\n        };\n    }\n    static fromFoldRanges(ranges) {\n        const rangesLength = ranges.length;\n        const startIndexes = new Uint32Array(rangesLength);\n        const endIndexes = new Uint32Array(rangesLength);\n        let types = [];\n        let gotTypes = false;\n        for (let i = 0; i < rangesLength; i++) {\n            const range = ranges[i];\n            startIndexes[i] = range.startLineNumber;\n            endIndexes[i] = range.endLineNumber;\n            types.push(range.type);\n            if (range.type) {\n                gotTypes = true;\n            }\n        }\n        if (!gotTypes) {\n            types = undefined;\n        }\n        const regions = new FoldingRegions(startIndexes, endIndexes, types);\n        for (let i = 0; i < rangesLength; i++) {\n            if (ranges[i].isCollapsed) {\n                regions.setCollapsed(i, true);\n            }\n            regions.setSource(i, ranges[i].source);\n        }\n        return regions;\n    }\n    /**\n     * Two inputs, each a FoldingRegions or a FoldRange[], are merged.\n     * Each input must be pre-sorted on startLineNumber.\n     * The first list is assumed to always include all regions currently defined by range providers.\n     * The second list only contains the previously collapsed and all manual ranges.\n     * If the line position matches, the range of the new range is taken, and the range is no longer manual\n     * When an entry in one list overlaps an entry in the other, the second list's entry \"wins\" and\n     * overlapping entries in the first list are discarded.\n     * Invalid entries are discarded. An entry is invalid if:\n     * \t\tthe start and end line numbers aren't a valid range of line numbers,\n     * \t\tit is out of sequence or has the same start line as a preceding entry,\n     * \t\tit overlaps a preceding entry and is not fully contained by that entry.\n     */\n    static sanitizeAndMerge(rangesA, rangesB, maxLineNumber) {\n        maxLineNumber = maxLineNumber !== null && maxLineNumber !== void 0 ? maxLineNumber : Number.MAX_VALUE;\n        const getIndexedFunction = (r, limit) => {\n            return Array.isArray(r)\n                ? ((i) => { return (i < limit) ? r[i] : undefined; })\n                : ((i) => { return (i < limit) ? r.toFoldRange(i) : undefined; });\n        };\n        const getA = getIndexedFunction(rangesA, rangesA.length);\n        const getB = getIndexedFunction(rangesB, rangesB.length);\n        let indexA = 0;\n        let indexB = 0;\n        let nextA = getA(0);\n        let nextB = getB(0);\n        const stackedRanges = [];\n        let topStackedRange;\n        let prevLineNumber = 0;\n        const resultRanges = [];\n        while (nextA || nextB) {\n            let useRange = undefined;\n            if (nextB && (!nextA || nextA.startLineNumber >= nextB.startLineNumber)) {\n                if (nextA && nextA.startLineNumber === nextB.startLineNumber) {\n                    if (nextB.source === 1 /* FoldSource.userDefined */) {\n                        // a user defined range (possibly unfolded)\n                        useRange = nextB;\n                    }\n                    else {\n                        // a previously folded range or a (possibly unfolded) recovered range\n                        useRange = nextA;\n                        useRange.isCollapsed = nextB.isCollapsed && nextA.endLineNumber === nextB.endLineNumber;\n                        useRange.source = 0 /* FoldSource.provider */;\n                    }\n                    nextA = getA(++indexA); // not necessary, just for speed\n                }\n                else {\n                    useRange = nextB;\n                    if (nextB.isCollapsed && nextB.source === 0 /* FoldSource.provider */) {\n                        // a previously collapsed range\n                        useRange.source = 2 /* FoldSource.recovered */;\n                    }\n                }\n                nextB = getB(++indexB);\n            }\n            else {\n                // nextA is next. The user folded B set takes precedence and we sometimes need to look\n                // ahead in it to check for an upcoming conflict.\n                let scanIndex = indexB;\n                let prescanB = nextB;\n                while (true) {\n                    if (!prescanB || prescanB.startLineNumber > nextA.endLineNumber) {\n                        useRange = nextA;\n                        break; // no conflict, use this nextA\n                    }\n                    if (prescanB.source === 1 /* FoldSource.userDefined */ && prescanB.endLineNumber > nextA.endLineNumber) {\n                        // we found a user folded range, it wins\n                        break; // without setting nextResult, so this nextA gets skipped\n                    }\n                    prescanB = getB(++scanIndex);\n                }\n                nextA = getA(++indexA);\n            }\n            if (useRange) {\n                while (topStackedRange\n                    && topStackedRange.endLineNumber < useRange.startLineNumber) {\n                    topStackedRange = stackedRanges.pop();\n                }\n                if (useRange.endLineNumber > useRange.startLineNumber\n                    && useRange.startLineNumber > prevLineNumber\n                    && useRange.endLineNumber <= maxLineNumber\n                    && (!topStackedRange\n                        || topStackedRange.endLineNumber >= useRange.endLineNumber)) {\n                    resultRanges.push(useRange);\n                    prevLineNumber = useRange.startLineNumber;\n                    if (topStackedRange) {\n                        stackedRanges.push(topStackedRange);\n                    }\n                    topStackedRange = useRange;\n                }\n            }\n        }\n        return resultRanges;\n    }\n}\nexport class FoldingRegion {\n    constructor(ranges, index) {\n        this.ranges = ranges;\n        this.index = index;\n    }\n    get startLineNumber() {\n        return this.ranges.getStartLineNumber(this.index);\n    }\n    get endLineNumber() {\n        return this.ranges.getEndLineNumber(this.index);\n    }\n    get regionIndex() {\n        return this.index;\n    }\n    get parentIndex() {\n        return this.ranges.getParentIndex(this.index);\n    }\n    get isCollapsed() {\n        return this.ranges.isCollapsed(this.index);\n    }\n    containedBy(range) {\n        return range.startLineNumber <= this.startLineNumber && range.endLineNumber >= this.endLineNumber;\n    }\n    containsLine(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}