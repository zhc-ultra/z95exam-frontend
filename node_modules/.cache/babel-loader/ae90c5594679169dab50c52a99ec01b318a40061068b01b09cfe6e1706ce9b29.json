{"ast":null,"code":"import _slicedToArray from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\nexport var BracketTokens = /*#__PURE__*/function () {\n  function BracketTokens(map) {\n    _classCallCheck(this, BracketTokens);\n    this.map = map;\n    this.hasRegExp = false;\n    this._regExpGlobal = null;\n  }\n  return _createClass(BracketTokens, [{\n    key: \"getRegExpStr\",\n    value: function getRegExpStr() {\n      if (this.isEmpty) {\n        return null;\n      } else {\n        var keys = _toConsumableArray(this.map.keys());\n        keys.sort();\n        keys.reverse();\n        return keys.map(function (k) {\n          return prepareBracketForRegExp(k);\n        }).join('|');\n      }\n    }\n    /**\n     * Returns null if there is no such regexp (because there are no brackets).\n    */\n  }, {\n    key: \"regExpGlobal\",\n    get: function get() {\n      if (!this.hasRegExp) {\n        var regExpStr = this.getRegExpStr();\n        this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n        this.hasRegExp = true;\n      }\n      return this._regExpGlobal;\n    }\n  }, {\n    key: \"getToken\",\n    value: function getToken(value) {\n      return this.map.get(value.toLowerCase());\n    }\n  }, {\n    key: \"findClosingTokenText\",\n    value: function findClosingTokenText(openingBracketIds) {\n      var _iterator = _createForOfIteratorHelper(this.map),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            closingText = _step$value[0],\n            info = _step$value[1];\n          if (info.kind === 2 /* TokenKind.ClosingBracket */ && info.bracketIds.intersects(openingBracketIds)) {\n            return closingText;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return undefined;\n    }\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this.map.size === 0;\n    }\n  }], [{\n    key: \"createFromLanguage\",\n    value: function createFromLanguage(configuration, denseKeyProvider) {\n      function getId(bracketInfo) {\n        return denseKeyProvider.getKey(\"\".concat(bracketInfo.languageId, \":::\").concat(bracketInfo.bracketText));\n      }\n      var map = new Map();\n      var _iterator2 = _createForOfIteratorHelper(configuration.bracketsNew.openingBrackets),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var openingBracket = _step2.value;\n          var length = toLength(0, openingBracket.bracketText.length);\n          var openingTextId = getId(openingBracket);\n          var bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n          map.set(openingBracket.bracketText, new Token(length, 1 /* TokenKind.OpeningBracket */, openingTextId, bracketIds, BracketAstNode.create(length, openingBracket, bracketIds)));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var _iterator3 = _createForOfIteratorHelper(configuration.bracketsNew.closingBrackets),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var closingBracket = _step3.value;\n          var _length = toLength(0, closingBracket.bracketText.length);\n          var _bracketIds = SmallImmutableSet.getEmpty();\n          var closingBrackets = closingBracket.getOpeningBrackets();\n          var _iterator4 = _createForOfIteratorHelper(closingBrackets),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var bracket = _step4.value;\n              _bracketIds = _bracketIds.add(getId(bracket), identityKeyProvider);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          map.set(closingBracket.bracketText, new Token(_length, 2 /* TokenKind.ClosingBracket */, getId(closingBrackets[0]), _bracketIds, BracketAstNode.create(_length, closingBracket, _bracketIds)));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return new BracketTokens(map);\n    }\n  }]);\n}();\nfunction prepareBracketForRegExp(str) {\n  var escaped = escapeRegExpCharacters(str);\n  // These bracket pair delimiters start or end with letters\n  // see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n  if (/^[\\w ]+/.test(str)) {\n    escaped = \"\\\\b\".concat(escaped);\n  }\n  if (/[\\w ]+$/.test(str)) {\n    escaped = \"\".concat(escaped, \"\\\\b\");\n  }\n  return escaped;\n}\nexport var LanguageAgnosticBracketTokens = /*#__PURE__*/function () {\n  function LanguageAgnosticBracketTokens(denseKeyProvider, getLanguageConfiguration) {\n    _classCallCheck(this, LanguageAgnosticBracketTokens);\n    this.denseKeyProvider = denseKeyProvider;\n    this.getLanguageConfiguration = getLanguageConfiguration;\n    this.languageIdToBracketTokens = new Map();\n  }\n  return _createClass(LanguageAgnosticBracketTokens, [{\n    key: \"didLanguageChange\",\n    value: function didLanguageChange(languageId) {\n      // Report a change whenever the language configuration updates.\n      return this.languageIdToBracketTokens.has(languageId);\n    }\n  }, {\n    key: \"getSingleLanguageBracketTokens\",\n    value: function getSingleLanguageBracketTokens(languageId) {\n      var singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n      if (!singleLanguageBracketTokens) {\n        singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n        this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n      }\n      return singleLanguageBracketTokens;\n    }\n  }]);\n}();","map":{"version":3,"names":["escapeRegExpCharacters","BracketAstNode","toLength","identityKeyProvider","SmallImmutableSet","Token","BracketTokens","map","_classCallCheck","hasRegExp","_regExpGlobal","_createClass","key","value","getRegExpStr","isEmpty","keys","_toConsumableArray","sort","reverse","k","prepareBracketForRegExp","join","get","regExpStr","RegExp","getToken","toLowerCase","findClosingTokenText","openingBracketIds","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","_slicedToArray","closingText","info","kind","bracketIds","intersects","err","e","f","undefined","size","createFromLanguage","configuration","denseKeyProvider","getId","bracketInfo","getKey","concat","languageId","bracketText","Map","_iterator2","bracketsNew","openingBrackets","_step2","openingBracket","length","openingTextId","getEmpty","add","set","create","_iterator3","closingBrackets","_step3","closingBracket","getOpeningBrackets","_iterator4","_step4","bracket","str","escaped","test","LanguageAgnosticBracketTokens","getLanguageConfiguration","languageIdToBracketTokens","didLanguageChange","has","getSingleLanguageBracketTokens","singleLanguageBracketTokens"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\nexport class BracketTokens {\n    static createFromLanguage(configuration, denseKeyProvider) {\n        function getId(bracketInfo) {\n            return denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);\n        }\n        const map = new Map();\n        for (const openingBracket of configuration.bracketsNew.openingBrackets) {\n            const length = toLength(0, openingBracket.bracketText.length);\n            const openingTextId = getId(openingBracket);\n            const bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n            map.set(openingBracket.bracketText, new Token(length, 1 /* TokenKind.OpeningBracket */, openingTextId, bracketIds, BracketAstNode.create(length, openingBracket, bracketIds)));\n        }\n        for (const closingBracket of configuration.bracketsNew.closingBrackets) {\n            const length = toLength(0, closingBracket.bracketText.length);\n            let bracketIds = SmallImmutableSet.getEmpty();\n            const closingBrackets = closingBracket.getOpeningBrackets();\n            for (const bracket of closingBrackets) {\n                bracketIds = bracketIds.add(getId(bracket), identityKeyProvider);\n            }\n            map.set(closingBracket.bracketText, new Token(length, 2 /* TokenKind.ClosingBracket */, getId(closingBrackets[0]), bracketIds, BracketAstNode.create(length, closingBracket, bracketIds)));\n        }\n        return new BracketTokens(map);\n    }\n    constructor(map) {\n        this.map = map;\n        this.hasRegExp = false;\n        this._regExpGlobal = null;\n    }\n    getRegExpStr() {\n        if (this.isEmpty) {\n            return null;\n        }\n        else {\n            const keys = [...this.map.keys()];\n            keys.sort();\n            keys.reverse();\n            return keys.map(k => prepareBracketForRegExp(k)).join('|');\n        }\n    }\n    /**\n     * Returns null if there is no such regexp (because there are no brackets).\n    */\n    get regExpGlobal() {\n        if (!this.hasRegExp) {\n            const regExpStr = this.getRegExpStr();\n            this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n            this.hasRegExp = true;\n        }\n        return this._regExpGlobal;\n    }\n    getToken(value) {\n        return this.map.get(value.toLowerCase());\n    }\n    findClosingTokenText(openingBracketIds) {\n        for (const [closingText, info] of this.map) {\n            if (info.kind === 2 /* TokenKind.ClosingBracket */ && info.bracketIds.intersects(openingBracketIds)) {\n                return closingText;\n            }\n        }\n        return undefined;\n    }\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\nfunction prepareBracketForRegExp(str) {\n    let escaped = escapeRegExpCharacters(str);\n    // These bracket pair delimiters start or end with letters\n    // see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n    if (/^[\\w ]+/.test(str)) {\n        escaped = `\\\\b${escaped}`;\n    }\n    if (/[\\w ]+$/.test(str)) {\n        escaped = `${escaped}\\\\b`;\n    }\n    return escaped;\n}\nexport class LanguageAgnosticBracketTokens {\n    constructor(denseKeyProvider, getLanguageConfiguration) {\n        this.denseKeyProvider = denseKeyProvider;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.languageIdToBracketTokens = new Map();\n    }\n    didLanguageChange(languageId) {\n        // Report a change whenever the language configuration updates.\n        return this.languageIdToBracketTokens.has(languageId);\n    }\n    getSingleLanguageBracketTokens(languageId) {\n        let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n        if (!singleLanguageBracketTokens) {\n            singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n            this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n        }\n        return singleLanguageBracketTokens;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}