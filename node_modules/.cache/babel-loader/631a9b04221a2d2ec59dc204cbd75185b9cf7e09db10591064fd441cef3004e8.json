{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.code-point-at.js\";\nimport \"core-js/modules/es.string.from-code-point.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../core/range.js';\nimport { Searcher } from '../model/textModelSearch.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { assertNever } from '../../../base/common/assert.js';\nimport { DEFAULT_WORD_REGEXP, getWordAtText } from '../core/wordHelper.js';\nexport var UnicodeTextModelHighlighter = /*#__PURE__*/function () {\n  function UnicodeTextModelHighlighter() {\n    _classCallCheck(this, UnicodeTextModelHighlighter);\n  }\n  return _createClass(UnicodeTextModelHighlighter, null, [{\n    key: \"computeUnicodeHighlights\",\n    value: function computeUnicodeHighlights(model, options, range) {\n      var startLine = range ? range.startLineNumber : 1;\n      var endLine = range ? range.endLineNumber : model.getLineCount();\n      var codePointHighlighter = new CodePointHighlighter(options);\n      var candidates = codePointHighlighter.getCandidateCodePoints();\n      var regex;\n      if (candidates === 'allNonBasicAscii') {\n        regex = new RegExp('[^\\\\t\\\\n\\\\r\\\\x20-\\\\x7E]', 'g');\n      } else {\n        regex = new RegExp(\"\".concat(buildRegExpCharClassExpr(Array.from(candidates))), 'g');\n      }\n      var searcher = new Searcher(null, regex);\n      var ranges = [];\n      var hasMore = false;\n      var m;\n      var ambiguousCharacterCount = 0;\n      var invisibleCharacterCount = 0;\n      var nonBasicAsciiCharacterCount = 0;\n      forLoop: for (var lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {\n        var lineContent = model.getLineContent(lineNumber);\n        var lineLength = lineContent.length;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n          m = searcher.next(lineContent);\n          if (m) {\n            var startIndex = m.index;\n            var endIndex = m.index + m[0].length;\n            // Extend range to entire code point\n            if (startIndex > 0) {\n              var charCodeBefore = lineContent.charCodeAt(startIndex - 1);\n              if (strings.isHighSurrogate(charCodeBefore)) {\n                startIndex--;\n              }\n            }\n            if (endIndex + 1 < lineLength) {\n              var _charCodeBefore = lineContent.charCodeAt(endIndex - 1);\n              if (strings.isHighSurrogate(_charCodeBefore)) {\n                endIndex++;\n              }\n            }\n            var str = lineContent.substring(startIndex, endIndex);\n            var word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);\n            if (word && word.endColumn <= startIndex + 1) {\n              // The word does not include the problematic character, ignore the word\n              word = null;\n            }\n            var highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);\n            if (highlightReason !== 0 /* SimpleHighlightReason.None */) {\n              if (highlightReason === 3 /* SimpleHighlightReason.Ambiguous */) {\n                ambiguousCharacterCount++;\n              } else if (highlightReason === 2 /* SimpleHighlightReason.Invisible */) {\n                invisibleCharacterCount++;\n              } else if (highlightReason === 1 /* SimpleHighlightReason.NonBasicASCII */) {\n                nonBasicAsciiCharacterCount++;\n              } else {\n                assertNever(highlightReason);\n              }\n              var MAX_RESULT_LENGTH = 1000;\n              if (ranges.length >= MAX_RESULT_LENGTH) {\n                hasMore = true;\n                break forLoop;\n              }\n              ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));\n            }\n          }\n        } while (m);\n      }\n      return {\n        ranges: ranges,\n        hasMore: hasMore,\n        ambiguousCharacterCount: ambiguousCharacterCount,\n        invisibleCharacterCount: invisibleCharacterCount,\n        nonBasicAsciiCharacterCount: nonBasicAsciiCharacterCount\n      };\n    }\n  }, {\n    key: \"computeUnicodeHighlightReason\",\n    value: function computeUnicodeHighlightReason(_char, options) {\n      var codePointHighlighter = new CodePointHighlighter(options);\n      var reason = codePointHighlighter.shouldHighlightNonBasicASCII(_char, null);\n      switch (reason) {\n        case 0 /* SimpleHighlightReason.None */:\n          return null;\n        case 2 /* SimpleHighlightReason.Invisible */:\n          return {\n            kind: 1 /* UnicodeHighlighterReasonKind.Invisible */\n          };\n        case 3 /* SimpleHighlightReason.Ambiguous */:\n          {\n            var codePoint = _char.codePointAt(0);\n            var primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);\n            var notAmbiguousInLocales = strings.AmbiguousCharacters.getLocales().filter(function (l) {\n              return !strings.AmbiguousCharacters.getInstance(new Set([].concat(_toConsumableArray(options.allowedLocales), [l]))).isAmbiguous(codePoint);\n            });\n            return {\n              kind: 0 /* UnicodeHighlighterReasonKind.Ambiguous */,\n              confusableWith: String.fromCodePoint(primaryConfusable),\n              notAmbiguousInLocales: notAmbiguousInLocales\n            };\n          }\n        case 1 /* SimpleHighlightReason.NonBasicASCII */:\n          return {\n            kind: 2 /* UnicodeHighlighterReasonKind.NonBasicAscii */\n          };\n      }\n    }\n  }]);\n}();\nfunction buildRegExpCharClassExpr(codePoints, flags) {\n  var src = \"[\".concat(strings.escapeRegExpCharacters(codePoints.map(function (i) {\n    return String.fromCodePoint(i);\n  }).join('')), \"]\");\n  return src;\n}\nvar CodePointHighlighter = /*#__PURE__*/function () {\n  function CodePointHighlighter(options) {\n    _classCallCheck(this, CodePointHighlighter);\n    this.options = options;\n    this.allowedCodePoints = new Set(options.allowedCodePoints);\n    this.ambiguousCharacters = strings.AmbiguousCharacters.getInstance(new Set(options.allowedLocales));\n  }\n  return _createClass(CodePointHighlighter, [{\n    key: \"getCandidateCodePoints\",\n    value: function getCandidateCodePoints() {\n      if (this.options.nonBasicASCII) {\n        return 'allNonBasicAscii';\n      }\n      var set = new Set();\n      if (this.options.invisibleCharacters) {\n        var _iterator = _createForOfIteratorHelper(strings.InvisibleCharacters.codePoints),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var cp = _step.value;\n            if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {\n              set.add(cp);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      if (this.options.ambiguousCharacters) {\n        var _iterator2 = _createForOfIteratorHelper(this.ambiguousCharacters.getConfusableCodePoints()),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _cp = _step2.value;\n            set.add(_cp);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      var _iterator3 = _createForOfIteratorHelper(this.allowedCodePoints),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _cp2 = _step3.value;\n          set[\"delete\"](_cp2);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return set;\n    }\n  }, {\n    key: \"shouldHighlightNonBasicASCII\",\n    value: function shouldHighlightNonBasicASCII(character, wordContext) {\n      var codePoint = character.codePointAt(0);\n      if (this.allowedCodePoints.has(codePoint)) {\n        return 0 /* SimpleHighlightReason.None */;\n      }\n      if (this.options.nonBasicASCII) {\n        return 1 /* SimpleHighlightReason.NonBasicASCII */;\n      }\n      var hasBasicASCIICharacters = false;\n      var hasNonConfusableNonBasicAsciiCharacter = false;\n      if (wordContext) {\n        var _iterator4 = _createForOfIteratorHelper(wordContext),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _char2 = _step4.value;\n            var _codePoint = _char2.codePointAt(0);\n            var isBasicASCII = strings.isBasicASCII(_char2);\n            hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII;\n            if (!isBasicASCII && !this.ambiguousCharacters.isAmbiguous(_codePoint) && !strings.InvisibleCharacters.isInvisibleCharacter(_codePoint)) {\n              hasNonConfusableNonBasicAsciiCharacter = true;\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n      if ( /* Don't allow mixing weird looking characters with ASCII */!hasBasicASCIICharacters && /* Is there an obviously weird looking character? */hasNonConfusableNonBasicAsciiCharacter) {\n        return 0 /* SimpleHighlightReason.None */;\n      }\n      if (this.options.invisibleCharacters) {\n        // TODO check for emojis\n        if (!isAllowedInvisibleCharacter(character) && strings.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n          return 2 /* SimpleHighlightReason.Invisible */;\n        }\n      }\n      if (this.options.ambiguousCharacters) {\n        if (this.ambiguousCharacters.isAmbiguous(codePoint)) {\n          return 3 /* SimpleHighlightReason.Ambiguous */;\n        }\n      }\n      return 0 /* SimpleHighlightReason.None */;\n    }\n  }]);\n}();\nfunction isAllowedInvisibleCharacter(character) {\n  return character === ' ' || character === '\\n' || character === '\\t';\n}","map":{"version":3,"names":["Range","Searcher","strings","assertNever","DEFAULT_WORD_REGEXP","getWordAtText","UnicodeTextModelHighlighter","_classCallCheck","_createClass","key","value","computeUnicodeHighlights","model","options","range","startLine","startLineNumber","endLine","endLineNumber","getLineCount","codePointHighlighter","CodePointHighlighter","candidates","getCandidateCodePoints","regex","RegExp","concat","buildRegExpCharClassExpr","Array","from","searcher","ranges","hasMore","m","ambiguousCharacterCount","invisibleCharacterCount","nonBasicAsciiCharacterCount","forLoop","lineNumber","lineCount","lineContent","getLineContent","lineLength","length","reset","next","startIndex","index","endIndex","charCodeBefore","charCodeAt","isHighSurrogate","str","substring","word","endColumn","highlightReason","shouldHighlightNonBasicASCII","MAX_RESULT_LENGTH","push","computeUnicodeHighlightReason","char","reason","kind","codePoint","codePointAt","primaryConfusable","ambiguousCharacters","getPrimaryConfusable","notAmbiguousInLocales","AmbiguousCharacters","getLocales","filter","l","getInstance","Set","_toConsumableArray","allowedLocales","isAmbiguous","confusableWith","String","fromCodePoint","codePoints","flags","src","escapeRegExpCharacters","map","i","join","allowedCodePoints","nonBasicASCII","set","invisibleCharacters","_iterator","_createForOfIteratorHelper","InvisibleCharacters","_step","s","n","done","cp","isAllowedInvisibleCharacter","add","err","e","f","_iterator2","getConfusableCodePoints","_step2","_iterator3","_step3","character","wordContext","has","hasBasicASCIICharacters","hasNonConfusableNonBasicAsciiCharacter","_iterator4","_step4","isBasicASCII","isInvisibleCharacter"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../core/range.js';\nimport { Searcher } from '../model/textModelSearch.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { assertNever } from '../../../base/common/assert.js';\nimport { DEFAULT_WORD_REGEXP, getWordAtText } from '../core/wordHelper.js';\nexport class UnicodeTextModelHighlighter {\n    static computeUnicodeHighlights(model, options, range) {\n        const startLine = range ? range.startLineNumber : 1;\n        const endLine = range ? range.endLineNumber : model.getLineCount();\n        const codePointHighlighter = new CodePointHighlighter(options);\n        const candidates = codePointHighlighter.getCandidateCodePoints();\n        let regex;\n        if (candidates === 'allNonBasicAscii') {\n            regex = new RegExp('[^\\\\t\\\\n\\\\r\\\\x20-\\\\x7E]', 'g');\n        }\n        else {\n            regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, 'g');\n        }\n        const searcher = new Searcher(null, regex);\n        const ranges = [];\n        let hasMore = false;\n        let m;\n        let ambiguousCharacterCount = 0;\n        let invisibleCharacterCount = 0;\n        let nonBasicAsciiCharacterCount = 0;\n        forLoop: for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {\n            const lineContent = model.getLineContent(lineNumber);\n            const lineLength = lineContent.length;\n            // Reset regex to search from the beginning\n            searcher.reset(0);\n            do {\n                m = searcher.next(lineContent);\n                if (m) {\n                    let startIndex = m.index;\n                    let endIndex = m.index + m[0].length;\n                    // Extend range to entire code point\n                    if (startIndex > 0) {\n                        const charCodeBefore = lineContent.charCodeAt(startIndex - 1);\n                        if (strings.isHighSurrogate(charCodeBefore)) {\n                            startIndex--;\n                        }\n                    }\n                    if (endIndex + 1 < lineLength) {\n                        const charCodeBefore = lineContent.charCodeAt(endIndex - 1);\n                        if (strings.isHighSurrogate(charCodeBefore)) {\n                            endIndex++;\n                        }\n                    }\n                    const str = lineContent.substring(startIndex, endIndex);\n                    let word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);\n                    if (word && word.endColumn <= startIndex + 1) {\n                        // The word does not include the problematic character, ignore the word\n                        word = null;\n                    }\n                    const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);\n                    if (highlightReason !== 0 /* SimpleHighlightReason.None */) {\n                        if (highlightReason === 3 /* SimpleHighlightReason.Ambiguous */) {\n                            ambiguousCharacterCount++;\n                        }\n                        else if (highlightReason === 2 /* SimpleHighlightReason.Invisible */) {\n                            invisibleCharacterCount++;\n                        }\n                        else if (highlightReason === 1 /* SimpleHighlightReason.NonBasicASCII */) {\n                            nonBasicAsciiCharacterCount++;\n                        }\n                        else {\n                            assertNever(highlightReason);\n                        }\n                        const MAX_RESULT_LENGTH = 1000;\n                        if (ranges.length >= MAX_RESULT_LENGTH) {\n                            hasMore = true;\n                            break forLoop;\n                        }\n                        ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));\n                    }\n                }\n            } while (m);\n        }\n        return {\n            ranges,\n            hasMore,\n            ambiguousCharacterCount,\n            invisibleCharacterCount,\n            nonBasicAsciiCharacterCount\n        };\n    }\n    static computeUnicodeHighlightReason(char, options) {\n        const codePointHighlighter = new CodePointHighlighter(options);\n        const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);\n        switch (reason) {\n            case 0 /* SimpleHighlightReason.None */:\n                return null;\n            case 2 /* SimpleHighlightReason.Invisible */:\n                return { kind: 1 /* UnicodeHighlighterReasonKind.Invisible */ };\n            case 3 /* SimpleHighlightReason.Ambiguous */: {\n                const codePoint = char.codePointAt(0);\n                const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);\n                const notAmbiguousInLocales = strings.AmbiguousCharacters.getLocales().filter((l) => !strings.AmbiguousCharacters.getInstance(new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));\n                return { kind: 0 /* UnicodeHighlighterReasonKind.Ambiguous */, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };\n            }\n            case 1 /* SimpleHighlightReason.NonBasicASCII */:\n                return { kind: 2 /* UnicodeHighlighterReasonKind.NonBasicAscii */ };\n        }\n    }\n}\nfunction buildRegExpCharClassExpr(codePoints, flags) {\n    const src = `[${strings.escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(''))}]`;\n    return src;\n}\nclass CodePointHighlighter {\n    constructor(options) {\n        this.options = options;\n        this.allowedCodePoints = new Set(options.allowedCodePoints);\n        this.ambiguousCharacters = strings.AmbiguousCharacters.getInstance(new Set(options.allowedLocales));\n    }\n    getCandidateCodePoints() {\n        if (this.options.nonBasicASCII) {\n            return 'allNonBasicAscii';\n        }\n        const set = new Set();\n        if (this.options.invisibleCharacters) {\n            for (const cp of strings.InvisibleCharacters.codePoints) {\n                if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {\n                    set.add(cp);\n                }\n            }\n        }\n        if (this.options.ambiguousCharacters) {\n            for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {\n                set.add(cp);\n            }\n        }\n        for (const cp of this.allowedCodePoints) {\n            set.delete(cp);\n        }\n        return set;\n    }\n    shouldHighlightNonBasicASCII(character, wordContext) {\n        const codePoint = character.codePointAt(0);\n        if (this.allowedCodePoints.has(codePoint)) {\n            return 0 /* SimpleHighlightReason.None */;\n        }\n        if (this.options.nonBasicASCII) {\n            return 1 /* SimpleHighlightReason.NonBasicASCII */;\n        }\n        let hasBasicASCIICharacters = false;\n        let hasNonConfusableNonBasicAsciiCharacter = false;\n        if (wordContext) {\n            for (const char of wordContext) {\n                const codePoint = char.codePointAt(0);\n                const isBasicASCII = strings.isBasicASCII(char);\n                hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII;\n                if (!isBasicASCII &&\n                    !this.ambiguousCharacters.isAmbiguous(codePoint) &&\n                    !strings.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n                    hasNonConfusableNonBasicAsciiCharacter = true;\n                }\n            }\n        }\n        if (\n        /* Don't allow mixing weird looking characters with ASCII */ !hasBasicASCIICharacters &&\n            /* Is there an obviously weird looking character? */ hasNonConfusableNonBasicAsciiCharacter) {\n            return 0 /* SimpleHighlightReason.None */;\n        }\n        if (this.options.invisibleCharacters) {\n            // TODO check for emojis\n            if (!isAllowedInvisibleCharacter(character) && strings.InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n                return 2 /* SimpleHighlightReason.Invisible */;\n            }\n        }\n        if (this.options.ambiguousCharacters) {\n            if (this.ambiguousCharacters.isAmbiguous(codePoint)) {\n                return 3 /* SimpleHighlightReason.Ambiguous */;\n            }\n        }\n        return 0 /* SimpleHighlightReason.None */;\n    }\n}\nfunction isAllowedInvisibleCharacter(character) {\n    return character === ' ' || character === '\\n' || character === '\\t';\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}