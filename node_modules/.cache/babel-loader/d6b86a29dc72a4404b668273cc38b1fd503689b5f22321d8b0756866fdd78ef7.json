{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _callSuper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _get from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { MOUSE_CURSOR_TEXT_CSS_CLASS_NAME } from '../../../../base/browser/ui/mouseCursor/mouseCursor.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport './viewLines.css';\nimport { applyFontInfo } from '../../config/domFontInfo.js';\nimport { HorizontalPosition, HorizontalRange, LineVisibleRanges } from '../../view/renderingContext.js';\nimport { VisibleLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { DomReadingContext } from './domReadingContext.js';\nimport { ViewLine, ViewLineOptions } from './viewLine.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nvar LastRenderedData = /*#__PURE__*/function () {\n  function LastRenderedData() {\n    _classCallCheck(this, LastRenderedData);\n    this._currentVisibleRange = new Range(1, 1, 1, 1);\n  }\n  return _createClass(LastRenderedData, [{\n    key: \"getCurrentVisibleRange\",\n    value: function getCurrentVisibleRange() {\n      return this._currentVisibleRange;\n    }\n  }, {\n    key: \"setCurrentVisibleRange\",\n    value: function setCurrentVisibleRange(currentVisibleRange) {\n      this._currentVisibleRange = currentVisibleRange;\n    }\n  }]);\n}();\nvar HorizontalRevealRangeRequest = /*#__PURE__*/_createClass(function HorizontalRevealRangeRequest(minimalReveal, lineNumber, startColumn, endColumn, startScrollTop, stopScrollTop, scrollType) {\n  _classCallCheck(this, HorizontalRevealRangeRequest);\n  this.minimalReveal = minimalReveal;\n  this.lineNumber = lineNumber;\n  this.startColumn = startColumn;\n  this.endColumn = endColumn;\n  this.startScrollTop = startScrollTop;\n  this.stopScrollTop = stopScrollTop;\n  this.scrollType = scrollType;\n  this.type = 'range';\n  this.minLineNumber = lineNumber;\n  this.maxLineNumber = lineNumber;\n});\nvar HorizontalRevealSelectionsRequest = /*#__PURE__*/_createClass(function HorizontalRevealSelectionsRequest(minimalReveal, selections, startScrollTop, stopScrollTop, scrollType) {\n  _classCallCheck(this, HorizontalRevealSelectionsRequest);\n  this.minimalReveal = minimalReveal;\n  this.selections = selections;\n  this.startScrollTop = startScrollTop;\n  this.stopScrollTop = stopScrollTop;\n  this.scrollType = scrollType;\n  this.type = 'selections';\n  var minLineNumber = selections[0].startLineNumber;\n  var maxLineNumber = selections[0].endLineNumber;\n  for (var i = 1, len = selections.length; i < len; i++) {\n    var selection = selections[i];\n    minLineNumber = Math.min(minLineNumber, selection.startLineNumber);\n    maxLineNumber = Math.max(maxLineNumber, selection.endLineNumber);\n  }\n  this.minLineNumber = minLineNumber;\n  this.maxLineNumber = maxLineNumber;\n});\nexport var ViewLines = /*#__PURE__*/function (_ViewPart) {\n  function ViewLines(context, linesContent) {\n    var _this;\n    _classCallCheck(this, ViewLines);\n    _this = _callSuper(this, ViewLines, [context]);\n    _this._linesContent = linesContent;\n    _this._textRangeRestingSpot = document.createElement('div');\n    _this._visibleLines = new VisibleLinesCollection(_this);\n    _this.domNode = _this._visibleLines.domNode;\n    var conf = _this._context.configuration;\n    var options = _this._context.configuration.options;\n    var fontInfo = options.get(50 /* EditorOption.fontInfo */);\n    var wrappingInfo = options.get(146 /* EditorOption.wrappingInfo */);\n    _this._lineHeight = options.get(67 /* EditorOption.lineHeight */);\n    _this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n    _this._isViewportWrapping = wrappingInfo.isViewportWrapping;\n    _this._revealHorizontalRightPadding = options.get(100 /* EditorOption.revealHorizontalRightPadding */);\n    _this._cursorSurroundingLines = options.get(29 /* EditorOption.cursorSurroundingLines */);\n    _this._cursorSurroundingLinesStyle = options.get(30 /* EditorOption.cursorSurroundingLinesStyle */);\n    _this._canUseLayerHinting = !options.get(32 /* EditorOption.disableLayerHinting */);\n    _this._viewLineOptions = new ViewLineOptions(conf, _this._context.theme.type);\n    PartFingerprints.write(_this.domNode, 8 /* PartFingerprint.ViewLines */);\n    _this.domNode.setClassName(\"view-lines \".concat(MOUSE_CURSOR_TEXT_CSS_CLASS_NAME));\n    applyFontInfo(_this.domNode, fontInfo);\n    // --- width & height\n    _this._maxLineWidth = 0;\n    _this._asyncUpdateLineWidths = new RunOnceScheduler(function () {\n      _this._updateLineWidthsSlow();\n    }, 200);\n    _this._asyncCheckMonospaceFontAssumptions = new RunOnceScheduler(function () {\n      _this._checkMonospaceFontAssumptions();\n    }, 2000);\n    _this._lastRenderedData = new LastRenderedData();\n    _this._horizontalRevealRequest = null;\n    // sticky scroll widget\n    _this._stickyScrollEnabled = options.get(115 /* EditorOption.stickyScroll */).enabled;\n    _this._maxNumberStickyLines = options.get(115 /* EditorOption.stickyScroll */).maxLineCount;\n    return _this;\n  }\n  _inherits(ViewLines, _ViewPart);\n  return _createClass(ViewLines, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this._asyncUpdateLineWidths.dispose();\n      this._asyncCheckMonospaceFontAssumptions.dispose();\n      _get(_getPrototypeOf(ViewLines.prototype), \"dispose\", this).call(this);\n    }\n  }, {\n    key: \"getDomNode\",\n    value: function getDomNode() {\n      return this.domNode;\n    }\n    // ---- begin IVisibleLinesHost\n  }, {\n    key: \"createVisibleLine\",\n    value: function createVisibleLine() {\n      return new ViewLine(this._viewLineOptions);\n    }\n    // ---- end IVisibleLinesHost\n    // ---- begin view event handlers\n  }, {\n    key: \"onConfigurationChanged\",\n    value: function onConfigurationChanged(e) {\n      this._visibleLines.onConfigurationChanged(e);\n      if (e.hasChanged(146 /* EditorOption.wrappingInfo */)) {\n        this._maxLineWidth = 0;\n      }\n      var options = this._context.configuration.options;\n      var fontInfo = options.get(50 /* EditorOption.fontInfo */);\n      var wrappingInfo = options.get(146 /* EditorOption.wrappingInfo */);\n      this._lineHeight = options.get(67 /* EditorOption.lineHeight */);\n      this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n      this._isViewportWrapping = wrappingInfo.isViewportWrapping;\n      this._revealHorizontalRightPadding = options.get(100 /* EditorOption.revealHorizontalRightPadding */);\n      this._cursorSurroundingLines = options.get(29 /* EditorOption.cursorSurroundingLines */);\n      this._cursorSurroundingLinesStyle = options.get(30 /* EditorOption.cursorSurroundingLinesStyle */);\n      this._canUseLayerHinting = !options.get(32 /* EditorOption.disableLayerHinting */);\n      // sticky scroll\n      this._stickyScrollEnabled = options.get(115 /* EditorOption.stickyScroll */).enabled;\n      this._maxNumberStickyLines = options.get(115 /* EditorOption.stickyScroll */).maxLineCount;\n      applyFontInfo(this.domNode, fontInfo);\n      this._onOptionsMaybeChanged();\n      if (e.hasChanged(145 /* EditorOption.layoutInfo */)) {\n        this._maxLineWidth = 0;\n      }\n      return true;\n    }\n  }, {\n    key: \"_onOptionsMaybeChanged\",\n    value: function _onOptionsMaybeChanged() {\n      var conf = this._context.configuration;\n      var newViewLineOptions = new ViewLineOptions(conf, this._context.theme.type);\n      if (!this._viewLineOptions.equals(newViewLineOptions)) {\n        this._viewLineOptions = newViewLineOptions;\n        var startLineNumber = this._visibleLines.getStartLineNumber();\n        var endLineNumber = this._visibleLines.getEndLineNumber();\n        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n          var line = this._visibleLines.getVisibleLine(lineNumber);\n          line.onOptionsChanged(this._viewLineOptions);\n        }\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"onCursorStateChanged\",\n    value: function onCursorStateChanged(e) {\n      var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n      var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n      var r = false;\n      for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n        r = this._visibleLines.getVisibleLine(lineNumber).onSelectionChanged() || r;\n      }\n      return r;\n    }\n  }, {\n    key: \"onDecorationsChanged\",\n    value: function onDecorationsChanged(e) {\n      if (true /*e.inlineDecorationsChanged*/) {\n        var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n          this._visibleLines.getVisibleLine(lineNumber).onDecorationsChanged();\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"onFlushed\",\n    value: function onFlushed(e) {\n      var shouldRender = this._visibleLines.onFlushed(e);\n      this._maxLineWidth = 0;\n      return shouldRender;\n    }\n  }, {\n    key: \"onLinesChanged\",\n    value: function onLinesChanged(e) {\n      return this._visibleLines.onLinesChanged(e);\n    }\n  }, {\n    key: \"onLinesDeleted\",\n    value: function onLinesDeleted(e) {\n      return this._visibleLines.onLinesDeleted(e);\n    }\n  }, {\n    key: \"onLinesInserted\",\n    value: function onLinesInserted(e) {\n      return this._visibleLines.onLinesInserted(e);\n    }\n  }, {\n    key: \"onRevealRangeRequest\",\n    value: function onRevealRangeRequest(e) {\n      // Using the future viewport here in order to handle multiple\n      // incoming reveal range requests that might all desire to be animated\n      var desiredScrollTop = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.minimalReveal, e.range, e.selections, e.verticalType);\n      if (desiredScrollTop === -1) {\n        // marker to abort the reveal range request\n        return false;\n      }\n      // validate the new desired scroll top\n      var newScrollPosition = this._context.viewLayout.validateScrollPosition({\n        scrollTop: desiredScrollTop\n      });\n      if (e.revealHorizontal) {\n        if (e.range && e.range.startLineNumber !== e.range.endLineNumber) {\n          // Two or more lines? => scroll to base (That's how you see most of the two lines)\n          newScrollPosition = {\n            scrollTop: newScrollPosition.scrollTop,\n            scrollLeft: 0\n          };\n        } else if (e.range) {\n          // We don't necessarily know the horizontal offset of this range since the line might not be in the view...\n          this._horizontalRevealRequest = new HorizontalRevealRangeRequest(e.minimalReveal, e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\n        } else if (e.selections && e.selections.length > 0) {\n          this._horizontalRevealRequest = new HorizontalRevealSelectionsRequest(e.minimalReveal, e.selections, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\n        }\n      } else {\n        this._horizontalRevealRequest = null;\n      }\n      var scrollTopDelta = Math.abs(this._context.viewLayout.getCurrentScrollTop() - newScrollPosition.scrollTop);\n      var scrollType = scrollTopDelta <= this._lineHeight ? 1 /* ScrollType.Immediate */ : e.scrollType;\n      this._context.viewModel.viewLayout.setScrollPosition(newScrollPosition, scrollType);\n      return true;\n    }\n  }, {\n    key: \"onScrollChanged\",\n    value: function onScrollChanged(e) {\n      if (this._horizontalRevealRequest && e.scrollLeftChanged) {\n        // cancel any outstanding horizontal reveal request if someone else scrolls horizontally.\n        this._horizontalRevealRequest = null;\n      }\n      if (this._horizontalRevealRequest && e.scrollTopChanged) {\n        var min = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n        var max = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n        if (e.scrollTop < min || e.scrollTop > max) {\n          // cancel any outstanding horizontal reveal request if someone else scrolls vertically.\n          this._horizontalRevealRequest = null;\n        }\n      }\n      this.domNode.setWidth(e.scrollWidth);\n      return this._visibleLines.onScrollChanged(e) || true;\n    }\n  }, {\n    key: \"onTokensChanged\",\n    value: function onTokensChanged(e) {\n      return this._visibleLines.onTokensChanged(e);\n    }\n  }, {\n    key: \"onZonesChanged\",\n    value: function onZonesChanged(e) {\n      this._context.viewModel.viewLayout.setMaxLineWidth(this._maxLineWidth);\n      return this._visibleLines.onZonesChanged(e);\n    }\n  }, {\n    key: \"onThemeChanged\",\n    value: function onThemeChanged(e) {\n      return this._onOptionsMaybeChanged();\n    }\n    // ---- end view event handlers\n    // ----------- HELPERS FOR OTHERS\n  }, {\n    key: \"getPositionFromDOMInfo\",\n    value: function getPositionFromDOMInfo(spanNode, offset) {\n      var viewLineDomNode = this._getViewLineDomNode(spanNode);\n      if (viewLineDomNode === null) {\n        // Couldn't find view line node\n        return null;\n      }\n      var lineNumber = this._getLineNumberFor(viewLineDomNode);\n      if (lineNumber === -1) {\n        // Couldn't find view line node\n        return null;\n      }\n      if (lineNumber < 1 || lineNumber > this._context.viewModel.getLineCount()) {\n        // lineNumber is outside range\n        return null;\n      }\n      if (this._context.viewModel.getLineMaxColumn(lineNumber) === 1) {\n        // Line is empty\n        return new Position(lineNumber, 1);\n      }\n      var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n      var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n      if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n        // Couldn't find line\n        return null;\n      }\n      var column = this._visibleLines.getVisibleLine(lineNumber).getColumnOfNodeOffset(spanNode, offset);\n      var minColumn = this._context.viewModel.getLineMinColumn(lineNumber);\n      if (column < minColumn) {\n        column = minColumn;\n      }\n      return new Position(lineNumber, column);\n    }\n  }, {\n    key: \"_getViewLineDomNode\",\n    value: function _getViewLineDomNode(node) {\n      while (node && node.nodeType === 1) {\n        if (node.className === ViewLine.CLASS_NAME) {\n          return node;\n        }\n        node = node.parentElement;\n      }\n      return null;\n    }\n    /**\n     * @returns the line number of this view line dom node.\n     */\n  }, {\n    key: \"_getLineNumberFor\",\n    value: function _getLineNumberFor(domNode) {\n      var startLineNumber = this._visibleLines.getStartLineNumber();\n      var endLineNumber = this._visibleLines.getEndLineNumber();\n      for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n        var line = this._visibleLines.getVisibleLine(lineNumber);\n        if (domNode === line.getDomNode()) {\n          return lineNumber;\n        }\n      }\n      return -1;\n    }\n  }, {\n    key: \"getLineWidth\",\n    value: function getLineWidth(lineNumber) {\n      var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n      var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n      if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n        // Couldn't find line\n        return -1;\n      }\n      var context = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);\n      var result = this._visibleLines.getVisibleLine(lineNumber).getWidth(context);\n      this._updateLineWidthsSlowIfDomDidLayout(context);\n      return result;\n    }\n  }, {\n    key: \"linesVisibleRangesForRange\",\n    value: function linesVisibleRangesForRange(_range, includeNewLines) {\n      if (this.shouldRender()) {\n        // Cannot read from the DOM because it is dirty\n        // i.e. the model & the dom are out of sync, so I'd be reading something stale\n        return null;\n      }\n      var originalEndLineNumber = _range.endLineNumber;\n      var range = Range.intersectRanges(_range, this._lastRenderedData.getCurrentVisibleRange());\n      if (!range) {\n        return null;\n      }\n      var visibleRanges = [];\n      var visibleRangesLen = 0;\n      var domReadingContext = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);\n      var nextLineModelLineNumber = 0;\n      if (includeNewLines) {\n        nextLineModelLineNumber = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(range.startLineNumber, 1)).lineNumber;\n      }\n      var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n      var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n      for (var lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n        if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n          continue;\n        }\n        var startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;\n        var continuesInNextLine = lineNumber !== range.endLineNumber;\n        var endColumn = continuesInNextLine ? this._context.viewModel.getLineMaxColumn(lineNumber) : range.endColumn;\n        var visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(lineNumber, startColumn, endColumn, domReadingContext);\n        if (!visibleRangesForLine) {\n          continue;\n        }\n        if (includeNewLines && lineNumber < originalEndLineNumber) {\n          var currentLineModelLineNumber = nextLineModelLineNumber;\n          nextLineModelLineNumber = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(lineNumber + 1, 1)).lineNumber;\n          if (currentLineModelLineNumber !== nextLineModelLineNumber) {\n            visibleRangesForLine.ranges[visibleRangesForLine.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth;\n          }\n        }\n        visibleRanges[visibleRangesLen++] = new LineVisibleRanges(visibleRangesForLine.outsideRenderedLine, lineNumber, HorizontalRange.from(visibleRangesForLine.ranges), continuesInNextLine);\n      }\n      this._updateLineWidthsSlowIfDomDidLayout(domReadingContext);\n      if (visibleRangesLen === 0) {\n        return null;\n      }\n      return visibleRanges;\n    }\n  }, {\n    key: \"_visibleRangesForLineRange\",\n    value: function _visibleRangesForLineRange(lineNumber, startColumn, endColumn) {\n      if (this.shouldRender()) {\n        // Cannot read from the DOM because it is dirty\n        // i.e. the model & the dom are out of sync, so I'd be reading something stale\n        return null;\n      }\n      if (lineNumber < this._visibleLines.getStartLineNumber() || lineNumber > this._visibleLines.getEndLineNumber()) {\n        return null;\n      }\n      var domReadingContext = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);\n      var result = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(lineNumber, startColumn, endColumn, domReadingContext);\n      this._updateLineWidthsSlowIfDomDidLayout(domReadingContext);\n      return result;\n    }\n  }, {\n    key: \"visibleRangeForPosition\",\n    value: function visibleRangeForPosition(position) {\n      var visibleRanges = this._visibleRangesForLineRange(position.lineNumber, position.column, position.column);\n      if (!visibleRanges) {\n        return null;\n      }\n      return new HorizontalPosition(visibleRanges.outsideRenderedLine, visibleRanges.ranges[0].left);\n    }\n    /**\n     * Updates the max line width if it is fast to compute.\n     * Returns true if all lines were taken into account.\n     * Returns false if some lines need to be reevaluated (in a slow fashion).\n     */\n  }, {\n    key: \"_updateLineWidthsFast\",\n    value: function _updateLineWidthsFast() {\n      return this._updateLineWidths(true);\n    }\n  }, {\n    key: \"_updateLineWidthsSlow\",\n    value: function _updateLineWidthsSlow() {\n      this._updateLineWidths(false);\n    }\n    /**\n     * Update the line widths using DOM layout information after someone else\n     * has caused a synchronous layout.\n     */\n  }, {\n    key: \"_updateLineWidthsSlowIfDomDidLayout\",\n    value: function _updateLineWidthsSlowIfDomDidLayout(domReadingContext) {\n      if (!domReadingContext.didDomLayout) {\n        // only proceed if we just did a layout\n        return;\n      }\n      if (this._asyncUpdateLineWidths.isScheduled()) {\n        // reading widths is not scheduled => widths are up-to-date\n        return;\n      }\n      this._asyncUpdateLineWidths.cancel();\n      this._updateLineWidthsSlow();\n    }\n  }, {\n    key: \"_updateLineWidths\",\n    value: function _updateLineWidths(fast) {\n      var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n      var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n      var localMaxLineWidth = 1;\n      var allWidthsComputed = true;\n      for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n        var visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n        if (fast && !visibleLine.getWidthIsFast()) {\n          // Cannot compute width in a fast way for this line\n          allWidthsComputed = false;\n          continue;\n        }\n        localMaxLineWidth = Math.max(localMaxLineWidth, visibleLine.getWidth(null));\n      }\n      if (allWidthsComputed && rendStartLineNumber === 1 && rendEndLineNumber === this._context.viewModel.getLineCount()) {\n        // we know the max line width for all the lines\n        this._maxLineWidth = 0;\n      }\n      this._ensureMaxLineWidth(localMaxLineWidth);\n      return allWidthsComputed;\n    }\n  }, {\n    key: \"_checkMonospaceFontAssumptions\",\n    value: function _checkMonospaceFontAssumptions() {\n      // Problems with monospace assumptions are more apparent for longer lines,\n      // as small rounding errors start to sum up, so we will select the longest\n      // line for a closer inspection\n      var longestLineNumber = -1;\n      var longestWidth = -1;\n      var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n      var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n      for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n        var visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n        if (visibleLine.needsMonospaceFontCheck()) {\n          var lineWidth = visibleLine.getWidth(null);\n          if (lineWidth > longestWidth) {\n            longestWidth = lineWidth;\n            longestLineNumber = lineNumber;\n          }\n        }\n      }\n      if (longestLineNumber === -1) {\n        return;\n      }\n      if (!this._visibleLines.getVisibleLine(longestLineNumber).monospaceAssumptionsAreValid()) {\n        for (var _lineNumber = rendStartLineNumber; _lineNumber <= rendEndLineNumber; _lineNumber++) {\n          var _visibleLine = this._visibleLines.getVisibleLine(_lineNumber);\n          _visibleLine.onMonospaceAssumptionsInvalidated();\n        }\n      }\n    }\n  }, {\n    key: \"prepareRender\",\n    value: function prepareRender() {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"renderText\",\n    value: function renderText(viewportData) {\n      // (1) render lines - ensures lines are in the DOM\n      this._visibleLines.renderLines(viewportData);\n      this._lastRenderedData.setCurrentVisibleRange(viewportData.visibleRange);\n      this.domNode.setWidth(this._context.viewLayout.getScrollWidth());\n      this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1000000));\n      // (2) compute horizontal scroll position:\n      //  - this must happen after the lines are in the DOM since it might need a line that rendered just now\n      //  - it might change `scrollWidth` and `scrollLeft`\n      if (this._horizontalRevealRequest) {\n        var horizontalRevealRequest = this._horizontalRevealRequest;\n        // Check that we have the line that contains the horizontal range in the viewport\n        if (viewportData.startLineNumber <= horizontalRevealRequest.minLineNumber && horizontalRevealRequest.maxLineNumber <= viewportData.endLineNumber) {\n          this._horizontalRevealRequest = null;\n          // allow `visibleRangesForRange2` to work\n          this.onDidRender();\n          // compute new scroll position\n          var newScrollLeft = this._computeScrollLeftToReveal(horizontalRevealRequest);\n          if (newScrollLeft) {\n            if (!this._isViewportWrapping) {\n              // ensure `scrollWidth` is large enough\n              this._ensureMaxLineWidth(newScrollLeft.maxHorizontalOffset);\n            }\n            // set `scrollLeft`\n            this._context.viewModel.viewLayout.setScrollPosition({\n              scrollLeft: newScrollLeft.scrollLeft\n            }, horizontalRevealRequest.scrollType);\n          }\n        }\n      }\n      // Update max line width (not so important, it is just so the horizontal scrollbar doesn't get too small)\n      if (!this._updateLineWidthsFast()) {\n        // Computing the width of some lines would be slow => delay it\n        this._asyncUpdateLineWidths.schedule();\n      } else {\n        this._asyncUpdateLineWidths.cancel();\n      }\n      if (platform.isLinux && !this._asyncCheckMonospaceFontAssumptions.isScheduled()) {\n        var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n          var visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n          if (visibleLine.needsMonospaceFontCheck()) {\n            this._asyncCheckMonospaceFontAssumptions.schedule();\n            break;\n          }\n        }\n      }\n      // (3) handle scrolling\n      this._linesContent.setLayerHinting(this._canUseLayerHinting);\n      this._linesContent.setContain('strict');\n      var adjustedScrollTop = this._context.viewLayout.getCurrentScrollTop() - viewportData.bigNumbersDelta;\n      this._linesContent.setTop(-adjustedScrollTop);\n      this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());\n    }\n    // --- width\n  }, {\n    key: \"_ensureMaxLineWidth\",\n    value: function _ensureMaxLineWidth(lineWidth) {\n      var iLineWidth = Math.ceil(lineWidth);\n      if (this._maxLineWidth < iLineWidth) {\n        this._maxLineWidth = iLineWidth;\n        this._context.viewModel.viewLayout.setMaxLineWidth(this._maxLineWidth);\n      }\n    }\n  }, {\n    key: \"_computeScrollTopToRevealRange\",\n    value: function _computeScrollTopToRevealRange(viewport, source, minimalReveal, range, selections, verticalType) {\n      var viewportStartY = viewport.top;\n      var viewportHeight = viewport.height;\n      var viewportEndY = viewportStartY + viewportHeight;\n      var boxIsSingleRange;\n      var boxStartY;\n      var boxEndY;\n      if (selections && selections.length > 0) {\n        var minLineNumber = selections[0].startLineNumber;\n        var maxLineNumber = selections[0].endLineNumber;\n        for (var i = 1, len = selections.length; i < len; i++) {\n          var selection = selections[i];\n          minLineNumber = Math.min(minLineNumber, selection.startLineNumber);\n          maxLineNumber = Math.max(maxLineNumber, selection.endLineNumber);\n        }\n        boxIsSingleRange = false;\n        boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(minLineNumber);\n        boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(maxLineNumber) + this._lineHeight;\n      } else if (range) {\n        boxIsSingleRange = true;\n        boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.startLineNumber);\n        boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.endLineNumber) + this._lineHeight;\n      } else {\n        return -1;\n      }\n      var shouldIgnoreScrollOff = (source === 'mouse' || minimalReveal) && this._cursorSurroundingLinesStyle === 'default';\n      var paddingTop = 0;\n      var paddingBottom = 0;\n      if (!shouldIgnoreScrollOff) {\n        var context = Math.min(viewportHeight / this._lineHeight / 2, this._cursorSurroundingLines);\n        if (this._stickyScrollEnabled) {\n          paddingTop = Math.max(context, this._maxNumberStickyLines) * this._lineHeight;\n        } else {\n          paddingTop = context * this._lineHeight;\n        }\n        paddingBottom = Math.max(0, context - 1) * this._lineHeight;\n      } else {\n        if (!minimalReveal) {\n          // Reveal one more line above (this case is hit when dragging)\n          paddingTop = this._lineHeight;\n        }\n      }\n      if (!minimalReveal) {\n        if (verticalType === 0 /* viewEvents.VerticalRevealType.Simple */ || verticalType === 4 /* viewEvents.VerticalRevealType.Bottom */) {\n          // Reveal one line more when the last line would be covered by the scrollbar - arrow down case or revealing a line explicitly at bottom\n          paddingBottom += this._lineHeight;\n        }\n      }\n      boxStartY -= paddingTop;\n      boxEndY += paddingBottom;\n      var newScrollTop;\n      if (boxEndY - boxStartY > viewportHeight) {\n        // the box is larger than the viewport ... scroll to its top\n        if (!boxIsSingleRange) {\n          // do not reveal multiple cursors if there are more than fit the viewport\n          return -1;\n        }\n        newScrollTop = boxStartY;\n      } else if (verticalType === 5 /* viewEvents.VerticalRevealType.NearTop */ || verticalType === 6 /* viewEvents.VerticalRevealType.NearTopIfOutsideViewport */) {\n        if (verticalType === 6 /* viewEvents.VerticalRevealType.NearTopIfOutsideViewport */ && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\n          // Box is already in the viewport... do nothing\n          newScrollTop = viewportStartY;\n        } else {\n          // We want a gap that is 20% of the viewport, but with a minimum of 5 lines\n          var desiredGapAbove = Math.max(5 * this._lineHeight, viewportHeight * 0.2);\n          // Try to scroll just above the box with the desired gap\n          var desiredScrollTop = boxStartY - desiredGapAbove;\n          // But ensure that the box is not pushed out of viewport\n          var minScrollTop = boxEndY - viewportHeight;\n          newScrollTop = Math.max(minScrollTop, desiredScrollTop);\n        }\n      } else if (verticalType === 1 /* viewEvents.VerticalRevealType.Center */ || verticalType === 2 /* viewEvents.VerticalRevealType.CenterIfOutsideViewport */) {\n        if (verticalType === 2 /* viewEvents.VerticalRevealType.CenterIfOutsideViewport */ && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\n          // Box is already in the viewport... do nothing\n          newScrollTop = viewportStartY;\n        } else {\n          // Box is outside the viewport... center it\n          var boxMiddleY = (boxStartY + boxEndY) / 2;\n          newScrollTop = Math.max(0, boxMiddleY - viewportHeight / 2);\n        }\n      } else {\n        newScrollTop = this._computeMinimumScrolling(viewportStartY, viewportEndY, boxStartY, boxEndY, verticalType === 3 /* viewEvents.VerticalRevealType.Top */, verticalType === 4 /* viewEvents.VerticalRevealType.Bottom */);\n      }\n      return newScrollTop;\n    }\n  }, {\n    key: \"_computeScrollLeftToReveal\",\n    value: function _computeScrollLeftToReveal(horizontalRevealRequest) {\n      var viewport = this._context.viewLayout.getCurrentViewport();\n      var layoutInfo = this._context.configuration.options.get(145 /* EditorOption.layoutInfo */);\n      var viewportStartX = viewport.left;\n      var viewportEndX = viewportStartX + viewport.width - layoutInfo.verticalScrollbarWidth;\n      var boxStartX = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n      var boxEndX = 0;\n      if (horizontalRevealRequest.type === 'range') {\n        var visibleRanges = this._visibleRangesForLineRange(horizontalRevealRequest.lineNumber, horizontalRevealRequest.startColumn, horizontalRevealRequest.endColumn);\n        if (!visibleRanges) {\n          return null;\n        }\n        var _iterator = _createForOfIteratorHelper(visibleRanges.ranges),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var visibleRange = _step.value;\n            boxStartX = Math.min(boxStartX, Math.round(visibleRange.left));\n            boxEndX = Math.max(boxEndX, Math.round(visibleRange.left + visibleRange.width));\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        var _iterator2 = _createForOfIteratorHelper(horizontalRevealRequest.selections),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var selection = _step2.value;\n            if (selection.startLineNumber !== selection.endLineNumber) {\n              return null;\n            }\n            var _visibleRanges = this._visibleRangesForLineRange(selection.startLineNumber, selection.startColumn, selection.endColumn);\n            if (!_visibleRanges) {\n              return null;\n            }\n            var _iterator3 = _createForOfIteratorHelper(_visibleRanges.ranges),\n              _step3;\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var _visibleRange = _step3.value;\n                boxStartX = Math.min(boxStartX, Math.round(_visibleRange.left));\n                boxEndX = Math.max(boxEndX, Math.round(_visibleRange.left + _visibleRange.width));\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      if (!horizontalRevealRequest.minimalReveal) {\n        boxStartX = Math.max(0, boxStartX - ViewLines.HORIZONTAL_EXTRA_PX);\n        boxEndX += this._revealHorizontalRightPadding;\n      }\n      if (horizontalRevealRequest.type === 'selections' && boxEndX - boxStartX > viewport.width) {\n        return null;\n      }\n      var newScrollLeft = this._computeMinimumScrolling(viewportStartX, viewportEndX, boxStartX, boxEndX);\n      return {\n        scrollLeft: newScrollLeft,\n        maxHorizontalOffset: boxEndX\n      };\n    }\n  }, {\n    key: \"_computeMinimumScrolling\",\n    value: function _computeMinimumScrolling(viewportStart, viewportEnd, boxStart, boxEnd, revealAtStart, revealAtEnd) {\n      viewportStart = viewportStart | 0;\n      viewportEnd = viewportEnd | 0;\n      boxStart = boxStart | 0;\n      boxEnd = boxEnd | 0;\n      revealAtStart = !!revealAtStart;\n      revealAtEnd = !!revealAtEnd;\n      var viewportLength = viewportEnd - viewportStart;\n      var boxLength = boxEnd - boxStart;\n      if (boxLength < viewportLength) {\n        // The box would fit in the viewport\n        if (revealAtStart) {\n          return boxStart;\n        }\n        if (revealAtEnd) {\n          return Math.max(0, boxEnd - viewportLength);\n        }\n        if (boxStart < viewportStart) {\n          // The box is above the viewport\n          return boxStart;\n        } else if (boxEnd > viewportEnd) {\n          // The box is below the viewport\n          return Math.max(0, boxEnd - viewportLength);\n        }\n      } else {\n        // The box would not fit in the viewport\n        // Reveal the beginning of the box\n        return boxStart;\n      }\n      return viewportStart;\n    }\n  }]);\n}(ViewPart);\n/**\n * Adds this amount of pixels to the right of lines (no-one wants to type near the edge of the viewport)\n */\nViewLines.HORIZONTAL_EXTRA_PX = 30;","map":{"version":3,"names":["MOUSE_CURSOR_TEXT_CSS_CLASS_NAME","RunOnceScheduler","platform","applyFontInfo","HorizontalPosition","HorizontalRange","LineVisibleRanges","VisibleLinesCollection","PartFingerprints","ViewPart","DomReadingContext","ViewLine","ViewLineOptions","Position","Range","LastRenderedData","_classCallCheck","_currentVisibleRange","_createClass","key","value","getCurrentVisibleRange","setCurrentVisibleRange","currentVisibleRange","HorizontalRevealRangeRequest","minimalReveal","lineNumber","startColumn","endColumn","startScrollTop","stopScrollTop","scrollType","type","minLineNumber","maxLineNumber","HorizontalRevealSelectionsRequest","selections","startLineNumber","endLineNumber","i","len","length","selection","Math","min","max","ViewLines","_ViewPart","context","linesContent","_this","_callSuper","_linesContent","_textRangeRestingSpot","document","createElement","_visibleLines","domNode","conf","_context","configuration","options","fontInfo","get","wrappingInfo","_lineHeight","_typicalHalfwidthCharacterWidth","typicalHalfwidthCharacterWidth","_isViewportWrapping","isViewportWrapping","_revealHorizontalRightPadding","_cursorSurroundingLines","_cursorSurroundingLinesStyle","_canUseLayerHinting","_viewLineOptions","theme","write","setClassName","concat","_maxLineWidth","_asyncUpdateLineWidths","_updateLineWidthsSlow","_asyncCheckMonospaceFontAssumptions","_checkMonospaceFontAssumptions","_lastRenderedData","_horizontalRevealRequest","_stickyScrollEnabled","enabled","_maxNumberStickyLines","maxLineCount","_inherits","dispose","_get","_getPrototypeOf","prototype","call","getDomNode","createVisibleLine","onConfigurationChanged","e","hasChanged","_onOptionsMaybeChanged","newViewLineOptions","equals","getStartLineNumber","getEndLineNumber","line","getVisibleLine","onOptionsChanged","onCursorStateChanged","rendStartLineNumber","rendEndLineNumber","r","onSelectionChanged","onDecorationsChanged","onFlushed","shouldRender","onLinesChanged","onLinesDeleted","onLinesInserted","onRevealRangeRequest","desiredScrollTop","_computeScrollTopToRevealRange","viewLayout","getFutureViewport","source","range","verticalType","newScrollPosition","validateScrollPosition","scrollTop","revealHorizontal","scrollLeft","getCurrentScrollTop","scrollTopDelta","abs","viewModel","setScrollPosition","onScrollChanged","scrollLeftChanged","scrollTopChanged","setWidth","scrollWidth","onTokensChanged","onZonesChanged","setMaxLineWidth","onThemeChanged","getPositionFromDOMInfo","spanNode","offset","viewLineDomNode","_getViewLineDomNode","_getLineNumberFor","getLineCount","getLineMaxColumn","column","getColumnOfNodeOffset","minColumn","getLineMinColumn","node","nodeType","className","CLASS_NAME","parentElement","getLineWidth","result","getWidth","_updateLineWidthsSlowIfDomDidLayout","linesVisibleRangesForRange","_range","includeNewLines","originalEndLineNumber","intersectRanges","visibleRanges","visibleRangesLen","domReadingContext","nextLineModelLineNumber","coordinatesConverter","convertViewPositionToModelPosition","continuesInNextLine","visibleRangesForLine","getVisibleRangesForRange","currentLineModelLineNumber","ranges","width","outsideRenderedLine","from","_visibleRangesForLineRange","visibleRangeForPosition","position","left","_updateLineWidthsFast","_updateLineWidths","didDomLayout","isScheduled","cancel","fast","localMaxLineWidth","allWidthsComputed","visibleLine","getWidthIsFast","_ensureMaxLineWidth","longestLineNumber","longestWidth","needsMonospaceFontCheck","lineWidth","monospaceAssumptionsAreValid","onMonospaceAssumptionsInvalidated","prepareRender","Error","render","renderText","viewportData","renderLines","visibleRange","getScrollWidth","setHeight","getScrollHeight","horizontalRevealRequest","onDidRender","newScrollLeft","_computeScrollLeftToReveal","maxHorizontalOffset","schedule","isLinux","setLayerHinting","setContain","adjustedScrollTop","bigNumbersDelta","setTop","setLeft","getCurrentScrollLeft","iLineWidth","ceil","viewport","viewportStartY","top","viewportHeight","height","viewportEndY","boxIsSingleRange","boxStartY","boxEndY","getVerticalOffsetForLineNumber","shouldIgnoreScrollOff","paddingTop","paddingBottom","newScrollTop","desiredGapAbove","minScrollTop","boxMiddleY","_computeMinimumScrolling","getCurrentViewport","layoutInfo","viewportStartX","viewportEndX","verticalScrollbarWidth","boxStartX","boxEndX","_iterator","_createForOfIteratorHelper","_step","s","n","done","round","err","f","_iterator2","_step2","_iterator3","_step3","HORIZONTAL_EXTRA_PX","viewportStart","viewportEnd","boxStart","boxEnd","revealAtStart","revealAtEnd","viewportLength","boxLength"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lines/viewLines.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { MOUSE_CURSOR_TEXT_CSS_CLASS_NAME } from '../../../../base/browser/ui/mouseCursor/mouseCursor.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport './viewLines.css';\nimport { applyFontInfo } from '../../config/domFontInfo.js';\nimport { HorizontalPosition, HorizontalRange, LineVisibleRanges } from '../../view/renderingContext.js';\nimport { VisibleLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { DomReadingContext } from './domReadingContext.js';\nimport { ViewLine, ViewLineOptions } from './viewLine.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nclass LastRenderedData {\n    constructor() {\n        this._currentVisibleRange = new Range(1, 1, 1, 1);\n    }\n    getCurrentVisibleRange() {\n        return this._currentVisibleRange;\n    }\n    setCurrentVisibleRange(currentVisibleRange) {\n        this._currentVisibleRange = currentVisibleRange;\n    }\n}\nclass HorizontalRevealRangeRequest {\n    constructor(minimalReveal, lineNumber, startColumn, endColumn, startScrollTop, stopScrollTop, scrollType) {\n        this.minimalReveal = minimalReveal;\n        this.lineNumber = lineNumber;\n        this.startColumn = startColumn;\n        this.endColumn = endColumn;\n        this.startScrollTop = startScrollTop;\n        this.stopScrollTop = stopScrollTop;\n        this.scrollType = scrollType;\n        this.type = 'range';\n        this.minLineNumber = lineNumber;\n        this.maxLineNumber = lineNumber;\n    }\n}\nclass HorizontalRevealSelectionsRequest {\n    constructor(minimalReveal, selections, startScrollTop, stopScrollTop, scrollType) {\n        this.minimalReveal = minimalReveal;\n        this.selections = selections;\n        this.startScrollTop = startScrollTop;\n        this.stopScrollTop = stopScrollTop;\n        this.scrollType = scrollType;\n        this.type = 'selections';\n        let minLineNumber = selections[0].startLineNumber;\n        let maxLineNumber = selections[0].endLineNumber;\n        for (let i = 1, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            minLineNumber = Math.min(minLineNumber, selection.startLineNumber);\n            maxLineNumber = Math.max(maxLineNumber, selection.endLineNumber);\n        }\n        this.minLineNumber = minLineNumber;\n        this.maxLineNumber = maxLineNumber;\n    }\n}\nexport class ViewLines extends ViewPart {\n    constructor(context, linesContent) {\n        super(context);\n        this._linesContent = linesContent;\n        this._textRangeRestingSpot = document.createElement('div');\n        this._visibleLines = new VisibleLinesCollection(this);\n        this.domNode = this._visibleLines.domNode;\n        const conf = this._context.configuration;\n        const options = this._context.configuration.options;\n        const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        const wrappingInfo = options.get(146 /* EditorOption.wrappingInfo */);\n        this._lineHeight = options.get(67 /* EditorOption.lineHeight */);\n        this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        this._isViewportWrapping = wrappingInfo.isViewportWrapping;\n        this._revealHorizontalRightPadding = options.get(100 /* EditorOption.revealHorizontalRightPadding */);\n        this._cursorSurroundingLines = options.get(29 /* EditorOption.cursorSurroundingLines */);\n        this._cursorSurroundingLinesStyle = options.get(30 /* EditorOption.cursorSurroundingLinesStyle */);\n        this._canUseLayerHinting = !options.get(32 /* EditorOption.disableLayerHinting */);\n        this._viewLineOptions = new ViewLineOptions(conf, this._context.theme.type);\n        PartFingerprints.write(this.domNode, 8 /* PartFingerprint.ViewLines */);\n        this.domNode.setClassName(`view-lines ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);\n        applyFontInfo(this.domNode, fontInfo);\n        // --- width & height\n        this._maxLineWidth = 0;\n        this._asyncUpdateLineWidths = new RunOnceScheduler(() => {\n            this._updateLineWidthsSlow();\n        }, 200);\n        this._asyncCheckMonospaceFontAssumptions = new RunOnceScheduler(() => {\n            this._checkMonospaceFontAssumptions();\n        }, 2000);\n        this._lastRenderedData = new LastRenderedData();\n        this._horizontalRevealRequest = null;\n        // sticky scroll widget\n        this._stickyScrollEnabled = options.get(115 /* EditorOption.stickyScroll */).enabled;\n        this._maxNumberStickyLines = options.get(115 /* EditorOption.stickyScroll */).maxLineCount;\n    }\n    dispose() {\n        this._asyncUpdateLineWidths.dispose();\n        this._asyncCheckMonospaceFontAssumptions.dispose();\n        super.dispose();\n    }\n    getDomNode() {\n        return this.domNode;\n    }\n    // ---- begin IVisibleLinesHost\n    createVisibleLine() {\n        return new ViewLine(this._viewLineOptions);\n    }\n    // ---- end IVisibleLinesHost\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        this._visibleLines.onConfigurationChanged(e);\n        if (e.hasChanged(146 /* EditorOption.wrappingInfo */)) {\n            this._maxLineWidth = 0;\n        }\n        const options = this._context.configuration.options;\n        const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        const wrappingInfo = options.get(146 /* EditorOption.wrappingInfo */);\n        this._lineHeight = options.get(67 /* EditorOption.lineHeight */);\n        this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        this._isViewportWrapping = wrappingInfo.isViewportWrapping;\n        this._revealHorizontalRightPadding = options.get(100 /* EditorOption.revealHorizontalRightPadding */);\n        this._cursorSurroundingLines = options.get(29 /* EditorOption.cursorSurroundingLines */);\n        this._cursorSurroundingLinesStyle = options.get(30 /* EditorOption.cursorSurroundingLinesStyle */);\n        this._canUseLayerHinting = !options.get(32 /* EditorOption.disableLayerHinting */);\n        // sticky scroll\n        this._stickyScrollEnabled = options.get(115 /* EditorOption.stickyScroll */).enabled;\n        this._maxNumberStickyLines = options.get(115 /* EditorOption.stickyScroll */).maxLineCount;\n        applyFontInfo(this.domNode, fontInfo);\n        this._onOptionsMaybeChanged();\n        if (e.hasChanged(145 /* EditorOption.layoutInfo */)) {\n            this._maxLineWidth = 0;\n        }\n        return true;\n    }\n    _onOptionsMaybeChanged() {\n        const conf = this._context.configuration;\n        const newViewLineOptions = new ViewLineOptions(conf, this._context.theme.type);\n        if (!this._viewLineOptions.equals(newViewLineOptions)) {\n            this._viewLineOptions = newViewLineOptions;\n            const startLineNumber = this._visibleLines.getStartLineNumber();\n            const endLineNumber = this._visibleLines.getEndLineNumber();\n            for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n                const line = this._visibleLines.getVisibleLine(lineNumber);\n                line.onOptionsChanged(this._viewLineOptions);\n            }\n            return true;\n        }\n        return false;\n    }\n    onCursorStateChanged(e) {\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        let r = false;\n        for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n            r = this._visibleLines.getVisibleLine(lineNumber).onSelectionChanged() || r;\n        }\n        return r;\n    }\n    onDecorationsChanged(e) {\n        if (true /*e.inlineDecorationsChanged*/) {\n            const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n            const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n            for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n                this._visibleLines.getVisibleLine(lineNumber).onDecorationsChanged();\n            }\n        }\n        return true;\n    }\n    onFlushed(e) {\n        const shouldRender = this._visibleLines.onFlushed(e);\n        this._maxLineWidth = 0;\n        return shouldRender;\n    }\n    onLinesChanged(e) {\n        return this._visibleLines.onLinesChanged(e);\n    }\n    onLinesDeleted(e) {\n        return this._visibleLines.onLinesDeleted(e);\n    }\n    onLinesInserted(e) {\n        return this._visibleLines.onLinesInserted(e);\n    }\n    onRevealRangeRequest(e) {\n        // Using the future viewport here in order to handle multiple\n        // incoming reveal range requests that might all desire to be animated\n        const desiredScrollTop = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.minimalReveal, e.range, e.selections, e.verticalType);\n        if (desiredScrollTop === -1) {\n            // marker to abort the reveal range request\n            return false;\n        }\n        // validate the new desired scroll top\n        let newScrollPosition = this._context.viewLayout.validateScrollPosition({ scrollTop: desiredScrollTop });\n        if (e.revealHorizontal) {\n            if (e.range && e.range.startLineNumber !== e.range.endLineNumber) {\n                // Two or more lines? => scroll to base (That's how you see most of the two lines)\n                newScrollPosition = {\n                    scrollTop: newScrollPosition.scrollTop,\n                    scrollLeft: 0\n                };\n            }\n            else if (e.range) {\n                // We don't necessarily know the horizontal offset of this range since the line might not be in the view...\n                this._horizontalRevealRequest = new HorizontalRevealRangeRequest(e.minimalReveal, e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\n            }\n            else if (e.selections && e.selections.length > 0) {\n                this._horizontalRevealRequest = new HorizontalRevealSelectionsRequest(e.minimalReveal, e.selections, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\n            }\n        }\n        else {\n            this._horizontalRevealRequest = null;\n        }\n        const scrollTopDelta = Math.abs(this._context.viewLayout.getCurrentScrollTop() - newScrollPosition.scrollTop);\n        const scrollType = (scrollTopDelta <= this._lineHeight ? 1 /* ScrollType.Immediate */ : e.scrollType);\n        this._context.viewModel.viewLayout.setScrollPosition(newScrollPosition, scrollType);\n        return true;\n    }\n    onScrollChanged(e) {\n        if (this._horizontalRevealRequest && e.scrollLeftChanged) {\n            // cancel any outstanding horizontal reveal request if someone else scrolls horizontally.\n            this._horizontalRevealRequest = null;\n        }\n        if (this._horizontalRevealRequest && e.scrollTopChanged) {\n            const min = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n            const max = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n            if (e.scrollTop < min || e.scrollTop > max) {\n                // cancel any outstanding horizontal reveal request if someone else scrolls vertically.\n                this._horizontalRevealRequest = null;\n            }\n        }\n        this.domNode.setWidth(e.scrollWidth);\n        return this._visibleLines.onScrollChanged(e) || true;\n    }\n    onTokensChanged(e) {\n        return this._visibleLines.onTokensChanged(e);\n    }\n    onZonesChanged(e) {\n        this._context.viewModel.viewLayout.setMaxLineWidth(this._maxLineWidth);\n        return this._visibleLines.onZonesChanged(e);\n    }\n    onThemeChanged(e) {\n        return this._onOptionsMaybeChanged();\n    }\n    // ---- end view event handlers\n    // ----------- HELPERS FOR OTHERS\n    getPositionFromDOMInfo(spanNode, offset) {\n        const viewLineDomNode = this._getViewLineDomNode(spanNode);\n        if (viewLineDomNode === null) {\n            // Couldn't find view line node\n            return null;\n        }\n        const lineNumber = this._getLineNumberFor(viewLineDomNode);\n        if (lineNumber === -1) {\n            // Couldn't find view line node\n            return null;\n        }\n        if (lineNumber < 1 || lineNumber > this._context.viewModel.getLineCount()) {\n            // lineNumber is outside range\n            return null;\n        }\n        if (this._context.viewModel.getLineMaxColumn(lineNumber) === 1) {\n            // Line is empty\n            return new Position(lineNumber, 1);\n        }\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n            // Couldn't find line\n            return null;\n        }\n        let column = this._visibleLines.getVisibleLine(lineNumber).getColumnOfNodeOffset(spanNode, offset);\n        const minColumn = this._context.viewModel.getLineMinColumn(lineNumber);\n        if (column < minColumn) {\n            column = minColumn;\n        }\n        return new Position(lineNumber, column);\n    }\n    _getViewLineDomNode(node) {\n        while (node && node.nodeType === 1) {\n            if (node.className === ViewLine.CLASS_NAME) {\n                return node;\n            }\n            node = node.parentElement;\n        }\n        return null;\n    }\n    /**\n     * @returns the line number of this view line dom node.\n     */\n    _getLineNumberFor(domNode) {\n        const startLineNumber = this._visibleLines.getStartLineNumber();\n        const endLineNumber = this._visibleLines.getEndLineNumber();\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const line = this._visibleLines.getVisibleLine(lineNumber);\n            if (domNode === line.getDomNode()) {\n                return lineNumber;\n            }\n        }\n        return -1;\n    }\n    getLineWidth(lineNumber) {\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n            // Couldn't find line\n            return -1;\n        }\n        const context = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);\n        const result = this._visibleLines.getVisibleLine(lineNumber).getWidth(context);\n        this._updateLineWidthsSlowIfDomDidLayout(context);\n        return result;\n    }\n    linesVisibleRangesForRange(_range, includeNewLines) {\n        if (this.shouldRender()) {\n            // Cannot read from the DOM because it is dirty\n            // i.e. the model & the dom are out of sync, so I'd be reading something stale\n            return null;\n        }\n        const originalEndLineNumber = _range.endLineNumber;\n        const range = Range.intersectRanges(_range, this._lastRenderedData.getCurrentVisibleRange());\n        if (!range) {\n            return null;\n        }\n        const visibleRanges = [];\n        let visibleRangesLen = 0;\n        const domReadingContext = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);\n        let nextLineModelLineNumber = 0;\n        if (includeNewLines) {\n            nextLineModelLineNumber = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(range.startLineNumber, 1)).lineNumber;\n        }\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        for (let lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n            if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n                continue;\n            }\n            const startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;\n            const continuesInNextLine = lineNumber !== range.endLineNumber;\n            const endColumn = continuesInNextLine ? this._context.viewModel.getLineMaxColumn(lineNumber) : range.endColumn;\n            const visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(lineNumber, startColumn, endColumn, domReadingContext);\n            if (!visibleRangesForLine) {\n                continue;\n            }\n            if (includeNewLines && lineNumber < originalEndLineNumber) {\n                const currentLineModelLineNumber = nextLineModelLineNumber;\n                nextLineModelLineNumber = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(lineNumber + 1, 1)).lineNumber;\n                if (currentLineModelLineNumber !== nextLineModelLineNumber) {\n                    visibleRangesForLine.ranges[visibleRangesForLine.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth;\n                }\n            }\n            visibleRanges[visibleRangesLen++] = new LineVisibleRanges(visibleRangesForLine.outsideRenderedLine, lineNumber, HorizontalRange.from(visibleRangesForLine.ranges), continuesInNextLine);\n        }\n        this._updateLineWidthsSlowIfDomDidLayout(domReadingContext);\n        if (visibleRangesLen === 0) {\n            return null;\n        }\n        return visibleRanges;\n    }\n    _visibleRangesForLineRange(lineNumber, startColumn, endColumn) {\n        if (this.shouldRender()) {\n            // Cannot read from the DOM because it is dirty\n            // i.e. the model & the dom are out of sync, so I'd be reading something stale\n            return null;\n        }\n        if (lineNumber < this._visibleLines.getStartLineNumber() || lineNumber > this._visibleLines.getEndLineNumber()) {\n            return null;\n        }\n        const domReadingContext = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);\n        const result = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(lineNumber, startColumn, endColumn, domReadingContext);\n        this._updateLineWidthsSlowIfDomDidLayout(domReadingContext);\n        return result;\n    }\n    visibleRangeForPosition(position) {\n        const visibleRanges = this._visibleRangesForLineRange(position.lineNumber, position.column, position.column);\n        if (!visibleRanges) {\n            return null;\n        }\n        return new HorizontalPosition(visibleRanges.outsideRenderedLine, visibleRanges.ranges[0].left);\n    }\n    /**\n     * Updates the max line width if it is fast to compute.\n     * Returns true if all lines were taken into account.\n     * Returns false if some lines need to be reevaluated (in a slow fashion).\n     */\n    _updateLineWidthsFast() {\n        return this._updateLineWidths(true);\n    }\n    _updateLineWidthsSlow() {\n        this._updateLineWidths(false);\n    }\n    /**\n     * Update the line widths using DOM layout information after someone else\n     * has caused a synchronous layout.\n     */\n    _updateLineWidthsSlowIfDomDidLayout(domReadingContext) {\n        if (!domReadingContext.didDomLayout) {\n            // only proceed if we just did a layout\n            return;\n        }\n        if (this._asyncUpdateLineWidths.isScheduled()) {\n            // reading widths is not scheduled => widths are up-to-date\n            return;\n        }\n        this._asyncUpdateLineWidths.cancel();\n        this._updateLineWidthsSlow();\n    }\n    _updateLineWidths(fast) {\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        let localMaxLineWidth = 1;\n        let allWidthsComputed = true;\n        for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n            const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n            if (fast && !visibleLine.getWidthIsFast()) {\n                // Cannot compute width in a fast way for this line\n                allWidthsComputed = false;\n                continue;\n            }\n            localMaxLineWidth = Math.max(localMaxLineWidth, visibleLine.getWidth(null));\n        }\n        if (allWidthsComputed && rendStartLineNumber === 1 && rendEndLineNumber === this._context.viewModel.getLineCount()) {\n            // we know the max line width for all the lines\n            this._maxLineWidth = 0;\n        }\n        this._ensureMaxLineWidth(localMaxLineWidth);\n        return allWidthsComputed;\n    }\n    _checkMonospaceFontAssumptions() {\n        // Problems with monospace assumptions are more apparent for longer lines,\n        // as small rounding errors start to sum up, so we will select the longest\n        // line for a closer inspection\n        let longestLineNumber = -1;\n        let longestWidth = -1;\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n        for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n            const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n            if (visibleLine.needsMonospaceFontCheck()) {\n                const lineWidth = visibleLine.getWidth(null);\n                if (lineWidth > longestWidth) {\n                    longestWidth = lineWidth;\n                    longestLineNumber = lineNumber;\n                }\n            }\n        }\n        if (longestLineNumber === -1) {\n            return;\n        }\n        if (!this._visibleLines.getVisibleLine(longestLineNumber).monospaceAssumptionsAreValid()) {\n            for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n                const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n                visibleLine.onMonospaceAssumptionsInvalidated();\n            }\n        }\n    }\n    prepareRender() {\n        throw new Error('Not supported');\n    }\n    render() {\n        throw new Error('Not supported');\n    }\n    renderText(viewportData) {\n        // (1) render lines - ensures lines are in the DOM\n        this._visibleLines.renderLines(viewportData);\n        this._lastRenderedData.setCurrentVisibleRange(viewportData.visibleRange);\n        this.domNode.setWidth(this._context.viewLayout.getScrollWidth());\n        this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1000000));\n        // (2) compute horizontal scroll position:\n        //  - this must happen after the lines are in the DOM since it might need a line that rendered just now\n        //  - it might change `scrollWidth` and `scrollLeft`\n        if (this._horizontalRevealRequest) {\n            const horizontalRevealRequest = this._horizontalRevealRequest;\n            // Check that we have the line that contains the horizontal range in the viewport\n            if (viewportData.startLineNumber <= horizontalRevealRequest.minLineNumber && horizontalRevealRequest.maxLineNumber <= viewportData.endLineNumber) {\n                this._horizontalRevealRequest = null;\n                // allow `visibleRangesForRange2` to work\n                this.onDidRender();\n                // compute new scroll position\n                const newScrollLeft = this._computeScrollLeftToReveal(horizontalRevealRequest);\n                if (newScrollLeft) {\n                    if (!this._isViewportWrapping) {\n                        // ensure `scrollWidth` is large enough\n                        this._ensureMaxLineWidth(newScrollLeft.maxHorizontalOffset);\n                    }\n                    // set `scrollLeft`\n                    this._context.viewModel.viewLayout.setScrollPosition({\n                        scrollLeft: newScrollLeft.scrollLeft\n                    }, horizontalRevealRequest.scrollType);\n                }\n            }\n        }\n        // Update max line width (not so important, it is just so the horizontal scrollbar doesn't get too small)\n        if (!this._updateLineWidthsFast()) {\n            // Computing the width of some lines would be slow => delay it\n            this._asyncUpdateLineWidths.schedule();\n        }\n        else {\n            this._asyncUpdateLineWidths.cancel();\n        }\n        if (platform.isLinux && !this._asyncCheckMonospaceFontAssumptions.isScheduled()) {\n            const rendStartLineNumber = this._visibleLines.getStartLineNumber();\n            const rendEndLineNumber = this._visibleLines.getEndLineNumber();\n            for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n                const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n                if (visibleLine.needsMonospaceFontCheck()) {\n                    this._asyncCheckMonospaceFontAssumptions.schedule();\n                    break;\n                }\n            }\n        }\n        // (3) handle scrolling\n        this._linesContent.setLayerHinting(this._canUseLayerHinting);\n        this._linesContent.setContain('strict');\n        const adjustedScrollTop = this._context.viewLayout.getCurrentScrollTop() - viewportData.bigNumbersDelta;\n        this._linesContent.setTop(-adjustedScrollTop);\n        this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());\n    }\n    // --- width\n    _ensureMaxLineWidth(lineWidth) {\n        const iLineWidth = Math.ceil(lineWidth);\n        if (this._maxLineWidth < iLineWidth) {\n            this._maxLineWidth = iLineWidth;\n            this._context.viewModel.viewLayout.setMaxLineWidth(this._maxLineWidth);\n        }\n    }\n    _computeScrollTopToRevealRange(viewport, source, minimalReveal, range, selections, verticalType) {\n        const viewportStartY = viewport.top;\n        const viewportHeight = viewport.height;\n        const viewportEndY = viewportStartY + viewportHeight;\n        let boxIsSingleRange;\n        let boxStartY;\n        let boxEndY;\n        if (selections && selections.length > 0) {\n            let minLineNumber = selections[0].startLineNumber;\n            let maxLineNumber = selections[0].endLineNumber;\n            for (let i = 1, len = selections.length; i < len; i++) {\n                const selection = selections[i];\n                minLineNumber = Math.min(minLineNumber, selection.startLineNumber);\n                maxLineNumber = Math.max(maxLineNumber, selection.endLineNumber);\n            }\n            boxIsSingleRange = false;\n            boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(minLineNumber);\n            boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(maxLineNumber) + this._lineHeight;\n        }\n        else if (range) {\n            boxIsSingleRange = true;\n            boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.startLineNumber);\n            boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.endLineNumber) + this._lineHeight;\n        }\n        else {\n            return -1;\n        }\n        const shouldIgnoreScrollOff = (source === 'mouse' || minimalReveal) && this._cursorSurroundingLinesStyle === 'default';\n        let paddingTop = 0;\n        let paddingBottom = 0;\n        if (!shouldIgnoreScrollOff) {\n            const context = Math.min((viewportHeight / this._lineHeight) / 2, this._cursorSurroundingLines);\n            if (this._stickyScrollEnabled) {\n                paddingTop = Math.max(context, this._maxNumberStickyLines) * this._lineHeight;\n            }\n            else {\n                paddingTop = context * this._lineHeight;\n            }\n            paddingBottom = Math.max(0, (context - 1)) * this._lineHeight;\n        }\n        else {\n            if (!minimalReveal) {\n                // Reveal one more line above (this case is hit when dragging)\n                paddingTop = this._lineHeight;\n            }\n        }\n        if (!minimalReveal) {\n            if (verticalType === 0 /* viewEvents.VerticalRevealType.Simple */ || verticalType === 4 /* viewEvents.VerticalRevealType.Bottom */) {\n                // Reveal one line more when the last line would be covered by the scrollbar - arrow down case or revealing a line explicitly at bottom\n                paddingBottom += this._lineHeight;\n            }\n        }\n        boxStartY -= paddingTop;\n        boxEndY += paddingBottom;\n        let newScrollTop;\n        if (boxEndY - boxStartY > viewportHeight) {\n            // the box is larger than the viewport ... scroll to its top\n            if (!boxIsSingleRange) {\n                // do not reveal multiple cursors if there are more than fit the viewport\n                return -1;\n            }\n            newScrollTop = boxStartY;\n        }\n        else if (verticalType === 5 /* viewEvents.VerticalRevealType.NearTop */ || verticalType === 6 /* viewEvents.VerticalRevealType.NearTopIfOutsideViewport */) {\n            if (verticalType === 6 /* viewEvents.VerticalRevealType.NearTopIfOutsideViewport */ && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\n                // Box is already in the viewport... do nothing\n                newScrollTop = viewportStartY;\n            }\n            else {\n                // We want a gap that is 20% of the viewport, but with a minimum of 5 lines\n                const desiredGapAbove = Math.max(5 * this._lineHeight, viewportHeight * 0.2);\n                // Try to scroll just above the box with the desired gap\n                const desiredScrollTop = boxStartY - desiredGapAbove;\n                // But ensure that the box is not pushed out of viewport\n                const minScrollTop = boxEndY - viewportHeight;\n                newScrollTop = Math.max(minScrollTop, desiredScrollTop);\n            }\n        }\n        else if (verticalType === 1 /* viewEvents.VerticalRevealType.Center */ || verticalType === 2 /* viewEvents.VerticalRevealType.CenterIfOutsideViewport */) {\n            if (verticalType === 2 /* viewEvents.VerticalRevealType.CenterIfOutsideViewport */ && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\n                // Box is already in the viewport... do nothing\n                newScrollTop = viewportStartY;\n            }\n            else {\n                // Box is outside the viewport... center it\n                const boxMiddleY = (boxStartY + boxEndY) / 2;\n                newScrollTop = Math.max(0, boxMiddleY - viewportHeight / 2);\n            }\n        }\n        else {\n            newScrollTop = this._computeMinimumScrolling(viewportStartY, viewportEndY, boxStartY, boxEndY, verticalType === 3 /* viewEvents.VerticalRevealType.Top */, verticalType === 4 /* viewEvents.VerticalRevealType.Bottom */);\n        }\n        return newScrollTop;\n    }\n    _computeScrollLeftToReveal(horizontalRevealRequest) {\n        const viewport = this._context.viewLayout.getCurrentViewport();\n        const layoutInfo = this._context.configuration.options.get(145 /* EditorOption.layoutInfo */);\n        const viewportStartX = viewport.left;\n        const viewportEndX = viewportStartX + viewport.width - layoutInfo.verticalScrollbarWidth;\n        let boxStartX = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n        let boxEndX = 0;\n        if (horizontalRevealRequest.type === 'range') {\n            const visibleRanges = this._visibleRangesForLineRange(horizontalRevealRequest.lineNumber, horizontalRevealRequest.startColumn, horizontalRevealRequest.endColumn);\n            if (!visibleRanges) {\n                return null;\n            }\n            for (const visibleRange of visibleRanges.ranges) {\n                boxStartX = Math.min(boxStartX, Math.round(visibleRange.left));\n                boxEndX = Math.max(boxEndX, Math.round(visibleRange.left + visibleRange.width));\n            }\n        }\n        else {\n            for (const selection of horizontalRevealRequest.selections) {\n                if (selection.startLineNumber !== selection.endLineNumber) {\n                    return null;\n                }\n                const visibleRanges = this._visibleRangesForLineRange(selection.startLineNumber, selection.startColumn, selection.endColumn);\n                if (!visibleRanges) {\n                    return null;\n                }\n                for (const visibleRange of visibleRanges.ranges) {\n                    boxStartX = Math.min(boxStartX, Math.round(visibleRange.left));\n                    boxEndX = Math.max(boxEndX, Math.round(visibleRange.left + visibleRange.width));\n                }\n            }\n        }\n        if (!horizontalRevealRequest.minimalReveal) {\n            boxStartX = Math.max(0, boxStartX - ViewLines.HORIZONTAL_EXTRA_PX);\n            boxEndX += this._revealHorizontalRightPadding;\n        }\n        if (horizontalRevealRequest.type === 'selections' && boxEndX - boxStartX > viewport.width) {\n            return null;\n        }\n        const newScrollLeft = this._computeMinimumScrolling(viewportStartX, viewportEndX, boxStartX, boxEndX);\n        return {\n            scrollLeft: newScrollLeft,\n            maxHorizontalOffset: boxEndX\n        };\n    }\n    _computeMinimumScrolling(viewportStart, viewportEnd, boxStart, boxEnd, revealAtStart, revealAtEnd) {\n        viewportStart = viewportStart | 0;\n        viewportEnd = viewportEnd | 0;\n        boxStart = boxStart | 0;\n        boxEnd = boxEnd | 0;\n        revealAtStart = !!revealAtStart;\n        revealAtEnd = !!revealAtEnd;\n        const viewportLength = viewportEnd - viewportStart;\n        const boxLength = boxEnd - boxStart;\n        if (boxLength < viewportLength) {\n            // The box would fit in the viewport\n            if (revealAtStart) {\n                return boxStart;\n            }\n            if (revealAtEnd) {\n                return Math.max(0, boxEnd - viewportLength);\n            }\n            if (boxStart < viewportStart) {\n                // The box is above the viewport\n                return boxStart;\n            }\n            else if (boxEnd > viewportEnd) {\n                // The box is below the viewport\n                return Math.max(0, boxEnd - viewportLength);\n            }\n        }\n        else {\n            // The box would not fit in the viewport\n            // Reveal the beginning of the box\n            return boxStart;\n        }\n        return viewportStart;\n    }\n}\n/**\n * Adds this amount of pixels to the right of lines (no-one wants to type near the edge of the viewport)\n */\nViewLines.HORIZONTAL_EXTRA_PX = 30;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}