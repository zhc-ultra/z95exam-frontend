{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals, groupAdjacentBy } from '../../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../../base/common/assert.js';\nimport { LineRange } from '../../core/lineRange.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { Range } from '../../core/range.js';\nimport { DateTimeout, InfiniteTimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { computeMovedLines } from './computeMovedLines.js';\nimport { extendDiffsToEntireWordIfAppropriate, optimizeSequenceDiffs, removeShortMatches, removeVeryShortMatchingLinesBetweenDiffs, removeVeryShortMatchingTextBetweenLongDiffs } from './heuristicSequenceOptimizations.js';\nimport { LineSequence } from './lineSequence.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LinesDiff, MovedText } from '../linesDiffComputer.js';\nimport { DetailedLineRangeMapping, RangeMapping } from '../rangeMapping.js';\nexport var DefaultLinesDiffComputer = /*#__PURE__*/function () {\n  function DefaultLinesDiffComputer() {\n    _classCallCheck(this, DefaultLinesDiffComputer);\n    this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n    this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n  }\n  return _createClass(DefaultLinesDiffComputer, [{\n    key: \"computeDiff\",\n    value: function computeDiff(originalLines, modifiedLines, options) {\n      var _this = this;\n      if (originalLines.length <= 1 && equals(originalLines, modifiedLines, function (a, b) {\n        return a === b;\n      })) {\n        return new LinesDiff([], [], false);\n      }\n      if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {\n        return new LinesDiff([new DetailedLineRangeMapping(new LineRange(1, originalLines.length + 1), new LineRange(1, modifiedLines.length + 1), [new RangeMapping(new Range(1, 1, originalLines.length, originalLines[0].length + 1), new Range(1, 1, modifiedLines.length, modifiedLines[0].length + 1))])], [], false);\n      }\n      var timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n      var considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n      var perfectHashes = new Map();\n      function getOrCreateHash(text) {\n        var hash = perfectHashes.get(text);\n        if (hash === undefined) {\n          hash = perfectHashes.size;\n          perfectHashes.set(text, hash);\n        }\n        return hash;\n      }\n      var originalLinesHashes = originalLines.map(function (l) {\n        return getOrCreateHash(l.trim());\n      });\n      var modifiedLinesHashes = modifiedLines.map(function (l) {\n        return getOrCreateHash(l.trim());\n      });\n      var sequence1 = new LineSequence(originalLinesHashes, originalLines);\n      var sequence2 = new LineSequence(modifiedLinesHashes, modifiedLines);\n      var lineAlignmentResult = function () {\n        if (sequence1.length + sequence2.length < 1700) {\n          // Use the improved algorithm for small files\n          return _this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, function (offset1, offset2) {\n            return originalLines[offset1] === modifiedLines[offset2] ? modifiedLines[offset2].length === 0 ? 0.1 : 1 + Math.log(1 + modifiedLines[offset2].length) : 0.99;\n          });\n        }\n        return _this.myersDiffingAlgorithm.compute(sequence1, sequence2);\n      }();\n      var lineAlignments = lineAlignmentResult.diffs;\n      var hitTimeout = lineAlignmentResult.hitTimeout;\n      lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n      lineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);\n      var alignments = [];\n      var scanForWhitespaceChanges = function scanForWhitespaceChanges(equalLinesCount) {\n        if (!considerWhitespaceChanges) {\n          return;\n        }\n        for (var i = 0; i < equalLinesCount; i++) {\n          var seq1Offset = seq1LastStart + i;\n          var seq2Offset = seq2LastStart + i;\n          if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n            // This is because of whitespace changes, diff these lines\n            var characterDiffs = _this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);\n            var _iterator = _createForOfIteratorHelper(characterDiffs.mappings),\n              _step;\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var a = _step.value;\n                alignments.push(a);\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n            if (characterDiffs.hitTimeout) {\n              hitTimeout = true;\n            }\n          }\n        }\n      };\n      var seq1LastStart = 0;\n      var seq2LastStart = 0;\n      var _iterator2 = _createForOfIteratorHelper(lineAlignments),\n        _step2;\n      try {\n        var _loop = function _loop() {\n          var diff = _step2.value;\n          assertFn(function () {\n            return diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart;\n          });\n          var equalLinesCount = diff.seq1Range.start - seq1LastStart;\n          scanForWhitespaceChanges(equalLinesCount);\n          seq1LastStart = diff.seq1Range.endExclusive;\n          seq2LastStart = diff.seq2Range.endExclusive;\n          var characterDiffs = _this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);\n          if (characterDiffs.hitTimeout) {\n            hitTimeout = true;\n          }\n          var _iterator5 = _createForOfIteratorHelper(characterDiffs.mappings),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var a = _step5.value;\n              alignments.push(a);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        };\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n      var changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);\n      var moves = [];\n      if (options.computeMoves) {\n        moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges);\n      }\n      // Make sure all ranges are valid\n      assertFn(function () {\n        function validatePosition(pos, lines) {\n          if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {\n            return false;\n          }\n          var line = lines[pos.lineNumber - 1];\n          if (pos.column < 1 || pos.column > line.length + 1) {\n            return false;\n          }\n          return true;\n        }\n        function validateRange(range, lines) {\n          if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {\n            return false;\n          }\n          if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {\n            return false;\n          }\n          return true;\n        }\n        var _iterator3 = _createForOfIteratorHelper(changes),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var c = _step3.value;\n            if (!c.innerChanges) {\n              return false;\n            }\n            var _iterator4 = _createForOfIteratorHelper(c.innerChanges),\n              _step4;\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var ic = _step4.value;\n                var valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) && validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);\n                if (!valid) {\n                  return false;\n                }\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n            if (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        return true;\n      });\n      return new LinesDiff(changes, moves, hitTimeout);\n    }\n  }, {\n    key: \"computeMoves\",\n    value: function computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {\n      var _this2 = this;\n      var moves = computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout);\n      var movesWithDiffs = moves.map(function (m) {\n        var moveChanges = _this2.refineDiff(originalLines, modifiedLines, new SequenceDiff(m.original.toOffsetRange(), m.modified.toOffsetRange()), timeout, considerWhitespaceChanges);\n        var mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);\n        return new MovedText(m, mappings);\n      });\n      return movesWithDiffs;\n    }\n  }, {\n    key: \"refineDiff\",\n    value: function refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {\n      var slice1 = new LinesSliceCharSequence(originalLines, diff.seq1Range, considerWhitespaceChanges);\n      var slice2 = new LinesSliceCharSequence(modifiedLines, diff.seq2Range, considerWhitespaceChanges);\n      var diffResult = slice1.length + slice2.length < 500 ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout) : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n      var diffs = diffResult.diffs;\n      diffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n      diffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs);\n      diffs = removeShortMatches(slice1, slice2, diffs);\n      diffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);\n      var result = diffs.map(function (d) {\n        return new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range));\n      });\n      // Assert: result applied on original should be the same as diff applied to original\n      return {\n        mappings: result,\n        hitTimeout: diffResult.hitTimeout\n      };\n    }\n  }]);\n}();\nexport function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines) {\n  var dontAssertStartLine = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var changes = [];\n  var _iterator6 = _createForOfIteratorHelper(groupAdjacentBy(alignments.map(function (a) {\n      return getLineRangeMapping(a, originalLines, modifiedLines);\n    }), function (a1, a2) {\n      return a1.original.overlapOrTouch(a2.original) || a1.modified.overlapOrTouch(a2.modified);\n    })),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var g = _step6.value;\n      var first = g[0];\n      var last = g[g.length - 1];\n      changes.push(new DetailedLineRangeMapping(first.original.join(last.original), first.modified.join(last.modified), g.map(function (a) {\n        return a.innerChanges[0];\n      })));\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  assertFn(function () {\n    if (!dontAssertStartLine && changes.length > 0) {\n      if (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {\n        return false;\n      }\n      if (modifiedLines.length - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length - changes[changes.length - 1].original.endLineNumberExclusive) {\n        return false;\n      }\n    }\n    return checkAdjacentItems(changes, function (m1, m2) {\n      return m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n      // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n      m1.original.endLineNumberExclusive < m2.original.startLineNumber && m1.modified.endLineNumberExclusive < m2.modified.startLineNumber;\n    });\n  });\n  return changes;\n}\nexport function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {\n  var lineStartDelta = 0;\n  var lineEndDelta = 0;\n  // rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n  // original: ]xxx \\n <- this line is not modified\n  // modified: ]xx  \\n\n  if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1 && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n    // We can only do this if the range is not empty yet\n    lineEndDelta = -1;\n  }\n  // original: xxx[ \\n <- this line is not modified\n  // modified: xxx[ \\n\n  if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n    // We can only do this if the range is not empty yet\n    lineStartDelta = 1;\n  }\n  var originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);\n  var modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);\n  return new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}","map":{"version":3,"names":["equals","groupAdjacentBy","assertFn","checkAdjacentItems","LineRange","OffsetRange","Range","DateTimeout","InfiniteTimeout","SequenceDiff","DynamicProgrammingDiffing","MyersDiffAlgorithm","computeMovedLines","extendDiffsToEntireWordIfAppropriate","optimizeSequenceDiffs","removeShortMatches","removeVeryShortMatchingLinesBetweenDiffs","removeVeryShortMatchingTextBetweenLongDiffs","LineSequence","LinesSliceCharSequence","LinesDiff","MovedText","DetailedLineRangeMapping","RangeMapping","DefaultLinesDiffComputer","_classCallCheck","dynamicProgrammingDiffing","myersDiffingAlgorithm","_createClass","key","value","computeDiff","originalLines","modifiedLines","options","_this","length","a","b","timeout","maxComputationTimeMs","instance","considerWhitespaceChanges","ignoreTrimWhitespace","perfectHashes","Map","getOrCreateHash","text","hash","get","undefined","size","set","originalLinesHashes","map","l","trim","modifiedLinesHashes","sequence1","sequence2","lineAlignmentResult","compute","offset1","offset2","Math","log","lineAlignments","diffs","hitTimeout","alignments","scanForWhitespaceChanges","equalLinesCount","i","seq1Offset","seq1LastStart","seq2Offset","seq2LastStart","characterDiffs","refineDiff","_iterator","_createForOfIteratorHelper","mappings","_step","s","n","done","push","err","e","f","_iterator2","_step2","_loop","diff","seq1Range","start","seq2Range","endExclusive","_iterator5","_step5","changes","lineRangeMappingFromRangeMappings","moves","computeMoves","validatePosition","pos","lines","lineNumber","line","column","validateRange","range","startLineNumber","endLineNumberExclusive","_iterator3","_step3","c","innerChanges","_iterator4","_step4","ic","valid","modifiedRange","getStartPosition","getEndPosition","originalRange","modified","original","hashedOriginalLines","hashedModifiedLines","_this2","movesWithDiffs","m","moveChanges","toOffsetRange","slice1","slice2","diffResult","result","d","translateRange","dontAssertStartLine","arguments","_iterator6","getLineRangeMapping","a1","a2","overlapOrTouch","_step6","g","first","last","join","m1","m2","rangeMapping","lineStartDelta","lineEndDelta","endColumn","endLineNumber","startColumn","originalLineRange","modifiedLineRange"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals, groupAdjacentBy } from '../../../../base/common/arrays.js';\nimport { assertFn, checkAdjacentItems } from '../../../../base/common/assert.js';\nimport { LineRange } from '../../core/lineRange.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { Range } from '../../core/range.js';\nimport { DateTimeout, InfiniteTimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { computeMovedLines } from './computeMovedLines.js';\nimport { extendDiffsToEntireWordIfAppropriate, optimizeSequenceDiffs, removeShortMatches, removeVeryShortMatchingLinesBetweenDiffs, removeVeryShortMatchingTextBetweenLongDiffs } from './heuristicSequenceOptimizations.js';\nimport { LineSequence } from './lineSequence.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LinesDiff, MovedText } from '../linesDiffComputer.js';\nimport { DetailedLineRangeMapping, RangeMapping } from '../rangeMapping.js';\nexport class DefaultLinesDiffComputer {\n    constructor() {\n        this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n        this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    }\n    computeDiff(originalLines, modifiedLines, options) {\n        if (originalLines.length <= 1 && equals(originalLines, modifiedLines, (a, b) => a === b)) {\n            return new LinesDiff([], [], false);\n        }\n        if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {\n            return new LinesDiff([\n                new DetailedLineRangeMapping(new LineRange(1, originalLines.length + 1), new LineRange(1, modifiedLines.length + 1), [\n                    new RangeMapping(new Range(1, 1, originalLines.length, originalLines[0].length + 1), new Range(1, 1, modifiedLines.length, modifiedLines[0].length + 1))\n                ])\n            ], [], false);\n        }\n        const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n        const considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n        const perfectHashes = new Map();\n        function getOrCreateHash(text) {\n            let hash = perfectHashes.get(text);\n            if (hash === undefined) {\n                hash = perfectHashes.size;\n                perfectHashes.set(text, hash);\n            }\n            return hash;\n        }\n        const originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));\n        const modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n        const sequence1 = new LineSequence(originalLinesHashes, originalLines);\n        const sequence2 = new LineSequence(modifiedLinesHashes, modifiedLines);\n        const lineAlignmentResult = (() => {\n            if (sequence1.length + sequence2.length < 1700) {\n                // Use the improved algorithm for small files\n                return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2]\n                    ? modifiedLines[offset2].length === 0\n                        ? 0.1\n                        : 1 + Math.log(1 + modifiedLines[offset2].length)\n                    : 0.99);\n            }\n            return this.myersDiffingAlgorithm.compute(sequence1, sequence2);\n        })();\n        let lineAlignments = lineAlignmentResult.diffs;\n        let hitTimeout = lineAlignmentResult.hitTimeout;\n        lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n        lineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);\n        const alignments = [];\n        const scanForWhitespaceChanges = (equalLinesCount) => {\n            if (!considerWhitespaceChanges) {\n                return;\n            }\n            for (let i = 0; i < equalLinesCount; i++) {\n                const seq1Offset = seq1LastStart + i;\n                const seq2Offset = seq2LastStart + i;\n                if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n                    // This is because of whitespace changes, diff these lines\n                    const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);\n                    for (const a of characterDiffs.mappings) {\n                        alignments.push(a);\n                    }\n                    if (characterDiffs.hitTimeout) {\n                        hitTimeout = true;\n                    }\n                }\n            }\n        };\n        let seq1LastStart = 0;\n        let seq2LastStart = 0;\n        for (const diff of lineAlignments) {\n            assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n            const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n            scanForWhitespaceChanges(equalLinesCount);\n            seq1LastStart = diff.seq1Range.endExclusive;\n            seq2LastStart = diff.seq2Range.endExclusive;\n            const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);\n            if (characterDiffs.hitTimeout) {\n                hitTimeout = true;\n            }\n            for (const a of characterDiffs.mappings) {\n                alignments.push(a);\n            }\n        }\n        scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n        const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);\n        let moves = [];\n        if (options.computeMoves) {\n            moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges);\n        }\n        // Make sure all ranges are valid\n        assertFn(() => {\n            function validatePosition(pos, lines) {\n                if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {\n                    return false;\n                }\n                const line = lines[pos.lineNumber - 1];\n                if (pos.column < 1 || pos.column > line.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            function validateRange(range, lines) {\n                if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {\n                    return false;\n                }\n                if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            for (const c of changes) {\n                if (!c.innerChanges) {\n                    return false;\n                }\n                for (const ic of c.innerChanges) {\n                    const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) &&\n                        validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);\n                    if (!valid) {\n                        return false;\n                    }\n                }\n                if (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {\n                    return false;\n                }\n            }\n            return true;\n        });\n        return new LinesDiff(changes, moves, hitTimeout);\n    }\n    computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {\n        const moves = computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout);\n        const movesWithDiffs = moves.map(m => {\n            const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(m.original.toOffsetRange(), m.modified.toOffsetRange()), timeout, considerWhitespaceChanges);\n            const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);\n            return new MovedText(m, mappings);\n        });\n        return movesWithDiffs;\n    }\n    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {\n        const slice1 = new LinesSliceCharSequence(originalLines, diff.seq1Range, considerWhitespaceChanges);\n        const slice2 = new LinesSliceCharSequence(modifiedLines, diff.seq2Range, considerWhitespaceChanges);\n        const diffResult = slice1.length + slice2.length < 500\n            ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout)\n            : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n        let diffs = diffResult.diffs;\n        diffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n        diffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs);\n        diffs = removeShortMatches(slice1, slice2, diffs);\n        diffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);\n        const result = diffs.map((d) => new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));\n        // Assert: result applied on original should be the same as diff applied to original\n        return {\n            mappings: result,\n            hitTimeout: diffResult.hitTimeout,\n        };\n    }\n}\nexport function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {\n    const changes = [];\n    for (const g of groupAdjacentBy(alignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.original.overlapOrTouch(a2.original)\n        || a1.modified.overlapOrTouch(a2.modified))) {\n        const first = g[0];\n        const last = g[g.length - 1];\n        changes.push(new DetailedLineRangeMapping(first.original.join(last.original), first.modified.join(last.modified), g.map(a => a.innerChanges[0])));\n    }\n    assertFn(() => {\n        if (!dontAssertStartLine && changes.length > 0) {\n            if (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {\n                return false;\n            }\n            if (modifiedLines.length - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length - changes[changes.length - 1].original.endLineNumberExclusive) {\n                return false;\n            }\n        }\n        return checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n            // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n            m1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n            m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);\n    });\n    return changes;\n}\nexport function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {\n    let lineStartDelta = 0;\n    let lineEndDelta = 0;\n    // rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n    // original: ]xxx \\n <- this line is not modified\n    // modified: ]xx  \\n\n    if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\n        && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\n        && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n        // We can only do this if the range is not empty yet\n        lineEndDelta = -1;\n    }\n    // original: xxx[ \\n <- this line is not modified\n    // modified: xxx[ \\n\n    if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta\n        && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n        // We can only do this if the range is not empty yet\n        lineStartDelta = 1;\n    }\n    const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);\n    const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);\n    return new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}