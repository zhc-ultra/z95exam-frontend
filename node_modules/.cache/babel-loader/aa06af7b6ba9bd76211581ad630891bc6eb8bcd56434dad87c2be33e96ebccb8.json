{"ast":null,"code":"import _defineProperty from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _typeof from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/es.object.get-own-property-names.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.flags.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.replace.js\";\n/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.48.0(0037b13fb5d186fdf1e7df51a9416a2de2b8c670)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __copyProps = function __copyProps(to, from, except, desc) {\n  if (from && _typeof(from) === \"object\" || typeof from === \"function\") {\n    var _iterator = _createForOfIteratorHelper(__getOwnPropNames(from)),\n      _step;\n    try {\n      var _loop = function _loop() {\n        var key = _step.value;\n        if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n          get: function get() {\n            return from[key];\n          },\n          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n      };\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        _loop();\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return to;\n};\nvar __reExport = function __reExport(target, mod, secondTarget) {\n  return __copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\");\n};\n\n// src/fillers/monaco-editor-core.ts\nvar monaco_editor_core_exports = {};\n__reExport(monaco_editor_core_exports, monaco_editor_core_star);\nimport * as monaco_editor_core_star from \"../../editor/editor.api.js\";\n\n// src/basic-languages/freemarker2/freemarker2.ts\nvar EMPTY_ELEMENTS = [\"assign\", \"flush\", \"ftl\", \"return\", \"global\", \"import\", \"include\", \"break\", \"continue\", \"local\", \"nested\", \"nt\", \"setting\", \"stop\", \"t\", \"lt\", \"rt\", \"fallback\"];\nvar BLOCK_ELEMENTS = [\"attempt\", \"autoesc\", \"autoEsc\", \"compress\", \"comment\", \"escape\", \"noescape\", \"function\", \"if\", \"list\", \"items\", \"sep\", \"macro\", \"noparse\", \"noParse\", \"noautoesc\", \"noAutoEsc\", \"outputformat\", \"switch\", \"visit\", \"recurse\"];\nvar TagSyntaxAngle = {\n  close: \">\",\n  id: \"angle\",\n  open: \"<\"\n};\nvar TagSyntaxBracket = {\n  close: \"\\\\]\",\n  id: \"bracket\",\n  open: \"\\\\[\"\n};\nvar TagSyntaxAuto = {\n  close: \"[>\\\\]]\",\n  id: \"auto\",\n  open: \"[<\\\\[]\"\n};\nvar InterpolationSyntaxDollar = {\n  close: \"\\\\}\",\n  id: \"dollar\",\n  open1: \"\\\\$\",\n  open2: \"\\\\{\"\n};\nvar InterpolationSyntaxBracket = {\n  close: \"\\\\]\",\n  id: \"bracket\",\n  open1: \"\\\\[\",\n  open2: \"=\"\n};\nfunction createLangConfiguration(ts) {\n  return {\n    brackets: [[\"<\", \">\"], [\"[\", \"]\"], [\"(\", \")\"], [\"{\", \"}\"]],\n    comments: {\n      blockComment: [\"\".concat(ts.open, \"--\"), \"--\".concat(ts.close)]\n    },\n    autoCloseBefore: \"\\n\\r\t }]),.:;=\",\n    autoClosingPairs: [{\n      open: \"{\",\n      close: \"}\"\n    }, {\n      open: \"[\",\n      close: \"]\"\n    }, {\n      open: \"(\",\n      close: \")\"\n    }, {\n      open: '\"',\n      close: '\"',\n      notIn: [\"string\"]\n    }, {\n      open: \"'\",\n      close: \"'\",\n      notIn: [\"string\"]\n    }],\n    surroundingPairs: [{\n      open: '\"',\n      close: '\"'\n    }, {\n      open: \"'\",\n      close: \"'\"\n    }, {\n      open: \"{\",\n      close: \"}\"\n    }, {\n      open: \"[\",\n      close: \"]\"\n    }, {\n      open: \"(\",\n      close: \")\"\n    }, {\n      open: \"<\",\n      close: \">\"\n    }],\n    folding: {\n      markers: {\n        start: new RegExp(\"\".concat(ts.open, \"#(?:\").concat(BLOCK_ELEMENTS.join(\"|\"), \")([^/\").concat(ts.close, \"]*(?!/)\").concat(ts.close, \")[^\").concat(ts.open, \"]*$\")),\n        end: new RegExp(\"\".concat(ts.open, \"/#(?:\").concat(BLOCK_ELEMENTS.join(\"|\"), \")[\\\\r\\\\n\\\\t ]*>\"))\n      }\n    },\n    onEnterRules: [{\n      beforeText: new RegExp(\"\".concat(ts.open, \"#(?!(?:\").concat(EMPTY_ELEMENTS.join(\"|\"), \"))([a-zA-Z_]+)([^/\").concat(ts.close, \"]*(?!/)\").concat(ts.close, \")[^\").concat(ts.open, \"]*$\")),\n      afterText: new RegExp(\"^\".concat(ts.open, \"/#([a-zA-Z_]+)[\\\\r\\\\n\\\\t ]*\").concat(ts.close, \"$\")),\n      action: {\n        indentAction: monaco_editor_core_exports.languages.IndentAction.IndentOutdent\n      }\n    }, {\n      beforeText: new RegExp(\"\".concat(ts.open, \"#(?!(?:\").concat(EMPTY_ELEMENTS.join(\"|\"), \"))([a-zA-Z_]+)([^/\").concat(ts.close, \"]*(?!/)\").concat(ts.close, \")[^\").concat(ts.open, \"]*$\")),\n      action: {\n        indentAction: monaco_editor_core_exports.languages.IndentAction.Indent\n      }\n    }]\n  };\n}\nfunction createLangConfigurationAuto() {\n  return {\n    // Cannot set block comment delimiter in auto mode...\n    // It depends on the content and the cursor position of the file...\n    brackets: [[\"<\", \">\"], [\"[\", \"]\"], [\"(\", \")\"], [\"{\", \"}\"]],\n    autoCloseBefore: \"\\n\\r\t }]),.:;=\",\n    autoClosingPairs: [{\n      open: \"{\",\n      close: \"}\"\n    }, {\n      open: \"[\",\n      close: \"]\"\n    }, {\n      open: \"(\",\n      close: \")\"\n    }, {\n      open: '\"',\n      close: '\"',\n      notIn: [\"string\"]\n    }, {\n      open: \"'\",\n      close: \"'\",\n      notIn: [\"string\"]\n    }],\n    surroundingPairs: [{\n      open: '\"',\n      close: '\"'\n    }, {\n      open: \"'\",\n      close: \"'\"\n    }, {\n      open: \"{\",\n      close: \"}\"\n    }, {\n      open: \"[\",\n      close: \"]\"\n    }, {\n      open: \"(\",\n      close: \")\"\n    }, {\n      open: \"<\",\n      close: \">\"\n    }],\n    folding: {\n      markers: {\n        start: new RegExp(\"[<\\\\[]#(?:\".concat(BLOCK_ELEMENTS.join(\"|\"), \")([^/>\\\\]]*(?!/)[>\\\\]])[^<\\\\[]*$\")),\n        end: new RegExp(\"[<\\\\[]/#(?:\".concat(BLOCK_ELEMENTS.join(\"|\"), \")[\\\\r\\\\n\\\\t ]*>\"))\n      }\n    },\n    onEnterRules: [{\n      beforeText: new RegExp(\"[<\\\\[]#(?!(?:\".concat(EMPTY_ELEMENTS.join(\"|\"), \"))([a-zA-Z_]+)([^/>\\\\]]*(?!/)[>\\\\]])[^[<\\\\[]]*$\")),\n      afterText: new RegExp(\"^[<\\\\[]/#([a-zA-Z_]+)[\\\\r\\\\n\\\\t ]*[>\\\\]]$\"),\n      action: {\n        indentAction: monaco_editor_core_exports.languages.IndentAction.IndentOutdent\n      }\n    }, {\n      beforeText: new RegExp(\"[<\\\\[]#(?!(?:\".concat(EMPTY_ELEMENTS.join(\"|\"), \"))([a-zA-Z_]+)([^/>\\\\]]*(?!/)[>\\\\]])[^[<\\\\[]]*$\")),\n      action: {\n        indentAction: monaco_editor_core_exports.languages.IndentAction.Indent\n      }\n    }]\n  };\n}\nfunction createMonarchLanguage(ts, is) {\n  var _tokenizer, _ref;\n  var id = \"_\".concat(ts.id, \"_\").concat(is.id);\n  var s = function s(name) {\n    return name.replace(/__id__/g, id);\n  };\n  var r = function r(regexp) {\n    var source = regexp.source.replace(/__id__/g, id);\n    return new RegExp(source, regexp.flags);\n  };\n  return _ref = {\n    // Settings\n    unicode: true,\n    includeLF: false,\n    start: s(\"default__id__\"),\n    ignoreCase: false,\n    defaultToken: \"invalid\",\n    tokenPostfix: \".freemarker2\",\n    brackets: [{\n      open: \"{\",\n      close: \"}\",\n      token: \"delimiter.curly\"\n    }, {\n      open: \"[\",\n      close: \"]\",\n      token: \"delimiter.square\"\n    }, {\n      open: \"(\",\n      close: \")\",\n      token: \"delimiter.parenthesis\"\n    }, {\n      open: \"<\",\n      close: \">\",\n      token: \"delimiter.angle\"\n    }]\n  }, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ref, s(\"open__id__\"), new RegExp(ts.open)), s(\"close__id__\"), new RegExp(ts.close)), s(\"iOpen1__id__\"), new RegExp(is.open1)), s(\"iOpen2__id__\"), new RegExp(is.open2)), s(\"iClose__id__\"), new RegExp(is.close)), s(\"startTag__id__\"), r(/(@open__id__)(#)/)), s(\"endTag__id__\"), r(/(@open__id__)(\\/#)/)), s(\"startOrEndTag__id__\"), r(/(@open__id__)(\\/?#)/)), s(\"closeTag1__id__\"), r(/((?:@blank)*)(@close__id__)/)), s(\"closeTag2__id__\"), r(/((?:@blank)*\\/?)(@close__id__)/)), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ref, \"blank\", /[ \\t\\n\\r]/), \"keywords\", [\"false\", \"true\", \"in\", \"as\", \"using\"]), \"directiveStartCloseTag1\", /attempt|recover|sep|auto[eE]sc|no(?:autoe|AutoE)sc|compress|default|no[eE]scape|comment|no[pP]arse/), \"directiveStartCloseTag2\", /else|break|continue|return|stop|flush|t|lt|rt|nt|nested|recurse|fallback|ftl/), \"directiveStartBlank\", /if|else[iI]f|list|for[eE]ach|switch|case|assign|global|local|include|import|function|macro|transform|visit|stop|return|call|setting|output[fF]ormat|nested|recurse|escape|ftl|items/), \"directiveEndCloseTag1\", /if|list|items|sep|recover|attempt|for[eE]ach|local|global|assign|function|macro|output[fF]ormat|auto[eE]sc|no(?:autoe|AutoE)sc|compress|transform|switch|escape|no[eE]scape/), \"escapedChar\", /\\\\(?:[ntrfbgla\\\\'\"\\{=]|(?:x[0-9A-Fa-f]{1,4}))/), \"asciiDigit\", /[0-9]/), \"integer\", /[0-9]+/), \"nonEscapedIdStartChar\", /[\\$@-Z_a-z\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u1FFF\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183-\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3006\\u3031-\\u3035\\u303B-\\u303C\\u3040-\\u318F\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3300-\\u337F\\u3400-\\u4DB5\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8D0-\\uA8D9\\uA8F2-\\uA8F7\\uA8FB\\uA900-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF-\\uA9D9\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5-\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40-\\uFB41\\uFB43-\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ref, \"escapedIdChar\", /\\\\[\\-\\.:#]/), \"idStartChar\", /(?:@nonEscapedIdStartChar)|(?:@escapedIdChar)/), \"id\", /(?:@idStartChar)(?:(?:@idStartChar)|(?:@asciiDigit))*/), \"specialHashKeys\", /\\*\\*|\\*|false|true|in|as|using/), \"namedSymbols\", /&lt;=|&gt;=|\\\\lte|\\\\lt|&lt;|\\\\gte|\\\\gt|&gt;|&amp;&amp;|\\\\and|-&gt;|->|==|!=|\\+=|-=|\\*=|\\/=|%=|\\+\\+|--|<=|&&|\\|\\||:|\\.\\.\\.|\\.\\.\\*|\\.\\.<|\\.\\.!|\\?\\?|=|<|\\+|-|\\*|\\/|%|\\||\\.\\.|\\?|!|&|\\.|,|;/), \"arrows\", [\"->\", \"-&gt;\"]), \"delimiters\", [\";\", \":\", \",\", \".\"]), \"stringOperators\", [\"lte\", \"lt\", \"gte\", \"gt\"]), \"noParseTags\", [\"noparse\", \"noParse\", \"comment\"]), \"tokenizer\", (_tokenizer = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_tokenizer, s(\"default__id__\"), [{\n    include: s(\"@directive_token__id__\")\n  }, {\n    include: s(\"@interpolation_and_text_token__id__\")\n  }]), s(\"fmExpression__id__.directive\"), [{\n    include: s(\"@blank_and_expression_comment_token__id__\")\n  }, {\n    include: s(\"@directive_end_token__id__\")\n  }, {\n    include: s(\"@expression_token__id__\")\n  }]), s(\"fmExpression__id__.interpolation\"), [{\n    include: s(\"@blank_and_expression_comment_token__id__\")\n  }, {\n    include: s(\"@expression_token__id__\")\n  }, {\n    include: s(\"@greater_operators_token__id__\")\n  }]), s(\"inParen__id__.plain\"), [{\n    include: s(\"@blank_and_expression_comment_token__id__\")\n  }, {\n    include: s(\"@directive_end_token__id__\")\n  }, {\n    include: s(\"@expression_token__id__\")\n  }]), s(\"inParen__id__.gt\"), [{\n    include: s(\"@blank_and_expression_comment_token__id__\")\n  }, {\n    include: s(\"@expression_token__id__\")\n  }, {\n    include: s(\"@greater_operators_token__id__\")\n  }]), s(\"noSpaceExpression__id__\"), [{\n    include: s(\"@no_space_expression_end_token__id__\")\n  }, {\n    include: s(\"@directive_end_token__id__\")\n  }, {\n    include: s(\"@expression_token__id__\")\n  }]), s(\"unifiedCall__id__\"), [{\n    include: s(\"@unified_call_token__id__\")\n  }]), s(\"singleString__id__\"), [{\n    include: s(\"@string_single_token__id__\")\n  }]), s(\"doubleString__id__\"), [{\n    include: s(\"@string_double_token__id__\")\n  }]), s(\"rawSingleString__id__\"), [{\n    include: s(\"@string_single_raw_token__id__\")\n  }]), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_tokenizer, s(\"rawDoubleString__id__\"), [{\n    include: s(\"@string_double_raw_token__id__\")\n  }]), s(\"expressionComment__id__\"), [{\n    include: s(\"@expression_comment_token__id__\")\n  }]), s(\"noParse__id__\"), [{\n    include: s(\"@no_parse_token__id__\")\n  }]), s(\"terseComment__id__\"), [{\n    include: s(\"@terse_comment_token__id__\")\n  }]), s(\"directive_token__id__\"), [\n  // <ATTEMPT : <START_TAG> \"attempt\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <RECOVER : <START_TAG> \"recover\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <SEP : <START_TAG> \"sep\" <CLOSE_TAG1>>\n  // <AUTOESC : <START_TAG> \"auto\" (\"e\"|\"E\") \"sc\" <CLOSE_TAG1>> {\n  //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 4), DEFAULT);\n  // }\n  // <NOAUTOESC : <START_TAG> \"no\" (\"autoe\"|\"AutoE\") \"sc\" <CLOSE_TAG1>> {\n  //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n  // }\n  // <COMPRESS : <START_TAG> \"compress\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <DEFAUL : <START_TAG> \"default\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <NOESCAPE : <START_TAG> \"no\" (\"e\" | \"E\") \"scape\" <CLOSE_TAG1>> {\n  //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n  // }\n  //\n  // <COMMENT : <START_TAG> \"comment\" <CLOSE_TAG1>> {\n  //     handleTagSyntaxAndSwitch(matchedToken, NO_PARSE); noparseTag = \"comment\";\n  // }\n  // <NOPARSE: <START_TAG> \"no\" (\"p\" | \"P\") \"arse\" <CLOSE_TAG1>> {\n  //     int tagNamingConvention = getTagNamingConvention(matchedToken, 2);\n  //     handleTagSyntaxAndSwitch(matchedToken, tagNamingConvention, NO_PARSE);\n  //     noparseTag = tagNamingConvention == Configuration.CAMEL_CASE_NAMING_CONVENTION ? \"noParse\" : \"noparse\";\n  // }\n  [r(/(?:@startTag__id__)(@directiveStartCloseTag1)(?:@closeTag1__id__)/), ts.id === \"auto\" ? {\n    cases: {\n      \"$1==<\": {\n        token: \"@rematch\",\n        switchTo: \"@default_angle_\".concat(is.id)\n      },\n      \"$1==[\": {\n        token: \"@rematch\",\n        switchTo: \"@default_bracket_\".concat(is.id)\n      }\n    }\n  } : [{\n    token: \"@brackets.directive\"\n  }, {\n    token: \"delimiter.directive\"\n  }, {\n    cases: {\n      \"@noParseTags\": {\n        token: \"tag\",\n        next: s(\"@noParse__id__.$3\")\n      },\n      \"@default\": {\n        token: \"tag\"\n      }\n    }\n  }, {\n    token: \"delimiter.directive\"\n  }, {\n    token: \"@brackets.directive\"\n  }]],\n  // <ELSE : <START_TAG> \"else\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <BREAK : <START_TAG> \"break\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <CONTINUE : <START_TAG> \"continue\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <SIMPLE_RETURN : <START_TAG> \"return\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <HALT : <START_TAG> \"stop\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <FLUSH : <START_TAG> \"flush\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <TRIM : <START_TAG> \"t\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <LTRIM : <START_TAG> \"lt\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <RTRIM : <START_TAG> \"rt\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <NOTRIM : <START_TAG> \"nt\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <SIMPLE_NESTED : <START_TAG> \"nested\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <SIMPLE_RECURSE : <START_TAG> \"recurse\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <FALLBACK : <START_TAG> \"fallback\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <TRIVIAL_FTL_HEADER : (\"<#ftl\" | \"[#ftl\") (\"/\")? (\">\" | \"]\")> { ftlHeader(matchedToken); }\n  [r(/(?:@startTag__id__)(@directiveStartCloseTag2)(?:@closeTag2__id__)/), ts.id === \"auto\" ? {\n    cases: {\n      \"$1==<\": {\n        token: \"@rematch\",\n        switchTo: \"@default_angle_\".concat(is.id)\n      },\n      \"$1==[\": {\n        token: \"@rematch\",\n        switchTo: \"@default_bracket_\".concat(is.id)\n      }\n    }\n  } : [{\n    token: \"@brackets.directive\"\n  }, {\n    token: \"delimiter.directive\"\n  }, {\n    token: \"tag\"\n  }, {\n    token: \"delimiter.directive\"\n  }, {\n    token: \"@brackets.directive\"\n  }]],\n  // <IF : <START_TAG> \"if\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n  // <ELSE_IF : <START_TAG> \"else\" (\"i\" | \"I\") \"f\" <BLANK>> {\n  // \thandleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 4), FM_EXPRESSION);\n  // }\n  // <LIST : <START_TAG> \"list\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n  // <FOREACH : <START_TAG> \"for\" (\"e\" | \"E\") \"ach\" <BLANK>> {\n  //    handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 3), FM_EXPRESSION);\n  // }\n  // <SWITCH : <START_TAG> \"switch\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n  // <CASE : <START_TAG> \"case\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n  // <ASSIGN : <START_TAG> \"assign\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n  // <GLOBALASSIGN : <START_TAG> \"global\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n  // <LOCALASSIGN : <START_TAG> \"local\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n  // <_INCLUDE : <START_TAG> \"include\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n  // <IMPORT : <START_TAG> \"import\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n  // <FUNCTION : <START_TAG> \"function\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n  // <MACRO : <START_TAG> \"macro\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n  // <TRANSFORM : <START_TAG> \"transform\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n  // <VISIT : <START_TAG> \"visit\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n  // <STOP : <START_TAG> \"stop\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n  // <RETURN : <START_TAG> \"return\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n  // <CALL : <START_TAG> \"call\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n  // <SETTING : <START_TAG> \"setting\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n  // <OUTPUTFORMAT : <START_TAG> \"output\" (\"f\"|\"F\") \"ormat\" <BLANK>> {\n  //    handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 6), FM_EXPRESSION);\n  // }\n  // <NESTED : <START_TAG> \"nested\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n  // <RECURSE : <START_TAG> \"recurse\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n  // <ESCAPE : <START_TAG> \"escape\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n  //\n  // Note: FreeMarker grammar appears to treat the FTL header as a special case,\n  // in order to remove new lines after the header (?), but since we only need\n  // to tokenize for highlighting, we can include this directive here.\n  // <FTL_HEADER : (\"<#ftl\" | \"[#ftl\") <BLANK>> { ftlHeader(matchedToken); }\n  //\n  // Note: FreeMarker grammar appears to treat the items directive as a special case for\n  // the AST parsing process, but since we only need to tokenize, we can include this\n  // directive here.\n  // <ITEMS : <START_TAG> \"items\" (<BLANK>)+ <AS> <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n  [r(/(?:@startTag__id__)(@directiveStartBlank)(@blank)/), ts.id === \"auto\" ? {\n    cases: {\n      \"$1==<\": {\n        token: \"@rematch\",\n        switchTo: \"@default_angle_\".concat(is.id)\n      },\n      \"$1==[\": {\n        token: \"@rematch\",\n        switchTo: \"@default_bracket_\".concat(is.id)\n      }\n    }\n  } : [{\n    token: \"@brackets.directive\"\n  }, {\n    token: \"delimiter.directive\"\n  }, {\n    token: \"tag\"\n  }, {\n    token: \"\",\n    next: s(\"@fmExpression__id__.directive\")\n  }]],\n  // <END_IF : <END_TAG> \"if\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <END_LIST : <END_TAG> \"list\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <END_SEP : <END_TAG> \"sep\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <END_RECOVER : <END_TAG> \"recover\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <END_ATTEMPT : <END_TAG> \"attempt\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <END_FOREACH : <END_TAG> \"for\" (\"e\" | \"E\") \"ach\" <CLOSE_TAG1>> {\n  //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 3), DEFAULT);\n  // }\n  // <END_LOCAL : <END_TAG> \"local\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <END_GLOBAL : <END_TAG> \"global\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <END_ASSIGN : <END_TAG> \"assign\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <END_FUNCTION : <END_TAG> \"function\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <END_MACRO : <END_TAG> \"macro\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <END_OUTPUTFORMAT : <END_TAG> \"output\" (\"f\" | \"F\") \"ormat\" <CLOSE_TAG1>> {\n  //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 6), DEFAULT);\n  // }\n  // <END_AUTOESC : <END_TAG> \"auto\" (\"e\" | \"E\") \"sc\" <CLOSE_TAG1>> {\n  //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 4), DEFAULT);\n  // }\n  // <END_NOAUTOESC : <END_TAG> \"no\" (\"autoe\"|\"AutoE\") \"sc\" <CLOSE_TAG1>> {\n  //   handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n  // }\n  // <END_COMPRESS : <END_TAG> \"compress\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <END_TRANSFORM : <END_TAG> \"transform\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <END_SWITCH : <END_TAG> \"switch\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <END_ESCAPE : <END_TAG> \"escape\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n  // <END_NOESCAPE : <END_TAG> \"no\" (\"e\" | \"E\") \"scape\" <CLOSE_TAG1>> {\n  //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n  // }\n  [r(/(?:@endTag__id__)(@directiveEndCloseTag1)(?:@closeTag1__id__)/), ts.id === \"auto\" ? {\n    cases: {\n      \"$1==<\": {\n        token: \"@rematch\",\n        switchTo: \"@default_angle_\".concat(is.id)\n      },\n      \"$1==[\": {\n        token: \"@rematch\",\n        switchTo: \"@default_bracket_\".concat(is.id)\n      }\n    }\n  } : [{\n    token: \"@brackets.directive\"\n  }, {\n    token: \"delimiter.directive\"\n  }, {\n    token: \"tag\"\n  }, {\n    token: \"delimiter.directive\"\n  }, {\n    token: \"@brackets.directive\"\n  }]],\n  // <UNIFIED_CALL : \"<@\" | \"[@\" > { unifiedCall(matchedToken); }\n  [r(/(@open__id__)(@)/), ts.id === \"auto\" ? {\n    cases: {\n      \"$1==<\": {\n        token: \"@rematch\",\n        switchTo: \"@default_angle_\".concat(is.id)\n      },\n      \"$1==[\": {\n        token: \"@rematch\",\n        switchTo: \"@default_bracket_\".concat(is.id)\n      }\n    }\n  } : [{\n    token: \"@brackets.directive\"\n  }, {\n    token: \"delimiter.directive\",\n    next: s(\"@unifiedCall__id__\")\n  }]],\n  // <UNIFIED_CALL_END : (\"<\" | \"[\") \"/@\" ((<ID>) (\".\"<ID>)*)? <CLOSE_TAG1>> { unifiedCallEnd(matchedToken); }\n  [r(/(@open__id__)(\\/@)((?:(?:@id)(?:\\.(?:@id))*)?)(?:@closeTag1__id__)/), [{\n    token: \"@brackets.directive\"\n  }, {\n    token: \"delimiter.directive\"\n  }, {\n    token: \"tag\"\n  }, {\n    token: \"delimiter.directive\"\n  }, {\n    token: \"@brackets.directive\"\n  }]],\n  // <TERSE_COMMENT : (\"<\" | \"[\") \"#--\" > { noparseTag = \"-->\"; handleTagSyntaxAndSwitch(matchedToken, NO_PARSE); }\n  [r(/(@open__id__)#--/), ts.id === \"auto\" ? {\n    cases: {\n      \"$1==<\": {\n        token: \"@rematch\",\n        switchTo: \"@default_angle_\".concat(is.id)\n      },\n      \"$1==[\": {\n        token: \"@rematch\",\n        switchTo: \"@default_bracket_\".concat(is.id)\n      }\n    }\n  } : {\n    token: \"comment\",\n    next: s(\"@terseComment__id__\")\n  }],\n  // <UNKNOWN_DIRECTIVE : (\"[#\" | \"[/#\" | \"<#\" | \"</#\") ([\"a\"-\"z\", \"A\"-\"Z\", \"_\"])+>\n  [r(/(?:@startOrEndTag__id__)([a-zA-Z_]+)/), ts.id === \"auto\" ? {\n    cases: {\n      \"$1==<\": {\n        token: \"@rematch\",\n        switchTo: \"@default_angle_\".concat(is.id)\n      },\n      \"$1==[\": {\n        token: \"@rematch\",\n        switchTo: \"@default_bracket_\".concat(is.id)\n      }\n    }\n  } : [{\n    token: \"@brackets.directive\"\n  }, {\n    token: \"delimiter.directive\"\n  }, {\n    token: \"tag.invalid\",\n    next: s(\"@fmExpression__id__.directive\")\n  }]]]), s(\"interpolation_and_text_token__id__\"), [\n  // <DOLLAR_INTERPOLATION_OPENING : \"${\"> { startInterpolation(matchedToken); }\n  // <SQUARE_BRACKET_INTERPOLATION_OPENING : \"[=\"> { startInterpolation(matchedToken); }\n  [r(/(@iOpen1__id__)(@iOpen2__id__)/), [{\n    token: is.id === \"bracket\" ? \"@brackets.interpolation\" : \"delimiter.interpolation\"\n  }, {\n    token: is.id === \"bracket\" ? \"delimiter.interpolation\" : \"@brackets.interpolation\",\n    next: s(\"@fmExpression__id__.interpolation\")\n  }]],\n  // <STATIC_TEXT_FALSE_ALARM : \"$\" | \"#\" | \"<\" | \"[\" | \"{\"> // to handle a lone dollar sign or \"<\" or \"# or <@ with whitespace after\"\n  // <STATIC_TEXT_WS : (\"\\n\" | \"\\r\" | \"\\t\" | \" \")+>\n  // <STATIC_TEXT_NON_WS : (~[\"$\", \"<\", \"#\", \"[\", \"{\", \"\\n\", \"\\r\", \"\\t\", \" \"])+>\n  [/[\\$#<\\[\\{]|(?:@blank)+|[^\\$<#\\[\\{\\n\\r\\t ]+/, {\n    token: \"source\"\n  }]]), s(\"string_single_token__id__\"), [[/[^'\\\\]/, {\n    token: \"string\"\n  }], [/@escapedChar/, {\n    token: \"string.escape\"\n  }], [/'/, {\n    token: \"string\",\n    next: \"@pop\"\n  }]]), s(\"string_double_token__id__\"), [[/[^\"\\\\]/, {\n    token: \"string\"\n  }], [/@escapedChar/, {\n    token: \"string.escape\"\n  }], [/\"/, {\n    token: \"string\",\n    next: \"@pop\"\n  }]]), s(\"string_single_raw_token__id__\"), [[/[^']+/, {\n    token: \"string.raw\"\n  }], [/'/, {\n    token: \"string.raw\",\n    next: \"@pop\"\n  }]]), s(\"string_double_raw_token__id__\"), [[/[^\"]+/, {\n    token: \"string.raw\"\n  }], [/\"/, {\n    token: \"string.raw\",\n    next: \"@pop\"\n  }]]), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_tokenizer, s(\"expression_token__id__\"), [\n  // Strings\n  [/(r?)(['\"])/, {\n    cases: {\n      \"r'\": [{\n        token: \"keyword\"\n      }, {\n        token: \"string.raw\",\n        next: s(\"@rawSingleString__id__\")\n      }],\n      'r\"': [{\n        token: \"keyword\"\n      }, {\n        token: \"string.raw\",\n        next: s(\"@rawDoubleString__id__\")\n      }],\n      \"'\": [{\n        token: \"source\"\n      }, {\n        token: \"string\",\n        next: s(\"@singleString__id__\")\n      }],\n      '\"': [{\n        token: \"source\"\n      }, {\n        token: \"string\",\n        next: s(\"@doubleString__id__\")\n      }]\n    }\n  }],\n  // Numbers\n  // <INTEGER : ([\"0\"-\"9\"])+>\n  // <DECIMAL : <INTEGER> \".\" <INTEGER>>\n  [/(?:@integer)(?:\\.(?:@integer))?/, {\n    cases: {\n      \"(?:@integer)\": {\n        token: \"number\"\n      },\n      \"@default\": {\n        token: \"number.float\"\n      }\n    }\n  }],\n  // Special hash keys that must not be treated as identifiers\n  // after a period, e.g. a.** is accessing the key \"**\" of a\n  [/(\\.)(@blank*)(@specialHashKeys)/, [{\n    token: \"delimiter\"\n  }, {\n    token: \"\"\n  }, {\n    token: \"identifier\"\n  }]],\n  // Symbols / operators\n  [/(?:@namedSymbols)/, {\n    cases: {\n      \"@arrows\": {\n        token: \"meta.arrow\"\n      },\n      \"@delimiters\": {\n        token: \"delimiter\"\n      },\n      \"@default\": {\n        token: \"operators\"\n      }\n    }\n  }],\n  // Identifiers\n  [/@id/, {\n    cases: {\n      \"@keywords\": {\n        token: \"keyword.$0\"\n      },\n      \"@stringOperators\": {\n        token: \"operators\"\n      },\n      \"@default\": {\n        token: \"identifier\"\n      }\n    }\n  }],\n  // <OPEN_BRACKET : \"[\">\n  // <CLOSE_BRACKET : \"]\">\n  // <OPEN_PAREN : \"(\">\n  // <CLOSE_PAREN : \")\">\n  // <OPENING_CURLY_BRACKET : \"{\">\n  // <CLOSING_CURLY_BRACKET : \"}\">\n  [/[\\[\\]\\(\\)\\{\\}]/, {\n    cases: {\n      \"\\\\[\": {\n        cases: {\n          \"$S2==gt\": {\n            token: \"@brackets\",\n            next: s(\"@inParen__id__.gt\")\n          },\n          \"@default\": {\n            token: \"@brackets\",\n            next: s(\"@inParen__id__.plain\")\n          }\n        }\n      },\n      \"\\\\]\": {\n        cases: _objectSpread(_objectSpread(_objectSpread({}, is.id === \"bracket\" ? {\n          \"$S2==interpolation\": {\n            token: \"@brackets.interpolation\",\n            next: \"@popall\"\n          }\n        } : {}), ts.id === \"bracket\" ? {\n          \"$S2==directive\": {\n            token: \"@brackets.directive\",\n            next: \"@popall\"\n          }\n        } : {}), {}, _defineProperty(_defineProperty({}, s(\"$S1==inParen__id__\"), {\n          token: \"@brackets\",\n          next: \"@pop\"\n        }), \"@default\", {\n          token: \"@brackets\"\n        }))\n      },\n      \"\\\\(\": {\n        token: \"@brackets\",\n        next: s(\"@inParen__id__.gt\")\n      },\n      \"\\\\)\": {\n        cases: _defineProperty(_defineProperty({}, s(\"$S1==inParen__id__\"), {\n          token: \"@brackets\",\n          next: \"@pop\"\n        }), \"@default\", {\n          token: \"@brackets\"\n        })\n      },\n      \"\\\\{\": {\n        cases: {\n          \"$S2==gt\": {\n            token: \"@brackets\",\n            next: s(\"@inParen__id__.gt\")\n          },\n          \"@default\": {\n            token: \"@brackets\",\n            next: s(\"@inParen__id__.plain\")\n          }\n        }\n      },\n      \"\\\\}\": {\n        cases: _objectSpread(_objectSpread({}, is.id === \"bracket\" ? {} : {\n          \"$S2==interpolation\": {\n            token: \"@brackets.interpolation\",\n            next: \"@popall\"\n          }\n        }), {}, _defineProperty(_defineProperty({}, s(\"$S1==inParen__id__\"), {\n          token: \"@brackets\",\n          next: \"@pop\"\n        }), \"@default\", {\n          token: \"@brackets\"\n        }))\n      }\n    }\n  }],\n  // <OPEN_MISPLACED_INTERPOLATION : \"${\" | \"#{\" | \"[=\">\n  [/\\$\\{/, {\n    token: \"delimiter.invalid\"\n  }]]), s(\"blank_and_expression_comment_token__id__\"), [\n  // < ( \" \" | \"\\t\" | \"\\n\" | \"\\r\" )+ >\n  [/(?:@blank)+/, {\n    token: \"\"\n  }],\n  // < (\"<\" | \"[\") (\"#\" | \"!\") \"--\"> : EXPRESSION_COMMENT\n  [/[<\\[][#!]--/, {\n    token: \"comment\",\n    next: s(\"@expressionComment__id__\")\n  }]]), s(\"directive_end_token__id__\"), [\n  // <DIRECTIVE_END : \">\">\n  // {\n  //     if (inFTLHeader) {\n  //         eatNewline();\n  //         inFTLHeader = false;\n  //     }\n  //     if (squBracTagSyntax || postInterpolationLexState != -1 /* We are in an interpolation */) {\n  //         matchedToken.kind = NATURAL_GT;\n  //     } else {\n  //         SwitchTo(DEFAULT);\n  //     }\n  // }\n  // This cannot happen while in auto mode, since this applies only to an\n  // fmExpression inside a directive. But once we encounter the start of a\n  // directive, we can establish the tag syntax mode.\n  [/>/, ts.id === \"bracket\" ? {\n    token: \"operators\"\n  } : {\n    token: \"@brackets.directive\",\n    next: \"@popall\"\n  }],\n  // <EMPTY_DIRECTIVE_END : \"/>\" | \"/]\">\n  // It is a syntax error to end a tag with the wrong close token\n  // Let's indicate that to the user by not closing the tag\n  [r(/(\\/)(@close__id__)/), [{\n    token: \"delimiter.directive\"\n  }, {\n    token: \"@brackets.directive\",\n    next: \"@popall\"\n  }]]]), s(\"greater_operators_token__id__\"), [\n  // <NATURAL_GT : \">\">\n  [/>/, {\n    token: \"operators\"\n  }],\n  // <NATURAL_GTE : \">=\">\n  [/>=/, {\n    token: \"operators\"\n  }]]), s(\"no_space_expression_end_token__id__\"), [\n  // <TERMINATING_WHITESPACE :  ([\"\\n\", \"\\r\", \"\\t\", \" \"])+> : FM_EXPRESSION\n  [/(?:@blank)+/, {\n    token: \"\",\n    switchTo: s(\"@fmExpression__id__.directive\")\n  }]]), s(\"unified_call_token__id__\"), [\n  // Special case for a call where the expression is just an ID\n  // <UNIFIED_CALL> <ID> <BLANK>+\n  [/(@id)((?:@blank)+)/, [{\n    token: \"tag\"\n  }, {\n    token: \"\",\n    next: s(\"@fmExpression__id__.directive\")\n  }]], [r(/(@id)(\\/?)(@close__id__)/), [{\n    token: \"tag\"\n  }, {\n    token: \"delimiter.directive\"\n  }, {\n    token: \"@brackets.directive\",\n    next: \"@popall\"\n  }]], [/./, {\n    token: \"@rematch\",\n    next: s(\"@noSpaceExpression__id__\")\n  }]]), s(\"no_parse_token__id__\"), [\n  // <MAYBE_END :\n  // \t (\"<\" | \"[\")\n  // \t \"/\"\n  // \t (\"#\")?\n  // \t ([\"a\"-\"z\", \"A\"-\"Z\"])+\n  // \t ( \" \" | \"\\t\" | \"\\n\" | \"\\r\" )*\n  // \t (\">\" | \"]\")\n  // >\n  [r(/(@open__id__)(\\/#?)([a-zA-Z]+)((?:@blank)*)(@close__id__)/), {\n    cases: {\n      \"$S2==$3\": [{\n        token: \"@brackets.directive\"\n      }, {\n        token: \"delimiter.directive\"\n      }, {\n        token: \"tag\"\n      }, {\n        token: \"\"\n      }, {\n        token: \"@brackets.directive\",\n        next: \"@popall\"\n      }],\n      \"$S2==comment\": [{\n        token: \"comment\"\n      }, {\n        token: \"comment\"\n      }, {\n        token: \"comment\"\n      }, {\n        token: \"comment\"\n      }, {\n        token: \"comment\"\n      }],\n      \"@default\": [{\n        token: \"source\"\n      }, {\n        token: \"source\"\n      }, {\n        token: \"source\"\n      }, {\n        token: \"source\"\n      }, {\n        token: \"source\"\n      }]\n    }\n  }],\n  // <KEEP_GOING : (~[\"<\", \"[\", \"-\"])+>\n  // <LONE_LESS_THAN_OR_DASH : [\"<\", \"[\", \"-\"]>\n  [/[^<\\[\\-]+|[<\\[\\-]/, {\n    cases: {\n      \"$S2==comment\": {\n        token: \"comment\"\n      },\n      \"@default\": {\n        token: \"source\"\n      }\n    }\n  }]]), s(\"expression_comment_token__id__\"), [\n  // < \"-->\" | \"--]\">\n  [/--[>\\]]/, {\n    token: \"comment\",\n    next: \"@pop\"\n  }],\n  // < (~[\"-\", \">\", \"]\"])+ >\n  // < \">\">\n  // < \"]\">\n  // < \"-\">\n  [/[^\\->\\]]+|[>\\]\\-]/, {\n    token: \"comment\"\n  }]]), s(\"terse_comment_token__id__\"), [\n  //  <TERSE_COMMENT_END : \"-->\" | \"--]\">\n  [r(/--(?:@close__id__)/), {\n    token: \"comment\",\n    next: \"@popall\"\n  }],\n  // <KEEP_GOING : (~[\"<\", \"[\", \"-\"])+>\n  // <LONE_LESS_THAN_OR_DASH : [\"<\", \"[\", \"-\"]>\n  [/[^<\\[\\-]+|[<\\[\\-]/, {\n    token: \"comment\"\n  }]])));\n}\nfunction createMonarchLanguageAuto(is) {\n  var angle = createMonarchLanguage(TagSyntaxAngle, is);\n  var bracket = createMonarchLanguage(TagSyntaxBracket, is);\n  var auto = createMonarchLanguage(TagSyntaxAuto, is);\n  return _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, angle), bracket), auto), {}, {\n    // Settings\n    unicode: true,\n    includeLF: false,\n    start: \"default_auto_\".concat(is.id),\n    ignoreCase: false,\n    defaultToken: \"invalid\",\n    tokenPostfix: \".freemarker2\",\n    brackets: [{\n      open: \"{\",\n      close: \"}\",\n      token: \"delimiter.curly\"\n    }, {\n      open: \"[\",\n      close: \"]\",\n      token: \"delimiter.square\"\n    }, {\n      open: \"(\",\n      close: \")\",\n      token: \"delimiter.parenthesis\"\n    }, {\n      open: \"<\",\n      close: \">\",\n      token: \"delimiter.angle\"\n    }],\n    tokenizer: _objectSpread(_objectSpread(_objectSpread({}, angle.tokenizer), bracket.tokenizer), auto.tokenizer)\n  });\n}\nvar TagAngleInterpolationDollar = {\n  conf: createLangConfiguration(TagSyntaxAngle),\n  language: createMonarchLanguage(TagSyntaxAngle, InterpolationSyntaxDollar)\n};\nvar TagBracketInterpolationDollar = {\n  conf: createLangConfiguration(TagSyntaxBracket),\n  language: createMonarchLanguage(TagSyntaxBracket, InterpolationSyntaxDollar)\n};\nvar TagAngleInterpolationBracket = {\n  conf: createLangConfiguration(TagSyntaxAngle),\n  language: createMonarchLanguage(TagSyntaxAngle, InterpolationSyntaxBracket)\n};\nvar TagBracketInterpolationBracket = {\n  conf: createLangConfiguration(TagSyntaxBracket),\n  language: createMonarchLanguage(TagSyntaxBracket, InterpolationSyntaxBracket)\n};\nvar TagAutoInterpolationDollar = {\n  conf: createLangConfigurationAuto(),\n  language: createMonarchLanguageAuto(InterpolationSyntaxDollar)\n};\nvar TagAutoInterpolationBracket = {\n  conf: createLangConfigurationAuto(),\n  language: createMonarchLanguageAuto(InterpolationSyntaxBracket)\n};\nexport { TagAngleInterpolationBracket, TagAngleInterpolationDollar, TagAutoInterpolationBracket, TagAutoInterpolationDollar, TagBracketInterpolationBracket, TagBracketInterpolationDollar };","map":{"version":3,"names":["__defProp","Object","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__hasOwnProp","prototype","hasOwnProperty","__copyProps","to","from","except","desc","_typeof","_iterator","_createForOfIteratorHelper","_step","_loop","key","value","call","get","enumerable","s","n","done","err","e","f","__reExport","target","mod","secondTarget","monaco_editor_core_exports","monaco_editor_core_star","EMPTY_ELEMENTS","BLOCK_ELEMENTS","TagSyntaxAngle","close","id","open","TagSyntaxBracket","TagSyntaxAuto","InterpolationSyntaxDollar","open1","open2","InterpolationSyntaxBracket","createLangConfiguration","ts","brackets","comments","blockComment","concat","autoCloseBefore","autoClosingPairs","notIn","surroundingPairs","folding","markers","start","RegExp","join","end","onEnterRules","beforeText","afterText","action","indentAction","languages","IndentAction","IndentOutdent","Indent","createLangConfigurationAuto","createMonarchLanguage","is","_tokenizer","_ref","name","replace","r","regexp","source","flags","unicode","includeLF","ignoreCase","defaultToken","tokenPostfix","token","_defineProperty","include","cases","switchTo","next","_objectSpread","createMonarchLanguageAuto","angle","bracket","auto","tokenizer","TagAngleInterpolationDollar","conf","language","TagBracketInterpolationDollar","TagAngleInterpolationBracket","TagBracketInterpolationBracket","TagAutoInterpolationDollar","TagAutoInterpolationBracket"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/basic-languages/freemarker2/freemarker2.js"],"sourcesContent":["/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.48.0(0037b13fb5d186fdf1e7df51a9416a2de2b8c670)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\n\n// src/fillers/monaco-editor-core.ts\nvar monaco_editor_core_exports = {};\n__reExport(monaco_editor_core_exports, monaco_editor_core_star);\nimport * as monaco_editor_core_star from \"../../editor/editor.api.js\";\n\n// src/basic-languages/freemarker2/freemarker2.ts\nvar EMPTY_ELEMENTS = [\n  \"assign\",\n  \"flush\",\n  \"ftl\",\n  \"return\",\n  \"global\",\n  \"import\",\n  \"include\",\n  \"break\",\n  \"continue\",\n  \"local\",\n  \"nested\",\n  \"nt\",\n  \"setting\",\n  \"stop\",\n  \"t\",\n  \"lt\",\n  \"rt\",\n  \"fallback\"\n];\nvar BLOCK_ELEMENTS = [\n  \"attempt\",\n  \"autoesc\",\n  \"autoEsc\",\n  \"compress\",\n  \"comment\",\n  \"escape\",\n  \"noescape\",\n  \"function\",\n  \"if\",\n  \"list\",\n  \"items\",\n  \"sep\",\n  \"macro\",\n  \"noparse\",\n  \"noParse\",\n  \"noautoesc\",\n  \"noAutoEsc\",\n  \"outputformat\",\n  \"switch\",\n  \"visit\",\n  \"recurse\"\n];\nvar TagSyntaxAngle = {\n  close: \">\",\n  id: \"angle\",\n  open: \"<\"\n};\nvar TagSyntaxBracket = {\n  close: \"\\\\]\",\n  id: \"bracket\",\n  open: \"\\\\[\"\n};\nvar TagSyntaxAuto = {\n  close: \"[>\\\\]]\",\n  id: \"auto\",\n  open: \"[<\\\\[]\"\n};\nvar InterpolationSyntaxDollar = {\n  close: \"\\\\}\",\n  id: \"dollar\",\n  open1: \"\\\\$\",\n  open2: \"\\\\{\"\n};\nvar InterpolationSyntaxBracket = {\n  close: \"\\\\]\",\n  id: \"bracket\",\n  open1: \"\\\\[\",\n  open2: \"=\"\n};\nfunction createLangConfiguration(ts) {\n  return {\n    brackets: [\n      [\"<\", \">\"],\n      [\"[\", \"]\"],\n      [\"(\", \")\"],\n      [\"{\", \"}\"]\n    ],\n    comments: {\n      blockComment: [`${ts.open}--`, `--${ts.close}`]\n    },\n    autoCloseBefore: \"\\n\\r\t }]),.:;=\",\n    autoClosingPairs: [\n      { open: \"{\", close: \"}\" },\n      { open: \"[\", close: \"]\" },\n      { open: \"(\", close: \")\" },\n      { open: '\"', close: '\"', notIn: [\"string\"] },\n      { open: \"'\", close: \"'\", notIn: [\"string\"] }\n    ],\n    surroundingPairs: [\n      { open: '\"', close: '\"' },\n      { open: \"'\", close: \"'\" },\n      { open: \"{\", close: \"}\" },\n      { open: \"[\", close: \"]\" },\n      { open: \"(\", close: \")\" },\n      { open: \"<\", close: \">\" }\n    ],\n    folding: {\n      markers: {\n        start: new RegExp(\n          `${ts.open}#(?:${BLOCK_ELEMENTS.join(\"|\")})([^/${ts.close}]*(?!/)${ts.close})[^${ts.open}]*$`\n        ),\n        end: new RegExp(`${ts.open}/#(?:${BLOCK_ELEMENTS.join(\"|\")})[\\\\r\\\\n\\\\t ]*>`)\n      }\n    },\n    onEnterRules: [\n      {\n        beforeText: new RegExp(\n          `${ts.open}#(?!(?:${EMPTY_ELEMENTS.join(\"|\")}))([a-zA-Z_]+)([^/${ts.close}]*(?!/)${ts.close})[^${ts.open}]*$`\n        ),\n        afterText: new RegExp(`^${ts.open}/#([a-zA-Z_]+)[\\\\r\\\\n\\\\t ]*${ts.close}$`),\n        action: {\n          indentAction: monaco_editor_core_exports.languages.IndentAction.IndentOutdent\n        }\n      },\n      {\n        beforeText: new RegExp(\n          `${ts.open}#(?!(?:${EMPTY_ELEMENTS.join(\"|\")}))([a-zA-Z_]+)([^/${ts.close}]*(?!/)${ts.close})[^${ts.open}]*$`\n        ),\n        action: { indentAction: monaco_editor_core_exports.languages.IndentAction.Indent }\n      }\n    ]\n  };\n}\nfunction createLangConfigurationAuto() {\n  return {\n    // Cannot set block comment delimiter in auto mode...\n    // It depends on the content and the cursor position of the file...\n    brackets: [\n      [\"<\", \">\"],\n      [\"[\", \"]\"],\n      [\"(\", \")\"],\n      [\"{\", \"}\"]\n    ],\n    autoCloseBefore: \"\\n\\r\t }]),.:;=\",\n    autoClosingPairs: [\n      { open: \"{\", close: \"}\" },\n      { open: \"[\", close: \"]\" },\n      { open: \"(\", close: \")\" },\n      { open: '\"', close: '\"', notIn: [\"string\"] },\n      { open: \"'\", close: \"'\", notIn: [\"string\"] }\n    ],\n    surroundingPairs: [\n      { open: '\"', close: '\"' },\n      { open: \"'\", close: \"'\" },\n      { open: \"{\", close: \"}\" },\n      { open: \"[\", close: \"]\" },\n      { open: \"(\", close: \")\" },\n      { open: \"<\", close: \">\" }\n    ],\n    folding: {\n      markers: {\n        start: new RegExp(`[<\\\\[]#(?:${BLOCK_ELEMENTS.join(\"|\")})([^/>\\\\]]*(?!/)[>\\\\]])[^<\\\\[]*$`),\n        end: new RegExp(`[<\\\\[]/#(?:${BLOCK_ELEMENTS.join(\"|\")})[\\\\r\\\\n\\\\t ]*>`)\n      }\n    },\n    onEnterRules: [\n      {\n        beforeText: new RegExp(\n          `[<\\\\[]#(?!(?:${EMPTY_ELEMENTS.join(\"|\")}))([a-zA-Z_]+)([^/>\\\\]]*(?!/)[>\\\\]])[^[<\\\\[]]*$`\n        ),\n        afterText: new RegExp(`^[<\\\\[]/#([a-zA-Z_]+)[\\\\r\\\\n\\\\t ]*[>\\\\]]$`),\n        action: {\n          indentAction: monaco_editor_core_exports.languages.IndentAction.IndentOutdent\n        }\n      },\n      {\n        beforeText: new RegExp(\n          `[<\\\\[]#(?!(?:${EMPTY_ELEMENTS.join(\"|\")}))([a-zA-Z_]+)([^/>\\\\]]*(?!/)[>\\\\]])[^[<\\\\[]]*$`\n        ),\n        action: { indentAction: monaco_editor_core_exports.languages.IndentAction.Indent }\n      }\n    ]\n  };\n}\nfunction createMonarchLanguage(ts, is) {\n  const id = `_${ts.id}_${is.id}`;\n  const s = (name) => name.replace(/__id__/g, id);\n  const r = (regexp) => {\n    const source = regexp.source.replace(/__id__/g, id);\n    return new RegExp(source, regexp.flags);\n  };\n  return {\n    // Settings\n    unicode: true,\n    includeLF: false,\n    start: s(\"default__id__\"),\n    ignoreCase: false,\n    defaultToken: \"invalid\",\n    tokenPostfix: `.freemarker2`,\n    brackets: [\n      { open: \"{\", close: \"}\", token: \"delimiter.curly\" },\n      { open: \"[\", close: \"]\", token: \"delimiter.square\" },\n      { open: \"(\", close: \")\", token: \"delimiter.parenthesis\" },\n      { open: \"<\", close: \">\", token: \"delimiter.angle\" }\n    ],\n    // Dynamic RegExp\n    [s(\"open__id__\")]: new RegExp(ts.open),\n    [s(\"close__id__\")]: new RegExp(ts.close),\n    [s(\"iOpen1__id__\")]: new RegExp(is.open1),\n    [s(\"iOpen2__id__\")]: new RegExp(is.open2),\n    [s(\"iClose__id__\")]: new RegExp(is.close),\n    // <#START_TAG : \"<\" | \"<#\" | \"[#\">\n    // <#END_TAG : \"</\" | \"</#\" | \"[/#\">\n    [s(\"startTag__id__\")]: r(/(@open__id__)(#)/),\n    [s(\"endTag__id__\")]: r(/(@open__id__)(\\/#)/),\n    [s(\"startOrEndTag__id__\")]: r(/(@open__id__)(\\/?#)/),\n    // <#CLOSE_TAG1 : (<BLANK>)* (\">\" | \"]\")>\n    [s(\"closeTag1__id__\")]: r(/((?:@blank)*)(@close__id__)/),\n    // <#CLOSE_TAG2 : (<BLANK>)* (\"/\")? (\">\" | \"]\")>\n    [s(\"closeTag2__id__\")]: r(/((?:@blank)*\\/?)(@close__id__)/),\n    // Static RegExp\n    // <#BLANK : \" \" | \"\\t\" | \"\\n\" | \"\\r\">\n    blank: /[ \\t\\n\\r]/,\n    // <FALSE : \"false\">\n    // <TRUE : \"true\">\n    // <IN : \"in\">\n    // <AS : \"as\">\n    // <USING : \"using\">\n    keywords: [\"false\", \"true\", \"in\", \"as\", \"using\"],\n    // Directive names that cannot have an expression parameters and cannot be self-closing\n    // E.g. <#if id==2> ... </#if>\n    directiveStartCloseTag1: /attempt|recover|sep|auto[eE]sc|no(?:autoe|AutoE)sc|compress|default|no[eE]scape|comment|no[pP]arse/,\n    // Directive names that cannot have an expression parameter and can be self-closing\n    // E.g. <#if> ... <#else>  ... </#if>\n    // E.g. <#if> ... <#else /></#if>\n    directiveStartCloseTag2: /else|break|continue|return|stop|flush|t|lt|rt|nt|nested|recurse|fallback|ftl/,\n    // Directive names that can have an expression parameter and cannot be self-closing\n    // E.g. <#if id==2> ... </#if>\n    directiveStartBlank: /if|else[iI]f|list|for[eE]ach|switch|case|assign|global|local|include|import|function|macro|transform|visit|stop|return|call|setting|output[fF]ormat|nested|recurse|escape|ftl|items/,\n    // Directive names that can have an end tag\n    // E.g. </#if>\n    directiveEndCloseTag1: /if|list|items|sep|recover|attempt|for[eE]ach|local|global|assign|function|macro|output[fF]ormat|auto[eE]sc|no(?:autoe|AutoE)sc|compress|transform|switch|escape|no[eE]scape/,\n    // <#ESCAPED_CHAR :\n    //     \"\\\\\"\n    //     (\n    //         (\"n\" | \"t\" | \"r\" | \"f\" | \"b\" | \"g\" | \"l\" | \"a\" | \"\\\\\" | \"'\" | \"\\\"\" | \"{\" | \"=\")\n    //         |\n    //         (\"x\" [\"0\"-\"9\", \"A\"-\"F\", \"a\"-\"f\"])\n    //     )\n    // >\n    // Note: While the JavaCC tokenizer rule only specifies one hex digit,\n    // FreeMarker actually interprets up to 4 hex digits.\n    escapedChar: /\\\\(?:[ntrfbgla\\\\'\"\\{=]|(?:x[0-9A-Fa-f]{1,4}))/,\n    // <#ASCII_DIGIT: [\"0\" - \"9\"]>\n    asciiDigit: /[0-9]/,\n    // <INTEGER : ([\"0\"-\"9\"])+>\n    integer: /[0-9]+/,\n    // <#NON_ESCAPED_ID_START_CHAR:\n    // [\n    // \t  // This was generated on JDK 1.8.0_20 Win64 with src/main/misc/identifierChars/IdentifierCharGenerator.java\n    //    ...\n    // ]\n    nonEscapedIdStartChar: /[\\$@-Z_a-z\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u1FFF\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183-\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3006\\u3031-\\u3035\\u303B-\\u303C\\u3040-\\u318F\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3300-\\u337F\\u3400-\\u4DB5\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8D0-\\uA8D9\\uA8F2-\\uA8F7\\uA8FB\\uA900-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF-\\uA9D9\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5-\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40-\\uFB41\\uFB43-\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/,\n    // <#ESCAPED_ID_CHAR: \"\\\\\" (\"-\" | \".\" | \":\" | \"#\")>\n    escapedIdChar: /\\\\[\\-\\.:#]/,\n    // <#ID_START_CHAR: <NON_ESCAPED_ID_START_CHAR>|<ESCAPED_ID_CHAR>>\n    idStartChar: /(?:@nonEscapedIdStartChar)|(?:@escapedIdChar)/,\n    // <ID: <ID_START_CHAR> (<ID_START_CHAR>|<ASCII_DIGIT>)*>\n    id: /(?:@idStartChar)(?:(?:@idStartChar)|(?:@asciiDigit))*/,\n    // Certain keywords / operators are allowed to index hashes\n    //\n    // Expression DotVariable(Expression exp) :\n    // {\n    // \tToken t;\n    // }\n    // {\n    // \t\t<DOT>\n    // \t\t(\n    // \t\t\tt = <ID> | t = <TIMES> | t = <DOUBLE_STAR>\n    // \t\t\t|\n    // \t\t\t(\n    // \t\t\t\tt = <LESS_THAN>\n    // \t\t\t\t|\n    // \t\t\t\tt = <LESS_THAN_EQUALS>\n    // \t\t\t\t|\n    // \t\t\t\tt = <ESCAPED_GT>\n    // \t\t\t\t|\n    // \t\t\t\tt = <ESCAPED_GTE>\n    // \t\t\t\t|\n    // \t\t\t\tt = <FALSE>\n    // \t\t\t\t|\n    // \t\t\t\tt = <TRUE>\n    // \t\t\t\t|\n    // \t\t\t\tt = <IN>\n    // \t\t\t\t|\n    // \t\t\t\tt = <AS>\n    // \t\t\t\t|\n    // \t\t\t\tt = <USING>\n    // \t\t\t)\n    // \t\t\t{\n    // \t\t\t\tif (!Character.isLetter(t.image.charAt(0))) {\n    // \t\t\t\t\tthrow new ParseException(t.image + \" is not a valid identifier.\", template, t);\n    // \t\t\t\t}\n    // \t\t\t}\n    // \t\t)\n    // \t\t{\n    // \t\t\tnotListLiteral(exp, \"hash\");\n    // \t\t\tnotStringLiteral(exp, \"hash\");\n    // \t\t\tnotBooleanLiteral(exp, \"hash\");\n    // \t\t\tDot dot = new Dot(exp, t.image);\n    // \t\t\tdot.setLocation(template, exp, t);\n    // \t\t\treturn dot;\n    // \t\t}\n    // }\n    specialHashKeys: /\\*\\*|\\*|false|true|in|as|using/,\n    // <DOUBLE_EQUALS : \"==\">\n    // <EQUALS : \"=\">\n    // <NOT_EQUALS : \"!=\">\n    // <PLUS_EQUALS : \"+=\">\n    // <MINUS_EQUALS : \"-=\">\n    // <TIMES_EQUALS : \"*=\">\n    // <DIV_EQUALS : \"/=\">\n    // <MOD_EQUALS : \"%=\">\n    // <PLUS_PLUS : \"++\">\n    // <MINUS_MINUS : \"--\">\n    // <LESS_THAN_EQUALS : \"lte\" | \"\\\\lte\" | \"<=\" | \"&lt;=\">\n    // <LESS_THAN : \"lt\" | \"\\\\lt\" | \"<\" | \"&lt;\">\n    // <ESCAPED_GTE : \"gte\" | \"\\\\gte\" | \"&gt;=\">\n    // <ESCAPED_GT: \"gt\" | \"\\\\gt\" |  \"&gt;\">\n    // <DOUBLE_STAR : \"**\">\n    // <PLUS : \"+\">\n    // <MINUS : \"-\">\n    // <TIMES : \"*\">\n    // <PERCENT : \"%\">\n    // <AND : \"&\" | \"&&\" | \"&amp;&amp;\" | \"\\\\and\" >\n    // <OR : \"|\" | \"||\">\n    // <EXCLAM : \"!\">\n    // <COMMA : \",\">\n    // <SEMICOLON : \";\">\n    // <COLON : \":\">\n    // <ELLIPSIS : \"...\">\n    // <DOT_DOT_ASTERISK : \"..*\" >\n    // <DOT_DOT_LESS : \"..<\" | \"..!\" >\n    // <DOT_DOT : \"..\">\n    // <EXISTS : \"??\">\n    // <BUILT_IN : \"?\">\n    // <LAMBDA_ARROW : \"->\" | \"-&gt;\">\n    namedSymbols: /&lt;=|&gt;=|\\\\lte|\\\\lt|&lt;|\\\\gte|\\\\gt|&gt;|&amp;&amp;|\\\\and|-&gt;|->|==|!=|\\+=|-=|\\*=|\\/=|%=|\\+\\+|--|<=|&&|\\|\\||:|\\.\\.\\.|\\.\\.\\*|\\.\\.<|\\.\\.!|\\?\\?|=|<|\\+|-|\\*|\\/|%|\\||\\.\\.|\\?|!|&|\\.|,|;/,\n    arrows: [\"->\", \"-&gt;\"],\n    delimiters: [\";\", \":\", \",\", \".\"],\n    stringOperators: [\"lte\", \"lt\", \"gte\", \"gt\"],\n    noParseTags: [\"noparse\", \"noParse\", \"comment\"],\n    tokenizer: {\n      // Parser states\n      // Plain text\n      [s(\"default__id__\")]: [\n        { include: s(\"@directive_token__id__\") },\n        { include: s(\"@interpolation_and_text_token__id__\") }\n      ],\n      // A FreeMarker expression inside a directive, e.g. <#if 2<3>\n      [s(\"fmExpression__id__.directive\")]: [\n        { include: s(\"@blank_and_expression_comment_token__id__\") },\n        { include: s(\"@directive_end_token__id__\") },\n        { include: s(\"@expression_token__id__\") }\n      ],\n      // A FreeMarker expression inside an interpolation, e.g. ${2+3}\n      [s(\"fmExpression__id__.interpolation\")]: [\n        { include: s(\"@blank_and_expression_comment_token__id__\") },\n        { include: s(\"@expression_token__id__\") },\n        { include: s(\"@greater_operators_token__id__\") }\n      ],\n      // In an expression and inside a not-yet closed parenthesis / bracket\n      [s(\"inParen__id__.plain\")]: [\n        { include: s(\"@blank_and_expression_comment_token__id__\") },\n        { include: s(\"@directive_end_token__id__\") },\n        { include: s(\"@expression_token__id__\") }\n      ],\n      [s(\"inParen__id__.gt\")]: [\n        { include: s(\"@blank_and_expression_comment_token__id__\") },\n        { include: s(\"@expression_token__id__\") },\n        { include: s(\"@greater_operators_token__id__\") }\n      ],\n      // Expression for the unified call, e.g. <@createMacro() ... >\n      [s(\"noSpaceExpression__id__\")]: [\n        { include: s(\"@no_space_expression_end_token__id__\") },\n        { include: s(\"@directive_end_token__id__\") },\n        { include: s(\"@expression_token__id__\") }\n      ],\n      // For the function of a unified call. Special case for when the\n      // expression is a simple identifier.\n      // <@join [1,2] \",\">\n      // <@null!join [1,2] \",\">\n      [s(\"unifiedCall__id__\")]: [{ include: s(\"@unified_call_token__id__\") }],\n      // For singly and doubly quoted string (that may contain interpolations)\n      [s(\"singleString__id__\")]: [{ include: s(\"@string_single_token__id__\") }],\n      [s(\"doubleString__id__\")]: [{ include: s(\"@string_double_token__id__\") }],\n      // For singly and doubly quoted string (that may not contain interpolations)\n      [s(\"rawSingleString__id__\")]: [{ include: s(\"@string_single_raw_token__id__\") }],\n      [s(\"rawDoubleString__id__\")]: [{ include: s(\"@string_double_raw_token__id__\") }],\n      // For a comment in an expression\n      // ${ 1 + <#-- comment --> 2}\n      [s(\"expressionComment__id__\")]: [{ include: s(\"@expression_comment_token__id__\") }],\n      // For <#noparse> ... </#noparse>\n      // For <#noParse> ... </#noParse>\n      // For <#comment> ... </#comment>\n      [s(\"noParse__id__\")]: [{ include: s(\"@no_parse_token__id__\") }],\n      // For <#-- ... -->\n      [s(\"terseComment__id__\")]: [{ include: s(\"@terse_comment_token__id__\") }],\n      // Common rules\n      [s(\"directive_token__id__\")]: [\n        // <ATTEMPT : <START_TAG> \"attempt\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <RECOVER : <START_TAG> \"recover\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <SEP : <START_TAG> \"sep\" <CLOSE_TAG1>>\n        // <AUTOESC : <START_TAG> \"auto\" (\"e\"|\"E\") \"sc\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 4), DEFAULT);\n        // }\n        // <NOAUTOESC : <START_TAG> \"no\" (\"autoe\"|\"AutoE\") \"sc\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n        // }\n        // <COMPRESS : <START_TAG> \"compress\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <DEFAUL : <START_TAG> \"default\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <NOESCAPE : <START_TAG> \"no\" (\"e\" | \"E\") \"scape\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n        // }\n        //\n        // <COMMENT : <START_TAG> \"comment\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, NO_PARSE); noparseTag = \"comment\";\n        // }\n        // <NOPARSE: <START_TAG> \"no\" (\"p\" | \"P\") \"arse\" <CLOSE_TAG1>> {\n        //     int tagNamingConvention = getTagNamingConvention(matchedToken, 2);\n        //     handleTagSyntaxAndSwitch(matchedToken, tagNamingConvention, NO_PARSE);\n        //     noparseTag = tagNamingConvention == Configuration.CAMEL_CASE_NAMING_CONVENTION ? \"noParse\" : \"noparse\";\n        // }\n        [\n          r(/(?:@startTag__id__)(@directiveStartCloseTag1)(?:@closeTag1__id__)/),\n          ts.id === \"auto\" ? {\n            cases: {\n              \"$1==<\": { token: \"@rematch\", switchTo: `@default_angle_${is.id}` },\n              \"$1==[\": { token: \"@rematch\", switchTo: `@default_bracket_${is.id}` }\n            }\n          } : [\n            { token: \"@brackets.directive\" },\n            { token: \"delimiter.directive\" },\n            {\n              cases: {\n                \"@noParseTags\": { token: \"tag\", next: s(\"@noParse__id__.$3\") },\n                \"@default\": { token: \"tag\" }\n              }\n            },\n            { token: \"delimiter.directive\" },\n            { token: \"@brackets.directive\" }\n          ]\n        ],\n        // <ELSE : <START_TAG> \"else\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <BREAK : <START_TAG> \"break\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <CONTINUE : <START_TAG> \"continue\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <SIMPLE_RETURN : <START_TAG> \"return\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <HALT : <START_TAG> \"stop\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <FLUSH : <START_TAG> \"flush\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <TRIM : <START_TAG> \"t\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <LTRIM : <START_TAG> \"lt\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <RTRIM : <START_TAG> \"rt\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <NOTRIM : <START_TAG> \"nt\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <SIMPLE_NESTED : <START_TAG> \"nested\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <SIMPLE_RECURSE : <START_TAG> \"recurse\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <FALLBACK : <START_TAG> \"fallback\" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <TRIVIAL_FTL_HEADER : (\"<#ftl\" | \"[#ftl\") (\"/\")? (\">\" | \"]\")> { ftlHeader(matchedToken); }\n        [\n          r(/(?:@startTag__id__)(@directiveStartCloseTag2)(?:@closeTag2__id__)/),\n          ts.id === \"auto\" ? {\n            cases: {\n              \"$1==<\": { token: \"@rematch\", switchTo: `@default_angle_${is.id}` },\n              \"$1==[\": { token: \"@rematch\", switchTo: `@default_bracket_${is.id}` }\n            }\n          } : [\n            { token: \"@brackets.directive\" },\n            { token: \"delimiter.directive\" },\n            { token: \"tag\" },\n            { token: \"delimiter.directive\" },\n            { token: \"@brackets.directive\" }\n          ]\n        ],\n        // <IF : <START_TAG> \"if\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <ELSE_IF : <START_TAG> \"else\" (\"i\" | \"I\") \"f\" <BLANK>> {\n        // \thandleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 4), FM_EXPRESSION);\n        // }\n        // <LIST : <START_TAG> \"list\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <FOREACH : <START_TAG> \"for\" (\"e\" | \"E\") \"ach\" <BLANK>> {\n        //    handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 3), FM_EXPRESSION);\n        // }\n        // <SWITCH : <START_TAG> \"switch\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <CASE : <START_TAG> \"case\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <ASSIGN : <START_TAG> \"assign\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <GLOBALASSIGN : <START_TAG> \"global\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <LOCALASSIGN : <START_TAG> \"local\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <_INCLUDE : <START_TAG> \"include\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <IMPORT : <START_TAG> \"import\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <FUNCTION : <START_TAG> \"function\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <MACRO : <START_TAG> \"macro\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <TRANSFORM : <START_TAG> \"transform\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <VISIT : <START_TAG> \"visit\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <STOP : <START_TAG> \"stop\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <RETURN : <START_TAG> \"return\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <CALL : <START_TAG> \"call\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <SETTING : <START_TAG> \"setting\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <OUTPUTFORMAT : <START_TAG> \"output\" (\"f\"|\"F\") \"ormat\" <BLANK>> {\n        //    handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 6), FM_EXPRESSION);\n        // }\n        // <NESTED : <START_TAG> \"nested\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <RECURSE : <START_TAG> \"recurse\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        // <ESCAPE : <START_TAG> \"escape\" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        //\n        // Note: FreeMarker grammar appears to treat the FTL header as a special case,\n        // in order to remove new lines after the header (?), but since we only need\n        // to tokenize for highlighting, we can include this directive here.\n        // <FTL_HEADER : (\"<#ftl\" | \"[#ftl\") <BLANK>> { ftlHeader(matchedToken); }\n        //\n        // Note: FreeMarker grammar appears to treat the items directive as a special case for\n        // the AST parsing process, but since we only need to tokenize, we can include this\n        // directive here.\n        // <ITEMS : <START_TAG> \"items\" (<BLANK>)+ <AS> <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }\n        [\n          r(/(?:@startTag__id__)(@directiveStartBlank)(@blank)/),\n          ts.id === \"auto\" ? {\n            cases: {\n              \"$1==<\": { token: \"@rematch\", switchTo: `@default_angle_${is.id}` },\n              \"$1==[\": { token: \"@rematch\", switchTo: `@default_bracket_${is.id}` }\n            }\n          } : [\n            { token: \"@brackets.directive\" },\n            { token: \"delimiter.directive\" },\n            { token: \"tag\" },\n            { token: \"\", next: s(\"@fmExpression__id__.directive\") }\n          ]\n        ],\n        // <END_IF : <END_TAG> \"if\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_LIST : <END_TAG> \"list\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_SEP : <END_TAG> \"sep\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_RECOVER : <END_TAG> \"recover\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_ATTEMPT : <END_TAG> \"attempt\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_FOREACH : <END_TAG> \"for\" (\"e\" | \"E\") \"ach\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 3), DEFAULT);\n        // }\n        // <END_LOCAL : <END_TAG> \"local\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_GLOBAL : <END_TAG> \"global\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_ASSIGN : <END_TAG> \"assign\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_FUNCTION : <END_TAG> \"function\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_MACRO : <END_TAG> \"macro\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_OUTPUTFORMAT : <END_TAG> \"output\" (\"f\" | \"F\") \"ormat\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 6), DEFAULT);\n        // }\n        // <END_AUTOESC : <END_TAG> \"auto\" (\"e\" | \"E\") \"sc\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 4), DEFAULT);\n        // }\n        // <END_NOAUTOESC : <END_TAG> \"no\" (\"autoe\"|\"AutoE\") \"sc\" <CLOSE_TAG1>> {\n        //   handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n        // }\n        // <END_COMPRESS : <END_TAG> \"compress\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_TRANSFORM : <END_TAG> \"transform\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_SWITCH : <END_TAG> \"switch\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_ESCAPE : <END_TAG> \"escape\" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }\n        // <END_NOESCAPE : <END_TAG> \"no\" (\"e\" | \"E\") \"scape\" <CLOSE_TAG1>> {\n        //     handleTagSyntaxAndSwitch(matchedToken, getTagNamingConvention(matchedToken, 2), DEFAULT);\n        // }\n        [\n          r(/(?:@endTag__id__)(@directiveEndCloseTag1)(?:@closeTag1__id__)/),\n          ts.id === \"auto\" ? {\n            cases: {\n              \"$1==<\": { token: \"@rematch\", switchTo: `@default_angle_${is.id}` },\n              \"$1==[\": { token: \"@rematch\", switchTo: `@default_bracket_${is.id}` }\n            }\n          } : [\n            { token: \"@brackets.directive\" },\n            { token: \"delimiter.directive\" },\n            { token: \"tag\" },\n            { token: \"delimiter.directive\" },\n            { token: \"@brackets.directive\" }\n          ]\n        ],\n        // <UNIFIED_CALL : \"<@\" | \"[@\" > { unifiedCall(matchedToken); }\n        [\n          r(/(@open__id__)(@)/),\n          ts.id === \"auto\" ? {\n            cases: {\n              \"$1==<\": { token: \"@rematch\", switchTo: `@default_angle_${is.id}` },\n              \"$1==[\": { token: \"@rematch\", switchTo: `@default_bracket_${is.id}` }\n            }\n          } : [\n            { token: \"@brackets.directive\" },\n            { token: \"delimiter.directive\", next: s(\"@unifiedCall__id__\") }\n          ]\n        ],\n        // <UNIFIED_CALL_END : (\"<\" | \"[\") \"/@\" ((<ID>) (\".\"<ID>)*)? <CLOSE_TAG1>> { unifiedCallEnd(matchedToken); }\n        [\n          r(/(@open__id__)(\\/@)((?:(?:@id)(?:\\.(?:@id))*)?)(?:@closeTag1__id__)/),\n          [\n            { token: \"@brackets.directive\" },\n            { token: \"delimiter.directive\" },\n            { token: \"tag\" },\n            { token: \"delimiter.directive\" },\n            { token: \"@brackets.directive\" }\n          ]\n        ],\n        // <TERSE_COMMENT : (\"<\" | \"[\") \"#--\" > { noparseTag = \"-->\"; handleTagSyntaxAndSwitch(matchedToken, NO_PARSE); }\n        [\n          r(/(@open__id__)#--/),\n          ts.id === \"auto\" ? {\n            cases: {\n              \"$1==<\": { token: \"@rematch\", switchTo: `@default_angle_${is.id}` },\n              \"$1==[\": { token: \"@rematch\", switchTo: `@default_bracket_${is.id}` }\n            }\n          } : { token: \"comment\", next: s(\"@terseComment__id__\") }\n        ],\n        // <UNKNOWN_DIRECTIVE : (\"[#\" | \"[/#\" | \"<#\" | \"</#\") ([\"a\"-\"z\", \"A\"-\"Z\", \"_\"])+>\n        [\n          r(/(?:@startOrEndTag__id__)([a-zA-Z_]+)/),\n          ts.id === \"auto\" ? {\n            cases: {\n              \"$1==<\": { token: \"@rematch\", switchTo: `@default_angle_${is.id}` },\n              \"$1==[\": { token: \"@rematch\", switchTo: `@default_bracket_${is.id}` }\n            }\n          } : [\n            { token: \"@brackets.directive\" },\n            { token: \"delimiter.directive\" },\n            { token: \"tag.invalid\", next: s(\"@fmExpression__id__.directive\") }\n          ]\n        ]\n      ],\n      // <DEFAULT, NO_DIRECTIVE> TOKEN :\n      [s(\"interpolation_and_text_token__id__\")]: [\n        // <DOLLAR_INTERPOLATION_OPENING : \"${\"> { startInterpolation(matchedToken); }\n        // <SQUARE_BRACKET_INTERPOLATION_OPENING : \"[=\"> { startInterpolation(matchedToken); }\n        [\n          r(/(@iOpen1__id__)(@iOpen2__id__)/),\n          [\n            { token: is.id === \"bracket\" ? \"@brackets.interpolation\" : \"delimiter.interpolation\" },\n            {\n              token: is.id === \"bracket\" ? \"delimiter.interpolation\" : \"@brackets.interpolation\",\n              next: s(\"@fmExpression__id__.interpolation\")\n            }\n          ]\n        ],\n        // <STATIC_TEXT_FALSE_ALARM : \"$\" | \"#\" | \"<\" | \"[\" | \"{\"> // to handle a lone dollar sign or \"<\" or \"# or <@ with whitespace after\"\n        // <STATIC_TEXT_WS : (\"\\n\" | \"\\r\" | \"\\t\" | \" \")+>\n        // <STATIC_TEXT_NON_WS : (~[\"$\", \"<\", \"#\", \"[\", \"{\", \"\\n\", \"\\r\", \"\\t\", \" \"])+>\n        [/[\\$#<\\[\\{]|(?:@blank)+|[^\\$<#\\[\\{\\n\\r\\t ]+/, { token: \"source\" }]\n      ],\n      // <STRING_LITERAL :\n      // \t(\n      // \t\t\"\\\"\"\n      // \t\t((~[\"\\\"\", \"\\\\\"]) | <ESCAPED_CHAR>)*\n      // \t\t\"\\\"\"\n      // \t)\n      // \t|\n      // \t(\n      // \t\t\"'\"\n      // \t\t((~[\"'\", \"\\\\\"]) | <ESCAPED_CHAR>)*\n      // \t\t\"'\"\n      // \t)\n      // >\n      [s(\"string_single_token__id__\")]: [\n        [/[^'\\\\]/, { token: \"string\" }],\n        [/@escapedChar/, { token: \"string.escape\" }],\n        [/'/, { token: \"string\", next: \"@pop\" }]\n      ],\n      [s(\"string_double_token__id__\")]: [\n        [/[^\"\\\\]/, { token: \"string\" }],\n        [/@escapedChar/, { token: \"string.escape\" }],\n        [/\"/, { token: \"string\", next: \"@pop\" }]\n      ],\n      // <RAW_STRING : \"r\" ((\"\\\"\" (~[\"\\\"\"])* \"\\\"\") | (\"'\" (~[\"'\"])* \"'\"))>\n      [s(\"string_single_raw_token__id__\")]: [\n        [/[^']+/, { token: \"string.raw\" }],\n        [/'/, { token: \"string.raw\", next: \"@pop\" }]\n      ],\n      [s(\"string_double_raw_token__id__\")]: [\n        [/[^\"]+/, { token: \"string.raw\" }],\n        [/\"/, { token: \"string.raw\", next: \"@pop\" }]\n      ],\n      // <FM_EXPRESSION, IN_PAREN, NO_SPACE_EXPRESSION, NAMED_PARAMETER_EXPRESSION> TOKEN :\n      [s(\"expression_token__id__\")]: [\n        // Strings\n        [\n          /(r?)(['\"])/,\n          {\n            cases: {\n              \"r'\": [\n                { token: \"keyword\" },\n                { token: \"string.raw\", next: s(\"@rawSingleString__id__\") }\n              ],\n              'r\"': [\n                { token: \"keyword\" },\n                { token: \"string.raw\", next: s(\"@rawDoubleString__id__\") }\n              ],\n              \"'\": [{ token: \"source\" }, { token: \"string\", next: s(\"@singleString__id__\") }],\n              '\"': [{ token: \"source\" }, { token: \"string\", next: s(\"@doubleString__id__\") }]\n            }\n          }\n        ],\n        // Numbers\n        // <INTEGER : ([\"0\"-\"9\"])+>\n        // <DECIMAL : <INTEGER> \".\" <INTEGER>>\n        [\n          /(?:@integer)(?:\\.(?:@integer))?/,\n          {\n            cases: {\n              \"(?:@integer)\": { token: \"number\" },\n              \"@default\": { token: \"number.float\" }\n            }\n          }\n        ],\n        // Special hash keys that must not be treated as identifiers\n        // after a period, e.g. a.** is accessing the key \"**\" of a\n        [\n          /(\\.)(@blank*)(@specialHashKeys)/,\n          [{ token: \"delimiter\" }, { token: \"\" }, { token: \"identifier\" }]\n        ],\n        // Symbols / operators\n        [\n          /(?:@namedSymbols)/,\n          {\n            cases: {\n              \"@arrows\": { token: \"meta.arrow\" },\n              \"@delimiters\": { token: \"delimiter\" },\n              \"@default\": { token: \"operators\" }\n            }\n          }\n        ],\n        // Identifiers\n        [\n          /@id/,\n          {\n            cases: {\n              \"@keywords\": { token: \"keyword.$0\" },\n              \"@stringOperators\": { token: \"operators\" },\n              \"@default\": { token: \"identifier\" }\n            }\n          }\n        ],\n        // <OPEN_BRACKET : \"[\">\n        // <CLOSE_BRACKET : \"]\">\n        // <OPEN_PAREN : \"(\">\n        // <CLOSE_PAREN : \")\">\n        // <OPENING_CURLY_BRACKET : \"{\">\n        // <CLOSING_CURLY_BRACKET : \"}\">\n        [\n          /[\\[\\]\\(\\)\\{\\}]/,\n          {\n            cases: {\n              \"\\\\[\": {\n                cases: {\n                  \"$S2==gt\": { token: \"@brackets\", next: s(\"@inParen__id__.gt\") },\n                  \"@default\": { token: \"@brackets\", next: s(\"@inParen__id__.plain\") }\n                }\n              },\n              \"\\\\]\": {\n                cases: {\n                  ...is.id === \"bracket\" ? {\n                    \"$S2==interpolation\": { token: \"@brackets.interpolation\", next: \"@popall\" }\n                  } : {},\n                  // This cannot happen while in auto mode, since this applies only to an\n                  // fmExpression inside a directive. But once we encounter the start of a\n                  // directive, we can establish the tag syntax mode.\n                  ...ts.id === \"bracket\" ? {\n                    \"$S2==directive\": { token: \"@brackets.directive\", next: \"@popall\" }\n                  } : {},\n                  // Ignore mismatched paren\n                  [s(\"$S1==inParen__id__\")]: { token: \"@brackets\", next: \"@pop\" },\n                  \"@default\": { token: \"@brackets\" }\n                }\n              },\n              \"\\\\(\": { token: \"@brackets\", next: s(\"@inParen__id__.gt\") },\n              \"\\\\)\": {\n                cases: {\n                  [s(\"$S1==inParen__id__\")]: { token: \"@brackets\", next: \"@pop\" },\n                  \"@default\": { token: \"@brackets\" }\n                }\n              },\n              \"\\\\{\": {\n                cases: {\n                  \"$S2==gt\": { token: \"@brackets\", next: s(\"@inParen__id__.gt\") },\n                  \"@default\": { token: \"@brackets\", next: s(\"@inParen__id__.plain\") }\n                }\n              },\n              \"\\\\}\": {\n                cases: {\n                  ...is.id === \"bracket\" ? {} : {\n                    \"$S2==interpolation\": { token: \"@brackets.interpolation\", next: \"@popall\" }\n                  },\n                  // Ignore mismatched paren\n                  [s(\"$S1==inParen__id__\")]: { token: \"@brackets\", next: \"@pop\" },\n                  \"@default\": { token: \"@brackets\" }\n                }\n              }\n            }\n          }\n        ],\n        // <OPEN_MISPLACED_INTERPOLATION : \"${\" | \"#{\" | \"[=\">\n        [/\\$\\{/, { token: \"delimiter.invalid\" }]\n      ],\n      // <FM_EXPRESSION, IN_PAREN, NAMED_PARAMETER_EXPRESSION> SKIP :\n      [s(\"blank_and_expression_comment_token__id__\")]: [\n        // < ( \" \" | \"\\t\" | \"\\n\" | \"\\r\" )+ >\n        [/(?:@blank)+/, { token: \"\" }],\n        // < (\"<\" | \"[\") (\"#\" | \"!\") \"--\"> : EXPRESSION_COMMENT\n        [/[<\\[][#!]--/, { token: \"comment\", next: s(\"@expressionComment__id__\") }]\n      ],\n      // <FM_EXPRESSION, NO_SPACE_EXPRESSION, NAMED_PARAMETER_EXPRESSION> TOKEN :\n      [s(\"directive_end_token__id__\")]: [\n        // <DIRECTIVE_END : \">\">\n        // {\n        //     if (inFTLHeader) {\n        //         eatNewline();\n        //         inFTLHeader = false;\n        //     }\n        //     if (squBracTagSyntax || postInterpolationLexState != -1 /* We are in an interpolation */) {\n        //         matchedToken.kind = NATURAL_GT;\n        //     } else {\n        //         SwitchTo(DEFAULT);\n        //     }\n        // }\n        // This cannot happen while in auto mode, since this applies only to an\n        // fmExpression inside a directive. But once we encounter the start of a\n        // directive, we can establish the tag syntax mode.\n        [\n          />/,\n          ts.id === \"bracket\" ? { token: \"operators\" } : { token: \"@brackets.directive\", next: \"@popall\" }\n        ],\n        // <EMPTY_DIRECTIVE_END : \"/>\" | \"/]\">\n        // It is a syntax error to end a tag with the wrong close token\n        // Let's indicate that to the user by not closing the tag\n        [\n          r(/(\\/)(@close__id__)/),\n          [{ token: \"delimiter.directive\" }, { token: \"@brackets.directive\", next: \"@popall\" }]\n        ]\n      ],\n      // <IN_PAREN> TOKEN :\n      [s(\"greater_operators_token__id__\")]: [\n        // <NATURAL_GT : \">\">\n        [/>/, { token: \"operators\" }],\n        // <NATURAL_GTE : \">=\">\n        [/>=/, { token: \"operators\" }]\n      ],\n      // <NO_SPACE_EXPRESSION> TOKEN :\n      [s(\"no_space_expression_end_token__id__\")]: [\n        // <TERMINATING_WHITESPACE :  ([\"\\n\", \"\\r\", \"\\t\", \" \"])+> : FM_EXPRESSION\n        [/(?:@blank)+/, { token: \"\", switchTo: s(\"@fmExpression__id__.directive\") }]\n      ],\n      [s(\"unified_call_token__id__\")]: [\n        // Special case for a call where the expression is just an ID\n        // <UNIFIED_CALL> <ID> <BLANK>+\n        [\n          /(@id)((?:@blank)+)/,\n          [{ token: \"tag\" }, { token: \"\", next: s(\"@fmExpression__id__.directive\") }]\n        ],\n        [\n          r(/(@id)(\\/?)(@close__id__)/),\n          [\n            { token: \"tag\" },\n            { token: \"delimiter.directive\" },\n            { token: \"@brackets.directive\", next: \"@popall\" }\n          ]\n        ],\n        [/./, { token: \"@rematch\", next: s(\"@noSpaceExpression__id__\") }]\n      ],\n      // <NO_PARSE> TOKEN :\n      [s(\"no_parse_token__id__\")]: [\n        // <MAYBE_END :\n        // \t (\"<\" | \"[\")\n        // \t \"/\"\n        // \t (\"#\")?\n        // \t ([\"a\"-\"z\", \"A\"-\"Z\"])+\n        // \t ( \" \" | \"\\t\" | \"\\n\" | \"\\r\" )*\n        // \t (\">\" | \"]\")\n        // >\n        [\n          r(/(@open__id__)(\\/#?)([a-zA-Z]+)((?:@blank)*)(@close__id__)/),\n          {\n            cases: {\n              \"$S2==$3\": [\n                { token: \"@brackets.directive\" },\n                { token: \"delimiter.directive\" },\n                { token: \"tag\" },\n                { token: \"\" },\n                { token: \"@brackets.directive\", next: \"@popall\" }\n              ],\n              \"$S2==comment\": [\n                { token: \"comment\" },\n                { token: \"comment\" },\n                { token: \"comment\" },\n                { token: \"comment\" },\n                { token: \"comment\" }\n              ],\n              \"@default\": [\n                { token: \"source\" },\n                { token: \"source\" },\n                { token: \"source\" },\n                { token: \"source\" },\n                { token: \"source\" }\n              ]\n            }\n          }\n        ],\n        // <KEEP_GOING : (~[\"<\", \"[\", \"-\"])+>\n        // <LONE_LESS_THAN_OR_DASH : [\"<\", \"[\", \"-\"]>\n        [\n          /[^<\\[\\-]+|[<\\[\\-]/,\n          {\n            cases: {\n              \"$S2==comment\": { token: \"comment\" },\n              \"@default\": { token: \"source\" }\n            }\n          }\n        ]\n      ],\n      // <EXPRESSION_COMMENT> SKIP:\n      [s(\"expression_comment_token__id__\")]: [\n        // < \"-->\" | \"--]\">\n        [\n          /--[>\\]]/,\n          {\n            token: \"comment\",\n            next: \"@pop\"\n          }\n        ],\n        // < (~[\"-\", \">\", \"]\"])+ >\n        // < \">\">\n        // < \"]\">\n        // < \"-\">\n        [/[^\\->\\]]+|[>\\]\\-]/, { token: \"comment\" }]\n      ],\n      [s(\"terse_comment_token__id__\")]: [\n        //  <TERSE_COMMENT_END : \"-->\" | \"--]\">\n        [r(/--(?:@close__id__)/), { token: \"comment\", next: \"@popall\" }],\n        // <KEEP_GOING : (~[\"<\", \"[\", \"-\"])+>\n        // <LONE_LESS_THAN_OR_DASH : [\"<\", \"[\", \"-\"]>\n        [/[^<\\[\\-]+|[<\\[\\-]/, { token: \"comment\" }]\n      ]\n    }\n  };\n}\nfunction createMonarchLanguageAuto(is) {\n  const angle = createMonarchLanguage(TagSyntaxAngle, is);\n  const bracket = createMonarchLanguage(TagSyntaxBracket, is);\n  const auto = createMonarchLanguage(TagSyntaxAuto, is);\n  return {\n    // Angle and bracket syntax mode\n    // We switch to one of these once we have determined the mode\n    ...angle,\n    ...bracket,\n    ...auto,\n    // Settings\n    unicode: true,\n    includeLF: false,\n    start: `default_auto_${is.id}`,\n    ignoreCase: false,\n    defaultToken: \"invalid\",\n    tokenPostfix: `.freemarker2`,\n    brackets: [\n      { open: \"{\", close: \"}\", token: \"delimiter.curly\" },\n      { open: \"[\", close: \"]\", token: \"delimiter.square\" },\n      { open: \"(\", close: \")\", token: \"delimiter.parenthesis\" },\n      { open: \"<\", close: \">\", token: \"delimiter.angle\" }\n    ],\n    tokenizer: {\n      ...angle.tokenizer,\n      ...bracket.tokenizer,\n      ...auto.tokenizer\n    }\n  };\n}\nvar TagAngleInterpolationDollar = {\n  conf: createLangConfiguration(TagSyntaxAngle),\n  language: createMonarchLanguage(TagSyntaxAngle, InterpolationSyntaxDollar)\n};\nvar TagBracketInterpolationDollar = {\n  conf: createLangConfiguration(TagSyntaxBracket),\n  language: createMonarchLanguage(TagSyntaxBracket, InterpolationSyntaxDollar)\n};\nvar TagAngleInterpolationBracket = {\n  conf: createLangConfiguration(TagSyntaxAngle),\n  language: createMonarchLanguage(TagSyntaxAngle, InterpolationSyntaxBracket)\n};\nvar TagBracketInterpolationBracket = {\n  conf: createLangConfiguration(TagSyntaxBracket),\n  language: createMonarchLanguage(TagSyntaxBracket, InterpolationSyntaxBracket)\n};\nvar TagAutoInterpolationDollar = {\n  conf: createLangConfigurationAuto(),\n  language: createMonarchLanguageAuto(InterpolationSyntaxDollar)\n};\nvar TagAutoInterpolationBracket = {\n  conf: createLangConfigurationAuto(),\n  language: createMonarchLanguageAuto(InterpolationSyntaxBracket)\n};\nexport {\n  TagAngleInterpolationBracket,\n  TagAngleInterpolationDollar,\n  TagAutoInterpolationBracket,\n  TagAutoInterpolationDollar,\n  TagBracketInterpolationBracket,\n  TagBracketInterpolationDollar\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}