{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _createForOfIteratorHelper from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../common/range.js';\n/**\n * Returns the intersection between a ranged group and a range.\n * Returns `[]` if the intersection is empty.\n */\nexport function groupIntersect(range, groups) {\n  var result = [];\n  var _iterator = _createForOfIteratorHelper(groups),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var r = _step.value;\n      if (range.start >= r.range.end) {\n        continue;\n      }\n      if (range.end < r.range.start) {\n        break;\n      }\n      var intersection = Range.intersect(range, r.range);\n      if (Range.isEmpty(intersection)) {\n        continue;\n      }\n      result.push({\n        range: intersection,\n        size: r.size\n      });\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return result;\n}\n/**\n * Shifts a range by that `much`.\n */\nexport function shift(_ref, much) {\n  var start = _ref.start,\n    end = _ref.end;\n  return {\n    start: start + much,\n    end: end + much\n  };\n}\n/**\n * Consolidates a collection of ranged groups.\n *\n * Consolidation is the process of merging consecutive ranged groups\n * that share the same `size`.\n */\nexport function consolidate(groups) {\n  var result = [];\n  var previousGroup = null;\n  var _iterator2 = _createForOfIteratorHelper(groups),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var group = _step2.value;\n      var start = group.range.start;\n      var end = group.range.end;\n      var size = group.size;\n      if (previousGroup && size === previousGroup.size) {\n        previousGroup.range.end = end;\n        continue;\n      }\n      previousGroup = {\n        range: {\n          start: start,\n          end: end\n        },\n        size: size\n      };\n      result.push(previousGroup);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return result;\n}\n/**\n * Concatenates several collections of ranged groups into a single\n * collection.\n */\nfunction concat() {\n  for (var _len = arguments.length, groups = new Array(_len), _key = 0; _key < _len; _key++) {\n    groups[_key] = arguments[_key];\n  }\n  return consolidate(groups.reduce(function (r, g) {\n    return r.concat(g);\n  }, []));\n}\nexport var RangeMap = /*#__PURE__*/function () {\n  function RangeMap(topPadding) {\n    _classCallCheck(this, RangeMap);\n    this.groups = [];\n    this._size = 0;\n    this._paddingTop = 0;\n    this._paddingTop = topPadding !== null && topPadding !== void 0 ? topPadding : 0;\n    this._size = this._paddingTop;\n  }\n  return _createClass(RangeMap, [{\n    key: \"paddingTop\",\n    get: function get() {\n      return this._paddingTop;\n    },\n    set: function set(paddingTop) {\n      this._size = this._size + paddingTop - this._paddingTop;\n      this._paddingTop = paddingTop;\n    }\n  }, {\n    key: \"splice\",\n    value: function splice(index, deleteCount) {\n      var items = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var diff = items.length - deleteCount;\n      var before = groupIntersect({\n        start: 0,\n        end: index\n      }, this.groups);\n      var after = groupIntersect({\n        start: index + deleteCount,\n        end: Number.POSITIVE_INFINITY\n      }, this.groups).map(function (g) {\n        return {\n          range: shift(g.range, diff),\n          size: g.size\n        };\n      });\n      var middle = items.map(function (item, i) {\n        return {\n          range: {\n            start: index + i,\n            end: index + i + 1\n          },\n          size: item.size\n        };\n      });\n      this.groups = concat(before, middle, after);\n      this._size = this._paddingTop + this.groups.reduce(function (t, g) {\n        return t + g.size * (g.range.end - g.range.start);\n      }, 0);\n    }\n    /**\n     * Returns the number of items in the range map.\n     */\n  }, {\n    key: \"count\",\n    get: function get() {\n      var len = this.groups.length;\n      if (!len) {\n        return 0;\n      }\n      return this.groups[len - 1].range.end;\n    }\n    /**\n     * Returns the sum of the sizes of all items in the range map.\n     */\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._size;\n    }\n    /**\n     * Returns the index of the item at the given position.\n     */\n  }, {\n    key: \"indexAt\",\n    value: function indexAt(position) {\n      if (position < 0) {\n        return -1;\n      }\n      if (position < this._paddingTop) {\n        return 0;\n      }\n      var index = 0;\n      var size = this._paddingTop;\n      var _iterator3 = _createForOfIteratorHelper(this.groups),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var group = _step3.value;\n          var count = group.range.end - group.range.start;\n          var newSize = size + count * group.size;\n          if (position < newSize) {\n            return index + Math.floor((position - size) / group.size);\n          }\n          index += count;\n          size = newSize;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return index;\n    }\n    /**\n     * Returns the index of the item right after the item at the\n     * index of the given position.\n     */\n  }, {\n    key: \"indexAfter\",\n    value: function indexAfter(position) {\n      return Math.min(this.indexAt(position) + 1, this.count);\n    }\n    /**\n     * Returns the start position of the item at the given index.\n     */\n  }, {\n    key: \"positionAt\",\n    value: function positionAt(index) {\n      if (index < 0) {\n        return -1;\n      }\n      var position = 0;\n      var count = 0;\n      var _iterator4 = _createForOfIteratorHelper(this.groups),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var group = _step4.value;\n          var groupCount = group.range.end - group.range.start;\n          var newCount = count + groupCount;\n          if (index < newCount) {\n            return this._paddingTop + position + (index - count) * group.size;\n          }\n          position += groupCount * group.size;\n          count = newCount;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      return -1;\n    }\n  }]);\n}();","map":{"version":3,"names":["Range","groupIntersect","range","groups","result","_iterator","_createForOfIteratorHelper","_step","s","n","done","r","value","start","end","intersection","intersect","isEmpty","push","size","err","e","f","shift","_ref","much","consolidate","previousGroup","_iterator2","_step2","group","concat","_len","arguments","length","Array","_key","reduce","g","RangeMap","topPadding","_classCallCheck","_size","_paddingTop","_createClass","key","get","set","paddingTop","splice","index","deleteCount","items","undefined","diff","before","after","Number","POSITIVE_INFINITY","map","middle","item","i","t","len","indexAt","position","_iterator3","_step3","count","newSize","Math","floor","indexAfter","min","positionAt","_iterator4","_step4","groupCount","newCount"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/base/browser/ui/list/rangeMap.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../common/range.js';\n/**\n * Returns the intersection between a ranged group and a range.\n * Returns `[]` if the intersection is empty.\n */\nexport function groupIntersect(range, groups) {\n    const result = [];\n    for (const r of groups) {\n        if (range.start >= r.range.end) {\n            continue;\n        }\n        if (range.end < r.range.start) {\n            break;\n        }\n        const intersection = Range.intersect(range, r.range);\n        if (Range.isEmpty(intersection)) {\n            continue;\n        }\n        result.push({\n            range: intersection,\n            size: r.size\n        });\n    }\n    return result;\n}\n/**\n * Shifts a range by that `much`.\n */\nexport function shift({ start, end }, much) {\n    return { start: start + much, end: end + much };\n}\n/**\n * Consolidates a collection of ranged groups.\n *\n * Consolidation is the process of merging consecutive ranged groups\n * that share the same `size`.\n */\nexport function consolidate(groups) {\n    const result = [];\n    let previousGroup = null;\n    for (const group of groups) {\n        const start = group.range.start;\n        const end = group.range.end;\n        const size = group.size;\n        if (previousGroup && size === previousGroup.size) {\n            previousGroup.range.end = end;\n            continue;\n        }\n        previousGroup = { range: { start, end }, size };\n        result.push(previousGroup);\n    }\n    return result;\n}\n/**\n * Concatenates several collections of ranged groups into a single\n * collection.\n */\nfunction concat(...groups) {\n    return consolidate(groups.reduce((r, g) => r.concat(g), []));\n}\nexport class RangeMap {\n    get paddingTop() {\n        return this._paddingTop;\n    }\n    set paddingTop(paddingTop) {\n        this._size = this._size + paddingTop - this._paddingTop;\n        this._paddingTop = paddingTop;\n    }\n    constructor(topPadding) {\n        this.groups = [];\n        this._size = 0;\n        this._paddingTop = 0;\n        this._paddingTop = topPadding !== null && topPadding !== void 0 ? topPadding : 0;\n        this._size = this._paddingTop;\n    }\n    splice(index, deleteCount, items = []) {\n        const diff = items.length - deleteCount;\n        const before = groupIntersect({ start: 0, end: index }, this.groups);\n        const after = groupIntersect({ start: index + deleteCount, end: Number.POSITIVE_INFINITY }, this.groups)\n            .map(g => ({ range: shift(g.range, diff), size: g.size }));\n        const middle = items.map((item, i) => ({\n            range: { start: index + i, end: index + i + 1 },\n            size: item.size\n        }));\n        this.groups = concat(before, middle, after);\n        this._size = this._paddingTop + this.groups.reduce((t, g) => t + (g.size * (g.range.end - g.range.start)), 0);\n    }\n    /**\n     * Returns the number of items in the range map.\n     */\n    get count() {\n        const len = this.groups.length;\n        if (!len) {\n            return 0;\n        }\n        return this.groups[len - 1].range.end;\n    }\n    /**\n     * Returns the sum of the sizes of all items in the range map.\n     */\n    get size() {\n        return this._size;\n    }\n    /**\n     * Returns the index of the item at the given position.\n     */\n    indexAt(position) {\n        if (position < 0) {\n            return -1;\n        }\n        if (position < this._paddingTop) {\n            return 0;\n        }\n        let index = 0;\n        let size = this._paddingTop;\n        for (const group of this.groups) {\n            const count = group.range.end - group.range.start;\n            const newSize = size + (count * group.size);\n            if (position < newSize) {\n                return index + Math.floor((position - size) / group.size);\n            }\n            index += count;\n            size = newSize;\n        }\n        return index;\n    }\n    /**\n     * Returns the index of the item right after the item at the\n     * index of the given position.\n     */\n    indexAfter(position) {\n        return Math.min(this.indexAt(position) + 1, this.count);\n    }\n    /**\n     * Returns the start position of the item at the given index.\n     */\n    positionAt(index) {\n        if (index < 0) {\n            return -1;\n        }\n        let position = 0;\n        let count = 0;\n        for (const group of this.groups) {\n            const groupCount = group.range.end - group.range.start;\n            const newCount = count + groupCount;\n            if (index < newCount) {\n                return this._paddingTop + position + ((index - count) * group.size);\n            }\n            position += groupCount * group.size;\n            count = newCount;\n        }\n        return -1;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}