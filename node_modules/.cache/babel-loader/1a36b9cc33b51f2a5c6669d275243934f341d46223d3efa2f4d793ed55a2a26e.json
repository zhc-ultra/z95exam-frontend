{"ast":null,"code":"import _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport var Token = /*#__PURE__*/_createClass(function Token(length, kind,\n/**\n * If this token is an opening bracket, this is the id of the opening bracket.\n * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n * Otherwise, it is -1.\n */\nbracketId,\n/**\n * If this token is an opening bracket, this just contains `bracketId`.\n * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n * Otherwise, it is empty.\n */\nbracketIds, astNode) {\n  _classCallCheck(this, Token);\n  this.length = length;\n  this.kind = kind;\n  this.bracketId = bracketId;\n  this.bracketIds = bracketIds;\n  this.astNode = astNode;\n});\nexport var TextBufferTokenizer = /*#__PURE__*/function () {\n  function TextBufferTokenizer(textModel, bracketTokens) {\n    _classCallCheck(this, TextBufferTokenizer);\n    this.textModel = textModel;\n    this.bracketTokens = bracketTokens;\n    this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n    this._offset = lengthZero;\n    this.didPeek = false;\n    this.peeked = null;\n    this.textBufferLineCount = textModel.getLineCount();\n    this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n  }\n  return _createClass(TextBufferTokenizer, [{\n    key: \"offset\",\n    get: function get() {\n      return this._offset;\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n    }\n  }, {\n    key: \"skip\",\n    value: function skip(length) {\n      this.didPeek = false;\n      this._offset = lengthAdd(this._offset, length);\n      var obj = lengthToObj(this._offset);\n      this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n  }, {\n    key: \"read\",\n    value: function read() {\n      var token;\n      if (this.peeked) {\n        this.didPeek = false;\n        token = this.peeked;\n      } else {\n        token = this.reader.read();\n      }\n      if (token) {\n        this._offset = lengthAdd(this._offset, token.length);\n      }\n      return token;\n    }\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      if (!this.didPeek) {\n        this.peeked = this.reader.read();\n        this.didPeek = true;\n      }\n      return this.peeked;\n    }\n  }]);\n}();\n/**\n * Does not support peek.\n*/\nvar NonPeekableTextBufferTokenizer = /*#__PURE__*/function () {\n  function NonPeekableTextBufferTokenizer(textModel, bracketTokens) {\n    _classCallCheck(this, NonPeekableTextBufferTokenizer);\n    this.textModel = textModel;\n    this.bracketTokens = bracketTokens;\n    this.lineIdx = 0;\n    this.line = null;\n    this.lineCharOffset = 0;\n    this.lineTokens = null;\n    this.lineTokenOffset = 0;\n    /** Must be a zero line token. The end of the document cannot be peeked. */\n    this.peekedToken = null;\n    this.textBufferLineCount = textModel.getLineCount();\n    this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n  }\n  return _createClass(NonPeekableTextBufferTokenizer, [{\n    key: \"setPosition\",\n    value: function setPosition(lineIdx, column) {\n      // We must not jump into a token!\n      if (lineIdx === this.lineIdx) {\n        this.lineCharOffset = column;\n        if (this.line !== null) {\n          this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n      } else {\n        this.lineIdx = lineIdx;\n        this.lineCharOffset = column;\n        this.line = null;\n      }\n      this.peekedToken = null;\n    }\n  }, {\n    key: \"read\",\n    value: function read() {\n      if (this.peekedToken) {\n        var token = this.peekedToken;\n        this.peekedToken = null;\n        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n        return token;\n      }\n      if (this.lineIdx > this.textBufferLineCount - 1 || this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength) {\n        // We are after the end\n        return null;\n      }\n      if (this.line === null) {\n        this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n        this.line = this.lineTokens.getLineContent();\n        this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n      }\n      var startLineIdx = this.lineIdx;\n      var startLineCharOffset = this.lineCharOffset;\n      // limits the length of text tokens.\n      // If text tokens get too long, incremental updates will be slow\n      var lengthHeuristic = 0;\n      while (true) {\n        var lineTokens = this.lineTokens;\n        var tokenCount = lineTokens.getCount();\n        var peekedBracketToken = null;\n        if (this.lineTokenOffset < tokenCount) {\n          var tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n          while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n            // Skip tokens that are identical.\n            // Sometimes, (bracket) identifiers are split up into multiple tokens.\n            this.lineTokenOffset++;\n          }\n          var isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* StandardTokenType.Other */;\n          var containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n          var endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n          // Is there a bracket token next? Only consume text.\n          if (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n            var languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n            var text = this.line.substring(this.lineCharOffset, endOffset);\n            var brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n            var regexp = brackets.regExpGlobal;\n            if (regexp) {\n              regexp.lastIndex = 0;\n              var match = regexp.exec(text);\n              if (match) {\n                peekedBracketToken = brackets.getToken(match[0]);\n                if (peekedBracketToken) {\n                  // Consume leading text of the token\n                  this.lineCharOffset += match.index;\n                }\n              }\n            }\n          }\n          lengthHeuristic += endOffset - this.lineCharOffset;\n          if (peekedBracketToken) {\n            // Don't skip the entire token, as a single token could contain multiple brackets.\n            if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n              // There is text before the bracket\n              this.peekedToken = peekedBracketToken;\n              break;\n            } else {\n              // Consume the peeked token\n              this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n              return peekedBracketToken;\n            }\n          } else {\n            // Skip the entire token, as the token contains no brackets at all.\n            this.lineTokenOffset++;\n            this.lineCharOffset = endOffset;\n          }\n        } else {\n          if (this.lineIdx === this.textBufferLineCount - 1) {\n            break;\n          }\n          this.lineIdx++;\n          this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n          this.lineTokenOffset = 0;\n          this.line = this.lineTokens.getLineContent();\n          this.lineCharOffset = 0;\n          lengthHeuristic += 33; // max 1000/33 = 30 lines\n          // This limits the amount of work to recompute min-indentation\n          if (lengthHeuristic > 1000) {\n            // only break (automatically) at the end of line.\n            break;\n          }\n        }\n        if (lengthHeuristic > 1500) {\n          // Eventually break regardless of the line length so that\n          // very long lines do not cause bad performance.\n          // This effective limits max indentation to 500, as\n          // indentation is not computed across multiple text nodes.\n          break;\n        }\n      }\n      // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n      // unless the line is too long.\n      // Thus, the min indentation of the document is the minimum min indentation of every text node.\n      var length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n      return new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n  }]);\n}();\nexport var FastTokenizer = /*#__PURE__*/function () {\n  function FastTokenizer(text, brackets) {\n    _classCallCheck(this, FastTokenizer);\n    this.text = text;\n    this._offset = lengthZero;\n    this.idx = 0;\n    var regExpStr = brackets.getRegExpStr();\n    var regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n    var tokens = [];\n    var match;\n    var curLineCount = 0;\n    var lastLineBreakOffset = 0;\n    var lastTokenEndOffset = 0;\n    var lastTokenEndLine = 0;\n    var smallTextTokens0Line = [];\n    for (var i = 0; i < 60; i++) {\n      smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n    }\n    var smallTextTokens1Line = [];\n    for (var _i = 0; _i < 60; _i++) {\n      smallTextTokens1Line.push(new Token(toLength(1, _i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, _i))));\n    }\n    if (regexp) {\n      regexp.lastIndex = 0;\n      // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n      while ((match = regexp.exec(text)) !== null) {\n        var curOffset = match.index;\n        var value = match[0];\n        if (value === '\\n') {\n          curLineCount++;\n          lastLineBreakOffset = curOffset + 1;\n        } else {\n          if (lastTokenEndOffset !== curOffset) {\n            var token = void 0;\n            if (lastTokenEndLine === curLineCount) {\n              var colCount = curOffset - lastTokenEndOffset;\n              if (colCount < smallTextTokens0Line.length) {\n                token = smallTextTokens0Line[colCount];\n              } else {\n                var length = toLength(0, colCount);\n                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n              }\n            } else {\n              var lineCount = curLineCount - lastTokenEndLine;\n              var _colCount = curOffset - lastLineBreakOffset;\n              if (lineCount === 1 && _colCount < smallTextTokens1Line.length) {\n                token = smallTextTokens1Line[_colCount];\n              } else {\n                var _length = toLength(lineCount, _colCount);\n                token = new Token(_length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(_length));\n              }\n            }\n            tokens.push(token);\n          }\n          // value is matched by regexp, so the token must exist\n          tokens.push(brackets.getToken(value));\n          lastTokenEndOffset = curOffset + value.length;\n          lastTokenEndLine = curLineCount;\n        }\n      }\n    }\n    var offset = text.length;\n    if (lastTokenEndOffset !== offset) {\n      var _length2 = lastTokenEndLine === curLineCount ? toLength(0, offset - lastTokenEndOffset) : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n      tokens.push(new Token(_length2, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(_length2)));\n    }\n    this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n    this.tokens = tokens;\n  }\n  return _createClass(FastTokenizer, [{\n    key: \"offset\",\n    get: function get() {\n      return this._offset;\n    }\n  }, {\n    key: \"read\",\n    value: function read() {\n      return this.tokens[this.idx++] || null;\n    }\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      return this.tokens[this.idx] || null;\n    }\n  }, {\n    key: \"skip\",\n    value: function skip(length) {\n      throw new NotSupportedError();\n    }\n  }]);\n}();","map":{"version":3,"names":["NotSupportedError","TokenMetadata","TextAstNode","lengthAdd","lengthDiff","lengthGetColumnCountIfZeroLineCount","lengthToObj","lengthZero","toLength","SmallImmutableSet","Token","_createClass","length","kind","bracketId","bracketIds","astNode","_classCallCheck","TextBufferTokenizer","textModel","bracketTokens","reader","NonPeekableTextBufferTokenizer","_offset","didPeek","peeked","textBufferLineCount","getLineCount","textBufferLastLineLength","getLineLength","key","get","value","skip","obj","setPosition","lineCount","columnCount","read","token","peek","lineIdx","line","lineCharOffset","lineTokens","lineTokenOffset","peekedToken","column","findTokenIndexAtOffset","tokenization","getLineTokens","getLineContent","startLineIdx","startLineCharOffset","lengthHeuristic","tokenCount","getCount","peekedBracketToken","tokenMetadata","getMetadata","isOther","getTokenType","containsBracketType","containsBalancedBrackets","endOffset","getEndOffset","languageId","getLanguageId","text","substring","brackets","getSingleLanguageBracketTokens","regexp","regExpGlobal","lastIndex","match","exec","getToken","index","getEmpty","FastTokenizer","idx","regExpStr","getRegExpStr","RegExp","tokens","curLineCount","lastLineBreakOffset","lastTokenEndOffset","lastTokenEndLine","smallTextTokens0Line","i","push","smallTextTokens1Line","curOffset","colCount","offset"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport class Token {\n    constructor(length, kind, \n    /**\n     * If this token is an opening bracket, this is the id of the opening bracket.\n     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n     * Otherwise, it is -1.\n     */\n    bracketId, \n    /**\n     * If this token is an opening bracket, this just contains `bracketId`.\n     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n     * Otherwise, it is empty.\n     */\n    bracketIds, astNode) {\n        this.length = length;\n        this.kind = kind;\n        this.bracketId = bracketId;\n        this.bracketIds = bracketIds;\n        this.astNode = astNode;\n    }\n}\nexport class TextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n        this._offset = lengthZero;\n        this.didPeek = false;\n        this.peeked = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n    }\n    skip(length) {\n        this.didPeek = false;\n        this._offset = lengthAdd(this._offset, length);\n        const obj = lengthToObj(this._offset);\n        this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n    read() {\n        let token;\n        if (this.peeked) {\n            this.didPeek = false;\n            token = this.peeked;\n        }\n        else {\n            token = this.reader.read();\n        }\n        if (token) {\n            this._offset = lengthAdd(this._offset, token.length);\n        }\n        return token;\n    }\n    peek() {\n        if (!this.didPeek) {\n            this.peeked = this.reader.read();\n            this.didPeek = true;\n        }\n        return this.peeked;\n    }\n}\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.lineIdx = 0;\n        this.line = null;\n        this.lineCharOffset = 0;\n        this.lineTokens = null;\n        this.lineTokenOffset = 0;\n        /** Must be a zero line token. The end of the document cannot be peeked. */\n        this.peekedToken = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    setPosition(lineIdx, column) {\n        // We must not jump into a token!\n        if (lineIdx === this.lineIdx) {\n            this.lineCharOffset = column;\n            if (this.line !== null) {\n                this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n            }\n        }\n        else {\n            this.lineIdx = lineIdx;\n            this.lineCharOffset = column;\n            this.line = null;\n        }\n        this.peekedToken = null;\n    }\n    read() {\n        if (this.peekedToken) {\n            const token = this.peekedToken;\n            this.peekedToken = null;\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n            return token;\n        }\n        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n            // We are after the end\n            return null;\n        }\n        if (this.line === null) {\n            this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n            this.line = this.lineTokens.getLineContent();\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        const startLineIdx = this.lineIdx;\n        const startLineCharOffset = this.lineCharOffset;\n        // limits the length of text tokens.\n        // If text tokens get too long, incremental updates will be slow\n        let lengthHeuristic = 0;\n        while (true) {\n            const lineTokens = this.lineTokens;\n            const tokenCount = lineTokens.getCount();\n            let peekedBracketToken = null;\n            if (this.lineTokenOffset < tokenCount) {\n                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n                    // Skip tokens that are identical.\n                    // Sometimes, (bracket) identifiers are split up into multiple tokens.\n                    this.lineTokenOffset++;\n                }\n                const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* StandardTokenType.Other */;\n                const containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n                // Is there a bracket token next? Only consume text.\n                if (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n                    const text = this.line.substring(this.lineCharOffset, endOffset);\n                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n                    const regexp = brackets.regExpGlobal;\n                    if (regexp) {\n                        regexp.lastIndex = 0;\n                        const match = regexp.exec(text);\n                        if (match) {\n                            peekedBracketToken = brackets.getToken(match[0]);\n                            if (peekedBracketToken) {\n                                // Consume leading text of the token\n                                this.lineCharOffset += match.index;\n                            }\n                        }\n                    }\n                }\n                lengthHeuristic += endOffset - this.lineCharOffset;\n                if (peekedBracketToken) {\n                    // Don't skip the entire token, as a single token could contain multiple brackets.\n                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n                        // There is text before the bracket\n                        this.peekedToken = peekedBracketToken;\n                        break;\n                    }\n                    else {\n                        // Consume the peeked token\n                        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n                        return peekedBracketToken;\n                    }\n                }\n                else {\n                    // Skip the entire token, as the token contains no brackets at all.\n                    this.lineTokenOffset++;\n                    this.lineCharOffset = endOffset;\n                }\n            }\n            else {\n                if (this.lineIdx === this.textBufferLineCount - 1) {\n                    break;\n                }\n                this.lineIdx++;\n                this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n                this.lineTokenOffset = 0;\n                this.line = this.lineTokens.getLineContent();\n                this.lineCharOffset = 0;\n                lengthHeuristic += 33; // max 1000/33 = 30 lines\n                // This limits the amount of work to recompute min-indentation\n                if (lengthHeuristic > 1000) {\n                    // only break (automatically) at the end of line.\n                    break;\n                }\n            }\n            if (lengthHeuristic > 1500) {\n                // Eventually break regardless of the line length so that\n                // very long lines do not cause bad performance.\n                // This effective limits max indentation to 500, as\n                // indentation is not computed across multiple text nodes.\n                break;\n            }\n        }\n        // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n        // unless the line is too long.\n        // Thus, the min indentation of the document is the minimum min indentation of every text node.\n        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n        return new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n}\nexport class FastTokenizer {\n    constructor(text, brackets) {\n        this.text = text;\n        this._offset = lengthZero;\n        this.idx = 0;\n        const regExpStr = brackets.getRegExpStr();\n        const regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n        const tokens = [];\n        let match;\n        let curLineCount = 0;\n        let lastLineBreakOffset = 0;\n        let lastTokenEndOffset = 0;\n        let lastTokenEndLine = 0;\n        const smallTextTokens0Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n        }\n        const smallTextTokens1Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens1Line.push(new Token(toLength(1, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n        }\n        if (regexp) {\n            regexp.lastIndex = 0;\n            // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n            while ((match = regexp.exec(text)) !== null) {\n                const curOffset = match.index;\n                const value = match[0];\n                if (value === '\\n') {\n                    curLineCount++;\n                    lastLineBreakOffset = curOffset + 1;\n                }\n                else {\n                    if (lastTokenEndOffset !== curOffset) {\n                        let token;\n                        if (lastTokenEndLine === curLineCount) {\n                            const colCount = curOffset - lastTokenEndOffset;\n                            if (colCount < smallTextTokens0Line.length) {\n                                token = smallTextTokens0Line[colCount];\n                            }\n                            else {\n                                const length = toLength(0, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        else {\n                            const lineCount = curLineCount - lastTokenEndLine;\n                            const colCount = curOffset - lastLineBreakOffset;\n                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                                token = smallTextTokens1Line[colCount];\n                            }\n                            else {\n                                const length = toLength(lineCount, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        tokens.push(token);\n                    }\n                    // value is matched by regexp, so the token must exist\n                    tokens.push(brackets.getToken(value));\n                    lastTokenEndOffset = curOffset + value.length;\n                    lastTokenEndLine = curLineCount;\n                }\n            }\n        }\n        const offset = text.length;\n        if (lastTokenEndOffset !== offset) {\n            const length = (lastTokenEndLine === curLineCount)\n                ? toLength(0, offset - lastTokenEndOffset)\n                : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n            tokens.push(new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n        }\n        this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n        this.tokens = tokens;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read() {\n        return this.tokens[this.idx++] || null;\n    }\n    peek() {\n        return this.tokens[this.idx] || null;\n    }\n    skip(length) {\n        throw new NotSupportedError();\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}