{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.starts-with.js\";\nimport \"core-js/modules/es.typed-array.int32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../../base/common/diff/diff.js';\nimport { commonPrefixLength, getLeadingWhitespace } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nimport { TextLength } from '../../../common/core/textLength.js';\nimport { SingleTextEdit } from '../../../common/core/textEdit.js';\nimport { GhostText, GhostTextPart } from './ghostText.js';\nexport function singleTextRemoveCommonPrefix(edit, model, validModelRange) {\n  var modelRange = validModelRange ? edit.range.intersectRanges(validModelRange) : edit.range;\n  if (!modelRange) {\n    return edit;\n  }\n  var valueToReplace = model.getValueInRange(modelRange, 1 /* EndOfLinePreference.LF */);\n  var commonPrefixLen = commonPrefixLength(valueToReplace, edit.text);\n  var start = TextLength.ofText(valueToReplace.substring(0, commonPrefixLen)).addToPosition(edit.range.getStartPosition());\n  var text = edit.text.substring(commonPrefixLen);\n  var range = Range.fromPositions(start, edit.range.getEndPosition());\n  return new SingleTextEdit(range, text);\n}\nexport function singleTextEditAugments(edit, base) {\n  // The augmented completion must replace the base range, but can replace even more\n  return edit.text.startsWith(base.text) && rangeExtends(edit.range, base.range);\n}\n/**\n * @param previewSuffixLength Sets where to split `inlineCompletion.text`.\n * \tIf the text is `hello` and the suffix length is 2, the non-preview part is `hel` and the preview-part is `lo`.\n*/\nexport function computeGhostText(edit, model, mode, cursorPosition) {\n  var previewSuffixLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var e = singleTextRemoveCommonPrefix(edit, model);\n  if (e.range.endLineNumber !== e.range.startLineNumber) {\n    // This edit might span multiple lines, but the first lines must be a common prefix.\n    return undefined;\n  }\n  var sourceLine = model.getLineContent(e.range.startLineNumber);\n  var sourceIndentationLength = getLeadingWhitespace(sourceLine).length;\n  var suggestionTouchesIndentation = e.range.startColumn - 1 <= sourceIndentationLength;\n  if (suggestionTouchesIndentation) {\n    // source:      ··········[······abc]\n    //                         ^^^^^^^^^ inlineCompletion.range\n    //              ^^^^^^^^^^ ^^^^^^ sourceIndentationLength\n    //                         ^^^^^^ replacedIndentation.length\n    //                               ^^^ rangeThatDoesNotReplaceIndentation\n    // inlineCompletion.text: '··foo'\n    //                         ^^ suggestionAddedIndentationLength\n    var suggestionAddedIndentationLength = getLeadingWhitespace(e.text).length;\n    var replacedIndentation = sourceLine.substring(e.range.startColumn - 1, sourceIndentationLength);\n    var _ref = [e.range.getStartPosition(), e.range.getEndPosition()],\n      startPosition = _ref[0],\n      endPosition = _ref[1];\n    var newStartPosition = startPosition.column + replacedIndentation.length <= endPosition.column ? startPosition.delta(0, replacedIndentation.length) : endPosition;\n    var rangeThatDoesNotReplaceIndentation = Range.fromPositions(newStartPosition, endPosition);\n    var suggestionWithoutIndentationChange = e.text.startsWith(replacedIndentation)\n    // Adds more indentation without changing existing indentation: We can add ghost text for this\n    ? e.text.substring(replacedIndentation.length)\n    // Changes or removes existing indentation. Only add ghost text for the non-indentation part.\n    : e.text.substring(suggestionAddedIndentationLength);\n    e = new SingleTextEdit(rangeThatDoesNotReplaceIndentation, suggestionWithoutIndentationChange);\n  }\n  // This is a single line string\n  var valueToBeReplaced = model.getValueInRange(e.range);\n  var changes = cachingDiff(valueToBeReplaced, e.text);\n  if (!changes) {\n    // No ghost text in case the diff would be too slow to compute\n    return undefined;\n  }\n  var lineNumber = e.range.startLineNumber;\n  var parts = new Array();\n  if (mode === 'prefix') {\n    var filteredChanges = changes.filter(function (c) {\n      return c.originalLength === 0;\n    });\n    if (filteredChanges.length > 1 || filteredChanges.length === 1 && filteredChanges[0].originalStart !== valueToBeReplaced.length) {\n      // Prefixes only have a single change.\n      return undefined;\n    }\n  }\n  var previewStartInCompletionText = e.text.length - previewSuffixLength;\n  var _iterator = _createForOfIteratorHelper(changes),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var c = _step.value;\n      var insertColumn = e.range.startColumn + c.originalStart + c.originalLength;\n      if (mode === 'subwordSmart' && cursorPosition && cursorPosition.lineNumber === e.range.startLineNumber && insertColumn < cursorPosition.column) {\n        // No ghost text before cursor\n        return undefined;\n      }\n      if (c.originalLength > 0) {\n        return undefined;\n      }\n      if (c.modifiedLength === 0) {\n        continue;\n      }\n      var modifiedEnd = c.modifiedStart + c.modifiedLength;\n      var nonPreviewTextEnd = Math.max(c.modifiedStart, Math.min(modifiedEnd, previewStartInCompletionText));\n      var nonPreviewText = e.text.substring(c.modifiedStart, nonPreviewTextEnd);\n      var italicText = e.text.substring(nonPreviewTextEnd, Math.max(c.modifiedStart, modifiedEnd));\n      if (nonPreviewText.length > 0) {\n        parts.push(new GhostTextPart(insertColumn, nonPreviewText, false));\n      }\n      if (italicText.length > 0) {\n        parts.push(new GhostTextPart(insertColumn, italicText, true));\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return new GhostText(lineNumber, parts);\n}\nfunction rangeExtends(extendingRange, rangeToExtend) {\n  return rangeToExtend.getStartPosition().equals(extendingRange.getStartPosition()) && rangeToExtend.getEndPosition().isBeforeOrEqual(extendingRange.getEndPosition());\n}\nvar lastRequest = undefined;\nfunction cachingDiff(originalValue, newValue) {\n  if ((lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.originalValue) === originalValue && (lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.newValue) === newValue) {\n    return lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.changes;\n  } else {\n    var changes = smartDiff(originalValue, newValue, true);\n    if (changes) {\n      var deletedChars = deletedCharacters(changes);\n      if (deletedChars > 0) {\n        // For performance reasons, don't compute diff if there is nothing to improve\n        var newChanges = smartDiff(originalValue, newValue, false);\n        if (newChanges && deletedCharacters(newChanges) < deletedChars) {\n          // Disabling smartness seems to be better here\n          changes = newChanges;\n        }\n      }\n    }\n    lastRequest = {\n      originalValue: originalValue,\n      newValue: newValue,\n      changes: changes\n    };\n    return changes;\n  }\n}\nfunction deletedCharacters(changes) {\n  var sum = 0;\n  var _iterator2 = _createForOfIteratorHelper(changes),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var c = _step2.value;\n      sum += c.originalLength;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return sum;\n}\n/**\n * When matching `if ()` with `if (f() = 1) { g(); }`,\n * align it like this:        `if (       )`\n * Not like this:\t\t\t  `if (  )`\n * Also not like this:\t\t  `if (             )`.\n *\n * The parenthesis are preprocessed to ensure that they match correctly.\n */\nfunction smartDiff(originalValue, newValue, smartBracketMatching) {\n  if (originalValue.length > 5000 || newValue.length > 5000) {\n    // We don't want to work on strings that are too big\n    return undefined;\n  }\n  function getMaxCharCode(val) {\n    var maxCharCode = 0;\n    for (var i = 0, len = val.length; i < len; i++) {\n      var charCode = val.charCodeAt(i);\n      if (charCode > maxCharCode) {\n        maxCharCode = charCode;\n      }\n    }\n    return maxCharCode;\n  }\n  var maxCharCode = Math.max(getMaxCharCode(originalValue), getMaxCharCode(newValue));\n  function getUniqueCharCode(id) {\n    if (id < 0) {\n      throw new Error('unexpected');\n    }\n    return maxCharCode + id + 1;\n  }\n  function getElements(source) {\n    var level = 0;\n    var group = 0;\n    var characters = new Int32Array(source.length);\n    for (var i = 0, len = source.length; i < len; i++) {\n      // TODO support more brackets\n      if (smartBracketMatching && source[i] === '(') {\n        var id = group * 100 + level;\n        characters[i] = getUniqueCharCode(2 * id);\n        level++;\n      } else if (smartBracketMatching && source[i] === ')') {\n        level = Math.max(level - 1, 0);\n        var _id = group * 100 + level;\n        characters[i] = getUniqueCharCode(2 * _id + 1);\n        if (level === 0) {\n          group++;\n        }\n      } else {\n        characters[i] = source.charCodeAt(i);\n      }\n    }\n    return characters;\n  }\n  var elements1 = getElements(originalValue);\n  var elements2 = getElements(newValue);\n  return new LcsDiff({\n    getElements: function getElements() {\n      return elements1;\n    }\n  }, {\n    getElements: function getElements() {\n      return elements2;\n    }\n  }).ComputeDiff(false).changes;\n}","map":{"version":3,"names":["LcsDiff","commonPrefixLength","getLeadingWhitespace","Range","TextLength","SingleTextEdit","GhostText","GhostTextPart","singleTextRemoveCommonPrefix","edit","model","validModelRange","modelRange","range","intersectRanges","valueToReplace","getValueInRange","commonPrefixLen","text","start","ofText","substring","addToPosition","getStartPosition","fromPositions","getEndPosition","singleTextEditAugments","base","startsWith","rangeExtends","computeGhostText","mode","cursorPosition","previewSuffixLength","arguments","length","undefined","e","endLineNumber","startLineNumber","sourceLine","getLineContent","sourceIndentationLength","suggestionTouchesIndentation","startColumn","suggestionAddedIndentationLength","replacedIndentation","_ref","startPosition","endPosition","newStartPosition","column","delta","rangeThatDoesNotReplaceIndentation","suggestionWithoutIndentationChange","valueToBeReplaced","changes","cachingDiff","lineNumber","parts","Array","filteredChanges","filter","c","originalLength","originalStart","previewStartInCompletionText","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","insertColumn","modifiedLength","modifiedEnd","modifiedStart","nonPreviewTextEnd","Math","max","min","nonPreviewText","italicText","push","err","f","extendingRange","rangeToExtend","equals","isBeforeOrEqual","lastRequest","originalValue","newValue","smartDiff","deletedChars","deletedCharacters","newChanges","sum","_iterator2","_step2","smartBracketMatching","getMaxCharCode","val","maxCharCode","i","len","charCode","charCodeAt","getUniqueCharCode","id","Error","getElements","source","level","group","characters","Int32Array","elements1","elements2","ComputeDiff"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/singleTextEdit.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../../base/common/diff/diff.js';\nimport { commonPrefixLength, getLeadingWhitespace } from '../../../../base/common/strings.js';\nimport { Range } from '../../../common/core/range.js';\nimport { TextLength } from '../../../common/core/textLength.js';\nimport { SingleTextEdit } from '../../../common/core/textEdit.js';\nimport { GhostText, GhostTextPart } from './ghostText.js';\nexport function singleTextRemoveCommonPrefix(edit, model, validModelRange) {\n    const modelRange = validModelRange ? edit.range.intersectRanges(validModelRange) : edit.range;\n    if (!modelRange) {\n        return edit;\n    }\n    const valueToReplace = model.getValueInRange(modelRange, 1 /* EndOfLinePreference.LF */);\n    const commonPrefixLen = commonPrefixLength(valueToReplace, edit.text);\n    const start = TextLength.ofText(valueToReplace.substring(0, commonPrefixLen)).addToPosition(edit.range.getStartPosition());\n    const text = edit.text.substring(commonPrefixLen);\n    const range = Range.fromPositions(start, edit.range.getEndPosition());\n    return new SingleTextEdit(range, text);\n}\nexport function singleTextEditAugments(edit, base) {\n    // The augmented completion must replace the base range, but can replace even more\n    return edit.text.startsWith(base.text) && rangeExtends(edit.range, base.range);\n}\n/**\n * @param previewSuffixLength Sets where to split `inlineCompletion.text`.\n * \tIf the text is `hello` and the suffix length is 2, the non-preview part is `hel` and the preview-part is `lo`.\n*/\nexport function computeGhostText(edit, model, mode, cursorPosition, previewSuffixLength = 0) {\n    let e = singleTextRemoveCommonPrefix(edit, model);\n    if (e.range.endLineNumber !== e.range.startLineNumber) {\n        // This edit might span multiple lines, but the first lines must be a common prefix.\n        return undefined;\n    }\n    const sourceLine = model.getLineContent(e.range.startLineNumber);\n    const sourceIndentationLength = getLeadingWhitespace(sourceLine).length;\n    const suggestionTouchesIndentation = e.range.startColumn - 1 <= sourceIndentationLength;\n    if (suggestionTouchesIndentation) {\n        // source:      ··········[······abc]\n        //                         ^^^^^^^^^ inlineCompletion.range\n        //              ^^^^^^^^^^ ^^^^^^ sourceIndentationLength\n        //                         ^^^^^^ replacedIndentation.length\n        //                               ^^^ rangeThatDoesNotReplaceIndentation\n        // inlineCompletion.text: '··foo'\n        //                         ^^ suggestionAddedIndentationLength\n        const suggestionAddedIndentationLength = getLeadingWhitespace(e.text).length;\n        const replacedIndentation = sourceLine.substring(e.range.startColumn - 1, sourceIndentationLength);\n        const [startPosition, endPosition] = [e.range.getStartPosition(), e.range.getEndPosition()];\n        const newStartPosition = startPosition.column + replacedIndentation.length <= endPosition.column\n            ? startPosition.delta(0, replacedIndentation.length)\n            : endPosition;\n        const rangeThatDoesNotReplaceIndentation = Range.fromPositions(newStartPosition, endPosition);\n        const suggestionWithoutIndentationChange = e.text.startsWith(replacedIndentation)\n            // Adds more indentation without changing existing indentation: We can add ghost text for this\n            ? e.text.substring(replacedIndentation.length)\n            // Changes or removes existing indentation. Only add ghost text for the non-indentation part.\n            : e.text.substring(suggestionAddedIndentationLength);\n        e = new SingleTextEdit(rangeThatDoesNotReplaceIndentation, suggestionWithoutIndentationChange);\n    }\n    // This is a single line string\n    const valueToBeReplaced = model.getValueInRange(e.range);\n    const changes = cachingDiff(valueToBeReplaced, e.text);\n    if (!changes) {\n        // No ghost text in case the diff would be too slow to compute\n        return undefined;\n    }\n    const lineNumber = e.range.startLineNumber;\n    const parts = new Array();\n    if (mode === 'prefix') {\n        const filteredChanges = changes.filter(c => c.originalLength === 0);\n        if (filteredChanges.length > 1 || filteredChanges.length === 1 && filteredChanges[0].originalStart !== valueToBeReplaced.length) {\n            // Prefixes only have a single change.\n            return undefined;\n        }\n    }\n    const previewStartInCompletionText = e.text.length - previewSuffixLength;\n    for (const c of changes) {\n        const insertColumn = e.range.startColumn + c.originalStart + c.originalLength;\n        if (mode === 'subwordSmart' && cursorPosition && cursorPosition.lineNumber === e.range.startLineNumber && insertColumn < cursorPosition.column) {\n            // No ghost text before cursor\n            return undefined;\n        }\n        if (c.originalLength > 0) {\n            return undefined;\n        }\n        if (c.modifiedLength === 0) {\n            continue;\n        }\n        const modifiedEnd = c.modifiedStart + c.modifiedLength;\n        const nonPreviewTextEnd = Math.max(c.modifiedStart, Math.min(modifiedEnd, previewStartInCompletionText));\n        const nonPreviewText = e.text.substring(c.modifiedStart, nonPreviewTextEnd);\n        const italicText = e.text.substring(nonPreviewTextEnd, Math.max(c.modifiedStart, modifiedEnd));\n        if (nonPreviewText.length > 0) {\n            parts.push(new GhostTextPart(insertColumn, nonPreviewText, false));\n        }\n        if (italicText.length > 0) {\n            parts.push(new GhostTextPart(insertColumn, italicText, true));\n        }\n    }\n    return new GhostText(lineNumber, parts);\n}\nfunction rangeExtends(extendingRange, rangeToExtend) {\n    return rangeToExtend.getStartPosition().equals(extendingRange.getStartPosition())\n        && rangeToExtend.getEndPosition().isBeforeOrEqual(extendingRange.getEndPosition());\n}\nlet lastRequest = undefined;\nfunction cachingDiff(originalValue, newValue) {\n    if ((lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.originalValue) === originalValue && (lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.newValue) === newValue) {\n        return lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.changes;\n    }\n    else {\n        let changes = smartDiff(originalValue, newValue, true);\n        if (changes) {\n            const deletedChars = deletedCharacters(changes);\n            if (deletedChars > 0) {\n                // For performance reasons, don't compute diff if there is nothing to improve\n                const newChanges = smartDiff(originalValue, newValue, false);\n                if (newChanges && deletedCharacters(newChanges) < deletedChars) {\n                    // Disabling smartness seems to be better here\n                    changes = newChanges;\n                }\n            }\n        }\n        lastRequest = {\n            originalValue,\n            newValue,\n            changes\n        };\n        return changes;\n    }\n}\nfunction deletedCharacters(changes) {\n    let sum = 0;\n    for (const c of changes) {\n        sum += c.originalLength;\n    }\n    return sum;\n}\n/**\n * When matching `if ()` with `if (f() = 1) { g(); }`,\n * align it like this:        `if (       )`\n * Not like this:\t\t\t  `if (  )`\n * Also not like this:\t\t  `if (             )`.\n *\n * The parenthesis are preprocessed to ensure that they match correctly.\n */\nfunction smartDiff(originalValue, newValue, smartBracketMatching) {\n    if (originalValue.length > 5000 || newValue.length > 5000) {\n        // We don't want to work on strings that are too big\n        return undefined;\n    }\n    function getMaxCharCode(val) {\n        let maxCharCode = 0;\n        for (let i = 0, len = val.length; i < len; i++) {\n            const charCode = val.charCodeAt(i);\n            if (charCode > maxCharCode) {\n                maxCharCode = charCode;\n            }\n        }\n        return maxCharCode;\n    }\n    const maxCharCode = Math.max(getMaxCharCode(originalValue), getMaxCharCode(newValue));\n    function getUniqueCharCode(id) {\n        if (id < 0) {\n            throw new Error('unexpected');\n        }\n        return maxCharCode + id + 1;\n    }\n    function getElements(source) {\n        let level = 0;\n        let group = 0;\n        const characters = new Int32Array(source.length);\n        for (let i = 0, len = source.length; i < len; i++) {\n            // TODO support more brackets\n            if (smartBracketMatching && source[i] === '(') {\n                const id = group * 100 + level;\n                characters[i] = getUniqueCharCode(2 * id);\n                level++;\n            }\n            else if (smartBracketMatching && source[i] === ')') {\n                level = Math.max(level - 1, 0);\n                const id = group * 100 + level;\n                characters[i] = getUniqueCharCode(2 * id + 1);\n                if (level === 0) {\n                    group++;\n                }\n            }\n            else {\n                characters[i] = source.charCodeAt(i);\n            }\n        }\n        return characters;\n    }\n    const elements1 = getElements(originalValue);\n    const elements2 = getElements(newValue);\n    return new LcsDiff({ getElements: () => elements1 }, { getElements: () => elements2 }).ComputeDiff(false).changes;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}