{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.unshift.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../../../base/common/arrays.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthEquals, lengthIsZero, lengthToObj, lengthZero, sumLengths } from './length.js';\nexport function combineTextEditInfos(textEditInfoFirst, textEditInfoSecond) {\n  if (textEditInfoFirst.length === 0) {\n    return textEditInfoSecond;\n  }\n  if (textEditInfoSecond.length === 0) {\n    return textEditInfoFirst;\n  }\n  // s0: State before any edits\n  var s0ToS1Map = new ArrayQueue(toLengthMapping(textEditInfoFirst));\n  // s1: State after first edit, but before second edit\n  var s1ToS2Map = toLengthMapping(textEditInfoSecond);\n  s1ToS2Map.push({\n    modified: false,\n    lengthBefore: undefined,\n    lengthAfter: undefined\n  }); // Copy everything from old to new\n  // s2: State after both edits\n  var curItem = s0ToS1Map.dequeue();\n  /**\n   * @param s1Length Use undefined for length \"infinity\"\n   */\n  function nextS0ToS1MapWithS1LengthOf(s1Length) {\n    if (s1Length === undefined) {\n      var arr = s0ToS1Map.takeWhile(function (v) {\n        return true;\n      }) || [];\n      if (curItem) {\n        arr.unshift(curItem);\n      }\n      return arr;\n    }\n    var result = [];\n    while (curItem && !lengthIsZero(s1Length)) {\n      var _curItem$splitAt = curItem.splitAt(s1Length),\n        _curItem$splitAt2 = _slicedToArray(_curItem$splitAt, 2),\n        item = _curItem$splitAt2[0],\n        remainingItem = _curItem$splitAt2[1];\n      result.push(item);\n      s1Length = lengthDiffNonNegative(item.lengthAfter, s1Length);\n      curItem = remainingItem !== null && remainingItem !== void 0 ? remainingItem : s0ToS1Map.dequeue();\n    }\n    if (!lengthIsZero(s1Length)) {\n      result.push(new LengthMapping(false, s1Length, s1Length));\n    }\n    return result;\n  }\n  var result = [];\n  function pushEdit(startOffset, endOffset, newLength) {\n    if (result.length > 0 && lengthEquals(result[result.length - 1].endOffset, startOffset)) {\n      var lastResult = result[result.length - 1];\n      result[result.length - 1] = new TextEditInfo(lastResult.startOffset, endOffset, lengthAdd(lastResult.newLength, newLength));\n    } else {\n      result.push({\n        startOffset: startOffset,\n        endOffset: endOffset,\n        newLength: newLength\n      });\n    }\n  }\n  var s0offset = lengthZero;\n  var _iterator = _createForOfIteratorHelper(s1ToS2Map),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var s1ToS2 = _step.value;\n      var _s0ToS1Map = nextS0ToS1MapWithS1LengthOf(s1ToS2.lengthBefore);\n      if (s1ToS2.modified) {\n        var s0Length = sumLengths(_s0ToS1Map, function (s) {\n          return s.lengthBefore;\n        });\n        var s0EndOffset = lengthAdd(s0offset, s0Length);\n        pushEdit(s0offset, s0EndOffset, s1ToS2.lengthAfter);\n        s0offset = s0EndOffset;\n      } else {\n        var _iterator2 = _createForOfIteratorHelper(_s0ToS1Map),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var s1 = _step2.value;\n            var s0startOffset = s0offset;\n            s0offset = lengthAdd(s0offset, s1.lengthBefore);\n            if (s1.modified) {\n              pushEdit(s0startOffset, s0offset, s1.lengthAfter);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return result;\n}\nvar LengthMapping = /*#__PURE__*/function () {\n  function LengthMapping(\n  /**\n   * If false, length before and length after equal.\n   */\n  modified, lengthBefore, lengthAfter) {\n    _classCallCheck(this, LengthMapping);\n    this.modified = modified;\n    this.lengthBefore = lengthBefore;\n    this.lengthAfter = lengthAfter;\n  }\n  return _createClass(LengthMapping, [{\n    key: \"splitAt\",\n    value: function splitAt(lengthAfter) {\n      var remainingLengthAfter = lengthDiffNonNegative(lengthAfter, this.lengthAfter);\n      if (lengthEquals(remainingLengthAfter, lengthZero)) {\n        return [this, undefined];\n      } else if (this.modified) {\n        return [new LengthMapping(this.modified, this.lengthBefore, lengthAfter), new LengthMapping(this.modified, lengthZero, remainingLengthAfter)];\n      } else {\n        return [new LengthMapping(this.modified, lengthAfter, lengthAfter), new LengthMapping(this.modified, remainingLengthAfter, remainingLengthAfter)];\n      }\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.modified ? 'M' : 'U', \":\").concat(lengthToObj(this.lengthBefore), \" -> \").concat(lengthToObj(this.lengthAfter));\n    }\n  }]);\n}();\nfunction toLengthMapping(textEditInfos) {\n  var result = [];\n  var lastOffset = lengthZero;\n  var _iterator3 = _createForOfIteratorHelper(textEditInfos),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var textEditInfo = _step3.value;\n      var spaceLength = lengthDiffNonNegative(lastOffset, textEditInfo.startOffset);\n      if (!lengthIsZero(spaceLength)) {\n        result.push(new LengthMapping(false, spaceLength, spaceLength));\n      }\n      var lengthBefore = lengthDiffNonNegative(textEditInfo.startOffset, textEditInfo.endOffset);\n      result.push(new LengthMapping(true, lengthBefore, textEditInfo.newLength));\n      lastOffset = textEditInfo.endOffset;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return result;\n}","map":{"version":3,"names":["ArrayQueue","TextEditInfo","lengthAdd","lengthDiffNonNegative","lengthEquals","lengthIsZero","lengthToObj","lengthZero","sumLengths","combineTextEditInfos","textEditInfoFirst","textEditInfoSecond","length","s0ToS1Map","toLengthMapping","s1ToS2Map","push","modified","lengthBefore","undefined","lengthAfter","curItem","dequeue","nextS0ToS1MapWithS1LengthOf","s1Length","arr","takeWhile","v","unshift","result","_curItem$splitAt","splitAt","_curItem$splitAt2","_slicedToArray","item","remainingItem","LengthMapping","pushEdit","startOffset","endOffset","newLength","lastResult","s0offset","_iterator","_createForOfIteratorHelper","_step","s","n","done","s1ToS2","value","s0Length","s0EndOffset","_iterator2","_step2","s1","s0startOffset","err","e","f","_classCallCheck","_createClass","key","remainingLengthAfter","toString","concat","textEditInfos","lastOffset","_iterator3","_step3","textEditInfo","spaceLength"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../../../base/common/arrays.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthEquals, lengthIsZero, lengthToObj, lengthZero, sumLengths } from './length.js';\nexport function combineTextEditInfos(textEditInfoFirst, textEditInfoSecond) {\n    if (textEditInfoFirst.length === 0) {\n        return textEditInfoSecond;\n    }\n    if (textEditInfoSecond.length === 0) {\n        return textEditInfoFirst;\n    }\n    // s0: State before any edits\n    const s0ToS1Map = new ArrayQueue(toLengthMapping(textEditInfoFirst));\n    // s1: State after first edit, but before second edit\n    const s1ToS2Map = toLengthMapping(textEditInfoSecond);\n    s1ToS2Map.push({ modified: false, lengthBefore: undefined, lengthAfter: undefined }); // Copy everything from old to new\n    // s2: State after both edits\n    let curItem = s0ToS1Map.dequeue();\n    /**\n     * @param s1Length Use undefined for length \"infinity\"\n     */\n    function nextS0ToS1MapWithS1LengthOf(s1Length) {\n        if (s1Length === undefined) {\n            const arr = s0ToS1Map.takeWhile(v => true) || [];\n            if (curItem) {\n                arr.unshift(curItem);\n            }\n            return arr;\n        }\n        const result = [];\n        while (curItem && !lengthIsZero(s1Length)) {\n            const [item, remainingItem] = curItem.splitAt(s1Length);\n            result.push(item);\n            s1Length = lengthDiffNonNegative(item.lengthAfter, s1Length);\n            curItem = remainingItem !== null && remainingItem !== void 0 ? remainingItem : s0ToS1Map.dequeue();\n        }\n        if (!lengthIsZero(s1Length)) {\n            result.push(new LengthMapping(false, s1Length, s1Length));\n        }\n        return result;\n    }\n    const result = [];\n    function pushEdit(startOffset, endOffset, newLength) {\n        if (result.length > 0 && lengthEquals(result[result.length - 1].endOffset, startOffset)) {\n            const lastResult = result[result.length - 1];\n            result[result.length - 1] = new TextEditInfo(lastResult.startOffset, endOffset, lengthAdd(lastResult.newLength, newLength));\n        }\n        else {\n            result.push({ startOffset, endOffset, newLength });\n        }\n    }\n    let s0offset = lengthZero;\n    for (const s1ToS2 of s1ToS2Map) {\n        const s0ToS1Map = nextS0ToS1MapWithS1LengthOf(s1ToS2.lengthBefore);\n        if (s1ToS2.modified) {\n            const s0Length = sumLengths(s0ToS1Map, s => s.lengthBefore);\n            const s0EndOffset = lengthAdd(s0offset, s0Length);\n            pushEdit(s0offset, s0EndOffset, s1ToS2.lengthAfter);\n            s0offset = s0EndOffset;\n        }\n        else {\n            for (const s1 of s0ToS1Map) {\n                const s0startOffset = s0offset;\n                s0offset = lengthAdd(s0offset, s1.lengthBefore);\n                if (s1.modified) {\n                    pushEdit(s0startOffset, s0offset, s1.lengthAfter);\n                }\n            }\n        }\n    }\n    return result;\n}\nclass LengthMapping {\n    constructor(\n    /**\n     * If false, length before and length after equal.\n     */\n    modified, lengthBefore, lengthAfter) {\n        this.modified = modified;\n        this.lengthBefore = lengthBefore;\n        this.lengthAfter = lengthAfter;\n    }\n    splitAt(lengthAfter) {\n        const remainingLengthAfter = lengthDiffNonNegative(lengthAfter, this.lengthAfter);\n        if (lengthEquals(remainingLengthAfter, lengthZero)) {\n            return [this, undefined];\n        }\n        else if (this.modified) {\n            return [\n                new LengthMapping(this.modified, this.lengthBefore, lengthAfter),\n                new LengthMapping(this.modified, lengthZero, remainingLengthAfter)\n            ];\n        }\n        else {\n            return [\n                new LengthMapping(this.modified, lengthAfter, lengthAfter),\n                new LengthMapping(this.modified, remainingLengthAfter, remainingLengthAfter)\n            ];\n        }\n    }\n    toString() {\n        return `${this.modified ? 'M' : 'U'}:${lengthToObj(this.lengthBefore)} -> ${lengthToObj(this.lengthAfter)}`;\n    }\n}\nfunction toLengthMapping(textEditInfos) {\n    const result = [];\n    let lastOffset = lengthZero;\n    for (const textEditInfo of textEditInfos) {\n        const spaceLength = lengthDiffNonNegative(lastOffset, textEditInfo.startOffset);\n        if (!lengthIsZero(spaceLength)) {\n            result.push(new LengthMapping(false, spaceLength, spaceLength));\n        }\n        const lengthBefore = lengthDiffNonNegative(textEditInfo.startOffset, textEditInfo.endOffset);\n        result.push(new LengthMapping(true, lengthBefore, textEditInfo.newLength));\n        lastOffset = textEditInfo.endOffset;\n    }\n    return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}