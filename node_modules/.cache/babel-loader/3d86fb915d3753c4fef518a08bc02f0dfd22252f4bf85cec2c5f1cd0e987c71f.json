{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.splice.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { EditOperation } from '../core/editOperation.js';\nimport { Range } from '../core/range.js';\nexport var TrimTrailingWhitespaceCommand = /*#__PURE__*/function () {\n  function TrimTrailingWhitespaceCommand(selection, cursors, trimInRegexesAndStrings) {\n    _classCallCheck(this, TrimTrailingWhitespaceCommand);\n    this._selection = selection;\n    this._cursors = cursors;\n    this._selectionId = null;\n    this._trimInRegexesAndStrings = trimInRegexesAndStrings;\n  }\n  return _createClass(TrimTrailingWhitespaceCommand, [{\n    key: \"getEditOperations\",\n    value: function getEditOperations(model, builder) {\n      var ops = trimTrailingWhitespace(model, this._cursors, this._trimInRegexesAndStrings);\n      for (var i = 0, len = ops.length; i < len; i++) {\n        var op = ops[i];\n        builder.addEditOperation(op.range, op.text);\n      }\n      this._selectionId = builder.trackSelection(this._selection);\n    }\n  }, {\n    key: \"computeCursorState\",\n    value: function computeCursorState(model, helper) {\n      return helper.getTrackedSelection(this._selectionId);\n    }\n  }]);\n}();\n/**\n * Generate commands for trimming trailing whitespace on a model and ignore lines on which cursors are sitting.\n */\nexport function trimTrailingWhitespace(model, cursors, trimInRegexesAndStrings) {\n  // Sort cursors ascending\n  cursors.sort(function (a, b) {\n    if (a.lineNumber === b.lineNumber) {\n      return a.column - b.column;\n    }\n    return a.lineNumber - b.lineNumber;\n  });\n  // Reduce multiple cursors on the same line and only keep the last one on the line\n  for (var i = cursors.length - 2; i >= 0; i--) {\n    if (cursors[i].lineNumber === cursors[i + 1].lineNumber) {\n      // Remove cursor at `i`\n      cursors.splice(i, 1);\n    }\n  }\n  var r = [];\n  var rLen = 0;\n  var cursorIndex = 0;\n  var cursorLen = cursors.length;\n  for (var lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {\n    var lineContent = model.getLineContent(lineNumber);\n    var maxLineColumn = lineContent.length + 1;\n    var minEditColumn = 0;\n    if (cursorIndex < cursorLen && cursors[cursorIndex].lineNumber === lineNumber) {\n      minEditColumn = cursors[cursorIndex].column;\n      cursorIndex++;\n      if (minEditColumn === maxLineColumn) {\n        // The cursor is at the end of the line => no edits for sure on this line\n        continue;\n      }\n    }\n    if (lineContent.length === 0) {\n      continue;\n    }\n    var lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n    var fromColumn = 0;\n    if (lastNonWhitespaceIndex === -1) {\n      // Entire line is whitespace\n      fromColumn = 1;\n    } else if (lastNonWhitespaceIndex !== lineContent.length - 1) {\n      // There is trailing whitespace\n      fromColumn = lastNonWhitespaceIndex + 2;\n    } else {\n      // There is no trailing whitespace\n      continue;\n    }\n    if (!trimInRegexesAndStrings) {\n      if (!model.tokenization.hasAccurateTokensForLine(lineNumber)) {\n        // We don't want to force line tokenization, as that can be expensive, but we also don't want to trim\n        // trailing whitespace in lines that are not tokenized yet, as that can be wrong and trim whitespace from\n        // lines that the user requested we don't. So we bail out if the tokens are not accurate for this line.\n        continue;\n      }\n      var lineTokens = model.tokenization.getLineTokens(lineNumber);\n      var fromColumnType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(fromColumn));\n      if (fromColumnType === 2 /* StandardTokenType.String */ || fromColumnType === 3 /* StandardTokenType.RegEx */) {\n        continue;\n      }\n    }\n    fromColumn = Math.max(minEditColumn, fromColumn);\n    r[rLen++] = EditOperation[\"delete\"](new Range(lineNumber, fromColumn, lineNumber, maxLineColumn));\n  }\n  return r;\n}","map":{"version":3,"names":["strings","EditOperation","Range","TrimTrailingWhitespaceCommand","selection","cursors","trimInRegexesAndStrings","_classCallCheck","_selection","_cursors","_selectionId","_trimInRegexesAndStrings","_createClass","key","value","getEditOperations","model","builder","ops","trimTrailingWhitespace","i","len","length","op","addEditOperation","range","text","trackSelection","computeCursorState","helper","getTrackedSelection","sort","a","b","lineNumber","column","splice","r","rLen","cursorIndex","cursorLen","lineCount","getLineCount","lineContent","getLineContent","maxLineColumn","minEditColumn","lastNonWhitespaceIndex","fromColumn","tokenization","hasAccurateTokensForLine","lineTokens","getLineTokens","fromColumnType","getStandardTokenType","findTokenIndexAtOffset","Math","max"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/commands/trimTrailingWhitespaceCommand.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { EditOperation } from '../core/editOperation.js';\nimport { Range } from '../core/range.js';\nexport class TrimTrailingWhitespaceCommand {\n    constructor(selection, cursors, trimInRegexesAndStrings) {\n        this._selection = selection;\n        this._cursors = cursors;\n        this._selectionId = null;\n        this._trimInRegexesAndStrings = trimInRegexesAndStrings;\n    }\n    getEditOperations(model, builder) {\n        const ops = trimTrailingWhitespace(model, this._cursors, this._trimInRegexesAndStrings);\n        for (let i = 0, len = ops.length; i < len; i++) {\n            const op = ops[i];\n            builder.addEditOperation(op.range, op.text);\n        }\n        this._selectionId = builder.trackSelection(this._selection);\n    }\n    computeCursorState(model, helper) {\n        return helper.getTrackedSelection(this._selectionId);\n    }\n}\n/**\n * Generate commands for trimming trailing whitespace on a model and ignore lines on which cursors are sitting.\n */\nexport function trimTrailingWhitespace(model, cursors, trimInRegexesAndStrings) {\n    // Sort cursors ascending\n    cursors.sort((a, b) => {\n        if (a.lineNumber === b.lineNumber) {\n            return a.column - b.column;\n        }\n        return a.lineNumber - b.lineNumber;\n    });\n    // Reduce multiple cursors on the same line and only keep the last one on the line\n    for (let i = cursors.length - 2; i >= 0; i--) {\n        if (cursors[i].lineNumber === cursors[i + 1].lineNumber) {\n            // Remove cursor at `i`\n            cursors.splice(i, 1);\n        }\n    }\n    const r = [];\n    let rLen = 0;\n    let cursorIndex = 0;\n    const cursorLen = cursors.length;\n    for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {\n        const lineContent = model.getLineContent(lineNumber);\n        const maxLineColumn = lineContent.length + 1;\n        let minEditColumn = 0;\n        if (cursorIndex < cursorLen && cursors[cursorIndex].lineNumber === lineNumber) {\n            minEditColumn = cursors[cursorIndex].column;\n            cursorIndex++;\n            if (minEditColumn === maxLineColumn) {\n                // The cursor is at the end of the line => no edits for sure on this line\n                continue;\n            }\n        }\n        if (lineContent.length === 0) {\n            continue;\n        }\n        const lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n        let fromColumn = 0;\n        if (lastNonWhitespaceIndex === -1) {\n            // Entire line is whitespace\n            fromColumn = 1;\n        }\n        else if (lastNonWhitespaceIndex !== lineContent.length - 1) {\n            // There is trailing whitespace\n            fromColumn = lastNonWhitespaceIndex + 2;\n        }\n        else {\n            // There is no trailing whitespace\n            continue;\n        }\n        if (!trimInRegexesAndStrings) {\n            if (!model.tokenization.hasAccurateTokensForLine(lineNumber)) {\n                // We don't want to force line tokenization, as that can be expensive, but we also don't want to trim\n                // trailing whitespace in lines that are not tokenized yet, as that can be wrong and trim whitespace from\n                // lines that the user requested we don't. So we bail out if the tokens are not accurate for this line.\n                continue;\n            }\n            const lineTokens = model.tokenization.getLineTokens(lineNumber);\n            const fromColumnType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(fromColumn));\n            if (fromColumnType === 2 /* StandardTokenType.String */ || fromColumnType === 3 /* StandardTokenType.RegEx */) {\n                continue;\n            }\n        }\n        fromColumn = Math.max(minEditColumn, fromColumn);\n        r[rLen++] = EditOperation.delete(new Range(lineNumber, fromColumn, lineNumber, maxLineColumn));\n    }\n    return r;\n}\n"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA,OAAO,KAAKA,OAAO,MAAM,iCAAiC;AAC1D,SAASC,aAAa,QAAQ,0BAA0B;AACxD,SAASC,KAAK,QAAQ,kBAAkB;AACxC,WAAaC,6BAA6B;EACtC,SAAAA,8BAAYC,SAAS,EAAEC,OAAO,EAAEC,uBAAuB,EAAE;IAAAC,eAAA,OAAAJ,6BAAA;IACrD,IAAI,CAACK,UAAU,GAAGJ,SAAS;IAC3B,IAAI,CAACK,QAAQ,GAAGJ,OAAO;IACvB,IAAI,CAACK,YAAY,GAAG,IAAI;IACxB,IAAI,CAACC,wBAAwB,GAAGL,uBAAuB;EAC3D;EAAC,OAAAM,YAAA,CAAAT,6BAAA;IAAAU,GAAA;IAAAC,KAAA,EACD,SAAAC,kBAAkBC,KAAK,EAAEC,OAAO,EAAE;MAC9B,IAAMC,GAAG,GAAGC,sBAAsB,CAACH,KAAK,EAAE,IAAI,CAACP,QAAQ,EAAE,IAAI,CAACE,wBAAwB,CAAC;MACvF,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,GAAG,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QAC5C,IAAMG,EAAE,GAAGL,GAAG,CAACE,CAAC,CAAC;QACjBH,OAAO,CAACO,gBAAgB,CAACD,EAAE,CAACE,KAAK,EAAEF,EAAE,CAACG,IAAI,CAAC;MAC/C;MACA,IAAI,CAAChB,YAAY,GAAGO,OAAO,CAACU,cAAc,CAAC,IAAI,CAACnB,UAAU,CAAC;IAC/D;EAAC;IAAAK,GAAA;IAAAC,KAAA,EACD,SAAAc,mBAAmBZ,KAAK,EAAEa,MAAM,EAAE;MAC9B,OAAOA,MAAM,CAACC,mBAAmB,CAAC,IAAI,CAACpB,YAAY,CAAC;IACxD;EAAC;AAAA;AAEL;AACA;AACA;AACA,OAAO,SAASS,sBAAsBA,CAACH,KAAK,EAAEX,OAAO,EAAEC,uBAAuB,EAAE;EAC5E;EACAD,OAAO,CAAC0B,IAAI,CAAC,UAACC,CAAC,EAAEC,CAAC,EAAK;IACnB,IAAID,CAAC,CAACE,UAAU,KAAKD,CAAC,CAACC,UAAU,EAAE;MAC/B,OAAOF,CAAC,CAACG,MAAM,GAAGF,CAAC,CAACE,MAAM;IAC9B;IACA,OAAOH,CAAC,CAACE,UAAU,GAAGD,CAAC,CAACC,UAAU;EACtC,CAAC,CAAC;EACF;EACA,KAAK,IAAId,CAAC,GAAGf,OAAO,CAACiB,MAAM,GAAG,CAAC,EAAEF,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC1C,IAAIf,OAAO,CAACe,CAAC,CAAC,CAACc,UAAU,KAAK7B,OAAO,CAACe,CAAC,GAAG,CAAC,CAAC,CAACc,UAAU,EAAE;MACrD;MACA7B,OAAO,CAAC+B,MAAM,CAAChB,CAAC,EAAE,CAAC,CAAC;IACxB;EACJ;EACA,IAAMiB,CAAC,GAAG,EAAE;EACZ,IAAIC,IAAI,GAAG,CAAC;EACZ,IAAIC,WAAW,GAAG,CAAC;EACnB,IAAMC,SAAS,GAAGnC,OAAO,CAACiB,MAAM;EAChC,KAAK,IAAIY,UAAU,GAAG,CAAC,EAAEO,SAAS,GAAGzB,KAAK,CAAC0B,YAAY,CAAC,CAAC,EAAER,UAAU,IAAIO,SAAS,EAAEP,UAAU,EAAE,EAAE;IAC9F,IAAMS,WAAW,GAAG3B,KAAK,CAAC4B,cAAc,CAACV,UAAU,CAAC;IACpD,IAAMW,aAAa,GAAGF,WAAW,CAACrB,MAAM,GAAG,CAAC;IAC5C,IAAIwB,aAAa,GAAG,CAAC;IACrB,IAAIP,WAAW,GAAGC,SAAS,IAAInC,OAAO,CAACkC,WAAW,CAAC,CAACL,UAAU,KAAKA,UAAU,EAAE;MAC3EY,aAAa,GAAGzC,OAAO,CAACkC,WAAW,CAAC,CAACJ,MAAM;MAC3CI,WAAW,EAAE;MACb,IAAIO,aAAa,KAAKD,aAAa,EAAE;QACjC;QACA;MACJ;IACJ;IACA,IAAIF,WAAW,CAACrB,MAAM,KAAK,CAAC,EAAE;MAC1B;IACJ;IACA,IAAMyB,sBAAsB,GAAG/C,OAAO,CAAC+C,sBAAsB,CAACJ,WAAW,CAAC;IAC1E,IAAIK,UAAU,GAAG,CAAC;IAClB,IAAID,sBAAsB,KAAK,CAAC,CAAC,EAAE;MAC/B;MACAC,UAAU,GAAG,CAAC;IAClB,CAAC,MACI,IAAID,sBAAsB,KAAKJ,WAAW,CAACrB,MAAM,GAAG,CAAC,EAAE;MACxD;MACA0B,UAAU,GAAGD,sBAAsB,GAAG,CAAC;IAC3C,CAAC,MACI;MACD;MACA;IACJ;IACA,IAAI,CAACzC,uBAAuB,EAAE;MAC1B,IAAI,CAACU,KAAK,CAACiC,YAAY,CAACC,wBAAwB,CAAChB,UAAU,CAAC,EAAE;QAC1D;QACA;QACA;QACA;MACJ;MACA,IAAMiB,UAAU,GAAGnC,KAAK,CAACiC,YAAY,CAACG,aAAa,CAAClB,UAAU,CAAC;MAC/D,IAAMmB,cAAc,GAAGF,UAAU,CAACG,oBAAoB,CAACH,UAAU,CAACI,sBAAsB,CAACP,UAAU,CAAC,CAAC;MACrG,IAAIK,cAAc,KAAK,CAAC,CAAC,kCAAkCA,cAAc,KAAK,CAAC,CAAC,+BAA+B;QAC3G;MACJ;IACJ;IACAL,UAAU,GAAGQ,IAAI,CAACC,GAAG,CAACX,aAAa,EAAEE,UAAU,CAAC;IAChDX,CAAC,CAACC,IAAI,EAAE,CAAC,GAAGrC,aAAa,UAAO,CAAC,IAAIC,KAAK,CAACgC,UAAU,EAAEc,UAAU,EAAEd,UAAU,EAAEW,aAAa,CAAC,CAAC;EAClG;EACA,OAAOR,CAAC;AACZ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}