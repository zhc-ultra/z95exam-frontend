{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function findLast(array, predicate, fromIdx) {\n  var idx = findLastIdx(array, predicate);\n  if (idx === -1) {\n    return undefined;\n  }\n  return array[idx];\n}\nexport function findLastIdx(array, predicate) {\n  var fromIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : array.length - 1;\n  for (var i = fromIndex; i >= 0; i--) {\n    var element = array[i];\n    if (predicate(element)) {\n      return i;\n    }\n  }\n  return -1;\n}\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `undefined` if no item matches, otherwise the last item that matches the predicate.\n */\nexport function findLastMonotonous(array, predicate) {\n  var idx = findLastIdxMonotonous(array, predicate);\n  return idx === -1 ? undefined : array[idx];\n}\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `startIdx - 1` if predicate is false for all items, otherwise the index of the last item that matches the predicate.\n */\nexport function findLastIdxMonotonous(array, predicate) {\n  var startIdx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var endIdxEx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : array.length;\n  var i = startIdx;\n  var j = endIdxEx;\n  while (i < j) {\n    var k = Math.floor((i + j) / 2);\n    if (predicate(array[k])) {\n      i = k + 1;\n    } else {\n      j = k;\n    }\n  }\n  return i - 1;\n}\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `undefined` if no item matches, otherwise the first item that matches the predicate.\n */\nexport function findFirstMonotonous(array, predicate) {\n  var idx = findFirstIdxMonotonousOrArrLen(array, predicate);\n  return idx === array.length ? undefined : array[idx];\n}\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `endIdxEx` if predicate is false for all items, otherwise the index of the first item that matches the predicate.\n */\nexport function findFirstIdxMonotonousOrArrLen(array, predicate) {\n  var startIdx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var endIdxEx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : array.length;\n  var i = startIdx;\n  var j = endIdxEx;\n  while (i < j) {\n    var k = Math.floor((i + j) / 2);\n    if (predicate(array[k])) {\n      j = k;\n    } else {\n      i = k + 1;\n    }\n  }\n  return i;\n}\n/**\n * Use this when\n * * You have a sorted array\n * * You query this array with a monotonous predicate to find the last item that has a certain property.\n * * You query this array multiple times with monotonous predicates that get weaker and weaker.\n */\nexport var MonotonousArray = /*#__PURE__*/function () {\n  function MonotonousArray(_array) {\n    _classCallCheck(this, MonotonousArray);\n    this._array = _array;\n    this._findLastMonotonousLastIdx = 0;\n  }\n  /**\n   * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n   * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.\n   */\n  return _createClass(MonotonousArray, [{\n    key: \"findLastMonotonous\",\n    value: function findLastMonotonous(predicate) {\n      if (MonotonousArray.assertInvariants) {\n        if (this._prevFindLastPredicate) {\n          var _iterator = _createForOfIteratorHelper(this._array),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var item = _step.value;\n              if (this._prevFindLastPredicate(item) && !predicate(item)) {\n                throw new Error('MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.');\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n        this._prevFindLastPredicate = predicate;\n      }\n      var idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);\n      this._findLastMonotonousLastIdx = idx + 1;\n      return idx === -1 ? undefined : this._array[idx];\n    }\n  }]);\n}();\nMonotonousArray.assertInvariants = false;\n/**\n * Returns the first item that is equal to or greater than every other item.\n*/\nexport function findFirstMaxBy(array, comparator) {\n  if (array.length === 0) {\n    return undefined;\n  }\n  var max = array[0];\n  for (var i = 1; i < array.length; i++) {\n    var item = array[i];\n    if (comparator(item, max) > 0) {\n      max = item;\n    }\n  }\n  return max;\n}\n/**\n * Returns the last item that is equal to or greater than every other item.\n*/\nexport function findLastMaxBy(array, comparator) {\n  if (array.length === 0) {\n    return undefined;\n  }\n  var max = array[0];\n  for (var i = 1; i < array.length; i++) {\n    var item = array[i];\n    if (comparator(item, max) >= 0) {\n      max = item;\n    }\n  }\n  return max;\n}\n/**\n * Returns the first item that is equal to or less than every other item.\n*/\nexport function findFirstMinBy(array, comparator) {\n  return findFirstMaxBy(array, function (a, b) {\n    return -comparator(a, b);\n  });\n}\nexport function findMaxIdxBy(array, comparator) {\n  if (array.length === 0) {\n    return -1;\n  }\n  var maxIdx = 0;\n  for (var i = 1; i < array.length; i++) {\n    var item = array[i];\n    if (comparator(item, array[maxIdx]) > 0) {\n      maxIdx = i;\n    }\n  }\n  return maxIdx;\n}\n/**\n * Returns the first mapped value of the array which is not undefined.\n */\nexport function mapFindFirst(items, mapFn) {\n  var _iterator2 = _createForOfIteratorHelper(items),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var value = _step2.value;\n      var mapped = mapFn(value);\n      if (mapped !== undefined) {\n        return mapped;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return undefined;\n}","map":{"version":3,"names":["findLast","array","predicate","fromIdx","idx","findLastIdx","undefined","fromIndex","arguments","length","i","element","findLastMonotonous","findLastIdxMonotonous","startIdx","endIdxEx","j","k","Math","floor","findFirstMonotonous","findFirstIdxMonotonousOrArrLen","MonotonousArray","_array","_classCallCheck","_findLastMonotonousLastIdx","_createClass","key","value","assertInvariants","_prevFindLastPredicate","_iterator","_createForOfIteratorHelper","_step","s","n","done","item","Error","err","e","f","findFirstMaxBy","comparator","max","findLastMaxBy","findFirstMinBy","a","b","findMaxIdxBy","maxIdx","mapFindFirst","items","mapFn","_iterator2","_step2","mapped"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/base/common/arraysFind.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function findLast(array, predicate, fromIdx) {\n    const idx = findLastIdx(array, predicate);\n    if (idx === -1) {\n        return undefined;\n    }\n    return array[idx];\n}\nexport function findLastIdx(array, predicate, fromIndex = array.length - 1) {\n    for (let i = fromIndex; i >= 0; i--) {\n        const element = array[i];\n        if (predicate(element)) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `undefined` if no item matches, otherwise the last item that matches the predicate.\n */\nexport function findLastMonotonous(array, predicate) {\n    const idx = findLastIdxMonotonous(array, predicate);\n    return idx === -1 ? undefined : array[idx];\n}\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `startIdx - 1` if predicate is false for all items, otherwise the index of the last item that matches the predicate.\n */\nexport function findLastIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {\n    let i = startIdx;\n    let j = endIdxEx;\n    while (i < j) {\n        const k = Math.floor((i + j) / 2);\n        if (predicate(array[k])) {\n            i = k + 1;\n        }\n        else {\n            j = k;\n        }\n    }\n    return i - 1;\n}\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `undefined` if no item matches, otherwise the first item that matches the predicate.\n */\nexport function findFirstMonotonous(array, predicate) {\n    const idx = findFirstIdxMonotonousOrArrLen(array, predicate);\n    return idx === array.length ? undefined : array[idx];\n}\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `endIdxEx` if predicate is false for all items, otherwise the index of the first item that matches the predicate.\n */\nexport function findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {\n    let i = startIdx;\n    let j = endIdxEx;\n    while (i < j) {\n        const k = Math.floor((i + j) / 2);\n        if (predicate(array[k])) {\n            j = k;\n        }\n        else {\n            i = k + 1;\n        }\n    }\n    return i;\n}\n/**\n * Use this when\n * * You have a sorted array\n * * You query this array with a monotonous predicate to find the last item that has a certain property.\n * * You query this array multiple times with monotonous predicates that get weaker and weaker.\n */\nexport class MonotonousArray {\n    constructor(_array) {\n        this._array = _array;\n        this._findLastMonotonousLastIdx = 0;\n    }\n    /**\n     * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n     * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.\n     */\n    findLastMonotonous(predicate) {\n        if (MonotonousArray.assertInvariants) {\n            if (this._prevFindLastPredicate) {\n                for (const item of this._array) {\n                    if (this._prevFindLastPredicate(item) && !predicate(item)) {\n                        throw new Error('MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.');\n                    }\n                }\n            }\n            this._prevFindLastPredicate = predicate;\n        }\n        const idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);\n        this._findLastMonotonousLastIdx = idx + 1;\n        return idx === -1 ? undefined : this._array[idx];\n    }\n}\nMonotonousArray.assertInvariants = false;\n/**\n * Returns the first item that is equal to or greater than every other item.\n*/\nexport function findFirstMaxBy(array, comparator) {\n    if (array.length === 0) {\n        return undefined;\n    }\n    let max = array[0];\n    for (let i = 1; i < array.length; i++) {\n        const item = array[i];\n        if (comparator(item, max) > 0) {\n            max = item;\n        }\n    }\n    return max;\n}\n/**\n * Returns the last item that is equal to or greater than every other item.\n*/\nexport function findLastMaxBy(array, comparator) {\n    if (array.length === 0) {\n        return undefined;\n    }\n    let max = array[0];\n    for (let i = 1; i < array.length; i++) {\n        const item = array[i];\n        if (comparator(item, max) >= 0) {\n            max = item;\n        }\n    }\n    return max;\n}\n/**\n * Returns the first item that is equal to or less than every other item.\n*/\nexport function findFirstMinBy(array, comparator) {\n    return findFirstMaxBy(array, (a, b) => -comparator(a, b));\n}\nexport function findMaxIdxBy(array, comparator) {\n    if (array.length === 0) {\n        return -1;\n    }\n    let maxIdx = 0;\n    for (let i = 1; i < array.length; i++) {\n        const item = array[i];\n        if (comparator(item, array[maxIdx]) > 0) {\n            maxIdx = i;\n        }\n    }\n    return maxIdx;\n}\n/**\n * Returns the first mapped value of the array which is not undefined.\n */\nexport function mapFindFirst(items, mapFn) {\n    for (const value of items) {\n        const mapped = mapFn(value);\n        if (mapped !== undefined) {\n            return mapped;\n        }\n    }\n    return undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}