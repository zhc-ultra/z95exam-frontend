{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reverse.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../../core/offsetRange.js';\nimport { SequenceDiff, InfiniteTimeout, DiffAlgorithmResult } from './diffAlgorithm.js';\nimport { Array2D } from '../utils.js';\n/**\n * A O(MN) diffing algorithm that supports a score function.\n * The algorithm can be improved by processing the 2d array diagonally.\n*/\nexport var DynamicProgrammingDiffing = /*#__PURE__*/function () {\n  function DynamicProgrammingDiffing() {\n    _classCallCheck(this, DynamicProgrammingDiffing);\n  }\n  return _createClass(DynamicProgrammingDiffing, [{\n    key: \"compute\",\n    value: function compute(sequence1, sequence2) {\n      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : InfiniteTimeout.instance;\n      var equalityScore = arguments.length > 3 ? arguments[3] : undefined;\n      if (sequence1.length === 0 || sequence2.length === 0) {\n        return DiffAlgorithmResult.trivial(sequence1, sequence2);\n      }\n      /**\n       * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\n       */\n      var lcsLengths = new Array2D(sequence1.length, sequence2.length);\n      var directions = new Array2D(sequence1.length, sequence2.length);\n      var lengths = new Array2D(sequence1.length, sequence2.length);\n      // ==== Initializing lcsLengths ====\n      for (var _s = 0; _s < sequence1.length; _s++) {\n        for (var _s2 = 0; _s2 < sequence2.length; _s2++) {\n          if (!timeout.isValid()) {\n            return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n          }\n          var horizontalLen = _s === 0 ? 0 : lcsLengths.get(_s - 1, _s2);\n          var verticalLen = _s2 === 0 ? 0 : lcsLengths.get(_s, _s2 - 1);\n          var extendedSeqScore = void 0;\n          if (sequence1.getElement(_s) === sequence2.getElement(_s2)) {\n            if (_s === 0 || _s2 === 0) {\n              extendedSeqScore = 0;\n            } else {\n              extendedSeqScore = lcsLengths.get(_s - 1, _s2 - 1);\n            }\n            if (_s > 0 && _s2 > 0 && directions.get(_s - 1, _s2 - 1) === 3) {\n              // Prefer consecutive diagonals\n              extendedSeqScore += lengths.get(_s - 1, _s2 - 1);\n            }\n            extendedSeqScore += equalityScore ? equalityScore(_s, _s2) : 1;\n          } else {\n            extendedSeqScore = -1;\n          }\n          var newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n          if (newValue === extendedSeqScore) {\n            // Prefer diagonals\n            var prevLen = _s > 0 && _s2 > 0 ? lengths.get(_s - 1, _s2 - 1) : 0;\n            lengths.set(_s, _s2, prevLen + 1);\n            directions.set(_s, _s2, 3);\n          } else if (newValue === horizontalLen) {\n            lengths.set(_s, _s2, 0);\n            directions.set(_s, _s2, 1);\n          } else if (newValue === verticalLen) {\n            lengths.set(_s, _s2, 0);\n            directions.set(_s, _s2, 2);\n          }\n          lcsLengths.set(_s, _s2, newValue);\n        }\n      }\n      // ==== Backtracking ====\n      var result = [];\n      var lastAligningPosS1 = sequence1.length;\n      var lastAligningPosS2 = sequence2.length;\n      function reportDecreasingAligningPositions(s1, s2) {\n        if (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n          result.push(new SequenceDiff(new OffsetRange(s1 + 1, lastAligningPosS1), new OffsetRange(s2 + 1, lastAligningPosS2)));\n        }\n        lastAligningPosS1 = s1;\n        lastAligningPosS2 = s2;\n      }\n      var s1 = sequence1.length - 1;\n      var s2 = sequence2.length - 1;\n      while (s1 >= 0 && s2 >= 0) {\n        if (directions.get(s1, s2) === 3) {\n          reportDecreasingAligningPositions(s1, s2);\n          s1--;\n          s2--;\n        } else {\n          if (directions.get(s1, s2) === 1) {\n            s1--;\n          } else {\n            s2--;\n          }\n        }\n      }\n      reportDecreasingAligningPositions(-1, -1);\n      result.reverse();\n      return new DiffAlgorithmResult(result, false);\n    }\n  }]);\n}();","map":{"version":3,"names":["OffsetRange","SequenceDiff","InfiniteTimeout","DiffAlgorithmResult","Array2D","DynamicProgrammingDiffing","_classCallCheck","_createClass","key","value","compute","sequence1","sequence2","timeout","arguments","length","undefined","instance","equalityScore","trivial","lcsLengths","directions","lengths","s1","s2","isValid","trivialTimedOut","horizontalLen","get","verticalLen","extendedSeqScore","getElement","newValue","Math","max","prevLen","set","result","lastAligningPosS1","lastAligningPosS2","reportDecreasingAligningPositions","push","reverse"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../../core/offsetRange.js';\nimport { SequenceDiff, InfiniteTimeout, DiffAlgorithmResult } from './diffAlgorithm.js';\nimport { Array2D } from '../utils.js';\n/**\n * A O(MN) diffing algorithm that supports a score function.\n * The algorithm can be improved by processing the 2d array diagonally.\n*/\nexport class DynamicProgrammingDiffing {\n    compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {\n        if (sequence1.length === 0 || sequence2.length === 0) {\n            return DiffAlgorithmResult.trivial(sequence1, sequence2);\n        }\n        /**\n         * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\n         */\n        const lcsLengths = new Array2D(sequence1.length, sequence2.length);\n        const directions = new Array2D(sequence1.length, sequence2.length);\n        const lengths = new Array2D(sequence1.length, sequence2.length);\n        // ==== Initializing lcsLengths ====\n        for (let s1 = 0; s1 < sequence1.length; s1++) {\n            for (let s2 = 0; s2 < sequence2.length; s2++) {\n                if (!timeout.isValid()) {\n                    return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n                }\n                const horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\n                const verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\n                let extendedSeqScore;\n                if (sequence1.getElement(s1) === sequence2.getElement(s2)) {\n                    if (s1 === 0 || s2 === 0) {\n                        extendedSeqScore = 0;\n                    }\n                    else {\n                        extendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\n                    }\n                    if (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\n                        // Prefer consecutive diagonals\n                        extendedSeqScore += lengths.get(s1 - 1, s2 - 1);\n                    }\n                    extendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\n                }\n                else {\n                    extendedSeqScore = -1;\n                }\n                const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n                if (newValue === extendedSeqScore) {\n                    // Prefer diagonals\n                    const prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\n                    lengths.set(s1, s2, prevLen + 1);\n                    directions.set(s1, s2, 3);\n                }\n                else if (newValue === horizontalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 1);\n                }\n                else if (newValue === verticalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 2);\n                }\n                lcsLengths.set(s1, s2, newValue);\n            }\n        }\n        // ==== Backtracking ====\n        const result = [];\n        let lastAligningPosS1 = sequence1.length;\n        let lastAligningPosS2 = sequence2.length;\n        function reportDecreasingAligningPositions(s1, s2) {\n            if (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(s1 + 1, lastAligningPosS1), new OffsetRange(s2 + 1, lastAligningPosS2)));\n            }\n            lastAligningPosS1 = s1;\n            lastAligningPosS2 = s2;\n        }\n        let s1 = sequence1.length - 1;\n        let s2 = sequence2.length - 1;\n        while (s1 >= 0 && s2 >= 0) {\n            if (directions.get(s1, s2) === 3) {\n                reportDecreasingAligningPositions(s1, s2);\n                s1--;\n                s2--;\n            }\n            else {\n                if (directions.get(s1, s2) === 1) {\n                    s1--;\n                }\n                else {\n                    s2--;\n                }\n            }\n        }\n        reportDecreasingAligningPositions(-1, -1);\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}