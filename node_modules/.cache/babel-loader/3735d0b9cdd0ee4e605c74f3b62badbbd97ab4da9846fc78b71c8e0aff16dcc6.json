{"ast":null,"code":"import _callSuper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _get from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from '../../../../base/browser/browser.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport { RangeUtil } from './rangeUtil.js';\nimport { FloatHorizontalRange, VisibleRanges } from '../../view/renderingContext.js';\nimport { LineDecoration } from '../../../common/viewLayout/lineDecorations.js';\nimport { RenderLineInput, renderViewLine, LineRange, DomPosition } from '../../../common/viewLayout/viewLineRenderer.js';\nimport { isHighContrast } from '../../../../platform/theme/common/theme.js';\nimport { EditorFontLigatures } from '../../../common/config/editorOptions.js';\nvar canUseFastRenderedViewLine = function () {\n  if (platform.isNative) {\n    // In VSCode we know very well when the zoom level changes\n    return true;\n  }\n  if (platform.isLinux || browser.isFirefox || browser.isSafari) {\n    // On Linux, it appears that zooming affects char widths (in pixels), which is unexpected.\n    // --\n    // Even though we read character widths correctly, having read them at a specific zoom level\n    // does not mean they are the same at the current zoom level.\n    // --\n    // This could be improved if we ever figure out how to get an event when browsers zoom,\n    // but until then we have to stick with reading client rects.\n    // --\n    // The same has been observed with Firefox on Windows7\n    // --\n    // The same has been oversved with Safari\n    return false;\n  }\n  return true;\n}();\nvar _monospaceAssumptionsAreValid = true;\nexport var ViewLineOptions = /*#__PURE__*/function () {\n  function ViewLineOptions(config, themeType) {\n    _classCallCheck(this, ViewLineOptions);\n    this.themeType = themeType;\n    var options = config.options;\n    var fontInfo = options.get(50 /* EditorOption.fontInfo */);\n    var experimentalWhitespaceRendering = options.get(38 /* EditorOption.experimentalWhitespaceRendering */);\n    if (experimentalWhitespaceRendering === 'off') {\n      this.renderWhitespace = options.get(99 /* EditorOption.renderWhitespace */);\n    } else {\n      // whitespace is rendered in a different layer\n      this.renderWhitespace = 'none';\n    }\n    this.renderControlCharacters = options.get(94 /* EditorOption.renderControlCharacters */);\n    this.spaceWidth = fontInfo.spaceWidth;\n    this.middotWidth = fontInfo.middotWidth;\n    this.wsmiddotWidth = fontInfo.wsmiddotWidth;\n    this.useMonospaceOptimizations = fontInfo.isMonospace && !options.get(33 /* EditorOption.disableMonospaceOptimizations */);\n    this.canUseHalfwidthRightwardsArrow = fontInfo.canUseHalfwidthRightwardsArrow;\n    this.lineHeight = options.get(67 /* EditorOption.lineHeight */);\n    this.stopRenderingLineAfter = options.get(117 /* EditorOption.stopRenderingLineAfter */);\n    this.fontLigatures = options.get(51 /* EditorOption.fontLigatures */);\n  }\n  return _createClass(ViewLineOptions, [{\n    key: \"equals\",\n    value: function equals(other) {\n      return this.themeType === other.themeType && this.renderWhitespace === other.renderWhitespace && this.renderControlCharacters === other.renderControlCharacters && this.spaceWidth === other.spaceWidth && this.middotWidth === other.middotWidth && this.wsmiddotWidth === other.wsmiddotWidth && this.useMonospaceOptimizations === other.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow && this.lineHeight === other.lineHeight && this.stopRenderingLineAfter === other.stopRenderingLineAfter && this.fontLigatures === other.fontLigatures;\n    }\n  }]);\n}();\nexport var ViewLine = /*#__PURE__*/function () {\n  function ViewLine(options) {\n    _classCallCheck(this, ViewLine);\n    this._options = options;\n    this._isMaybeInvalid = true;\n    this._renderedViewLine = null;\n  }\n  // --- begin IVisibleLineData\n  return _createClass(ViewLine, [{\n    key: \"getDomNode\",\n    value: function getDomNode() {\n      if (this._renderedViewLine && this._renderedViewLine.domNode) {\n        return this._renderedViewLine.domNode.domNode;\n      }\n      return null;\n    }\n  }, {\n    key: \"setDomNode\",\n    value: function setDomNode(domNode) {\n      if (this._renderedViewLine) {\n        this._renderedViewLine.domNode = createFastDomNode(domNode);\n      } else {\n        throw new Error('I have no rendered view line to set the dom node to...');\n      }\n    }\n  }, {\n    key: \"onContentChanged\",\n    value: function onContentChanged() {\n      this._isMaybeInvalid = true;\n    }\n  }, {\n    key: \"onTokensChanged\",\n    value: function onTokensChanged() {\n      this._isMaybeInvalid = true;\n    }\n  }, {\n    key: \"onDecorationsChanged\",\n    value: function onDecorationsChanged() {\n      this._isMaybeInvalid = true;\n    }\n  }, {\n    key: \"onOptionsChanged\",\n    value: function onOptionsChanged(newOptions) {\n      this._isMaybeInvalid = true;\n      this._options = newOptions;\n    }\n  }, {\n    key: \"onSelectionChanged\",\n    value: function onSelectionChanged() {\n      if (isHighContrast(this._options.themeType) || this._options.renderWhitespace === 'selection') {\n        this._isMaybeInvalid = true;\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"renderLine\",\n    value: function renderLine(lineNumber, deltaTop, lineHeight, viewportData, sb) {\n      if (this._isMaybeInvalid === false) {\n        // it appears that nothing relevant has changed\n        return false;\n      }\n      this._isMaybeInvalid = false;\n      var lineData = viewportData.getViewLineRenderingData(lineNumber);\n      var options = this._options;\n      var actualInlineDecorations = LineDecoration.filter(lineData.inlineDecorations, lineNumber, lineData.minColumn, lineData.maxColumn);\n      // Only send selection information when needed for rendering whitespace\n      var selectionsOnLine = null;\n      if (isHighContrast(options.themeType) || this._options.renderWhitespace === 'selection') {\n        var selections = viewportData.selections;\n        var _iterator = _createForOfIteratorHelper(selections),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var selection = _step.value;\n            if (selection.endLineNumber < lineNumber || selection.startLineNumber > lineNumber) {\n              // Selection does not intersect line\n              continue;\n            }\n            var startColumn = selection.startLineNumber === lineNumber ? selection.startColumn : lineData.minColumn;\n            var endColumn = selection.endLineNumber === lineNumber ? selection.endColumn : lineData.maxColumn;\n            if (startColumn < endColumn) {\n              if (isHighContrast(options.themeType)) {\n                actualInlineDecorations.push(new LineDecoration(startColumn, endColumn, 'inline-selected-text', 0 /* InlineDecorationType.Regular */));\n              }\n              if (this._options.renderWhitespace === 'selection') {\n                if (!selectionsOnLine) {\n                  selectionsOnLine = [];\n                }\n                selectionsOnLine.push(new LineRange(startColumn - 1, endColumn - 1));\n              }\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      var renderLineInput = new RenderLineInput(options.useMonospaceOptimizations, options.canUseHalfwidthRightwardsArrow, lineData.content, lineData.continuesWithWrappedLine, lineData.isBasicASCII, lineData.containsRTL, lineData.minColumn - 1, lineData.tokens, actualInlineDecorations, lineData.tabSize, lineData.startVisibleColumn, options.spaceWidth, options.middotWidth, options.wsmiddotWidth, options.stopRenderingLineAfter, options.renderWhitespace, options.renderControlCharacters, options.fontLigatures !== EditorFontLigatures.OFF, selectionsOnLine);\n      if (this._renderedViewLine && this._renderedViewLine.input.equals(renderLineInput)) {\n        // no need to do anything, we have the same render input\n        return false;\n      }\n      sb.appendString('<div style=\"top:');\n      sb.appendString(String(deltaTop));\n      sb.appendString('px;height:');\n      sb.appendString(String(lineHeight));\n      sb.appendString('px;\" class=\"');\n      sb.appendString(ViewLine.CLASS_NAME);\n      sb.appendString('\">');\n      var output = renderViewLine(renderLineInput, sb);\n      sb.appendString('</div>');\n      var renderedViewLine = null;\n      if (_monospaceAssumptionsAreValid && canUseFastRenderedViewLine && lineData.isBasicASCII && options.useMonospaceOptimizations && output.containsForeignElements === 0 /* ForeignElementType.None */) {\n        renderedViewLine = new FastRenderedViewLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, output.characterMapping);\n      }\n      if (!renderedViewLine) {\n        renderedViewLine = createRenderedLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, output.characterMapping, output.containsRTL, output.containsForeignElements);\n      }\n      this._renderedViewLine = renderedViewLine;\n      return true;\n    }\n  }, {\n    key: \"layoutLine\",\n    value: function layoutLine(lineNumber, deltaTop, lineHeight) {\n      if (this._renderedViewLine && this._renderedViewLine.domNode) {\n        this._renderedViewLine.domNode.setTop(deltaTop);\n        this._renderedViewLine.domNode.setHeight(lineHeight);\n      }\n    }\n    // --- end IVisibleLineData\n  }, {\n    key: \"getWidth\",\n    value: function getWidth(context) {\n      if (!this._renderedViewLine) {\n        return 0;\n      }\n      return this._renderedViewLine.getWidth(context);\n    }\n  }, {\n    key: \"getWidthIsFast\",\n    value: function getWidthIsFast() {\n      if (!this._renderedViewLine) {\n        return true;\n      }\n      return this._renderedViewLine.getWidthIsFast();\n    }\n  }, {\n    key: \"needsMonospaceFontCheck\",\n    value: function needsMonospaceFontCheck() {\n      if (!this._renderedViewLine) {\n        return false;\n      }\n      return this._renderedViewLine instanceof FastRenderedViewLine;\n    }\n  }, {\n    key: \"monospaceAssumptionsAreValid\",\n    value: function monospaceAssumptionsAreValid() {\n      if (!this._renderedViewLine) {\n        return _monospaceAssumptionsAreValid;\n      }\n      if (this._renderedViewLine instanceof FastRenderedViewLine) {\n        return this._renderedViewLine.monospaceAssumptionsAreValid();\n      }\n      return _monospaceAssumptionsAreValid;\n    }\n  }, {\n    key: \"onMonospaceAssumptionsInvalidated\",\n    value: function onMonospaceAssumptionsInvalidated() {\n      if (this._renderedViewLine && this._renderedViewLine instanceof FastRenderedViewLine) {\n        this._renderedViewLine = this._renderedViewLine.toSlowRenderedLine();\n      }\n    }\n  }, {\n    key: \"getVisibleRangesForRange\",\n    value: function getVisibleRangesForRange(lineNumber, startColumn, endColumn, context) {\n      if (!this._renderedViewLine) {\n        return null;\n      }\n      startColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, startColumn));\n      endColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, endColumn));\n      var stopRenderingLineAfter = this._renderedViewLine.input.stopRenderingLineAfter;\n      if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1 && endColumn > stopRenderingLineAfter + 1) {\n        // This range is obviously not visible\n        return new VisibleRanges(true, [new FloatHorizontalRange(this.getWidth(context), 0)]);\n      }\n      if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1) {\n        startColumn = stopRenderingLineAfter + 1;\n      }\n      if (stopRenderingLineAfter !== -1 && endColumn > stopRenderingLineAfter + 1) {\n        endColumn = stopRenderingLineAfter + 1;\n      }\n      var horizontalRanges = this._renderedViewLine.getVisibleRangesForRange(lineNumber, startColumn, endColumn, context);\n      if (horizontalRanges && horizontalRanges.length > 0) {\n        return new VisibleRanges(false, horizontalRanges);\n      }\n      return null;\n    }\n  }, {\n    key: \"getColumnOfNodeOffset\",\n    value: function getColumnOfNodeOffset(spanNode, offset) {\n      if (!this._renderedViewLine) {\n        return 1;\n      }\n      return this._renderedViewLine.getColumnOfNodeOffset(spanNode, offset);\n    }\n  }]);\n}();\nViewLine.CLASS_NAME = 'view-line';\n/**\n * A rendered line which is guaranteed to contain only regular ASCII and is rendered with a monospace font.\n */\nvar FastRenderedViewLine = /*#__PURE__*/function () {\n  function FastRenderedViewLine(domNode, renderLineInput, characterMapping) {\n    _classCallCheck(this, FastRenderedViewLine);\n    this._cachedWidth = -1;\n    this.domNode = domNode;\n    this.input = renderLineInput;\n    var keyColumnCount = Math.floor(renderLineInput.lineContent.length / 300 /* Constants.MaxMonospaceDistance */);\n    if (keyColumnCount > 0) {\n      this._keyColumnPixelOffsetCache = new Float32Array(keyColumnCount);\n      for (var i = 0; i < keyColumnCount; i++) {\n        this._keyColumnPixelOffsetCache[i] = -1;\n      }\n    } else {\n      this._keyColumnPixelOffsetCache = null;\n    }\n    this._characterMapping = characterMapping;\n    this._charWidth = renderLineInput.spaceWidth;\n  }\n  return _createClass(FastRenderedViewLine, [{\n    key: \"getWidth\",\n    value: function getWidth(context) {\n      if (!this.domNode || this.input.lineContent.length < 300 /* Constants.MaxMonospaceDistance */) {\n        var horizontalOffset = this._characterMapping.getHorizontalOffset(this._characterMapping.length);\n        return Math.round(this._charWidth * horizontalOffset);\n      }\n      if (this._cachedWidth === -1) {\n        this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth;\n        context === null || context === void 0 ? void 0 : context.markDidDomLayout();\n      }\n      return this._cachedWidth;\n    }\n  }, {\n    key: \"getWidthIsFast\",\n    value: function getWidthIsFast() {\n      return this.input.lineContent.length < 300 /* Constants.MaxMonospaceDistance */ || this._cachedWidth !== -1;\n    }\n  }, {\n    key: \"monospaceAssumptionsAreValid\",\n    value: function monospaceAssumptionsAreValid() {\n      if (!this.domNode) {\n        return _monospaceAssumptionsAreValid;\n      }\n      if (this.input.lineContent.length < 300 /* Constants.MaxMonospaceDistance */) {\n        var expectedWidth = this.getWidth(null);\n        var actualWidth = this.domNode.domNode.firstChild.offsetWidth;\n        if (Math.abs(expectedWidth - actualWidth) >= 2) {\n          // more than 2px off\n          console.warn(\"monospace assumptions have been violated, therefore disabling monospace optimizations!\");\n          _monospaceAssumptionsAreValid = false;\n        }\n      }\n      return _monospaceAssumptionsAreValid;\n    }\n  }, {\n    key: \"toSlowRenderedLine\",\n    value: function toSlowRenderedLine() {\n      return createRenderedLine(this.domNode, this.input, this._characterMapping, false, 0 /* ForeignElementType.None */);\n    }\n  }, {\n    key: \"getVisibleRangesForRange\",\n    value: function getVisibleRangesForRange(lineNumber, startColumn, endColumn, context) {\n      var startPosition = this._getColumnPixelOffset(lineNumber, startColumn, context);\n      var endPosition = this._getColumnPixelOffset(lineNumber, endColumn, context);\n      return [new FloatHorizontalRange(startPosition, endPosition - startPosition)];\n    }\n  }, {\n    key: \"_getColumnPixelOffset\",\n    value: function _getColumnPixelOffset(lineNumber, column, context) {\n      if (column <= 300 /* Constants.MaxMonospaceDistance */) {\n        var _horizontalOffset = this._characterMapping.getHorizontalOffset(column);\n        return this._charWidth * _horizontalOffset;\n      }\n      var keyColumnOrdinal = Math.floor((column - 1) / 300 /* Constants.MaxMonospaceDistance */) - 1;\n      var keyColumn = (keyColumnOrdinal + 1) * 300 /* Constants.MaxMonospaceDistance */ + 1;\n      var keyColumnPixelOffset = -1;\n      if (this._keyColumnPixelOffsetCache) {\n        keyColumnPixelOffset = this._keyColumnPixelOffsetCache[keyColumnOrdinal];\n        if (keyColumnPixelOffset === -1) {\n          keyColumnPixelOffset = this._actualReadPixelOffset(lineNumber, keyColumn, context);\n          this._keyColumnPixelOffsetCache[keyColumnOrdinal] = keyColumnPixelOffset;\n        }\n      }\n      if (keyColumnPixelOffset === -1) {\n        // Could not read actual key column pixel offset\n        var _horizontalOffset2 = this._characterMapping.getHorizontalOffset(column);\n        return this._charWidth * _horizontalOffset2;\n      }\n      var keyColumnHorizontalOffset = this._characterMapping.getHorizontalOffset(keyColumn);\n      var horizontalOffset = this._characterMapping.getHorizontalOffset(column);\n      return keyColumnPixelOffset + this._charWidth * (horizontalOffset - keyColumnHorizontalOffset);\n    }\n  }, {\n    key: \"_getReadingTarget\",\n    value: function _getReadingTarget(myDomNode) {\n      return myDomNode.domNode.firstChild;\n    }\n  }, {\n    key: \"_actualReadPixelOffset\",\n    value: function _actualReadPixelOffset(lineNumber, column, context) {\n      if (!this.domNode) {\n        return -1;\n      }\n      var domPosition = this._characterMapping.getDomPosition(column);\n      var r = RangeUtil.readHorizontalRanges(this._getReadingTarget(this.domNode), domPosition.partIndex, domPosition.charIndex, domPosition.partIndex, domPosition.charIndex, context);\n      if (!r || r.length === 0) {\n        return -1;\n      }\n      return r[0].left;\n    }\n  }, {\n    key: \"getColumnOfNodeOffset\",\n    value: function getColumnOfNodeOffset(spanNode, offset) {\n      return _getColumnOfNodeOffset(this._characterMapping, spanNode, offset);\n    }\n  }]);\n}();\n/**\n * Every time we render a line, we save what we have rendered in an instance of this class.\n */\nvar RenderedViewLine = /*#__PURE__*/function () {\n  function RenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\n    _classCallCheck(this, RenderedViewLine);\n    this.domNode = domNode;\n    this.input = renderLineInput;\n    this._characterMapping = characterMapping;\n    this._isWhitespaceOnly = /^\\s*$/.test(renderLineInput.lineContent);\n    this._containsForeignElements = containsForeignElements;\n    this._cachedWidth = -1;\n    this._pixelOffsetCache = null;\n    if (!containsRTL || this._characterMapping.length === 0 /* the line is empty */) {\n      this._pixelOffsetCache = new Float32Array(Math.max(2, this._characterMapping.length + 1));\n      for (var column = 0, len = this._characterMapping.length; column <= len; column++) {\n        this._pixelOffsetCache[column] = -1;\n      }\n    }\n  }\n  // --- Reading from the DOM methods\n  return _createClass(RenderedViewLine, [{\n    key: \"_getReadingTarget\",\n    value: function _getReadingTarget(myDomNode) {\n      return myDomNode.domNode.firstChild;\n    }\n    /**\n     * Width of the line in pixels\n     */\n  }, {\n    key: \"getWidth\",\n    value: function getWidth(context) {\n      if (!this.domNode) {\n        return 0;\n      }\n      if (this._cachedWidth === -1) {\n        this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth;\n        context === null || context === void 0 ? void 0 : context.markDidDomLayout();\n      }\n      return this._cachedWidth;\n    }\n  }, {\n    key: \"getWidthIsFast\",\n    value: function getWidthIsFast() {\n      if (this._cachedWidth === -1) {\n        return false;\n      }\n      return true;\n    }\n    /**\n     * Visible ranges for a model range\n     */\n  }, {\n    key: \"getVisibleRangesForRange\",\n    value: function getVisibleRangesForRange(lineNumber, startColumn, endColumn, context) {\n      if (!this.domNode) {\n        return null;\n      }\n      if (this._pixelOffsetCache !== null) {\n        // the text is LTR\n        var startOffset = this._readPixelOffset(this.domNode, lineNumber, startColumn, context);\n        if (startOffset === -1) {\n          return null;\n        }\n        var endOffset = this._readPixelOffset(this.domNode, lineNumber, endColumn, context);\n        if (endOffset === -1) {\n          return null;\n        }\n        return [new FloatHorizontalRange(startOffset, endOffset - startOffset)];\n      }\n      return this._readVisibleRangesForRange(this.domNode, lineNumber, startColumn, endColumn, context);\n    }\n  }, {\n    key: \"_readVisibleRangesForRange\",\n    value: function _readVisibleRangesForRange(domNode, lineNumber, startColumn, endColumn, context) {\n      if (startColumn === endColumn) {\n        var pixelOffset = this._readPixelOffset(domNode, lineNumber, startColumn, context);\n        if (pixelOffset === -1) {\n          return null;\n        } else {\n          return [new FloatHorizontalRange(pixelOffset, 0)];\n        }\n      } else {\n        return this._readRawVisibleRangesForRange(domNode, startColumn, endColumn, context);\n      }\n    }\n  }, {\n    key: \"_readPixelOffset\",\n    value: function _readPixelOffset(domNode, lineNumber, column, context) {\n      if (this._characterMapping.length === 0) {\n        // This line has no content\n        if (this._containsForeignElements === 0 /* ForeignElementType.None */) {\n          // We can assume the line is really empty\n          return 0;\n        }\n        if (this._containsForeignElements === 2 /* ForeignElementType.After */) {\n          // We have foreign elements after the (empty) line\n          return 0;\n        }\n        if (this._containsForeignElements === 1 /* ForeignElementType.Before */) {\n          // We have foreign elements before the (empty) line\n          return this.getWidth(context);\n        }\n        // We have foreign elements before & after the (empty) line\n        var readingTarget = this._getReadingTarget(domNode);\n        if (readingTarget.firstChild) {\n          context.markDidDomLayout();\n          return readingTarget.firstChild.offsetWidth;\n        } else {\n          return 0;\n        }\n      }\n      if (this._pixelOffsetCache !== null) {\n        // the text is LTR\n        var cachedPixelOffset = this._pixelOffsetCache[column];\n        if (cachedPixelOffset !== -1) {\n          return cachedPixelOffset;\n        }\n        var result = this._actualReadPixelOffset(domNode, lineNumber, column, context);\n        this._pixelOffsetCache[column] = result;\n        return result;\n      }\n      return this._actualReadPixelOffset(domNode, lineNumber, column, context);\n    }\n  }, {\n    key: \"_actualReadPixelOffset\",\n    value: function _actualReadPixelOffset(domNode, lineNumber, column, context) {\n      if (this._characterMapping.length === 0) {\n        // This line has no content\n        var _r = RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), 0, 0, 0, 0, context);\n        if (!_r || _r.length === 0) {\n          return -1;\n        }\n        return _r[0].left;\n      }\n      if (column === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === 0 /* ForeignElementType.None */) {\n        // This branch helps in the case of whitespace only lines which have a width set\n        return this.getWidth(context);\n      }\n      var domPosition = this._characterMapping.getDomPosition(column);\n      var r = RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), domPosition.partIndex, domPosition.charIndex, domPosition.partIndex, domPosition.charIndex, context);\n      if (!r || r.length === 0) {\n        return -1;\n      }\n      var result = r[0].left;\n      if (this.input.isBasicASCII) {\n        var horizontalOffset = this._characterMapping.getHorizontalOffset(column);\n        var expectedResult = Math.round(this.input.spaceWidth * horizontalOffset);\n        if (Math.abs(expectedResult - result) <= 1) {\n          return expectedResult;\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"_readRawVisibleRangesForRange\",\n    value: function _readRawVisibleRangesForRange(domNode, startColumn, endColumn, context) {\n      if (startColumn === 1 && endColumn === this._characterMapping.length) {\n        // This branch helps IE with bidi text & gives a performance boost to other browsers when reading visible ranges for an entire line\n        return [new FloatHorizontalRange(0, this.getWidth(context))];\n      }\n      var startDomPosition = this._characterMapping.getDomPosition(startColumn);\n      var endDomPosition = this._characterMapping.getDomPosition(endColumn);\n      return RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), startDomPosition.partIndex, startDomPosition.charIndex, endDomPosition.partIndex, endDomPosition.charIndex, context);\n    }\n    /**\n     * Returns the column for the text found at a specific offset inside a rendered dom node\n     */\n  }, {\n    key: \"getColumnOfNodeOffset\",\n    value: function getColumnOfNodeOffset(spanNode, offset) {\n      return _getColumnOfNodeOffset(this._characterMapping, spanNode, offset);\n    }\n  }]);\n}();\nvar WebKitRenderedViewLine = /*#__PURE__*/function (_RenderedViewLine) {\n  function WebKitRenderedViewLine() {\n    _classCallCheck(this, WebKitRenderedViewLine);\n    return _callSuper(this, WebKitRenderedViewLine, arguments);\n  }\n  _inherits(WebKitRenderedViewLine, _RenderedViewLine);\n  return _createClass(WebKitRenderedViewLine, [{\n    key: \"_readVisibleRangesForRange\",\n    value: function _readVisibleRangesForRange(domNode, lineNumber, startColumn, endColumn, context) {\n      var output = _get(_getPrototypeOf(WebKitRenderedViewLine.prototype), \"_readVisibleRangesForRange\", this).call(this, domNode, lineNumber, startColumn, endColumn, context);\n      if (!output || output.length === 0 || startColumn === endColumn || startColumn === 1 && endColumn === this._characterMapping.length) {\n        return output;\n      }\n      // WebKit is buggy and returns an expanded range (to contain words in some cases)\n      // The last client rect is enlarged (I think)\n      if (!this.input.containsRTL) {\n        // This is an attempt to patch things up\n        // Find position of last column\n        var endPixelOffset = this._readPixelOffset(domNode, lineNumber, endColumn, context);\n        if (endPixelOffset !== -1) {\n          var lastRange = output[output.length - 1];\n          if (lastRange.left < endPixelOffset) {\n            // Trim down the width of the last visible range to not go after the last column's position\n            lastRange.width = endPixelOffset - lastRange.left;\n          }\n        }\n      }\n      return output;\n    }\n  }]);\n}(RenderedViewLine);\nvar createRenderedLine = function () {\n  if (browser.isWebKit) {\n    return createWebKitRenderedLine;\n  }\n  return createNormalRenderedLine;\n}();\nfunction createWebKitRenderedLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\n  return new WebKitRenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements);\n}\nfunction createNormalRenderedLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\n  return new RenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements);\n}\nfunction _getColumnOfNodeOffset(characterMapping, spanNode, offset) {\n  var spanNodeTextContentLength = spanNode.textContent.length;\n  var spanIndex = -1;\n  while (spanNode) {\n    spanNode = spanNode.previousSibling;\n    spanIndex++;\n  }\n  return characterMapping.getColumn(new DomPosition(spanIndex, offset), spanNodeTextContentLength);\n}\nexport { _getColumnOfNodeOffset as getColumnOfNodeOffset };","map":{"version":3,"names":["browser","createFastDomNode","platform","RangeUtil","FloatHorizontalRange","VisibleRanges","LineDecoration","RenderLineInput","renderViewLine","LineRange","DomPosition","isHighContrast","EditorFontLigatures","canUseFastRenderedViewLine","isNative","isLinux","isFirefox","isSafari","monospaceAssumptionsAreValid","ViewLineOptions","config","themeType","_classCallCheck","options","fontInfo","get","experimentalWhitespaceRendering","renderWhitespace","renderControlCharacters","spaceWidth","middotWidth","wsmiddotWidth","useMonospaceOptimizations","isMonospace","canUseHalfwidthRightwardsArrow","lineHeight","stopRenderingLineAfter","fontLigatures","_createClass","key","value","equals","other","ViewLine","_options","_isMaybeInvalid","_renderedViewLine","getDomNode","domNode","setDomNode","Error","onContentChanged","onTokensChanged","onDecorationsChanged","onOptionsChanged","newOptions","onSelectionChanged","renderLine","lineNumber","deltaTop","viewportData","sb","lineData","getViewLineRenderingData","actualInlineDecorations","filter","inlineDecorations","minColumn","maxColumn","selectionsOnLine","selections","_iterator","_createForOfIteratorHelper","_step","s","n","done","selection","endLineNumber","startLineNumber","startColumn","endColumn","push","err","e","f","renderLineInput","content","continuesWithWrappedLine","isBasicASCII","containsRTL","tokens","tabSize","startVisibleColumn","OFF","input","appendString","String","CLASS_NAME","output","renderedViewLine","containsForeignElements","FastRenderedViewLine","characterMapping","createRenderedLine","layoutLine","setTop","setHeight","getWidth","context","getWidthIsFast","needsMonospaceFontCheck","onMonospaceAssumptionsInvalidated","toSlowRenderedLine","getVisibleRangesForRange","Math","min","lineContent","length","max","horizontalRanges","getColumnOfNodeOffset","spanNode","offset","_cachedWidth","keyColumnCount","floor","_keyColumnPixelOffsetCache","Float32Array","i","_characterMapping","_charWidth","horizontalOffset","getHorizontalOffset","round","_getReadingTarget","offsetWidth","markDidDomLayout","expectedWidth","actualWidth","firstChild","abs","console","warn","startPosition","_getColumnPixelOffset","endPosition","column","keyColumnOrdinal","keyColumn","keyColumnPixelOffset","_actualReadPixelOffset","keyColumnHorizontalOffset","myDomNode","domPosition","getDomPosition","r","readHorizontalRanges","partIndex","charIndex","left","RenderedViewLine","_isWhitespaceOnly","test","_containsForeignElements","_pixelOffsetCache","len","startOffset","_readPixelOffset","endOffset","_readVisibleRangesForRange","pixelOffset","_readRawVisibleRangesForRange","readingTarget","cachedPixelOffset","result","expectedResult","startDomPosition","endDomPosition","WebKitRenderedViewLine","_RenderedViewLine","_callSuper","arguments","_inherits","_get","_getPrototypeOf","prototype","call","endPixelOffset","lastRange","width","isWebKit","createWebKitRenderedLine","createNormalRenderedLine","spanNodeTextContentLength","textContent","spanIndex","previousSibling","getColumn","_getColumnOfNodeOffset"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lines/viewLine.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from '../../../../base/browser/browser.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport { RangeUtil } from './rangeUtil.js';\nimport { FloatHorizontalRange, VisibleRanges } from '../../view/renderingContext.js';\nimport { LineDecoration } from '../../../common/viewLayout/lineDecorations.js';\nimport { RenderLineInput, renderViewLine, LineRange, DomPosition } from '../../../common/viewLayout/viewLineRenderer.js';\nimport { isHighContrast } from '../../../../platform/theme/common/theme.js';\nimport { EditorFontLigatures } from '../../../common/config/editorOptions.js';\nconst canUseFastRenderedViewLine = (function () {\n    if (platform.isNative) {\n        // In VSCode we know very well when the zoom level changes\n        return true;\n    }\n    if (platform.isLinux || browser.isFirefox || browser.isSafari) {\n        // On Linux, it appears that zooming affects char widths (in pixels), which is unexpected.\n        // --\n        // Even though we read character widths correctly, having read them at a specific zoom level\n        // does not mean they are the same at the current zoom level.\n        // --\n        // This could be improved if we ever figure out how to get an event when browsers zoom,\n        // but until then we have to stick with reading client rects.\n        // --\n        // The same has been observed with Firefox on Windows7\n        // --\n        // The same has been oversved with Safari\n        return false;\n    }\n    return true;\n})();\nlet monospaceAssumptionsAreValid = true;\nexport class ViewLineOptions {\n    constructor(config, themeType) {\n        this.themeType = themeType;\n        const options = config.options;\n        const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        const experimentalWhitespaceRendering = options.get(38 /* EditorOption.experimentalWhitespaceRendering */);\n        if (experimentalWhitespaceRendering === 'off') {\n            this.renderWhitespace = options.get(99 /* EditorOption.renderWhitespace */);\n        }\n        else {\n            // whitespace is rendered in a different layer\n            this.renderWhitespace = 'none';\n        }\n        this.renderControlCharacters = options.get(94 /* EditorOption.renderControlCharacters */);\n        this.spaceWidth = fontInfo.spaceWidth;\n        this.middotWidth = fontInfo.middotWidth;\n        this.wsmiddotWidth = fontInfo.wsmiddotWidth;\n        this.useMonospaceOptimizations = (fontInfo.isMonospace\n            && !options.get(33 /* EditorOption.disableMonospaceOptimizations */));\n        this.canUseHalfwidthRightwardsArrow = fontInfo.canUseHalfwidthRightwardsArrow;\n        this.lineHeight = options.get(67 /* EditorOption.lineHeight */);\n        this.stopRenderingLineAfter = options.get(117 /* EditorOption.stopRenderingLineAfter */);\n        this.fontLigatures = options.get(51 /* EditorOption.fontLigatures */);\n    }\n    equals(other) {\n        return (this.themeType === other.themeType\n            && this.renderWhitespace === other.renderWhitespace\n            && this.renderControlCharacters === other.renderControlCharacters\n            && this.spaceWidth === other.spaceWidth\n            && this.middotWidth === other.middotWidth\n            && this.wsmiddotWidth === other.wsmiddotWidth\n            && this.useMonospaceOptimizations === other.useMonospaceOptimizations\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n            && this.lineHeight === other.lineHeight\n            && this.stopRenderingLineAfter === other.stopRenderingLineAfter\n            && this.fontLigatures === other.fontLigatures);\n    }\n}\nexport class ViewLine {\n    constructor(options) {\n        this._options = options;\n        this._isMaybeInvalid = true;\n        this._renderedViewLine = null;\n    }\n    // --- begin IVisibleLineData\n    getDomNode() {\n        if (this._renderedViewLine && this._renderedViewLine.domNode) {\n            return this._renderedViewLine.domNode.domNode;\n        }\n        return null;\n    }\n    setDomNode(domNode) {\n        if (this._renderedViewLine) {\n            this._renderedViewLine.domNode = createFastDomNode(domNode);\n        }\n        else {\n            throw new Error('I have no rendered view line to set the dom node to...');\n        }\n    }\n    onContentChanged() {\n        this._isMaybeInvalid = true;\n    }\n    onTokensChanged() {\n        this._isMaybeInvalid = true;\n    }\n    onDecorationsChanged() {\n        this._isMaybeInvalid = true;\n    }\n    onOptionsChanged(newOptions) {\n        this._isMaybeInvalid = true;\n        this._options = newOptions;\n    }\n    onSelectionChanged() {\n        if (isHighContrast(this._options.themeType) || this._options.renderWhitespace === 'selection') {\n            this._isMaybeInvalid = true;\n            return true;\n        }\n        return false;\n    }\n    renderLine(lineNumber, deltaTop, lineHeight, viewportData, sb) {\n        if (this._isMaybeInvalid === false) {\n            // it appears that nothing relevant has changed\n            return false;\n        }\n        this._isMaybeInvalid = false;\n        const lineData = viewportData.getViewLineRenderingData(lineNumber);\n        const options = this._options;\n        const actualInlineDecorations = LineDecoration.filter(lineData.inlineDecorations, lineNumber, lineData.minColumn, lineData.maxColumn);\n        // Only send selection information when needed for rendering whitespace\n        let selectionsOnLine = null;\n        if (isHighContrast(options.themeType) || this._options.renderWhitespace === 'selection') {\n            const selections = viewportData.selections;\n            for (const selection of selections) {\n                if (selection.endLineNumber < lineNumber || selection.startLineNumber > lineNumber) {\n                    // Selection does not intersect line\n                    continue;\n                }\n                const startColumn = (selection.startLineNumber === lineNumber ? selection.startColumn : lineData.minColumn);\n                const endColumn = (selection.endLineNumber === lineNumber ? selection.endColumn : lineData.maxColumn);\n                if (startColumn < endColumn) {\n                    if (isHighContrast(options.themeType)) {\n                        actualInlineDecorations.push(new LineDecoration(startColumn, endColumn, 'inline-selected-text', 0 /* InlineDecorationType.Regular */));\n                    }\n                    if (this._options.renderWhitespace === 'selection') {\n                        if (!selectionsOnLine) {\n                            selectionsOnLine = [];\n                        }\n                        selectionsOnLine.push(new LineRange(startColumn - 1, endColumn - 1));\n                    }\n                }\n            }\n        }\n        const renderLineInput = new RenderLineInput(options.useMonospaceOptimizations, options.canUseHalfwidthRightwardsArrow, lineData.content, lineData.continuesWithWrappedLine, lineData.isBasicASCII, lineData.containsRTL, lineData.minColumn - 1, lineData.tokens, actualInlineDecorations, lineData.tabSize, lineData.startVisibleColumn, options.spaceWidth, options.middotWidth, options.wsmiddotWidth, options.stopRenderingLineAfter, options.renderWhitespace, options.renderControlCharacters, options.fontLigatures !== EditorFontLigatures.OFF, selectionsOnLine);\n        if (this._renderedViewLine && this._renderedViewLine.input.equals(renderLineInput)) {\n            // no need to do anything, we have the same render input\n            return false;\n        }\n        sb.appendString('<div style=\"top:');\n        sb.appendString(String(deltaTop));\n        sb.appendString('px;height:');\n        sb.appendString(String(lineHeight));\n        sb.appendString('px;\" class=\"');\n        sb.appendString(ViewLine.CLASS_NAME);\n        sb.appendString('\">');\n        const output = renderViewLine(renderLineInput, sb);\n        sb.appendString('</div>');\n        let renderedViewLine = null;\n        if (monospaceAssumptionsAreValid && canUseFastRenderedViewLine && lineData.isBasicASCII && options.useMonospaceOptimizations && output.containsForeignElements === 0 /* ForeignElementType.None */) {\n            renderedViewLine = new FastRenderedViewLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, output.characterMapping);\n        }\n        if (!renderedViewLine) {\n            renderedViewLine = createRenderedLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, output.characterMapping, output.containsRTL, output.containsForeignElements);\n        }\n        this._renderedViewLine = renderedViewLine;\n        return true;\n    }\n    layoutLine(lineNumber, deltaTop, lineHeight) {\n        if (this._renderedViewLine && this._renderedViewLine.domNode) {\n            this._renderedViewLine.domNode.setTop(deltaTop);\n            this._renderedViewLine.domNode.setHeight(lineHeight);\n        }\n    }\n    // --- end IVisibleLineData\n    getWidth(context) {\n        if (!this._renderedViewLine) {\n            return 0;\n        }\n        return this._renderedViewLine.getWidth(context);\n    }\n    getWidthIsFast() {\n        if (!this._renderedViewLine) {\n            return true;\n        }\n        return this._renderedViewLine.getWidthIsFast();\n    }\n    needsMonospaceFontCheck() {\n        if (!this._renderedViewLine) {\n            return false;\n        }\n        return (this._renderedViewLine instanceof FastRenderedViewLine);\n    }\n    monospaceAssumptionsAreValid() {\n        if (!this._renderedViewLine) {\n            return monospaceAssumptionsAreValid;\n        }\n        if (this._renderedViewLine instanceof FastRenderedViewLine) {\n            return this._renderedViewLine.monospaceAssumptionsAreValid();\n        }\n        return monospaceAssumptionsAreValid;\n    }\n    onMonospaceAssumptionsInvalidated() {\n        if (this._renderedViewLine && this._renderedViewLine instanceof FastRenderedViewLine) {\n            this._renderedViewLine = this._renderedViewLine.toSlowRenderedLine();\n        }\n    }\n    getVisibleRangesForRange(lineNumber, startColumn, endColumn, context) {\n        if (!this._renderedViewLine) {\n            return null;\n        }\n        startColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, startColumn));\n        endColumn = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, endColumn));\n        const stopRenderingLineAfter = this._renderedViewLine.input.stopRenderingLineAfter;\n        if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1 && endColumn > stopRenderingLineAfter + 1) {\n            // This range is obviously not visible\n            return new VisibleRanges(true, [new FloatHorizontalRange(this.getWidth(context), 0)]);\n        }\n        if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter + 1) {\n            startColumn = stopRenderingLineAfter + 1;\n        }\n        if (stopRenderingLineAfter !== -1 && endColumn > stopRenderingLineAfter + 1) {\n            endColumn = stopRenderingLineAfter + 1;\n        }\n        const horizontalRanges = this._renderedViewLine.getVisibleRangesForRange(lineNumber, startColumn, endColumn, context);\n        if (horizontalRanges && horizontalRanges.length > 0) {\n            return new VisibleRanges(false, horizontalRanges);\n        }\n        return null;\n    }\n    getColumnOfNodeOffset(spanNode, offset) {\n        if (!this._renderedViewLine) {\n            return 1;\n        }\n        return this._renderedViewLine.getColumnOfNodeOffset(spanNode, offset);\n    }\n}\nViewLine.CLASS_NAME = 'view-line';\n/**\n * A rendered line which is guaranteed to contain only regular ASCII and is rendered with a monospace font.\n */\nclass FastRenderedViewLine {\n    constructor(domNode, renderLineInput, characterMapping) {\n        this._cachedWidth = -1;\n        this.domNode = domNode;\n        this.input = renderLineInput;\n        const keyColumnCount = Math.floor(renderLineInput.lineContent.length / 300 /* Constants.MaxMonospaceDistance */);\n        if (keyColumnCount > 0) {\n            this._keyColumnPixelOffsetCache = new Float32Array(keyColumnCount);\n            for (let i = 0; i < keyColumnCount; i++) {\n                this._keyColumnPixelOffsetCache[i] = -1;\n            }\n        }\n        else {\n            this._keyColumnPixelOffsetCache = null;\n        }\n        this._characterMapping = characterMapping;\n        this._charWidth = renderLineInput.spaceWidth;\n    }\n    getWidth(context) {\n        if (!this.domNode || this.input.lineContent.length < 300 /* Constants.MaxMonospaceDistance */) {\n            const horizontalOffset = this._characterMapping.getHorizontalOffset(this._characterMapping.length);\n            return Math.round(this._charWidth * horizontalOffset);\n        }\n        if (this._cachedWidth === -1) {\n            this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth;\n            context === null || context === void 0 ? void 0 : context.markDidDomLayout();\n        }\n        return this._cachedWidth;\n    }\n    getWidthIsFast() {\n        return (this.input.lineContent.length < 300 /* Constants.MaxMonospaceDistance */) || this._cachedWidth !== -1;\n    }\n    monospaceAssumptionsAreValid() {\n        if (!this.domNode) {\n            return monospaceAssumptionsAreValid;\n        }\n        if (this.input.lineContent.length < 300 /* Constants.MaxMonospaceDistance */) {\n            const expectedWidth = this.getWidth(null);\n            const actualWidth = this.domNode.domNode.firstChild.offsetWidth;\n            if (Math.abs(expectedWidth - actualWidth) >= 2) {\n                // more than 2px off\n                console.warn(`monospace assumptions have been violated, therefore disabling monospace optimizations!`);\n                monospaceAssumptionsAreValid = false;\n            }\n        }\n        return monospaceAssumptionsAreValid;\n    }\n    toSlowRenderedLine() {\n        return createRenderedLine(this.domNode, this.input, this._characterMapping, false, 0 /* ForeignElementType.None */);\n    }\n    getVisibleRangesForRange(lineNumber, startColumn, endColumn, context) {\n        const startPosition = this._getColumnPixelOffset(lineNumber, startColumn, context);\n        const endPosition = this._getColumnPixelOffset(lineNumber, endColumn, context);\n        return [new FloatHorizontalRange(startPosition, endPosition - startPosition)];\n    }\n    _getColumnPixelOffset(lineNumber, column, context) {\n        if (column <= 300 /* Constants.MaxMonospaceDistance */) {\n            const horizontalOffset = this._characterMapping.getHorizontalOffset(column);\n            return this._charWidth * horizontalOffset;\n        }\n        const keyColumnOrdinal = Math.floor((column - 1) / 300 /* Constants.MaxMonospaceDistance */) - 1;\n        const keyColumn = (keyColumnOrdinal + 1) * 300 /* Constants.MaxMonospaceDistance */ + 1;\n        let keyColumnPixelOffset = -1;\n        if (this._keyColumnPixelOffsetCache) {\n            keyColumnPixelOffset = this._keyColumnPixelOffsetCache[keyColumnOrdinal];\n            if (keyColumnPixelOffset === -1) {\n                keyColumnPixelOffset = this._actualReadPixelOffset(lineNumber, keyColumn, context);\n                this._keyColumnPixelOffsetCache[keyColumnOrdinal] = keyColumnPixelOffset;\n            }\n        }\n        if (keyColumnPixelOffset === -1) {\n            // Could not read actual key column pixel offset\n            const horizontalOffset = this._characterMapping.getHorizontalOffset(column);\n            return this._charWidth * horizontalOffset;\n        }\n        const keyColumnHorizontalOffset = this._characterMapping.getHorizontalOffset(keyColumn);\n        const horizontalOffset = this._characterMapping.getHorizontalOffset(column);\n        return keyColumnPixelOffset + this._charWidth * (horizontalOffset - keyColumnHorizontalOffset);\n    }\n    _getReadingTarget(myDomNode) {\n        return myDomNode.domNode.firstChild;\n    }\n    _actualReadPixelOffset(lineNumber, column, context) {\n        if (!this.domNode) {\n            return -1;\n        }\n        const domPosition = this._characterMapping.getDomPosition(column);\n        const r = RangeUtil.readHorizontalRanges(this._getReadingTarget(this.domNode), domPosition.partIndex, domPosition.charIndex, domPosition.partIndex, domPosition.charIndex, context);\n        if (!r || r.length === 0) {\n            return -1;\n        }\n        return r[0].left;\n    }\n    getColumnOfNodeOffset(spanNode, offset) {\n        return getColumnOfNodeOffset(this._characterMapping, spanNode, offset);\n    }\n}\n/**\n * Every time we render a line, we save what we have rendered in an instance of this class.\n */\nclass RenderedViewLine {\n    constructor(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\n        this.domNode = domNode;\n        this.input = renderLineInput;\n        this._characterMapping = characterMapping;\n        this._isWhitespaceOnly = /^\\s*$/.test(renderLineInput.lineContent);\n        this._containsForeignElements = containsForeignElements;\n        this._cachedWidth = -1;\n        this._pixelOffsetCache = null;\n        if (!containsRTL || this._characterMapping.length === 0 /* the line is empty */) {\n            this._pixelOffsetCache = new Float32Array(Math.max(2, this._characterMapping.length + 1));\n            for (let column = 0, len = this._characterMapping.length; column <= len; column++) {\n                this._pixelOffsetCache[column] = -1;\n            }\n        }\n    }\n    // --- Reading from the DOM methods\n    _getReadingTarget(myDomNode) {\n        return myDomNode.domNode.firstChild;\n    }\n    /**\n     * Width of the line in pixels\n     */\n    getWidth(context) {\n        if (!this.domNode) {\n            return 0;\n        }\n        if (this._cachedWidth === -1) {\n            this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth;\n            context === null || context === void 0 ? void 0 : context.markDidDomLayout();\n        }\n        return this._cachedWidth;\n    }\n    getWidthIsFast() {\n        if (this._cachedWidth === -1) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Visible ranges for a model range\n     */\n    getVisibleRangesForRange(lineNumber, startColumn, endColumn, context) {\n        if (!this.domNode) {\n            return null;\n        }\n        if (this._pixelOffsetCache !== null) {\n            // the text is LTR\n            const startOffset = this._readPixelOffset(this.domNode, lineNumber, startColumn, context);\n            if (startOffset === -1) {\n                return null;\n            }\n            const endOffset = this._readPixelOffset(this.domNode, lineNumber, endColumn, context);\n            if (endOffset === -1) {\n                return null;\n            }\n            return [new FloatHorizontalRange(startOffset, endOffset - startOffset)];\n        }\n        return this._readVisibleRangesForRange(this.domNode, lineNumber, startColumn, endColumn, context);\n    }\n    _readVisibleRangesForRange(domNode, lineNumber, startColumn, endColumn, context) {\n        if (startColumn === endColumn) {\n            const pixelOffset = this._readPixelOffset(domNode, lineNumber, startColumn, context);\n            if (pixelOffset === -1) {\n                return null;\n            }\n            else {\n                return [new FloatHorizontalRange(pixelOffset, 0)];\n            }\n        }\n        else {\n            return this._readRawVisibleRangesForRange(domNode, startColumn, endColumn, context);\n        }\n    }\n    _readPixelOffset(domNode, lineNumber, column, context) {\n        if (this._characterMapping.length === 0) {\n            // This line has no content\n            if (this._containsForeignElements === 0 /* ForeignElementType.None */) {\n                // We can assume the line is really empty\n                return 0;\n            }\n            if (this._containsForeignElements === 2 /* ForeignElementType.After */) {\n                // We have foreign elements after the (empty) line\n                return 0;\n            }\n            if (this._containsForeignElements === 1 /* ForeignElementType.Before */) {\n                // We have foreign elements before the (empty) line\n                return this.getWidth(context);\n            }\n            // We have foreign elements before & after the (empty) line\n            const readingTarget = this._getReadingTarget(domNode);\n            if (readingTarget.firstChild) {\n                context.markDidDomLayout();\n                return readingTarget.firstChild.offsetWidth;\n            }\n            else {\n                return 0;\n            }\n        }\n        if (this._pixelOffsetCache !== null) {\n            // the text is LTR\n            const cachedPixelOffset = this._pixelOffsetCache[column];\n            if (cachedPixelOffset !== -1) {\n                return cachedPixelOffset;\n            }\n            const result = this._actualReadPixelOffset(domNode, lineNumber, column, context);\n            this._pixelOffsetCache[column] = result;\n            return result;\n        }\n        return this._actualReadPixelOffset(domNode, lineNumber, column, context);\n    }\n    _actualReadPixelOffset(domNode, lineNumber, column, context) {\n        if (this._characterMapping.length === 0) {\n            // This line has no content\n            const r = RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), 0, 0, 0, 0, context);\n            if (!r || r.length === 0) {\n                return -1;\n            }\n            return r[0].left;\n        }\n        if (column === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === 0 /* ForeignElementType.None */) {\n            // This branch helps in the case of whitespace only lines which have a width set\n            return this.getWidth(context);\n        }\n        const domPosition = this._characterMapping.getDomPosition(column);\n        const r = RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), domPosition.partIndex, domPosition.charIndex, domPosition.partIndex, domPosition.charIndex, context);\n        if (!r || r.length === 0) {\n            return -1;\n        }\n        const result = r[0].left;\n        if (this.input.isBasicASCII) {\n            const horizontalOffset = this._characterMapping.getHorizontalOffset(column);\n            const expectedResult = Math.round(this.input.spaceWidth * horizontalOffset);\n            if (Math.abs(expectedResult - result) <= 1) {\n                return expectedResult;\n            }\n        }\n        return result;\n    }\n    _readRawVisibleRangesForRange(domNode, startColumn, endColumn, context) {\n        if (startColumn === 1 && endColumn === this._characterMapping.length) {\n            // This branch helps IE with bidi text & gives a performance boost to other browsers when reading visible ranges for an entire line\n            return [new FloatHorizontalRange(0, this.getWidth(context))];\n        }\n        const startDomPosition = this._characterMapping.getDomPosition(startColumn);\n        const endDomPosition = this._characterMapping.getDomPosition(endColumn);\n        return RangeUtil.readHorizontalRanges(this._getReadingTarget(domNode), startDomPosition.partIndex, startDomPosition.charIndex, endDomPosition.partIndex, endDomPosition.charIndex, context);\n    }\n    /**\n     * Returns the column for the text found at a specific offset inside a rendered dom node\n     */\n    getColumnOfNodeOffset(spanNode, offset) {\n        return getColumnOfNodeOffset(this._characterMapping, spanNode, offset);\n    }\n}\nclass WebKitRenderedViewLine extends RenderedViewLine {\n    _readVisibleRangesForRange(domNode, lineNumber, startColumn, endColumn, context) {\n        const output = super._readVisibleRangesForRange(domNode, lineNumber, startColumn, endColumn, context);\n        if (!output || output.length === 0 || startColumn === endColumn || (startColumn === 1 && endColumn === this._characterMapping.length)) {\n            return output;\n        }\n        // WebKit is buggy and returns an expanded range (to contain words in some cases)\n        // The last client rect is enlarged (I think)\n        if (!this.input.containsRTL) {\n            // This is an attempt to patch things up\n            // Find position of last column\n            const endPixelOffset = this._readPixelOffset(domNode, lineNumber, endColumn, context);\n            if (endPixelOffset !== -1) {\n                const lastRange = output[output.length - 1];\n                if (lastRange.left < endPixelOffset) {\n                    // Trim down the width of the last visible range to not go after the last column's position\n                    lastRange.width = endPixelOffset - lastRange.left;\n                }\n            }\n        }\n        return output;\n    }\n}\nconst createRenderedLine = (function () {\n    if (browser.isWebKit) {\n        return createWebKitRenderedLine;\n    }\n    return createNormalRenderedLine;\n})();\nfunction createWebKitRenderedLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\n    return new WebKitRenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements);\n}\nfunction createNormalRenderedLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements) {\n    return new RenderedViewLine(domNode, renderLineInput, characterMapping, containsRTL, containsForeignElements);\n}\nexport function getColumnOfNodeOffset(characterMapping, spanNode, offset) {\n    const spanNodeTextContentLength = spanNode.textContent.length;\n    let spanIndex = -1;\n    while (spanNode) {\n        spanNode = spanNode.previousSibling;\n        spanIndex++;\n    }\n    return characterMapping.getColumn(new DomPosition(spanIndex, offset), spanNodeTextContentLength);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}