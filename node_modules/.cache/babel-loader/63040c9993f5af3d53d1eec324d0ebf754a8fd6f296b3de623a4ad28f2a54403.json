{"ast":null,"code":"import _callSuper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _get from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.last-index-of.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.string.ends-with.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.string.starts-with.js\";\nimport \"core-js/modules/es.string.substr.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { CompositionSurroundSelectionCommand, SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nimport { IndentAction } from '../languages/languageConfiguration.js';\nimport { getIndentationAtPosition } from '../languages/languageConfigurationRegistry.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nimport { getIndentActionForType, getIndentForEnter, getInheritIndentForLine } from '../languages/autoIndent.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nexport var TypeOperations = /*#__PURE__*/function () {\n  function TypeOperations() {\n    _classCallCheck(this, TypeOperations);\n  }\n  return _createClass(TypeOperations, null, [{\n    key: \"indent\",\n    value: function indent(config, model, selections) {\n      if (model === null || selections === null) {\n        return [];\n      }\n      var commands = [];\n      for (var i = 0, len = selections.length; i < len; i++) {\n        commands[i] = new ShiftCommand(selections[i], {\n          isUnshift: false,\n          tabSize: config.tabSize,\n          indentSize: config.indentSize,\n          insertSpaces: config.insertSpaces,\n          useTabStops: config.useTabStops,\n          autoIndent: config.autoIndent\n        }, config.languageConfigurationService);\n      }\n      return commands;\n    }\n  }, {\n    key: \"outdent\",\n    value: function outdent(config, model, selections) {\n      var commands = [];\n      for (var i = 0, len = selections.length; i < len; i++) {\n        commands[i] = new ShiftCommand(selections[i], {\n          isUnshift: true,\n          tabSize: config.tabSize,\n          indentSize: config.indentSize,\n          insertSpaces: config.insertSpaces,\n          useTabStops: config.useTabStops,\n          autoIndent: config.autoIndent\n        }, config.languageConfigurationService);\n      }\n      return commands;\n    }\n  }, {\n    key: \"shiftIndent\",\n    value: function shiftIndent(config, indentation, count) {\n      count = count || 1;\n      return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n  }, {\n    key: \"unshiftIndent\",\n    value: function unshiftIndent(config, indentation, count) {\n      count = count || 1;\n      return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n  }, {\n    key: \"_distributedPaste\",\n    value: function _distributedPaste(config, model, selections, text) {\n      var commands = [];\n      for (var i = 0, len = selections.length; i < len; i++) {\n        commands[i] = new ReplaceCommand(selections[i], text[i]);\n      }\n      return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: true\n      });\n    }\n  }, {\n    key: \"_simplePaste\",\n    value: function _simplePaste(config, model, selections, text, pasteOnNewLine) {\n      var commands = [];\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n        var position = selection.getPosition();\n        if (pasteOnNewLine && !selection.isEmpty()) {\n          pasteOnNewLine = false;\n        }\n        if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n          pasteOnNewLine = false;\n        }\n        if (pasteOnNewLine) {\n          // Paste entire line at the beginning of line\n          var typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n          commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n        } else {\n          commands[i] = new ReplaceCommand(selection, text);\n        }\n      }\n      return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: true\n      });\n    }\n  }, {\n    key: \"_distributePasteToCursors\",\n    value: function _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n      if (pasteOnNewLine) {\n        return null;\n      }\n      if (selections.length === 1) {\n        return null;\n      }\n      if (multicursorText && multicursorText.length === selections.length) {\n        return multicursorText;\n      }\n      if (config.multiCursorPaste === 'spread') {\n        // Try to spread the pasted text in case the line count matches the cursor count\n        // Remove trailing \\n if present\n        if (text.charCodeAt(text.length - 1) === 10 /* CharCode.LineFeed */) {\n          text = text.substr(0, text.length - 1);\n        }\n        // Remove trailing \\r if present\n        if (text.charCodeAt(text.length - 1) === 13 /* CharCode.CarriageReturn */) {\n          text = text.substr(0, text.length - 1);\n        }\n        var lines = strings.splitLines(text);\n        if (lines.length === selections.length) {\n          return lines;\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"paste\",\n    value: function paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n      var distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n      if (distributedPaste) {\n        selections = selections.sort(Range.compareRangesUsingStarts);\n        return this._distributedPaste(config, model, selections, distributedPaste);\n      } else {\n        return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n      }\n    }\n  }, {\n    key: \"_goodIndentForLine\",\n    value: function _goodIndentForLine(config, model, lineNumber) {\n      var action = null;\n      var indentation = '';\n      var expectedIndentAction = getInheritIndentForLine(config.autoIndent, model, lineNumber, false, config.languageConfigurationService);\n      if (expectedIndentAction) {\n        action = expectedIndentAction.action;\n        indentation = expectedIndentAction.indentation;\n      } else if (lineNumber > 1) {\n        var lastLineNumber;\n        for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n          var lineText = model.getLineContent(lastLineNumber);\n          var nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n          if (nonWhitespaceIdx >= 0) {\n            break;\n          }\n        }\n        if (lastLineNumber < 1) {\n          // No previous line with content found\n          return null;\n        }\n        var maxColumn = model.getLineMaxColumn(lastLineNumber);\n        var expectedEnterAction = getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn), config.languageConfigurationService);\n        if (expectedEnterAction) {\n          indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n        }\n      }\n      if (action) {\n        if (action === IndentAction.Indent) {\n          indentation = TypeOperations.shiftIndent(config, indentation);\n        }\n        if (action === IndentAction.Outdent) {\n          indentation = TypeOperations.unshiftIndent(config, indentation);\n        }\n        indentation = config.normalizeIndentation(indentation);\n      }\n      if (!indentation) {\n        return null;\n      }\n      return indentation;\n    }\n  }, {\n    key: \"_replaceJumpToNextIndent\",\n    value: function _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n      var typeText = '';\n      var position = selection.getStartPosition();\n      if (config.insertSpaces) {\n        var visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n        var indentSize = config.indentSize;\n        var spacesCnt = indentSize - visibleColumnFromColumn % indentSize;\n        for (var i = 0; i < spacesCnt; i++) {\n          typeText += ' ';\n        }\n      } else {\n        typeText = '\\t';\n      }\n      return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n    }\n  }, {\n    key: \"tab\",\n    value: function tab(config, model, selections) {\n      var commands = [];\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n        if (selection.isEmpty()) {\n          var lineText = model.getLineContent(selection.startLineNumber);\n          if (/^\\s*$/.test(lineText) && model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n            var goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n            goodIndent = goodIndent || '\\t';\n            var possibleTypeText = config.normalizeIndentation(goodIndent);\n            if (!lineText.startsWith(possibleTypeText)) {\n              commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n              continue;\n            }\n          }\n          commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n        } else {\n          if (selection.startLineNumber === selection.endLineNumber) {\n            var lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n            if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n              // This is a single line selection that is not the entire line\n              commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n              continue;\n            }\n          }\n          commands[i] = new ShiftCommand(selection, {\n            isUnshift: false,\n            tabSize: config.tabSize,\n            indentSize: config.indentSize,\n            insertSpaces: config.insertSpaces,\n            useTabStops: config.useTabStops,\n            autoIndent: config.autoIndent\n          }, config.languageConfigurationService);\n        }\n      }\n      return commands;\n    }\n  }, {\n    key: \"compositionType\",\n    value: function compositionType(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n      var _this = this;\n      var commands = selections.map(function (selection) {\n        return _this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta);\n      });\n      return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n        shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n        shouldPushStackElementAfter: false\n      });\n    }\n  }, {\n    key: \"_compositionType\",\n    value: function _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n      if (!selection.isEmpty()) {\n        // looks like https://github.com/microsoft/vscode/issues/2773\n        // where a cursor operation occurred before a canceled composition\n        // => ignore composition\n        return null;\n      }\n      var pos = selection.getPosition();\n      var startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n      var endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n      var range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n      var oldText = model.getValueInRange(range);\n      if (oldText === text && positionDelta === 0) {\n        // => ignore composition that doesn't do anything\n        return null;\n      }\n      return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n    }\n  }, {\n    key: \"_typeCommand\",\n    value: function _typeCommand(range, text, keepPosition) {\n      if (keepPosition) {\n        return new ReplaceCommandWithoutChangingPosition(range, text, true);\n      } else {\n        return new ReplaceCommand(range, text, true);\n      }\n    }\n  }, {\n    key: \"_enter\",\n    value: function _enter(config, model, keepPosition, range) {\n      if (config.autoIndent === 0 /* EditorAutoIndentStrategy.None */) {\n        return TypeOperations._typeCommand(range, '\\n', keepPosition);\n      }\n      if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* EditorAutoIndentStrategy.Keep */) {\n        var _lineText = model.getLineContent(range.startLineNumber);\n        var _indentation = strings.getLeadingWhitespace(_lineText).substring(0, range.startColumn - 1);\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(_indentation), keepPosition);\n      }\n      var r = getEnterAction(config.autoIndent, model, range, config.languageConfigurationService);\n      if (r) {\n        if (r.indentAction === IndentAction.None) {\n          // Nothing special\n          return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n        } else if (r.indentAction === IndentAction.Indent) {\n          // Indent once\n          return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n        } else if (r.indentAction === IndentAction.IndentOutdent) {\n          // Ultra special\n          var normalIndent = config.normalizeIndentation(r.indentation);\n          var increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n          var typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n          if (keepPosition) {\n            return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n          } else {\n            return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n          }\n        } else if (r.indentAction === IndentAction.Outdent) {\n          var actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\n          return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n        }\n      }\n      var lineText = model.getLineContent(range.startLineNumber);\n      var indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n      if (config.autoIndent >= 4 /* EditorAutoIndentStrategy.Full */) {\n        var ir = getIndentForEnter(config.autoIndent, model, range, {\n          unshiftIndent: function unshiftIndent(indent) {\n            return TypeOperations.unshiftIndent(config, indent);\n          },\n          shiftIndent: function shiftIndent(indent) {\n            return TypeOperations.shiftIndent(config, indent);\n          },\n          normalizeIndentation: function normalizeIndentation(indent) {\n            return config.normalizeIndentation(indent);\n          }\n        }, config.languageConfigurationService);\n        if (ir) {\n          var oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n          var oldEndColumn = range.endColumn;\n          var newLineContent = model.getLineContent(range.endLineNumber);\n          var firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n          if (firstNonWhitespace >= 0) {\n            range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n          } else {\n            range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n          }\n          if (keepPosition) {\n            return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n          } else {\n            var offset = 0;\n            if (oldEndColumn <= firstNonWhitespace + 1) {\n              if (!config.insertSpaces) {\n                oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n              }\n              offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n            }\n            return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n          }\n        }\n      }\n      return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n  }, {\n    key: \"_isAutoIndentType\",\n    value: function _isAutoIndentType(config, model, selections) {\n      if (config.autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return false;\n      }\n      for (var i = 0, len = selections.length; i < len; i++) {\n        if (!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"_runAutoIndentType\",\n    value: function _runAutoIndentType(config, model, range, ch) {\n      var currentIndentation = getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n      var actualIndentation = getIndentActionForType(config.autoIndent, model, range, ch, {\n        shiftIndent: function shiftIndent(indentation) {\n          return TypeOperations.shiftIndent(config, indentation);\n        },\n        unshiftIndent: function unshiftIndent(indentation) {\n          return TypeOperations.unshiftIndent(config, indentation);\n        }\n      }, config.languageConfigurationService);\n      if (actualIndentation === null) {\n        return null;\n      }\n      if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n        var firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n        if (firstNonWhitespace === 0) {\n          return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n        } else {\n          return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_isAutoClosingOvertype\",\n    value: function _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n      if (config.autoClosingOvertype === 'never') {\n        return false;\n      }\n      if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n        return false;\n      }\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n        if (!selection.isEmpty()) {\n          return false;\n        }\n        var position = selection.getPosition();\n        var lineText = model.getLineContent(position.lineNumber);\n        var afterCharacter = lineText.charAt(position.column - 1);\n        if (afterCharacter !== ch) {\n          return false;\n        }\n        // Do not over-type quotes after a backslash\n        var chIsQuote = isQuote(ch);\n        var beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* CharCode.Null */;\n        if (beforeCharacter === 92 /* CharCode.Backslash */ && chIsQuote) {\n          return false;\n        }\n        // Must over-type a closing character typed by the editor\n        if (config.autoClosingOvertype === 'auto') {\n          var found = false;\n          for (var j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n            var autoClosedCharacter = autoClosedCharacters[j];\n            if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"_runAutoClosingOvertype\",\n    value: function _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\n      var commands = [];\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n        var position = selection.getPosition();\n        var typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n        commands[i] = new ReplaceCommand(typeSelection, ch);\n      }\n      return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n        shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n        shouldPushStackElementAfter: false\n      });\n    }\n  }, {\n    key: \"_isBeforeClosingBrace\",\n    value: function _isBeforeClosingBrace(config, lineAfter) {\n      // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n      var nextChar = lineAfter.charAt(0);\n      var potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n      var potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n      var isBeforeStartingBrace = potentialStartingBraces.some(function (x) {\n        return lineAfter.startsWith(x.open);\n      });\n      var isBeforeClosingBrace = potentialClosingBraces.some(function (x) {\n        return lineAfter.startsWith(x.close);\n      });\n      return !isBeforeStartingBrace && isBeforeClosingBrace;\n    }\n    /**\n     * Determine if typing `ch` at all `positions` in the `model` results in an\n     * auto closing open sequence being typed.\n     *\n     * Auto closing open sequences can consist of multiple characters, which\n     * can lead to ambiguities. In such a case, the longest auto-closing open\n     * sequence is returned.\n     */\n  }, {\n    key: \"_findAutoClosingPairOpen\",\n    value: function _findAutoClosingPairOpen(config, model, positions, ch) {\n      var candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n      if (!candidates) {\n        return null;\n      }\n      // Determine which auto-closing pair it is\n      var result = null;\n      var _iterator = _createForOfIteratorHelper(candidates),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var candidate = _step.value;\n          if (result === null || candidate.open.length > result.open.length) {\n            var candidateIsMatch = true;\n            var _iterator2 = _createForOfIteratorHelper(positions),\n              _step2;\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var position = _step2.value;\n                var relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n                if (relevantText + ch !== candidate.open) {\n                  candidateIsMatch = false;\n                  break;\n                }\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n            if (candidateIsMatch) {\n              result = candidate;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return result;\n    }\n    /**\n     * Find another auto-closing pair that is contained by the one passed in.\n     *\n     * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n     * this method will find [(,)] as a containment pair for [(*,*)]\n     */\n  }, {\n    key: \"_findContainedAutoClosingPair\",\n    value: function _findContainedAutoClosingPair(config, pair) {\n      if (pair.open.length <= 1) {\n        return null;\n      }\n      var lastChar = pair.close.charAt(pair.close.length - 1);\n      // get candidates with the same last character as close\n      var candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n      var result = null;\n      var _iterator3 = _createForOfIteratorHelper(candidates),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var candidate = _step3.value;\n          if (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n            if (!result || candidate.open.length > result.open.length) {\n              result = candidate;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return result;\n    }\n  }, {\n    key: \"_getAutoClosingPairClose\",\n    value: function _getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped) {\n      var _iterator4 = _createForOfIteratorHelper(selections),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var selection = _step4.value;\n          if (!selection.isEmpty()) {\n            return null;\n          }\n        }\n        // This method is called both when typing (regularly) and when composition ends\n        // This means that we need to work with a text buffer where sometimes `ch` is not\n        // there (it is being typed right now) or with a text buffer where `ch` has already been typed\n        //\n        // In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n        // with two conceptual positions, the position before `ch` and the position after `ch`\n        //\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      var positions = selections.map(function (s) {\n        var position = s.getPosition();\n        if (chIsAlreadyTyped) {\n          return {\n            lineNumber: position.lineNumber,\n            beforeColumn: position.column - ch.length,\n            afterColumn: position.column\n          };\n        } else {\n          return {\n            lineNumber: position.lineNumber,\n            beforeColumn: position.column,\n            afterColumn: position.column\n          };\n        }\n      });\n      // Find the longest auto-closing open pair in case of multiple ending in `ch`\n      // e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n      var pair = this._findAutoClosingPairOpen(config, model, positions.map(function (p) {\n        return new Position(p.lineNumber, p.beforeColumn);\n      }), ch);\n      if (!pair) {\n        return null;\n      }\n      var autoCloseConfig;\n      var shouldAutoCloseBefore;\n      var chIsQuote = isQuote(ch);\n      if (chIsQuote) {\n        autoCloseConfig = config.autoClosingQuotes;\n        shouldAutoCloseBefore = config.shouldAutoCloseBefore.quote;\n      } else {\n        var pairIsForComments = config.blockCommentStartToken ? pair.open.includes(config.blockCommentStartToken) : false;\n        if (pairIsForComments) {\n          autoCloseConfig = config.autoClosingComments;\n          shouldAutoCloseBefore = config.shouldAutoCloseBefore.comment;\n        } else {\n          autoCloseConfig = config.autoClosingBrackets;\n          shouldAutoCloseBefore = config.shouldAutoCloseBefore.bracket;\n        }\n      }\n      if (autoCloseConfig === 'never') {\n        return null;\n      }\n      // Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n      // e.g. when having [(,)] and [(*,*)]\n      // - when typing (, the resulting state is (|)\n      // - when typing *, the desired resulting state is (*|*), not (*|*))\n      var containedPair = this._findContainedAutoClosingPair(config, pair);\n      var containedPairClose = containedPair ? containedPair.close : '';\n      var isContainedPairPresent = true;\n      var _iterator5 = _createForOfIteratorHelper(positions),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var position = _step5.value;\n          var lineNumber = position.lineNumber,\n            beforeColumn = position.beforeColumn,\n            afterColumn = position.afterColumn;\n          var lineText = model.getLineContent(lineNumber);\n          var lineBefore = lineText.substring(0, beforeColumn - 1);\n          var lineAfter = lineText.substring(afterColumn - 1);\n          if (!lineAfter.startsWith(containedPairClose)) {\n            isContainedPairPresent = false;\n          }\n          // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n          if (lineAfter.length > 0) {\n            var characterAfter = lineAfter.charAt(0);\n            var isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\n            if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n              return null;\n            }\n          }\n          // Do not auto-close ' or \" after a word character\n          if (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n            var wordSeparators = getMapForWordSeparators(config.wordSeparators, []);\n            if (lineBefore.length > 0) {\n              var characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n              if (wordSeparators.get(characterBefore) === 0 /* WordCharacterClass.Regular */) {\n                return null;\n              }\n            }\n          }\n          if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n            // Do not force tokenization\n            return null;\n          }\n          model.tokenization.forceTokenization(lineNumber);\n          var lineTokens = model.tokenization.getLineTokens(lineNumber);\n          var scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n          if (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n            return null;\n          }\n          // Typing for example a quote could either start a new string, in which case auto-closing is desirable\n          // or it could end a previously started string, in which case auto-closing is not desirable\n          //\n          // In certain cases, it is really not possible to look at the previous token to determine\n          // what would happen. That's why we do something really unusual, we pretend to type a different\n          // character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n          // character, are we in a string (i.e. the quote would most likely end a string) or not?\n          //\n          var neutralCharacter = pair.findNeutralCharacter();\n          if (neutralCharacter) {\n            var tokenType = model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n            if (!pair.isOK(tokenType)) {\n              return null;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      if (isContainedPairPresent) {\n        return pair.close.substring(0, pair.close.length - containedPairClose.length);\n      } else {\n        return pair.close;\n      }\n    }\n  }, {\n    key: \"_runAutoClosingOpenCharType\",\n    value: function _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, chIsAlreadyTyped, autoClosingPairClose) {\n      var commands = [];\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n        commands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n      }\n      return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: false\n      });\n    }\n  }, {\n    key: \"_shouldSurroundChar\",\n    value: function _shouldSurroundChar(config, ch) {\n      if (isQuote(ch)) {\n        return config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined';\n      } else {\n        // Character is a bracket\n        return config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined';\n      }\n    }\n  }, {\n    key: \"_isSurroundSelectionType\",\n    value: function _isSurroundSelectionType(config, model, selections, ch) {\n      if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n        return false;\n      }\n      var isTypingAQuoteCharacter = isQuote(ch);\n      var _iterator6 = _createForOfIteratorHelper(selections),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var selection = _step6.value;\n          if (selection.isEmpty()) {\n            return false;\n          }\n          var selectionContainsOnlyWhitespace = true;\n          for (var lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n            var lineText = model.getLineContent(lineNumber);\n            var startIndex = lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0;\n            var endIndex = lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length;\n            var selectedText = lineText.substring(startIndex, endIndex);\n            if (/[^ \\t]/.test(selectedText)) {\n              // this selected text contains something other than whitespace\n              selectionContainsOnlyWhitespace = false;\n              break;\n            }\n          }\n          if (selectionContainsOnlyWhitespace) {\n            return false;\n          }\n          if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n            var selectionText = model.getValueInRange(selection);\n            if (isQuote(selectionText)) {\n              // Typing a quote character on top of another quote character\n              // => disable surround selection type\n              return false;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      return true;\n    }\n  }, {\n    key: \"_runSurroundSelectionType\",\n    value: function _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\n      var commands = [];\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n        var closeCharacter = config.surroundingPairs[ch];\n        commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n      }\n      return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: true\n      });\n    }\n  }, {\n    key: \"_isTypeInterceptorElectricChar\",\n    value: function _isTypeInterceptorElectricChar(config, model, selections) {\n      if (selections.length === 1 && model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"_typeInterceptorElectricChar\",\n    value: function _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n      if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n        return null;\n      }\n      var position = selection.getPosition();\n      model.tokenization.forceTokenization(position.lineNumber);\n      var lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n      var electricAction;\n      try {\n        electricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n      } catch (e) {\n        onUnexpectedError(e);\n        return null;\n      }\n      if (!electricAction) {\n        return null;\n      }\n      if (electricAction.matchOpenBracket) {\n        var endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n        var match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n          lineNumber: position.lineNumber,\n          column: endColumn\n        }, 500 /* give at most 500ms to compute */);\n        if (match) {\n          if (match.startLineNumber === position.lineNumber) {\n            // matched something on the same line => no change in indentation\n            return null;\n          }\n          var matchLine = model.getLineContent(match.startLineNumber);\n          var matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n          var newIndentation = config.normalizeIndentation(matchLineIndentation);\n          var lineText = model.getLineContent(position.lineNumber);\n          var lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n          var prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n          var typeText = newIndentation + prefix + ch;\n          var typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n          var command = new ReplaceCommand(typeSelection, typeText);\n          return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n            shouldPushStackElementBefore: false,\n            shouldPushStackElementAfter: true\n          });\n        }\n      }\n      return null;\n    }\n    /**\n     * This is very similar with typing, but the character is already in the text buffer!\n     */\n  }, {\n    key: \"compositionEndWithInterceptors\",\n    value: function compositionEndWithInterceptors(prevEditOperationType, config, model, compositions, selections, autoClosedCharacters) {\n      if (!compositions) {\n        // could not deduce what the composition did\n        return null;\n      }\n      var insertedText = null;\n      var _iterator7 = _createForOfIteratorHelper(compositions),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _composition = _step7.value;\n          if (insertedText === null) {\n            insertedText = _composition.insertedText;\n          } else if (insertedText !== _composition.insertedText) {\n            // not all selections agree on what was typed\n            return null;\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      if (!insertedText || insertedText.length !== 1) {\n        // we're only interested in the case where a single character was inserted\n        return null;\n      }\n      var ch = insertedText;\n      var hasDeletion = false;\n      var _iterator8 = _createForOfIteratorHelper(compositions),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _composition2 = _step8.value;\n          if (_composition2.deletedText.length !== 0) {\n            hasDeletion = true;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n      if (hasDeletion) {\n        // Check if this could have been a surround selection\n        if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n          return null;\n        }\n        var isTypingAQuoteCharacter = isQuote(ch);\n        var _iterator9 = _createForOfIteratorHelper(compositions),\n          _step9;\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var composition = _step9.value;\n            if (composition.deletedSelectionStart !== 0 || composition.deletedSelectionEnd !== composition.deletedText.length) {\n              // more text was deleted than was selected, so this could not have been a surround selection\n              return null;\n            }\n            if (/^[ \\t]+$/.test(composition.deletedText)) {\n              // deleted text was only whitespace\n              return null;\n            }\n            if (isTypingAQuoteCharacter && isQuote(composition.deletedText)) {\n              // deleted text was a quote\n              return null;\n            }\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n        var positions = [];\n        var _iterator10 = _createForOfIteratorHelper(selections),\n          _step10;\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var selection = _step10.value;\n            if (!selection.isEmpty()) {\n              return null;\n            }\n            positions.push(selection.getPosition());\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n        if (positions.length !== compositions.length) {\n          return null;\n        }\n        var commands = [];\n        for (var i = 0, len = positions.length; i < len; i++) {\n          commands.push(new CompositionSurroundSelectionCommand(positions[i], compositions[i].deletedText, config.surroundingPairs[ch]));\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n          shouldPushStackElementBefore: true,\n          shouldPushStackElementAfter: false\n        });\n      }\n      if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n        // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n        var _commands = selections.map(function (s) {\n          return new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false);\n        });\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, _commands, {\n          shouldPushStackElementBefore: true,\n          shouldPushStackElementAfter: false\n        });\n      }\n      var autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\n      if (autoClosingPairClose !== null) {\n        return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\n      }\n      return null;\n    }\n  }, {\n    key: \"typeWithInterceptors\",\n    value: function typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n      if (!isDoingComposition && ch === '\\n') {\n        var _commands2 = [];\n        for (var i = 0, len = selections.length; i < len; i++) {\n          _commands2[i] = TypeOperations._enter(config, model, false, selections[i]);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, _commands2, {\n          shouldPushStackElementBefore: true,\n          shouldPushStackElementAfter: false\n        });\n      }\n      if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n        var _commands3 = [];\n        var autoIndentFails = false;\n        for (var _i = 0, _len = selections.length; _i < _len; _i++) {\n          _commands3[_i] = this._runAutoIndentType(config, model, selections[_i], ch);\n          if (!_commands3[_i]) {\n            autoIndentFails = true;\n            break;\n          }\n        }\n        if (!autoIndentFails) {\n          return new EditOperationResult(4 /* EditOperationType.TypingOther */, _commands3, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n          });\n        }\n      }\n      if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n        return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\n      }\n      if (!isDoingComposition) {\n        var autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\n        if (autoClosingPairClose) {\n          return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\n        }\n      }\n      if (!isDoingComposition && this._isSurroundSelectionType(config, model, selections, ch)) {\n        return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n      }\n      // Electric characters make sense only when dealing with a single cursor,\n      // as multiple cursors typing brackets for example would interfer with bracket matching\n      if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n        var r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n        if (r) {\n          return r;\n        }\n      }\n      // A simple character type\n      var commands = [];\n      for (var _i2 = 0, _len2 = selections.length; _i2 < _len2; _i2++) {\n        commands[_i2] = new ReplaceCommand(selections[_i2], ch);\n      }\n      var opType = getTypingOperation(ch, prevEditOperationType);\n      return new EditOperationResult(opType, commands, {\n        shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n        shouldPushStackElementAfter: false\n      });\n    }\n  }, {\n    key: \"typeWithoutInterceptors\",\n    value: function typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n      var commands = [];\n      for (var i = 0, len = selections.length; i < len; i++) {\n        commands[i] = new ReplaceCommand(selections[i], str);\n      }\n      var opType = getTypingOperation(str, prevEditOperationType);\n      return new EditOperationResult(opType, commands, {\n        shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n        shouldPushStackElementAfter: false\n      });\n    }\n  }, {\n    key: \"lineInsertBefore\",\n    value: function lineInsertBefore(config, model, selections) {\n      if (model === null || selections === null) {\n        return [];\n      }\n      var commands = [];\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var lineNumber = selections[i].positionLineNumber;\n        if (lineNumber === 1) {\n          commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n        } else {\n          lineNumber--;\n          var column = model.getLineMaxColumn(lineNumber);\n          commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n        }\n      }\n      return commands;\n    }\n  }, {\n    key: \"lineInsertAfter\",\n    value: function lineInsertAfter(config, model, selections) {\n      if (model === null || selections === null) {\n        return [];\n      }\n      var commands = [];\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var lineNumber = selections[i].positionLineNumber;\n        var column = model.getLineMaxColumn(lineNumber);\n        commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n      }\n      return commands;\n    }\n  }, {\n    key: \"lineBreakInsert\",\n    value: function lineBreakInsert(config, model, selections) {\n      var commands = [];\n      for (var i = 0, len = selections.length; i < len; i++) {\n        commands[i] = this._enter(config, model, true, selections[i]);\n      }\n      return commands;\n    }\n  }]);\n}();\nexport var TypeWithAutoClosingCommand = /*#__PURE__*/function (_ReplaceCommandWithOf) {\n  function TypeWithAutoClosingCommand(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n    var _this2;\n    _classCallCheck(this, TypeWithAutoClosingCommand);\n    _this2 = _callSuper(this, TypeWithAutoClosingCommand, [selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length]);\n    _this2._openCharacter = openCharacter;\n    _this2._closeCharacter = closeCharacter;\n    _this2.closeCharacterRange = null;\n    _this2.enclosingRange = null;\n    return _this2;\n  }\n  _inherits(TypeWithAutoClosingCommand, _ReplaceCommandWithOf);\n  return _createClass(TypeWithAutoClosingCommand, [{\n    key: \"computeCursorState\",\n    value: function computeCursorState(model, helper) {\n      var inverseEditOperations = helper.getInverseEditOperations();\n      var range = inverseEditOperations[0].range;\n      this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n      this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n      return _get(_getPrototypeOf(TypeWithAutoClosingCommand.prototype), \"computeCursorState\", this).call(this, model, helper);\n    }\n  }]);\n}(ReplaceCommandWithOffsetCursorState);\nexport var CompositionOutcome = /*#__PURE__*/_createClass(function CompositionOutcome(deletedText, deletedSelectionStart, deletedSelectionEnd, insertedText, insertedSelectionStart, insertedSelectionEnd) {\n  _classCallCheck(this, CompositionOutcome);\n  this.deletedText = deletedText;\n  this.deletedSelectionStart = deletedSelectionStart;\n  this.deletedSelectionEnd = deletedSelectionEnd;\n  this.insertedText = insertedText;\n  this.insertedSelectionStart = insertedSelectionStart;\n  this.insertedSelectionEnd = insertedSelectionEnd;\n});\nfunction getTypingOperation(typedText, previousTypingOperation) {\n  if (typedText === ' ') {\n    return previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */ || previousTypingOperation === 6 /* EditOperationType.TypingConsecutiveSpace */ ? 6 /* EditOperationType.TypingConsecutiveSpace */ : 5 /* EditOperationType.TypingFirstSpace */;\n  }\n  return 4 /* EditOperationType.TypingOther */;\n}\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n  if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n    // Always set an undo stop before non-type operations\n    return true;\n  }\n  if (previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */) {\n    // `abc |d`: No undo stop\n    // `abc  |d`: Undo stop\n    return false;\n  }\n  // Insert undo stop between different operation types\n  return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\nfunction normalizeOperationType(type) {\n  return type === 6 /* EditOperationType.TypingConsecutiveSpace */ || type === 5 /* EditOperationType.TypingFirstSpace */ ? 'space' : type;\n}\nfunction isTypingOperation(type) {\n  return type === 4 /* EditOperationType.TypingOther */ || type === 5 /* EditOperationType.TypingFirstSpace */ || type === 6 /* EditOperationType.TypingConsecutiveSpace */;\n}","map":{"version":3,"names":["onUnexpectedError","strings","ReplaceCommand","ReplaceCommandWithOffsetCursorState","ReplaceCommandWithoutChangingPosition","ReplaceCommandThatPreservesSelection","ShiftCommand","CompositionSurroundSelectionCommand","SurroundSelectionCommand","EditOperationResult","isQuote","getMapForWordSeparators","Range","Position","IndentAction","getIndentationAtPosition","createScopedLineTokens","getIndentActionForType","getIndentForEnter","getInheritIndentForLine","getEnterAction","TypeOperations","_classCallCheck","_createClass","key","value","indent","config","model","selections","commands","i","len","length","isUnshift","tabSize","indentSize","insertSpaces","useTabStops","autoIndent","languageConfigurationService","outdent","shiftIndent","indentation","count","unshiftIndent","_distributedPaste","text","shouldPushStackElementBefore","shouldPushStackElementAfter","_simplePaste","pasteOnNewLine","selection","position","getPosition","isEmpty","indexOf","typeSelection","lineNumber","_distributePasteToCursors","multicursorText","multiCursorPaste","charCodeAt","substr","lines","splitLines","paste","distributedPaste","sort","compareRangesUsingStarts","_goodIndentForLine","action","expectedIndentAction","lastLineNumber","lineText","getLineContent","nonWhitespaceIdx","lastNonWhitespaceIndex","maxColumn","getLineMaxColumn","expectedEnterAction","appendText","Indent","Outdent","normalizeIndentation","_replaceJumpToNextIndent","insertsAutoWhitespace","typeText","getStartPosition","visibleColumnFromColumn","spacesCnt","tab","startLineNumber","test","tokenization","isCheapToTokenize","goodIndent","possibleTypeText","startsWith","endLineNumber","lineMaxColumn","startColumn","endColumn","compositionType","prevEditOperationType","replacePrevCharCnt","replaceNextCharCnt","positionDelta","_this","map","_compositionType","shouldPushStackElementBetween","pos","Math","max","column","min","range","oldText","getValueInRange","_typeCommand","keepPosition","_enter","getLeadingWhitespace","substring","r","indentAction","None","IndentOutdent","normalIndent","increasedIndent","actualIndentation","ir","oldEndViewColumn","getEndPosition","oldEndColumn","newLineContent","firstNonWhitespace","firstNonWhitespaceIndex","setEndPosition","afterEnter","offset","ceil","_isAutoIndentType","_runAutoIndentType","ch","currentIndentation","getLineFirstNonWhitespaceColumn","_isAutoClosingOvertype","autoClosedCharacters","autoClosingOvertype","autoClosingPairs","autoClosingPairsCloseSingleChar","has","afterCharacter","charAt","chIsQuote","beforeCharacter","found","j","lenJ","autoClosedCharacter","_runAutoClosingOvertype","_isBeforeClosingBrace","lineAfter","nextChar","potentialStartingBraces","autoClosingPairsOpenByStart","get","potentialClosingBraces","autoClosingPairsCloseByStart","isBeforeStartingBrace","some","x","open","isBeforeClosingBrace","close","_findAutoClosingPairOpen","positions","candidates","autoClosingPairsOpenByEnd","result","_iterator","_createForOfIteratorHelper","_step","s","n","done","candidate","candidateIsMatch","_iterator2","_step2","relevantText","err","e","f","_findContainedAutoClosingPair","pair","lastChar","autoClosingPairsCloseByEnd","_iterator3","_step3","includes","endsWith","_getAutoClosingPairClose","chIsAlreadyTyped","_iterator4","_step4","beforeColumn","afterColumn","p","autoCloseConfig","shouldAutoCloseBefore","autoClosingQuotes","quote","pairIsForComments","blockCommentStartToken","autoClosingComments","comment","autoClosingBrackets","bracket","containedPair","containedPairClose","isContainedPairPresent","_iterator5","_step5","lineBefore","characterAfter","isBeforeCloseBrace","wordSeparators","characterBefore","forceTokenization","lineTokens","getLineTokens","scopedLineTokens","shouldAutoClose","firstCharOffset","neutralCharacter","findNeutralCharacter","tokenType","getTokenTypeIfInsertingCharacter","isOK","_runAutoClosingOpenCharType","autoClosingPairClose","TypeWithAutoClosingCommand","_shouldSurroundChar","autoSurround","_isSurroundSelectionType","surroundingPairs","hasOwnProperty","isTypingAQuoteCharacter","_iterator6","_step6","selectionContainsOnlyWhitespace","startIndex","endIndex","selectedText","selectionText","_runSurroundSelectionType","closeCharacter","_isTypeInterceptorElectricChar","_typeInterceptorElectricChar","electricChars","electricAction","onElectricCharacter","matchOpenBracket","lastIndexOf","match","bracketPairs","findMatchingBracketUp","matchLine","matchLineIndentation","newIndentation","lineFirstNonBlankColumn","prefix","command","getTypingOperation","compositionEndWithInterceptors","compositions","insertedText","_iterator7","_step7","composition","hasDeletion","_iterator8","_step8","deletedText","_iterator9","_step9","deletedSelectionStart","deletedSelectionEnd","_iterator10","_step10","push","positionLineNumber","positionColumn","typeWithInterceptors","isDoingComposition","autoIndentFails","opType","typeWithoutInterceptors","str","lineInsertBefore","lineInsertAfter","lineBreakInsert","_ReplaceCommandWithOf","openCharacter","insertOpenCharacter","_this2","_callSuper","_openCharacter","_closeCharacter","closeCharacterRange","enclosingRange","_inherits","computeCursorState","helper","inverseEditOperations","getInverseEditOperations","_get","_getPrototypeOf","prototype","call","CompositionOutcome","insertedSelectionStart","insertedSelectionEnd","typedText","previousTypingOperation","typingOperation","isTypingOperation","normalizeOperationType","type"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorTypeOperations.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { CompositionSurroundSelectionCommand, SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nimport { IndentAction } from '../languages/languageConfiguration.js';\nimport { getIndentationAtPosition } from '../languages/languageConfigurationRegistry.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nimport { getIndentActionForType, getIndentForEnter, getInheritIndentForLine } from '../languages/autoIndent.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nexport class TypeOperations {\n    static indent(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: false,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static outdent(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: true,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static shiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static unshiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static _distributedPaste(config, model, selections, text) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], text[i]);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (pasteOnNewLine && !selection.isEmpty()) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine) {\n                // Paste entire line at the beginning of line\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n                commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, text);\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n        if (pasteOnNewLine) {\n            return null;\n        }\n        if (selections.length === 1) {\n            return null;\n        }\n        if (multicursorText && multicursorText.length === selections.length) {\n            return multicursorText;\n        }\n        if (config.multiCursorPaste === 'spread') {\n            // Try to spread the pasted text in case the line count matches the cursor count\n            // Remove trailing \\n if present\n            if (text.charCodeAt(text.length - 1) === 10 /* CharCode.LineFeed */) {\n                text = text.substr(0, text.length - 1);\n            }\n            // Remove trailing \\r if present\n            if (text.charCodeAt(text.length - 1) === 13 /* CharCode.CarriageReturn */) {\n                text = text.substr(0, text.length - 1);\n            }\n            const lines = strings.splitLines(text);\n            if (lines.length === selections.length) {\n                return lines;\n            }\n        }\n        return null;\n    }\n    static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n        const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n        if (distributedPaste) {\n            selections = selections.sort(Range.compareRangesUsingStarts);\n            return this._distributedPaste(config, model, selections, distributedPaste);\n        }\n        else {\n            return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n        }\n    }\n    static _goodIndentForLine(config, model, lineNumber) {\n        let action = null;\n        let indentation = '';\n        const expectedIndentAction = getInheritIndentForLine(config.autoIndent, model, lineNumber, false, config.languageConfigurationService);\n        if (expectedIndentAction) {\n            action = expectedIndentAction.action;\n            indentation = expectedIndentAction.indentation;\n        }\n        else if (lineNumber > 1) {\n            let lastLineNumber;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                const lineText = model.getLineContent(lastLineNumber);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n            }\n            if (lastLineNumber < 1) {\n                // No previous line with content found\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(lastLineNumber);\n            const expectedEnterAction = getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn), config.languageConfigurationService);\n            if (expectedEnterAction) {\n                indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n            }\n        }\n        if (action) {\n            if (action === IndentAction.Indent) {\n                indentation = TypeOperations.shiftIndent(config, indentation);\n            }\n            if (action === IndentAction.Outdent) {\n                indentation = TypeOperations.unshiftIndent(config, indentation);\n            }\n            indentation = config.normalizeIndentation(indentation);\n        }\n        if (!indentation) {\n            return null;\n        }\n        return indentation;\n    }\n    static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n        let typeText = '';\n        const position = selection.getStartPosition();\n        if (config.insertSpaces) {\n            const visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n            const indentSize = config.indentSize;\n            const spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n            for (let i = 0; i < spacesCnt; i++) {\n                typeText += ' ';\n            }\n        }\n        else {\n            typeText = '\\t';\n        }\n        return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n    }\n    static tab(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                const lineText = model.getLineContent(selection.startLineNumber);\n                if (/^\\s*$/.test(lineText) && model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n                    let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n                    goodIndent = goodIndent || '\\t';\n                    const possibleTypeText = config.normalizeIndentation(goodIndent);\n                    if (!lineText.startsWith(possibleTypeText)) {\n                        commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n                        continue;\n                    }\n                }\n                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n            }\n            else {\n                if (selection.startLineNumber === selection.endLineNumber) {\n                    const lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n                        // This is a single line selection that is not the entire line\n                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n                        continue;\n                    }\n                }\n                commands[i] = new ShiftCommand(selection, {\n                    isUnshift: false,\n                    tabSize: config.tabSize,\n                    indentSize: config.indentSize,\n                    insertSpaces: config.insertSpaces,\n                    useTabStops: config.useTabStops,\n                    autoIndent: config.autoIndent\n                }, config.languageConfigurationService);\n            }\n        }\n        return commands;\n    }\n    static compositionType(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        if (!selection.isEmpty()) {\n            // looks like https://github.com/microsoft/vscode/issues/2773\n            // where a cursor operation occurred before a canceled composition\n            // => ignore composition\n            return null;\n        }\n        const pos = selection.getPosition();\n        const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n        const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n        const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n        const oldText = model.getValueInRange(range);\n        if (oldText === text && positionDelta === 0) {\n            // => ignore composition that doesn't do anything\n            return null;\n        }\n        return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n    }\n    static _typeCommand(range, text, keepPosition) {\n        if (keepPosition) {\n            return new ReplaceCommandWithoutChangingPosition(range, text, true);\n        }\n        else {\n            return new ReplaceCommand(range, text, true);\n        }\n    }\n    static _enter(config, model, keepPosition, range) {\n        if (config.autoIndent === 0 /* EditorAutoIndentStrategy.None */) {\n            return TypeOperations._typeCommand(range, '\\n', keepPosition);\n        }\n        if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* EditorAutoIndentStrategy.Keep */) {\n            const lineText = model.getLineContent(range.startLineNumber);\n            const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n            return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n        }\n        const r = getEnterAction(config.autoIndent, model, range, config.languageConfigurationService);\n        if (r) {\n            if (r.indentAction === IndentAction.None) {\n                // Nothing special\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.Indent) {\n                // Indent once\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.IndentOutdent) {\n                // Ultra special\n                const normalIndent = config.normalizeIndentation(r.indentation);\n                const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n                const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n                }\n                else {\n                    return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n                }\n            }\n            else if (r.indentAction === IndentAction.Outdent) {\n                const actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n            }\n        }\n        const lineText = model.getLineContent(range.startLineNumber);\n        const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n        if (config.autoIndent >= 4 /* EditorAutoIndentStrategy.Full */) {\n            const ir = getIndentForEnter(config.autoIndent, model, range, {\n                unshiftIndent: (indent) => {\n                    return TypeOperations.unshiftIndent(config, indent);\n                },\n                shiftIndent: (indent) => {\n                    return TypeOperations.shiftIndent(config, indent);\n                },\n                normalizeIndentation: (indent) => {\n                    return config.normalizeIndentation(indent);\n                }\n            }, config.languageConfigurationService);\n            if (ir) {\n                let oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n                const oldEndColumn = range.endColumn;\n                const newLineContent = model.getLineContent(range.endLineNumber);\n                const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n                if (firstNonWhitespace >= 0) {\n                    range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n                }\n                else {\n                    range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n                }\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n                }\n                else {\n                    let offset = 0;\n                    if (oldEndColumn <= firstNonWhitespace + 1) {\n                        if (!config.insertSpaces) {\n                            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n                        }\n                        offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n                    }\n                    return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n                }\n            }\n        }\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n    static _isAutoIndentType(config, model, selections) {\n        if (config.autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            if (!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _runAutoIndentType(config, model, range, ch) {\n        const currentIndentation = getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n        const actualIndentation = getIndentActionForType(config.autoIndent, model, range, ch, {\n            shiftIndent: (indentation) => {\n                return TypeOperations.shiftIndent(config, indentation);\n            },\n            unshiftIndent: (indentation) => {\n                return TypeOperations.unshiftIndent(config, indentation);\n            },\n        }, config.languageConfigurationService);\n        if (actualIndentation === null) {\n            return null;\n        }\n        if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n            const firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n            if (firstNonWhitespace === 0) {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n            }\n            else {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) +\n                    model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n            }\n        }\n        return null;\n    }\n    static _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n        if (config.autoClosingOvertype === 'never') {\n            return false;\n        }\n        if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const position = selection.getPosition();\n            const lineText = model.getLineContent(position.lineNumber);\n            const afterCharacter = lineText.charAt(position.column - 1);\n            if (afterCharacter !== ch) {\n                return false;\n            }\n            // Do not over-type quotes after a backslash\n            const chIsQuote = isQuote(ch);\n            const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* CharCode.Null */;\n            if (beforeCharacter === 92 /* CharCode.Backslash */ && chIsQuote) {\n                return false;\n            }\n            // Must over-type a closing character typed by the editor\n            if (config.autoClosingOvertype === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(typeSelection, ch);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _isBeforeClosingBrace(config, lineAfter) {\n        // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n        const nextChar = lineAfter.charAt(0);\n        const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n        const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n        const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n        const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n        return !isBeforeStartingBrace && isBeforeClosingBrace;\n    }\n    /**\n     * Determine if typing `ch` at all `positions` in the `model` results in an\n     * auto closing open sequence being typed.\n     *\n     * Auto closing open sequences can consist of multiple characters, which\n     * can lead to ambiguities. In such a case, the longest auto-closing open\n     * sequence is returned.\n     */\n    static _findAutoClosingPairOpen(config, model, positions, ch) {\n        const candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n        if (!candidates) {\n            return null;\n        }\n        // Determine which auto-closing pair it is\n        let result = null;\n        for (const candidate of candidates) {\n            if (result === null || candidate.open.length > result.open.length) {\n                let candidateIsMatch = true;\n                for (const position of positions) {\n                    const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n                    if (relevantText + ch !== candidate.open) {\n                        candidateIsMatch = false;\n                        break;\n                    }\n                }\n                if (candidateIsMatch) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Find another auto-closing pair that is contained by the one passed in.\n     *\n     * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n     * this method will find [(,)] as a containment pair for [(*,*)]\n     */\n    static _findContainedAutoClosingPair(config, pair) {\n        if (pair.open.length <= 1) {\n            return null;\n        }\n        const lastChar = pair.close.charAt(pair.close.length - 1);\n        // get candidates with the same last character as close\n        const candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n        let result = null;\n        for (const candidate of candidates) {\n            if (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n                if (!result || candidate.open.length > result.open.length) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    static _getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped) {\n        for (const selection of selections) {\n            if (!selection.isEmpty()) {\n                return null;\n            }\n        }\n        // This method is called both when typing (regularly) and when composition ends\n        // This means that we need to work with a text buffer where sometimes `ch` is not\n        // there (it is being typed right now) or with a text buffer where `ch` has already been typed\n        //\n        // In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n        // with two conceptual positions, the position before `ch` and the position after `ch`\n        //\n        const positions = selections.map((s) => {\n            const position = s.getPosition();\n            if (chIsAlreadyTyped) {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column - ch.length, afterColumn: position.column };\n            }\n            else {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column, afterColumn: position.column };\n            }\n        });\n        // Find the longest auto-closing open pair in case of multiple ending in `ch`\n        // e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n        const pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n        if (!pair) {\n            return null;\n        }\n        let autoCloseConfig;\n        let shouldAutoCloseBefore;\n        const chIsQuote = isQuote(ch);\n        if (chIsQuote) {\n            autoCloseConfig = config.autoClosingQuotes;\n            shouldAutoCloseBefore = config.shouldAutoCloseBefore.quote;\n        }\n        else {\n            const pairIsForComments = config.blockCommentStartToken ? pair.open.includes(config.blockCommentStartToken) : false;\n            if (pairIsForComments) {\n                autoCloseConfig = config.autoClosingComments;\n                shouldAutoCloseBefore = config.shouldAutoCloseBefore.comment;\n            }\n            else {\n                autoCloseConfig = config.autoClosingBrackets;\n                shouldAutoCloseBefore = config.shouldAutoCloseBefore.bracket;\n            }\n        }\n        if (autoCloseConfig === 'never') {\n            return null;\n        }\n        // Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n        // e.g. when having [(,)] and [(*,*)]\n        // - when typing (, the resulting state is (|)\n        // - when typing *, the desired resulting state is (*|*), not (*|*))\n        const containedPair = this._findContainedAutoClosingPair(config, pair);\n        const containedPairClose = containedPair ? containedPair.close : '';\n        let isContainedPairPresent = true;\n        for (const position of positions) {\n            const { lineNumber, beforeColumn, afterColumn } = position;\n            const lineText = model.getLineContent(lineNumber);\n            const lineBefore = lineText.substring(0, beforeColumn - 1);\n            const lineAfter = lineText.substring(afterColumn - 1);\n            if (!lineAfter.startsWith(containedPairClose)) {\n                isContainedPairPresent = false;\n            }\n            // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n            if (lineAfter.length > 0) {\n                const characterAfter = lineAfter.charAt(0);\n                const isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\n                if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n                    return null;\n                }\n            }\n            // Do not auto-close ' or \" after a word character\n            if (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n                const wordSeparators = getMapForWordSeparators(config.wordSeparators, []);\n                if (lineBefore.length > 0) {\n                    const characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n                    if (wordSeparators.get(characterBefore) === 0 /* WordCharacterClass.Regular */) {\n                        return null;\n                    }\n                }\n            }\n            if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n                // Do not force tokenization\n                return null;\n            }\n            model.tokenization.forceTokenization(lineNumber);\n            const lineTokens = model.tokenization.getLineTokens(lineNumber);\n            const scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n            if (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n                return null;\n            }\n            // Typing for example a quote could either start a new string, in which case auto-closing is desirable\n            // or it could end a previously started string, in which case auto-closing is not desirable\n            //\n            // In certain cases, it is really not possible to look at the previous token to determine\n            // what would happen. That's why we do something really unusual, we pretend to type a different\n            // character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n            // character, are we in a string (i.e. the quote would most likely end a string) or not?\n            //\n            const neutralCharacter = pair.findNeutralCharacter();\n            if (neutralCharacter) {\n                const tokenType = model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n                if (!pair.isOK(tokenType)) {\n                    return null;\n                }\n            }\n        }\n        if (isContainedPairPresent) {\n            return pair.close.substring(0, pair.close.length - containedPairClose.length);\n        }\n        else {\n            return pair.close;\n        }\n    }\n    static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, chIsAlreadyTyped, autoClosingPairClose) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            commands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _shouldSurroundChar(config, ch) {\n        if (isQuote(ch)) {\n            return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n        }\n        else {\n            // Character is a bracket\n            return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n        }\n    }\n    static _isSurroundSelectionType(config, model, selections, ch) {\n        if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n            return false;\n        }\n        const isTypingAQuoteCharacter = isQuote(ch);\n        for (const selection of selections) {\n            if (selection.isEmpty()) {\n                return false;\n            }\n            let selectionContainsOnlyWhitespace = true;\n            for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                const startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n                const endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n                const selectedText = lineText.substring(startIndex, endIndex);\n                if (/[^ \\t]/.test(selectedText)) {\n                    // this selected text contains something other than whitespace\n                    selectionContainsOnlyWhitespace = false;\n                    break;\n                }\n            }\n            if (selectionContainsOnlyWhitespace) {\n                return false;\n            }\n            if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n                const selectionText = model.getValueInRange(selection);\n                if (isQuote(selectionText)) {\n                    // Typing a quote character on top of another quote character\n                    // => disable surround selection type\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const closeCharacter = config.surroundingPairs[ch];\n            commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _isTypeInterceptorElectricChar(config, model, selections) {\n        if (selections.length === 1 && model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n            return true;\n        }\n        return false;\n    }\n    static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n            return null;\n        }\n        const position = selection.getPosition();\n        model.tokenization.forceTokenization(position.lineNumber);\n        const lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n        let electricAction;\n        try {\n            electricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n        if (!electricAction) {\n            return null;\n        }\n        if (electricAction.matchOpenBracket) {\n            const endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n            const match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n                lineNumber: position.lineNumber,\n                column: endColumn\n            }, 500 /* give at most 500ms to compute */);\n            if (match) {\n                if (match.startLineNumber === position.lineNumber) {\n                    // matched something on the same line => no change in indentation\n                    return null;\n                }\n                const matchLine = model.getLineContent(match.startLineNumber);\n                const matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n                const newIndentation = config.normalizeIndentation(matchLineIndentation);\n                const lineText = model.getLineContent(position.lineNumber);\n                const lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n                const prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n                const typeText = newIndentation + prefix + ch;\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n                const command = new ReplaceCommand(typeSelection, typeText);\n                return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n                    shouldPushStackElementBefore: false,\n                    shouldPushStackElementAfter: true\n                });\n            }\n        }\n        return null;\n    }\n    /**\n     * This is very similar with typing, but the character is already in the text buffer!\n     */\n    static compositionEndWithInterceptors(prevEditOperationType, config, model, compositions, selections, autoClosedCharacters) {\n        if (!compositions) {\n            // could not deduce what the composition did\n            return null;\n        }\n        let insertedText = null;\n        for (const composition of compositions) {\n            if (insertedText === null) {\n                insertedText = composition.insertedText;\n            }\n            else if (insertedText !== composition.insertedText) {\n                // not all selections agree on what was typed\n                return null;\n            }\n        }\n        if (!insertedText || insertedText.length !== 1) {\n            // we're only interested in the case where a single character was inserted\n            return null;\n        }\n        const ch = insertedText;\n        let hasDeletion = false;\n        for (const composition of compositions) {\n            if (composition.deletedText.length !== 0) {\n                hasDeletion = true;\n                break;\n            }\n        }\n        if (hasDeletion) {\n            // Check if this could have been a surround selection\n            if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n                return null;\n            }\n            const isTypingAQuoteCharacter = isQuote(ch);\n            for (const composition of compositions) {\n                if (composition.deletedSelectionStart !== 0 || composition.deletedSelectionEnd !== composition.deletedText.length) {\n                    // more text was deleted than was selected, so this could not have been a surround selection\n                    return null;\n                }\n                if (/^[ \\t]+$/.test(composition.deletedText)) {\n                    // deleted text was only whitespace\n                    return null;\n                }\n                if (isTypingAQuoteCharacter && isQuote(composition.deletedText)) {\n                    // deleted text was a quote\n                    return null;\n                }\n            }\n            const positions = [];\n            for (const selection of selections) {\n                if (!selection.isEmpty()) {\n                    return null;\n                }\n                positions.push(selection.getPosition());\n            }\n            if (positions.length !== compositions.length) {\n                return null;\n            }\n            const commands = [];\n            for (let i = 0, len = positions.length; i < len; i++) {\n                commands.push(new CompositionSurroundSelectionCommand(positions[i], compositions[i].deletedText, config.surroundingPairs[ch]));\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n            const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\n        if (autoClosingPairClose !== null) {\n            return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\n        }\n        return null;\n    }\n    static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n        if (!isDoingComposition && ch === '\\n') {\n            const commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = TypeOperations._enter(config, model, false, selections[i]);\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false,\n            });\n        }\n        if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n            const commands = [];\n            let autoIndentFails = false;\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = this._runAutoIndentType(config, model, selections[i], ch);\n                if (!commands[i]) {\n                    autoIndentFails = true;\n                    break;\n                }\n            }\n            if (!autoIndentFails) {\n                return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                    shouldPushStackElementBefore: true,\n                    shouldPushStackElementAfter: false,\n                });\n            }\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\n        }\n        if (!isDoingComposition) {\n            const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\n            if (autoClosingPairClose) {\n                return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\n            }\n        }\n        if (!isDoingComposition && this._isSurroundSelectionType(config, model, selections, ch)) {\n            return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n        }\n        // Electric characters make sense only when dealing with a single cursor,\n        // as multiple cursors typing brackets for example would interfer with bracket matching\n        if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n            const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n            if (r) {\n                return r;\n            }\n        }\n        // A simple character type\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], ch);\n        }\n        const opType = getTypingOperation(ch, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], str);\n        }\n        const opType = getTypingOperation(str, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static lineInsertBefore(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let lineNumber = selections[i].positionLineNumber;\n            if (lineNumber === 1) {\n                commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n            }\n            else {\n                lineNumber--;\n                const column = model.getLineMaxColumn(lineNumber);\n                commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n            }\n        }\n        return commands;\n    }\n    static lineInsertAfter(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const lineNumber = selections[i].positionLineNumber;\n            const column = model.getLineMaxColumn(lineNumber);\n            commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n        }\n        return commands;\n    }\n    static lineBreakInsert(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = this._enter(config, model, true, selections[i]);\n        }\n        return commands;\n    }\n}\nexport class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n    constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n        super(selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length);\n        this._openCharacter = openCharacter;\n        this._closeCharacter = closeCharacter;\n        this.closeCharacterRange = null;\n        this.enclosingRange = null;\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const range = inverseEditOperations[0].range;\n        this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        return super.computeCursorState(model, helper);\n    }\n}\nexport class CompositionOutcome {\n    constructor(deletedText, deletedSelectionStart, deletedSelectionEnd, insertedText, insertedSelectionStart, insertedSelectionEnd) {\n        this.deletedText = deletedText;\n        this.deletedSelectionStart = deletedSelectionStart;\n        this.deletedSelectionEnd = deletedSelectionEnd;\n        this.insertedText = insertedText;\n        this.insertedSelectionStart = insertedSelectionStart;\n        this.insertedSelectionEnd = insertedSelectionEnd;\n    }\n}\nfunction getTypingOperation(typedText, previousTypingOperation) {\n    if (typedText === ' ') {\n        return previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */\n            || previousTypingOperation === 6 /* EditOperationType.TypingConsecutiveSpace */\n            ? 6 /* EditOperationType.TypingConsecutiveSpace */\n            : 5 /* EditOperationType.TypingFirstSpace */;\n    }\n    return 4 /* EditOperationType.TypingOther */;\n}\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n    if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n        // Always set an undo stop before non-type operations\n        return true;\n    }\n    if (previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */) {\n        // `abc |d`: No undo stop\n        // `abc  |d`: Undo stop\n        return false;\n    }\n    // Insert undo stop between different operation types\n    return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\nfunction normalizeOperationType(type) {\n    return (type === 6 /* EditOperationType.TypingConsecutiveSpace */ || type === 5 /* EditOperationType.TypingFirstSpace */)\n        ? 'space'\n        : type;\n}\nfunction isTypingOperation(type) {\n    return type === 4 /* EditOperationType.TypingOther */\n        || type === 5 /* EditOperationType.TypingFirstSpace */\n        || type === 6 /* EditOperationType.TypingConsecutiveSpace */;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}