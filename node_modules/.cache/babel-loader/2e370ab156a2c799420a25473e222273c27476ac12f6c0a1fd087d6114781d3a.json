{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _typeof from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.object.create.js\";\nimport \"core-js/modules/es.object.define-property.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.reflect.to-string-tag.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar ShiftCommand_1;\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nvar repeatCache = Object.create(null);\nfunction cachedStringRepeat(str, count) {\n  if (count <= 0) {\n    return '';\n  }\n  if (!repeatCache[str]) {\n    repeatCache[str] = ['', str];\n  }\n  var cache = repeatCache[str];\n  for (var i = cache.length; i <= count; i++) {\n    cache[i] = cache[i - 1] + str;\n  }\n  return cache[count];\n}\nvar ShiftCommand = ShiftCommand_1 = /*#__PURE__*/function () {\n  function ShiftCommand(range, opts, _languageConfigurationService) {\n    _classCallCheck(this, ShiftCommand);\n    this._languageConfigurationService = _languageConfigurationService;\n    this._opts = opts;\n    this._selection = range;\n    this._selectionId = null;\n    this._useLastEditRangeForCursorEndPosition = false;\n    this._selectionStartColumnStaysPut = false;\n  }\n  return _createClass(ShiftCommand, [{\n    key: \"_addEditOperation\",\n    value: function _addEditOperation(builder, range, text) {\n      if (this._useLastEditRangeForCursorEndPosition) {\n        builder.addTrackedEditOperation(range, text);\n      } else {\n        builder.addEditOperation(range, text);\n      }\n    }\n  }, {\n    key: \"getEditOperations\",\n    value: function getEditOperations(model, builder) {\n      var startLine = this._selection.startLineNumber;\n      var endLine = this._selection.endLineNumber;\n      if (this._selection.endColumn === 1 && startLine !== endLine) {\n        endLine = endLine - 1;\n      }\n      var _this$_opts = this._opts,\n        tabSize = _this$_opts.tabSize,\n        indentSize = _this$_opts.indentSize,\n        insertSpaces = _this$_opts.insertSpaces;\n      var shouldIndentEmptyLines = startLine === endLine;\n      if (this._opts.useTabStops) {\n        // if indenting or outdenting on a whitespace only line\n        if (this._selection.isEmpty()) {\n          if (/^\\s*$/.test(model.getLineContent(startLine))) {\n            this._useLastEditRangeForCursorEndPosition = true;\n          }\n        }\n        // keep track of previous line's \"miss-alignment\"\n        var previousLineExtraSpaces = 0,\n          extraSpaces = 0;\n        for (var lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {\n          extraSpaces = 0;\n          var lineText = model.getLineContent(lineNumber);\n          var indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n          if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n            // empty line or line with no leading whitespace => nothing to do\n            continue;\n          }\n          if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n            // do not indent empty lines => nothing to do\n            continue;\n          }\n          if (indentationEndIndex === -1) {\n            // the entire line is whitespace\n            indentationEndIndex = lineText.length;\n          }\n          if (lineNumber > 1) {\n            var contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);\n            if (contentStartVisibleColumn % indentSize !== 0) {\n              // The current line is \"miss-aligned\", so let's see if this is expected...\n              // This can only happen when it has trailing commas in the indent\n              if (model.tokenization.isCheapToTokenize(lineNumber - 1)) {\n                var enterAction = getEnterAction(this._opts.autoIndent, model, new Range(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1), lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)), this._languageConfigurationService);\n                if (enterAction) {\n                  extraSpaces = previousLineExtraSpaces;\n                  if (enterAction.appendText) {\n                    for (var j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {\n                      if (enterAction.appendText.charCodeAt(j) === 32 /* CharCode.Space */) {\n                        extraSpaces++;\n                      } else {\n                        break;\n                      }\n                    }\n                  }\n                  if (enterAction.removeText) {\n                    extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);\n                  }\n                  // Act as if `prefixSpaces` is not part of the indentation\n                  for (var _j = 0; _j < extraSpaces; _j++) {\n                    if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== 32 /* CharCode.Space */) {\n                      break;\n                    }\n                    indentationEndIndex--;\n                  }\n                }\n              }\n            }\n          }\n          if (this._opts.isUnshift && indentationEndIndex === 0) {\n            // line with no leading whitespace => nothing to do\n            continue;\n          }\n          var desiredIndent = void 0;\n          if (this._opts.isUnshift) {\n            desiredIndent = ShiftCommand_1.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n          } else {\n            desiredIndent = ShiftCommand_1.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n          }\n          this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);\n          if (lineNumber === startLine && !this._selection.isEmpty()) {\n            // Force the startColumn to stay put because we're inserting after it\n            this._selectionStartColumnStaysPut = this._selection.startColumn <= indentationEndIndex + 1;\n          }\n        }\n      } else {\n        // if indenting or outdenting on a whitespace only line\n        if (!this._opts.isUnshift && this._selection.isEmpty() && model.getLineLength(startLine) === 0) {\n          this._useLastEditRangeForCursorEndPosition = true;\n        }\n        var oneIndent = insertSpaces ? cachedStringRepeat(' ', indentSize) : '\\t';\n        for (var _lineNumber = startLine; _lineNumber <= endLine; _lineNumber++) {\n          var _lineText = model.getLineContent(_lineNumber);\n          var _indentationEndIndex = strings.firstNonWhitespaceIndex(_lineText);\n          if (this._opts.isUnshift && (_lineText.length === 0 || _indentationEndIndex === 0)) {\n            // empty line or line with no leading whitespace => nothing to do\n            continue;\n          }\n          if (!shouldIndentEmptyLines && !this._opts.isUnshift && _lineText.length === 0) {\n            // do not indent empty lines => nothing to do\n            continue;\n          }\n          if (_indentationEndIndex === -1) {\n            // the entire line is whitespace\n            _indentationEndIndex = _lineText.length;\n          }\n          if (this._opts.isUnshift && _indentationEndIndex === 0) {\n            // line with no leading whitespace => nothing to do\n            continue;\n          }\n          if (this._opts.isUnshift) {\n            _indentationEndIndex = Math.min(_indentationEndIndex, indentSize);\n            for (var i = 0; i < _indentationEndIndex; i++) {\n              var chr = _lineText.charCodeAt(i);\n              if (chr === 9 /* CharCode.Tab */) {\n                _indentationEndIndex = i + 1;\n                break;\n              }\n            }\n            this._addEditOperation(builder, new Range(_lineNumber, 1, _lineNumber, _indentationEndIndex + 1), '');\n          } else {\n            this._addEditOperation(builder, new Range(_lineNumber, 1, _lineNumber, 1), oneIndent);\n            if (_lineNumber === startLine && !this._selection.isEmpty()) {\n              // Force the startColumn to stay put because we're inserting after it\n              this._selectionStartColumnStaysPut = this._selection.startColumn === 1;\n            }\n          }\n        }\n      }\n      this._selectionId = builder.trackSelection(this._selection);\n    }\n  }, {\n    key: \"computeCursorState\",\n    value: function computeCursorState(model, helper) {\n      if (this._useLastEditRangeForCursorEndPosition) {\n        var lastOp = helper.getInverseEditOperations()[0];\n        return new Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);\n      }\n      var result = helper.getTrackedSelection(this._selectionId);\n      if (this._selectionStartColumnStaysPut) {\n        // The selection start should not move\n        var initialStartColumn = this._selection.startColumn;\n        var resultStartColumn = result.startColumn;\n        if (resultStartColumn <= initialStartColumn) {\n          return result;\n        }\n        if (result.getDirection() === 0 /* SelectionDirection.LTR */) {\n          return new Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);\n        }\n        return new Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);\n      }\n      return result;\n    }\n  }], [{\n    key: \"unshiftIndent\",\n    value: function unshiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n      // Determine the visible column where the content starts\n      var contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n      if (insertSpaces) {\n        var indent = cachedStringRepeat(' ', indentSize);\n        var desiredTabStop = CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize);\n        var indentCount = desiredTabStop / indentSize; // will be an integer\n        return cachedStringRepeat(indent, indentCount);\n      } else {\n        var _indent = '\\t';\n        var _desiredTabStop = CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize);\n        var _indentCount = _desiredTabStop / tabSize; // will be an integer\n        return cachedStringRepeat(_indent, _indentCount);\n      }\n    }\n  }, {\n    key: \"shiftIndent\",\n    value: function shiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n      // Determine the visible column where the content starts\n      var contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n      if (insertSpaces) {\n        var indent = cachedStringRepeat(' ', indentSize);\n        var desiredTabStop = CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize);\n        var indentCount = desiredTabStop / indentSize; // will be an integer\n        return cachedStringRepeat(indent, indentCount);\n      } else {\n        var _indent2 = '\\t';\n        var _desiredTabStop2 = CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize);\n        var _indentCount2 = _desiredTabStop2 / tabSize; // will be an integer\n        return cachedStringRepeat(_indent2, _indentCount2);\n      }\n    }\n  }]);\n}();\nShiftCommand = ShiftCommand_1 = __decorate([__param(2, ILanguageConfigurationService)], ShiftCommand);\nexport { ShiftCommand };","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","_typeof","decorate","i","defineProperty","__param","paramIndex","decorator","ShiftCommand_1","strings","CursorColumns","Range","Selection","getEnterAction","ILanguageConfigurationService","repeatCache","create","cachedStringRepeat","str","count","cache","ShiftCommand","range","opts","_languageConfigurationService","_classCallCheck","_opts","_selection","_selectionId","_useLastEditRangeForCursorEndPosition","_selectionStartColumnStaysPut","_createClass","value","_addEditOperation","builder","text","addTrackedEditOperation","addEditOperation","getEditOperations","model","startLine","startLineNumber","endLine","endLineNumber","endColumn","_this$_opts","tabSize","indentSize","insertSpaces","shouldIndentEmptyLines","useTabStops","isEmpty","test","getLineContent","previousLineExtraSpaces","extraSpaces","lineNumber","lineText","indentationEndIndex","firstNonWhitespaceIndex","isUnshift","contentStartVisibleColumn","visibleColumnFromColumn","tokenization","isCheapToTokenize","enterAction","autoIndent","getLineMaxColumn","appendText","j","lenJ","charCodeAt","removeText","Math","max","desiredIndent","unshiftIndent","shiftIndent","startColumn","getLineLength","oneIndent","min","chr","trackSelection","computeCursorState","helper","lastOp","getInverseEditOperations","result","getTrackedSelection","initialStartColumn","resultStartColumn","getDirection","line","column","indent","desiredTabStop","prevIndentTabStop","indentCount","prevRenderTabStop","nextIndentTabStop","nextRenderTabStop"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/commands/shiftCommand.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar ShiftCommand_1;\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nconst repeatCache = Object.create(null);\nfunction cachedStringRepeat(str, count) {\n    if (count <= 0) {\n        return '';\n    }\n    if (!repeatCache[str]) {\n        repeatCache[str] = ['', str];\n    }\n    const cache = repeatCache[str];\n    for (let i = cache.length; i <= count; i++) {\n        cache[i] = cache[i - 1] + str;\n    }\n    return cache[count];\n}\nlet ShiftCommand = ShiftCommand_1 = class ShiftCommand {\n    static unshiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n        // Determine the visible column where the content starts\n        const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n        if (insertSpaces) {\n            const indent = cachedStringRepeat(' ', indentSize);\n            const desiredTabStop = CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize);\n            const indentCount = desiredTabStop / indentSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n        else {\n            const indent = '\\t';\n            const desiredTabStop = CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize);\n            const indentCount = desiredTabStop / tabSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n    }\n    static shiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n        // Determine the visible column where the content starts\n        const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n        if (insertSpaces) {\n            const indent = cachedStringRepeat(' ', indentSize);\n            const desiredTabStop = CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize);\n            const indentCount = desiredTabStop / indentSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n        else {\n            const indent = '\\t';\n            const desiredTabStop = CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize);\n            const indentCount = desiredTabStop / tabSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n    }\n    constructor(range, opts, _languageConfigurationService) {\n        this._languageConfigurationService = _languageConfigurationService;\n        this._opts = opts;\n        this._selection = range;\n        this._selectionId = null;\n        this._useLastEditRangeForCursorEndPosition = false;\n        this._selectionStartColumnStaysPut = false;\n    }\n    _addEditOperation(builder, range, text) {\n        if (this._useLastEditRangeForCursorEndPosition) {\n            builder.addTrackedEditOperation(range, text);\n        }\n        else {\n            builder.addEditOperation(range, text);\n        }\n    }\n    getEditOperations(model, builder) {\n        const startLine = this._selection.startLineNumber;\n        let endLine = this._selection.endLineNumber;\n        if (this._selection.endColumn === 1 && startLine !== endLine) {\n            endLine = endLine - 1;\n        }\n        const { tabSize, indentSize, insertSpaces } = this._opts;\n        const shouldIndentEmptyLines = (startLine === endLine);\n        if (this._opts.useTabStops) {\n            // if indenting or outdenting on a whitespace only line\n            if (this._selection.isEmpty()) {\n                if (/^\\s*$/.test(model.getLineContent(startLine))) {\n                    this._useLastEditRangeForCursorEndPosition = true;\n                }\n            }\n            // keep track of previous line's \"miss-alignment\"\n            let previousLineExtraSpaces = 0, extraSpaces = 0;\n            for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {\n                extraSpaces = 0;\n                const lineText = model.getLineContent(lineNumber);\n                let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n                    // empty line or line with no leading whitespace => nothing to do\n                    continue;\n                }\n                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n                    // do not indent empty lines => nothing to do\n                    continue;\n                }\n                if (indentationEndIndex === -1) {\n                    // the entire line is whitespace\n                    indentationEndIndex = lineText.length;\n                }\n                if (lineNumber > 1) {\n                    const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);\n                    if (contentStartVisibleColumn % indentSize !== 0) {\n                        // The current line is \"miss-aligned\", so let's see if this is expected...\n                        // This can only happen when it has trailing commas in the indent\n                        if (model.tokenization.isCheapToTokenize(lineNumber - 1)) {\n                            const enterAction = getEnterAction(this._opts.autoIndent, model, new Range(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1), lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)), this._languageConfigurationService);\n                            if (enterAction) {\n                                extraSpaces = previousLineExtraSpaces;\n                                if (enterAction.appendText) {\n                                    for (let j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {\n                                        if (enterAction.appendText.charCodeAt(j) === 32 /* CharCode.Space */) {\n                                            extraSpaces++;\n                                        }\n                                        else {\n                                            break;\n                                        }\n                                    }\n                                }\n                                if (enterAction.removeText) {\n                                    extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);\n                                }\n                                // Act as if `prefixSpaces` is not part of the indentation\n                                for (let j = 0; j < extraSpaces; j++) {\n                                    if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== 32 /* CharCode.Space */) {\n                                        break;\n                                    }\n                                    indentationEndIndex--;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (this._opts.isUnshift && indentationEndIndex === 0) {\n                    // line with no leading whitespace => nothing to do\n                    continue;\n                }\n                let desiredIndent;\n                if (this._opts.isUnshift) {\n                    desiredIndent = ShiftCommand_1.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n                }\n                else {\n                    desiredIndent = ShiftCommand_1.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n                }\n                this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);\n                if (lineNumber === startLine && !this._selection.isEmpty()) {\n                    // Force the startColumn to stay put because we're inserting after it\n                    this._selectionStartColumnStaysPut = (this._selection.startColumn <= indentationEndIndex + 1);\n                }\n            }\n        }\n        else {\n            // if indenting or outdenting on a whitespace only line\n            if (!this._opts.isUnshift && this._selection.isEmpty() && model.getLineLength(startLine) === 0) {\n                this._useLastEditRangeForCursorEndPosition = true;\n            }\n            const oneIndent = (insertSpaces ? cachedStringRepeat(' ', indentSize) : '\\t');\n            for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n                    // empty line or line with no leading whitespace => nothing to do\n                    continue;\n                }\n                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n                    // do not indent empty lines => nothing to do\n                    continue;\n                }\n                if (indentationEndIndex === -1) {\n                    // the entire line is whitespace\n                    indentationEndIndex = lineText.length;\n                }\n                if (this._opts.isUnshift && indentationEndIndex === 0) {\n                    // line with no leading whitespace => nothing to do\n                    continue;\n                }\n                if (this._opts.isUnshift) {\n                    indentationEndIndex = Math.min(indentationEndIndex, indentSize);\n                    for (let i = 0; i < indentationEndIndex; i++) {\n                        const chr = lineText.charCodeAt(i);\n                        if (chr === 9 /* CharCode.Tab */) {\n                            indentationEndIndex = i + 1;\n                            break;\n                        }\n                    }\n                    this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), '');\n                }\n                else {\n                    this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, 1), oneIndent);\n                    if (lineNumber === startLine && !this._selection.isEmpty()) {\n                        // Force the startColumn to stay put because we're inserting after it\n                        this._selectionStartColumnStaysPut = (this._selection.startColumn === 1);\n                    }\n                }\n            }\n        }\n        this._selectionId = builder.trackSelection(this._selection);\n    }\n    computeCursorState(model, helper) {\n        if (this._useLastEditRangeForCursorEndPosition) {\n            const lastOp = helper.getInverseEditOperations()[0];\n            return new Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);\n        }\n        const result = helper.getTrackedSelection(this._selectionId);\n        if (this._selectionStartColumnStaysPut) {\n            // The selection start should not move\n            const initialStartColumn = this._selection.startColumn;\n            const resultStartColumn = result.startColumn;\n            if (resultStartColumn <= initialStartColumn) {\n                return result;\n            }\n            if (result.getDirection() === 0 /* SelectionDirection.LTR */) {\n                return new Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);\n            }\n            return new Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);\n        }\n        return result;\n    }\n};\nShiftCommand = ShiftCommand_1 = __decorate([\n    __param(2, ILanguageConfigurationService)\n], ShiftCommand);\nexport { ShiftCommand };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}