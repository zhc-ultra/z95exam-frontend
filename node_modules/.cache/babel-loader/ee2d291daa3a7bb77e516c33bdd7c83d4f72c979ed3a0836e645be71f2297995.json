{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/yinger/Desktop/algo_evaluator_front/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport \"core-js/modules/es.date.now.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nexport var USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp() {\n  var allowInWords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n  var _iterator = _createForOfIteratorHelper(USUAL_WORD_SEPARATORS),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var sep = _step.value;\n      if (allowInWords.indexOf(sep) >= 0) {\n        continue;\n      }\n      source += '\\\\' + sep;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  source += '\\\\s]+)';\n  return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport var DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n  var result = DEFAULT_WORD_REGEXP;\n  if (wordDefinition && wordDefinition instanceof RegExp) {\n    if (!wordDefinition.global) {\n      var flags = 'g';\n      if (wordDefinition.ignoreCase) {\n        flags += 'i';\n      }\n      if (wordDefinition.multiline) {\n        flags += 'm';\n      }\n      if (wordDefinition.unicode) {\n        flags += 'u';\n      }\n      result = new RegExp(wordDefinition.source, flags);\n    } else {\n      result = wordDefinition;\n    }\n  }\n  result.lastIndex = 0;\n  return result;\n}\nvar _defaultConfig = new LinkedList();\n_defaultConfig.unshift({\n  maxLen: 1000,\n  windowSize: 15,\n  timeBudget: 150\n});\nexport function getWordAtText(column, wordDefinition, text, textOffset, config) {\n  // Ensure the regex has the 'g' flag, otherwise this will loop forever\n  wordDefinition = ensureValidWordDefinition(wordDefinition);\n  if (!config) {\n    config = Iterable.first(_defaultConfig);\n  }\n  if (text.length > config.maxLen) {\n    // don't throw strings that long at the regexp\n    // but use a sub-string in which a word must occur\n    var start = column - config.maxLen / 2;\n    if (start < 0) {\n      start = 0;\n    } else {\n      textOffset += start;\n    }\n    text = text.substring(start, column + config.maxLen / 2);\n    return getWordAtText(column, wordDefinition, text, textOffset, config);\n  }\n  var t1 = Date.now();\n  var pos = column - 1 - textOffset;\n  var prevRegexIndex = -1;\n  var match = null;\n  for (var i = 1;; i++) {\n    // check time budget\n    if (Date.now() - t1 >= config.timeBudget) {\n      break;\n    }\n    // reset the index at which the regexp should start matching, also know where it\n    // should stop so that subsequent search don't repeat previous searches\n    var regexIndex = pos - config.windowSize * i;\n    wordDefinition.lastIndex = Math.max(0, regexIndex);\n    var thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n    if (!thisMatch && match) {\n      // stop: we have something\n      break;\n    }\n    match = thisMatch;\n    // stop: searched at start\n    if (regexIndex <= 0) {\n      break;\n    }\n    prevRegexIndex = regexIndex;\n  }\n  if (match) {\n    var result = {\n      word: match[0],\n      startColumn: textOffset + 1 + match.index,\n      endColumn: textOffset + 1 + match.index + match[0].length\n    };\n    wordDefinition.lastIndex = 0;\n    return result;\n  }\n  return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n  var match;\n  while (match = wordDefinition.exec(text)) {\n    var matchIndex = match.index || 0;\n    if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n      return match;\n    } else if (stopPos > 0 && matchIndex > stopPos) {\n      return null;\n    }\n  }\n  return null;\n}","map":{"version":3,"names":["Iterable","LinkedList","USUAL_WORD_SEPARATORS","createWordRegExp","allowInWords","arguments","length","undefined","source","_iterator","_createForOfIteratorHelper","_step","s","n","done","sep","value","indexOf","err","e","f","RegExp","DEFAULT_WORD_REGEXP","ensureValidWordDefinition","wordDefinition","result","global","flags","ignoreCase","multiline","unicode","lastIndex","_defaultConfig","unshift","maxLen","windowSize","timeBudget","getWordAtText","column","text","textOffset","config","first","start","substring","t1","Date","now","pos","prevRegexIndex","match","i","regexIndex","Math","max","thisMatch","_findRegexMatchEnclosingPosition","word","startColumn","index","endColumn","stopPos","exec","matchIndex"],"sources":["/Users/yinger/Desktop/algo_evaluator_front/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords = '') {\n    let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n    for (const sep of USUAL_WORD_SEPARATORS) {\n        if (allowInWords.indexOf(sep) >= 0) {\n            continue;\n        }\n        source += '\\\\' + sep;\n    }\n    source += '\\\\s]+)';\n    return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n    let result = DEFAULT_WORD_REGEXP;\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\n        if (!wordDefinition.global) {\n            let flags = 'g';\n            if (wordDefinition.ignoreCase) {\n                flags += 'i';\n            }\n            if (wordDefinition.multiline) {\n                flags += 'm';\n            }\n            if (wordDefinition.unicode) {\n                flags += 'u';\n            }\n            result = new RegExp(wordDefinition.source, flags);\n        }\n        else {\n            result = wordDefinition;\n        }\n    }\n    result.lastIndex = 0;\n    return result;\n}\nconst _defaultConfig = new LinkedList();\n_defaultConfig.unshift({\n    maxLen: 1000,\n    windowSize: 15,\n    timeBudget: 150\n});\nexport function getWordAtText(column, wordDefinition, text, textOffset, config) {\n    // Ensure the regex has the 'g' flag, otherwise this will loop forever\n    wordDefinition = ensureValidWordDefinition(wordDefinition);\n    if (!config) {\n        config = Iterable.first(_defaultConfig);\n    }\n    if (text.length > config.maxLen) {\n        // don't throw strings that long at the regexp\n        // but use a sub-string in which a word must occur\n        let start = column - config.maxLen / 2;\n        if (start < 0) {\n            start = 0;\n        }\n        else {\n            textOffset += start;\n        }\n        text = text.substring(start, column + config.maxLen / 2);\n        return getWordAtText(column, wordDefinition, text, textOffset, config);\n    }\n    const t1 = Date.now();\n    const pos = column - 1 - textOffset;\n    let prevRegexIndex = -1;\n    let match = null;\n    for (let i = 1;; i++) {\n        // check time budget\n        if (Date.now() - t1 >= config.timeBudget) {\n            break;\n        }\n        // reset the index at which the regexp should start matching, also know where it\n        // should stop so that subsequent search don't repeat previous searches\n        const regexIndex = pos - config.windowSize * i;\n        wordDefinition.lastIndex = Math.max(0, regexIndex);\n        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n        if (!thisMatch && match) {\n            // stop: we have something\n            break;\n        }\n        match = thisMatch;\n        // stop: searched at start\n        if (regexIndex <= 0) {\n            break;\n        }\n        prevRegexIndex = regexIndex;\n    }\n    if (match) {\n        const result = {\n            word: match[0],\n            startColumn: textOffset + 1 + match.index,\n            endColumn: textOffset + 1 + match.index + match[0].length\n        };\n        wordDefinition.lastIndex = 0;\n        return result;\n    }\n    return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n    let match;\n    while (match = wordDefinition.exec(text)) {\n        const matchIndex = match.index || 0;\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n            return match;\n        }\n        else if (stopPos > 0 && matchIndex > stopPos) {\n            return null;\n        }\n    }\n    return null;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}