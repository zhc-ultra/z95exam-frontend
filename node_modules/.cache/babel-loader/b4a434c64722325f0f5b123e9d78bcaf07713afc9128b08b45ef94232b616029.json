{"ast":null,"code":"import _classCallCheck from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/yinger/Desktop/z95_exam_frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.data-view.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.typed-array.uint32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from './lineTokens.js';\nexport var EMPTY_LINE_TOKENS = new Uint32Array(0).buffer;\nexport var ContiguousTokensEditing = /*#__PURE__*/function () {\n  function ContiguousTokensEditing() {\n    _classCallCheck(this, ContiguousTokensEditing);\n  }\n  return _createClass(ContiguousTokensEditing, null, [{\n    key: \"deleteBeginning\",\n    value: function deleteBeginning(lineTokens, toChIndex) {\n      if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n        return lineTokens;\n      }\n      return ContiguousTokensEditing[\"delete\"](lineTokens, 0, toChIndex);\n    }\n  }, {\n    key: \"deleteEnding\",\n    value: function deleteEnding(lineTokens, fromChIndex) {\n      if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n        return lineTokens;\n      }\n      var tokens = toUint32Array(lineTokens);\n      var lineTextLength = tokens[tokens.length - 2];\n      return ContiguousTokensEditing[\"delete\"](lineTokens, fromChIndex, lineTextLength);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(lineTokens, fromChIndex, toChIndex) {\n      if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n        return lineTokens;\n      }\n      var tokens = toUint32Array(lineTokens);\n      var tokensCount = tokens.length >>> 1;\n      // special case: deleting everything\n      if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n        return EMPTY_LINE_TOKENS;\n      }\n      var fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n      var fromTokenStartOffset = fromTokenIndex > 0 ? tokens[fromTokenIndex - 1 << 1] : 0;\n      var fromTokenEndOffset = tokens[fromTokenIndex << 1];\n      if (toChIndex < fromTokenEndOffset) {\n        // the delete range is inside a single token\n        var _delta = toChIndex - fromChIndex;\n        for (var i = fromTokenIndex; i < tokensCount; i++) {\n          tokens[i << 1] -= _delta;\n        }\n        return lineTokens;\n      }\n      var dest;\n      var lastEnd;\n      if (fromTokenStartOffset !== fromChIndex) {\n        tokens[fromTokenIndex << 1] = fromChIndex;\n        dest = fromTokenIndex + 1 << 1;\n        lastEnd = fromChIndex;\n      } else {\n        dest = fromTokenIndex << 1;\n        lastEnd = fromTokenStartOffset;\n      }\n      var delta = toChIndex - fromChIndex;\n      for (var tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n        var tokenEndOffset = tokens[tokenIndex << 1] - delta;\n        if (tokenEndOffset > lastEnd) {\n          tokens[dest++] = tokenEndOffset;\n          tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n          lastEnd = tokenEndOffset;\n        }\n      }\n      if (dest === tokens.length) {\n        // nothing to trim\n        return lineTokens;\n      }\n      var tmp = new Uint32Array(dest);\n      tmp.set(tokens.subarray(0, dest), 0);\n      return tmp.buffer;\n    }\n  }, {\n    key: \"append\",\n    value: function append(lineTokens, _otherTokens) {\n      if (_otherTokens === EMPTY_LINE_TOKENS) {\n        return lineTokens;\n      }\n      if (lineTokens === EMPTY_LINE_TOKENS) {\n        return _otherTokens;\n      }\n      if (lineTokens === null) {\n        return lineTokens;\n      }\n      if (_otherTokens === null) {\n        // cannot determine combined line length...\n        return null;\n      }\n      var myTokens = toUint32Array(lineTokens);\n      var otherTokens = toUint32Array(_otherTokens);\n      var otherTokensCount = otherTokens.length >>> 1;\n      var result = new Uint32Array(myTokens.length + otherTokens.length);\n      result.set(myTokens, 0);\n      var dest = myTokens.length;\n      var delta = myTokens[myTokens.length - 2];\n      for (var i = 0; i < otherTokensCount; i++) {\n        result[dest++] = otherTokens[i << 1] + delta;\n        result[dest++] = otherTokens[(i << 1) + 1];\n      }\n      return result.buffer;\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(lineTokens, chIndex, textLength) {\n      if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n        // nothing to do\n        return lineTokens;\n      }\n      var tokens = toUint32Array(lineTokens);\n      var tokensCount = tokens.length >>> 1;\n      var fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n      if (fromTokenIndex > 0) {\n        var fromTokenStartOffset = tokens[fromTokenIndex - 1 << 1];\n        if (fromTokenStartOffset === chIndex) {\n          fromTokenIndex--;\n        }\n      }\n      for (var tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n        tokens[tokenIndex << 1] += textLength;\n      }\n      return lineTokens;\n    }\n  }]);\n}();\nexport function toUint32Array(arr) {\n  if (arr instanceof Uint32Array) {\n    return arr;\n  } else {\n    return new Uint32Array(arr);\n  }\n}","map":{"version":3,"names":["LineTokens","EMPTY_LINE_TOKENS","Uint32Array","buffer","ContiguousTokensEditing","_classCallCheck","_createClass","key","value","deleteBeginning","lineTokens","toChIndex","deleteEnding","fromChIndex","tokens","toUint32Array","lineTextLength","length","_delete","tokensCount","fromTokenIndex","findIndexInTokensArray","fromTokenStartOffset","fromTokenEndOffset","delta","i","dest","lastEnd","tokenIndex","tokenEndOffset","tmp","set","subarray","append","_otherTokens","myTokens","otherTokens","otherTokensCount","result","insert","chIndex","textLength","arr"],"sources":["/Users/yinger/Desktop/z95_exam_frontend/node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensEditing.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from './lineTokens.js';\nexport const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\nexport class ContiguousTokensEditing {\n    static deleteBeginning(lineTokens, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        return ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);\n    }\n    static deleteEnding(lineTokens, fromChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const lineTextLength = tokens[tokens.length - 2];\n        return ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);\n    }\n    static delete(lineTokens, fromChIndex, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        // special case: deleting everything\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n            return EMPTY_LINE_TOKENS;\n        }\n        const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n        const fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n        const fromTokenEndOffset = tokens[fromTokenIndex << 1];\n        if (toChIndex < fromTokenEndOffset) {\n            // the delete range is inside a single token\n            const delta = (toChIndex - fromChIndex);\n            for (let i = fromTokenIndex; i < tokensCount; i++) {\n                tokens[i << 1] -= delta;\n            }\n            return lineTokens;\n        }\n        let dest;\n        let lastEnd;\n        if (fromTokenStartOffset !== fromChIndex) {\n            tokens[fromTokenIndex << 1] = fromChIndex;\n            dest = ((fromTokenIndex + 1) << 1);\n            lastEnd = fromChIndex;\n        }\n        else {\n            dest = (fromTokenIndex << 1);\n            lastEnd = fromTokenStartOffset;\n        }\n        const delta = (toChIndex - fromChIndex);\n        for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n            const tokenEndOffset = tokens[tokenIndex << 1] - delta;\n            if (tokenEndOffset > lastEnd) {\n                tokens[dest++] = tokenEndOffset;\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n                lastEnd = tokenEndOffset;\n            }\n        }\n        if (dest === tokens.length) {\n            // nothing to trim\n            return lineTokens;\n        }\n        const tmp = new Uint32Array(dest);\n        tmp.set(tokens.subarray(0, dest), 0);\n        return tmp.buffer;\n    }\n    static append(lineTokens, _otherTokens) {\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        if (lineTokens === EMPTY_LINE_TOKENS) {\n            return _otherTokens;\n        }\n        if (lineTokens === null) {\n            return lineTokens;\n        }\n        if (_otherTokens === null) {\n            // cannot determine combined line length...\n            return null;\n        }\n        const myTokens = toUint32Array(lineTokens);\n        const otherTokens = toUint32Array(_otherTokens);\n        const otherTokensCount = (otherTokens.length >>> 1);\n        const result = new Uint32Array(myTokens.length + otherTokens.length);\n        result.set(myTokens, 0);\n        let dest = myTokens.length;\n        const delta = myTokens[myTokens.length - 2];\n        for (let i = 0; i < otherTokensCount; i++) {\n            result[dest++] = otherTokens[(i << 1)] + delta;\n            result[dest++] = otherTokens[(i << 1) + 1];\n        }\n        return result.buffer;\n    }\n    static insert(lineTokens, chIndex, textLength) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            // nothing to do\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n        if (fromTokenIndex > 0) {\n            const fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n            if (fromTokenStartOffset === chIndex) {\n                fromTokenIndex--;\n            }\n        }\n        for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n            tokens[tokenIndex << 1] += textLength;\n        }\n        return lineTokens;\n    }\n}\nexport function toUint32Array(arr) {\n    if (arr instanceof Uint32Array) {\n        return arr;\n    }\n    else {\n        return new Uint32Array(arr);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}